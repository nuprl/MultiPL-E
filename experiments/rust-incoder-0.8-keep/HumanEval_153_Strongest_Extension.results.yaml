name: HumanEval_153_Strongest_Extension
language: rust
results:
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension = format!(\"\
    {}.0\", class_name);\n\n    for extension in extensions {\n        let (strength,\
    \ name) = extension.chars().count();\n        if strength > strongest_extension.chars().count()\
    \ as i32 {\n            strongest_extension = format!(\"{}.{}\", class_name, name);\n\
    \        }\n    }\n\n    strongest_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpepvv0q4n.rs:20:13\n   |\n\
    20 |         let (strength, name) = extension.chars().count();\n   |         \
    \    ^^^^^^^^^^^^^^^^   ------------------------- this expression has type `usize`\n\
    \   |             |\n   |             expected `usize`, found tuple\n   |\n  \
    \ = note: expected type `usize`\n             found tuple `(_, _)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    for\
    \ extension in extensions {\n        match extension.chars().filter(|c| c.is_uppercase()).count()\
    \ {\n            2 => {\n                if strength > 0 {\n                 \
    \   return class_name + \".\" + extension;\n                } else {\n       \
    \             strength = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \                    return class_name + \".\" + extension;\n                }\n\
    \            },\n            _ => {\n                strength = strength.saturating_sub(extension.chars().filter(|c|\
    \ c.is_lowercase()).count());\n            }\n        }\n    }\n    if strength\
    \ > 0 {\n        return class_name + \".\" + extensions[0];\n    } else {\n  \
    \      return class_name;\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3qs20lh8.rs:22:47\n   |\n\
    22 |                     return class_name + \".\" + extension;\n   |        \
    \                                       ^^^^^^^^^\n   |                      \
    \                         |\n   |                                            \
    \   expected `&str`, found struct `String`\n   |                             \
    \                  help: consider borrowing here: `&extension`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3qs20lh8.rs:24:32\n   |\n17 |     let mut strength\
    \ = -1i32;\n   |                        ----- expected due to this value\n...\n\
    24 |                     strength = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3qs20lh8.rs:25:47\n\
    \   |\n25 |                     return class_name + \".\" + extension;\n   | \
    \                                              ^^^^^^^^^\n   |               \
    \                                |\n   |                                     \
    \          expected `&str`, found struct `String`\n   |                      \
    \                         help: consider borrowing here: `&extension`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3qs20lh8.rs:29:52\n   |\n29 |              \
    \   strength = strength.saturating_sub(extension.chars().filter(|c| c.is_lowercase()).count());\n\
    \   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i32`\
    \ and panic if the converted value doesn't fit\n   |\n29 |                 strength\
    \ = strength.saturating_sub(extension.chars().filter(|c| c.is_lowercase()).count().try_into().unwrap());\n\
    \   |                                                                        \
    \                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3qs20lh8.rs:34:35\n   |\n34 |         return class_name\
    \ + \".\" + extensions[0]"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter = String::new();\n\
    \    let mut extensions_count = extensions[0].len() as f64;\n    for ext in extensions\
    \ {\n        if ext.len() == extensions_count {\n            counter.push_str(&ext);\n\
    \        } else {\n            counter.push_str(&ext[..(counter.len() - extensions_count)].to_ascii_lowercase());\n\
    \            extensions_count = ext.len() as f64;\n            counter.push_str(&ext[..(counter.len()\
    \ - extensions_count)].to_ascii_uppercase());\n        }\n    }\n    counter.push_str(&class_name[..counter.len()\
    \ - extensions_count].to_ascii_uppercase());\n    counter.push_str(&class_name[..counter.len()\
    \ - extensions_count].to_ascii_lowercase());\n    counter\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcq9ii39a.rs:20:25\n   |\n\
    20 |         if ext.len() == extensions_count {\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `usize`, found `f64`\n\nerror[E0277]: cannot subtract\
    \ `f64` from `usize`\n  --> /tmp/tmpcq9ii39a.rs:23:52\n   |\n23 |            \
    \ counter.push_str(&ext[..(counter.len() - extensions_count)].to_ascii_lowercase());\n\
    \   |                                                    ^ no implementation for\
    \ `usize - f64`\n   |\n   = help: the trait `Sub<f64>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: cannot subtract `f64` from `usize`\n  --> /tmp/tmpcq9ii39a.rs:25:52\n\
    \   |\n25 |             counter.push_str(&ext[..(counter.len() - extensions_count)].to_ascii_uppercase());\n\
    \   |                                                    ^ no implementation for\
    \ `usize - f64`\n   |\n   = help: the trait `Sub<f64>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: cannot subtract `f64` from `usize`\n  --> /tmp/tmpcq9ii39a.rs:28:50\n\
    \   |\n28 |     counter.push_str(&class_name[..counter.len() - extensions_count].to_ascii_uppercase());\n\
    \   |                                                  ^ no implementation for\
    \ `usize - f64`\n   |\n   = help: the trait `Sub<f64>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut s =\
    \ String::new();\n    for e in extensions.iter() {\n        if e.chars().filter(|x|x\
    \ == char::ToUpper).count() > e.chars().filter(|x|x == char::ToLower).count()\
    \ {\n            s = s.push_str(e);\n        } else {\n            s = s.push_str(&e);\n\
    \        }\n    }\n    s + \"_\" + class_name\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `ToUpper` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpvy0myjbo.rs:20:43\n   |\n20 |         if\
    \ e.chars().filter(|x|x == char::ToUpper).count() > e.chars().filter(|x|x == char::ToLower).count()\
    \ {\n   |                                           ^^^^^^^ associated item not\
    \ found in `char`\n\nerror[E0599]: no associated item named `ToLower` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpvy0myjbo.rs:20:93\n   |\n20\
    \ |         if e.chars().filter(|x|x == char::ToUpper).count() > e.chars().filter(|x|x\
    \ == char::ToLower).count() {\n   |                                          \
    \                                                   ^^^^^^^ associated item not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvy0myjbo.rs:21:17\n\
    \   |\n18 |     let mut s = String::new();\n   |                 -------------\
    \ expected due to this value\n...\n21 |             s = s.push_str(e);\n   | \
    \                ^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\nnote:\
    \ method `push_str` modifies its receiver in-place\n  --> /tmp/tmpvy0myjbo.rs:21:19\n\
    \   |\n21 |             s = s.push_str(e);\n   |                 - ^^^^^^^^ this\
    \ call modifies `s` in-place\n   |                 |\n   |                 you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvy0myjbo.rs:23:17\n   |\n18 |     let mut s = String::new();\n\
    \   |                 ------------- expected due to this value\n...\n23 |    \
    \         s = s.push_str(&e);\n   |                 ^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n\
    \  --> /tmp/tmpvy0myjbo.rs:23:19\n   |\n23 |             s = s.push_str(&e);\n\
    \   |                 - ^^^^^^^^ this call modifies `s` in-place\n   |       \
    \          |\n   |                 you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0308]: mismatched type"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut sm = 0;\n    let mut cap =\
    \ 0;\n    for extension in extensions {\n        let mut extension_length = extension.len();\n\
    \        if extension_length >= class_name.len() {\n            extension_length\
    \ = class_name.len();\n        }\n        for index in 0..extension_length {\n\
    \            if class_name.chars().any(|c| c == extension[index]) {\n        \
    \        sm = sm + 1;\n            }\n            if class_name.chars().all(|c|\
    \ c == extension[index].lowercase()) {\n                cap = cap + 1;\n     \
    \       }\n        }\n    }\n    (1.0 * cap as f64) / (1.0 * sm as f64) as String\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmper7jiphn.rs:25:48\n\
    \   |\n25 |             if class_name.chars().any(|c| c == extension[index]) {\n\
    \   |                                                ^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmper7jiphn.rs:28:48\n   |\n28 |             if class_name.chars().all(|c|\
    \ c == extension[index].lowercase()) {\n   |                                 \
    \               ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ cannot divide `f64` by `String`\n  --> /tmp/tmper7jiphn.rs:33:24\n   |\n33 |\
    \     (1.0 * cap as f64) / (1.0 * sm as f64) as String\n   |                 \
    \       ^ no implementation for `f64 / String`\n   |\n   = help: the trait `Div<String>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1;\n    let mut\
    \ name = \"\";\n    for extension in extensions {\n        let splitted_name =\
    \ extension.split(\"_\").map(|x| x.to_lowercase()).collect::<Vec<_>>();\n    \
    \    let caps = splitted_name.len();\n        let sms = splitted_name.len() -\
    \ caps;\n        assert!(sms == 0 || caps == 0, \"Unexpected extension's name\"\
    );\n        strength += caps as f64 - sms as f64;\n        name = splitted_name.iter().max().unwrap();\n\
    \    }\n    format!(\"{}{}.{}\", class_name, name, strength)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpd669f98a.rs:24:18\n\
    \   |\n24 |         strength += caps as f64 - sms as f64;\n   |              \
    \    ^^ no implementation for `{integer} += f64`\n   |\n   = help: the trait `AddAssign<f64>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.len() < 3 {\n      \
    \  \"\".to_string()\n    }\n    let mut strength = 0usize;\n    let mut max_extension\
    \ = \"\".to_string();\n    for extension in extensions {\n        let cap = extension.chars().filter(|&x|\
    \ x > 'A' && x < 'Z').count();\n        let sm = extension.chars().filter(|&x|\
    \ x > 'a' && x < 'z').count();\n        strength = if cap < sm { cap - sm } else\
    \ { sm - cap };\n        if strength > max_extension.len() {\n            max_extension\
    \ = extension;\n        }\n    }\n    if strength != 0usize {\n        class_name\
    \ + String::from(\".\") + max_extension\n    } else {\n        class_name + String::from(\"\
    .\")\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83g2nnnh.rs:18:9\n   |\n\
    17 | /     if extensions.len() < 3 {\n18 | |         \"\".to_string()\n   | |\
    \         ^^^^^^^^^^^^^^ expected `()`, found struct `String`\n19 | |     }\n\
    \   | |_____- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n18 |         \"\".to_string();\n   |                       +\nhelp:\
    \ consider using a semicolon here\n   |\n19 |     };\n   |      +\nhelp: you might\
    \ have meant to return this value\n   |\n18 |         return \"\".to_string();\n\
    \   |         ++++++               +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp83g2nnnh.rs:31:22\n   |\n31 |         class_name + String::from(\".\"\
    ) + max_extension\n   |                      ^^^^^^^^^^^^^^^^^\n   |         \
    \             |\n   |                      expected `&str`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&String::from(\".\"\
    )`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83g2nnnh.rs:31:42\n   |\n\
    31 |         class_name + String::from(\".\") + max_extension\n   |          \
    \                                ^^^^^^^^^^^^^\n   |                         \
    \                 |\n   |                                          expected `&str`,\
    \ found struct `String`\n   |                                          help: consider\
    \ borrowing here: `&max_extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83g2nnnh.rs:33:22\n\
    \   |\n33 |         class_name + String::from(\".\")\n   |                   \
    \   ^^^^^^^^^^^^^^^^^\n   |                      |\n   |                     \
    \ expected `&str`, found struct `String`\n   |                      help: consider\
    \ borrowing here: `&String::from(\".\")`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n     \
    \   return \"\";\n    }\n    let mut class_name = class_name.to_string();\n  \
    \  let mut best_extension: Vec<String> = Vec::new();\n    let mut strongest_extension:\
    \ String = String::from(\"\");\n    let mut is_best_extension = true;\n\n    for\
    \ extension in extensions {\n        let mut extension = extension.to_string();\n\
    \        let mut first_letter = String::from(\"-\");\n        for c in extension.chars()\
    \ {\n            if c.is_uppercase() {\n                first_letter = String::from(*c.to_ascii_lowercase());\n\
    \            }\n        }\n        let mut strength = first_letter.len() as i32;\n\
    \        let mut extension_parts = extension.split_by_ascii_lowercase();\n   \
    \     for part in extension_parts {\n            if part.len() <= strongest_extension.len()\
    \ {\n                strongest_extension = String::from(part.to_ascii_lowercase());\n\
    \            } else {\n                strength = (part.len() - strongest_extension.len())\
    \ as i32;\n            }\n        }\n        if strength > 0 {\n            if\
    \ best_extension.is_empty() || strength < best_extension[0].len() {\n        \
    \        best_extension.push(String::from(extension));\n            }\n      \
    \  } else {\n            strongest_extension = String::from(extension);\n    \
    \    }\n    }\n    if best_extension.is_empty() {\n        return strongest_extension;\n\
    \    }\n    for best_extension in best_extension {\n        let mut strength =\
    \ best_extension.len() as i32;\n        if strength > 0 {\n            is_best_extension\
    \ = false;\n            break;\n        }\n    }\n    if is_best_extension {\n\
    \        return class_name + \".\" + strongest_extension;\n    } else {\n    \
    \    return class_name;\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0yrp8c43.rs:18:16\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n17 |     if extensions.is_empty()\
    \ {\n18 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp0yrp8c43.rs:30:45\n   |\n30 |                 first_letter = String::from(*c.to_ascii_lowercase());\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0599]: no method named `split_by_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0yrp8c43.rs:34:45\n   |\n34 |         let\
    \ mut extension_parts = extension.split_by_ascii_lowercase();\n   |          \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0yrp8c43.rs:43:56\n   |\n43 |             if\
    \ best_extension.is_empty() || strength < best_extension[0].len() {\n   |    \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `i32`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n43 |             if best_extension.is_empty()\
    \ || strength < best_extension[0].len().try_into().unwrap() {\n   |          \
    \                                                                     ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0yrp8c43.rs:61:35\n   |\n61 |\
    \         return class_name + \".\" + strongest_extension;\n   |             \
    \                      ^^^^^^^^^^^^^^^^^^^\n   |                             \
    \      |\n   |                                   expected `&str`, found struct\
    \ `String`\n   |                                   help: consider borrowi"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut num_uppercase = String::new();\n\
    \    let mut num_lowercase = String::new();\n\n    for extension in extensions\
    \ {\n        let num_upper = extension.chars().filter(|&c| c.is_uppercase().unwrap()).count();\n\
    \        num_upper.to_string().push_str(&num_uppercase);\n        num_uppercase.push_str(&num_upper);\n\
    \n        let num_lower = extension.chars().filter(|&c| c.is_lowercase().unwrap()).count();\n\
    \        num_lower.to_string().push_str(&num_lowercase);\n        num_lowercase.push_str(&num_lower);\n\
    \    }\n\n    let mut strength = String::new();\n    if num_uppercase > num_lowercase\
    \ {\n        strength.push_str(&class_name.to_string().to_lowercase());\n    }\
    \ else {\n        strength.push_str(&class_name.to_string().to_uppercase());\n\
    \    }\n    strength.push_str(&extensions[extensions.len() - 1]);\n\n    strength\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpg68xda6t.rs:21:72\n   |\n21 |         let num_upper = extension.chars().filter(|&c|\
    \ c.is_uppercase().unwrap()).count();\n   |                                  \
    \                                      ^^^^^^ method not found in `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg68xda6t.rs:23:32\n   |\n23 |         num_uppercase.push_str(&num_upper);\n\
    \   |                                ^^^^^^^^^^ expected `str`, found `usize`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&usize`\n\
    \nerror[E0599]: no method named `unwrap` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpg68xda6t.rs:25:72\n   |\n25 |         let num_lower = extension.chars().filter(|&c|\
    \ c.is_lowercase().unwrap()).count();\n   |                                  \
    \                                      ^^^^^^ method not found in `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg68xda6t.rs:27:32\n   |\n27 |         num_lowercase.push_str(&num_lower);\n\
    \   |                                ^^^^^^^^^^ expected `str`, found `usize`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&usize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n    let\
    \ mut max_extension_name = String::new();\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let (strength, extension) = e.split('.').map(|s| s.parse().ok()).unwrap_or_else(|_|\
    \ {\n            panic!(\"Strongest_Extension: failed to parse extension {}\"\
    , e)\n        });\n        if strength > max_strength {\n            max_strength\
    \ = strength;\n            max_extension_name = e.to_string();\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, max_extension_name)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or_else` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpgomgsz8e.rs:20:74\n   |\n20 |         let (strength,\
    \ extension) = e.split('.').map(|s| s.parse().ok()).unwrap_or_else(|_| {\n   |\
    \                                                                          ^^^^^^^^^^^^^^\
    \ method not found in `Map<std::str::Split<'_, char>, [closure@/tmp/tmpgomgsz8e.rs:20:54:\
    \ 20:72]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut classname = String::from(class_name);\n\
    \    let mut extensions = extensions.iter().cloned();\n    let mut strength =\
    \ -1;\n    let mut best_extension = String::from(\"\");\n\n    loop {\n      \
    \  let mut extension = String::from(\"\");\n\n        match extension.chars().enumerate().find(|&(_,\
    \ n)| n == 0 {\n            0 => true,\n            _ => false\n        }) {\n\
    \            Some((i, _)) => extension = extensions[i - 1],\n            None\
    \ => break,\n        }\n\n        if extension != \"\" {\n            let cap_offset\
    \ = classname.chars().count() + extension.chars().count() - 1;\n            let\
    \ sma_offset = classname.chars().count() - extension.chars().count();\n      \
    \      strength = (cap_offset - sma_offset) as f64 / cap_offset;\n        }\n\n\
    \        if strength > 0 {\n            best_extension = extension.to_string()\
    \ + classname + best_extension;\n        } else {\n            best_extension\
    \ = extension.to_string() + classname;\n        }\n\n        if extensions.len()\
    \ == 0 || strength == -1 {\n            break;\n        }\n\n        extensions.remove(best_extension);\n\
    \        extension = String::from(\"\");\n    }\n\n    best_extension\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpjyvj6ome.rs:26:15\n   |\n26 |             0 => true,\n   |    \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, or an operator, found `{`\n  --> /tmp/tmpjyvj6ome.rs:25:67\n\
    \   |\n25 |         match extension.chars().enumerate().find(|&(_, n)| n == 0\
    \ {\n   |                                                                  -^\
    \ expected one of `)`, `,`, `.`, `?`, or an operator\n   |                   \
    \                                               |\n   |                      \
    \                                            help: missing `,`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpjyvj6ome.rs:25:45\n\
    \     |\n25   |           match extension.chars().enumerate().find(|&(_, n)| n\
    \ == 0 {\n     |  _____________________________________________^^^^_----------------_-\n\
    \     | |                                             |\n     | |            \
    \                                 expected 1 argument\n26   | |             0\
    \ => true,\n27   | |             _ => false\n28   | |         }) {\n     | |_________-\
    \ supplied 2 arguments\n     |\nnote: associated function defined here\n\nerror[E0608]:\
    \ cannot index into a value of type `Cloned<std::slice::Iter<'_, String>>`\n \
    \ --> /tmp/tmpjyvj6ome.rs:29:41\n   |\n29 |             Some((i, _)) => extension\
    \ = extensions[i - 1],\n   |                                         ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpjyvj6ome.rs:36:57\n\
    \   |\n36 |             strength = (cap_offset - sma_offset) as f64 / cap_offset;\n\
    \   |                                                         ^ no implementation\
    \ for `f64 / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter: usize = 0;\n    for\
    \ extension in extensions {\n        if extension.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count() == 0 {\n            return format!(\"{}.{}\", class_name,\
    \ extension);\n        }\n        counter += extension.chars().filter(|c| c >=\
    \ 'a' && c <= 'z').count();\n    }\n    if counter == 0 {\n        return format!(\"\
    {}.{}\", class_name, extensions.iter().min().unwrap());\n    }\n    format!(\"\
    {}.{}\", class_name, extensions.iter().sort_by_key(|&x| x.chars().filter(|c| c\
    \ >= 'a' && c <= 'z').count()).first().unwrap());\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp54t30uxd.rs:19:46\n   |\n\
    19 |         if extension.chars().filter(|c| c >= 'A' && c <= 'Z').count() ==\
    \ 0 {\n   |                                              ^^^\n   |           \
    \                                   |\n   |                                  \
    \            expected `&char`, found `char`\n   |                            \
    \                  help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp54t30uxd.rs:19:58\n   |\n19 |         if extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() == 0 {\n   |                                 \
    \                         ^^^\n   |                                          \
    \                |\n   |                                                     \
    \     expected `&char`, found `char`\n   |                                   \
    \                       help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp54t30uxd.rs:22:54\n   |\n22 |         counter\
    \ += extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |       \
    \                                               ^^^\n   |                    \
    \                                  |\n   |                                   \
    \                   expected `&char`, found `char`\n   |                     \
    \                                 help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp54t30uxd.rs:22:66\n   |\n22 |         counter\
    \ += extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |       \
    \                                                           ^^^\n   |        \
    \                                                          |\n   |           \
    \                                                       expected `&char`, found\
    \ `char`\n   |                                                               \
    \   help: consider borrowing here: `&'z'`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp54t30uxd.rs:27:52\n\
    \   |\n27 |     format!(\"{}.{}\", class_name, exte"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut result: usize = 0;\n    let\
    \ mut min: usize = 0;\n\n    for extension in extensions {\n        let mut num\
    \ = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() + 1;\n      \
    \  if *extension.chars().filter(|c| *c >= 'a' && *c <= 'z').count() > num {\n\
    \            num = (*extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\
    \ + 1) * 2\n                    + (*extension.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count() + 1);\n        }\n        let sm: usize = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let cap: usize = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let score = cap - sm;\n        if\
    \ min > score {\n            min = score;\n            result = num;\n       \
    \ }\n    }\n    format!(\"{}.{}\", class_name, extensions[result..result+min].to_lowercase().to_string())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdxsisdb2.rs:22:12\n\
    \   |\n22 |         if *extension.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ > num {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdxsisdb2.rs:23:20\n\
    \   |\n23 |             num = (*extension.chars().filter(|c| *c >= 'A' && *c <=\
    \ 'Z').count() + 1) * 2\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdxsisdb2.rs:24:24\n\
    \   |\n24 |                     + (*extension.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count() + 1);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `to_lowercase` found for slice `[String]` in the\
    \ current scope\n  --> /tmp/tmpdxsisdb2.rs:34:65\n   |\n34 |     format!(\"{}.{}\"\
    , class_name, extensions[result..result+min].to_lowercase().to_string())\n   |\
    \                                                                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_vec`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut s = \"\".to_string();\n  \
    \  for (i, s) in extensions {\n        let c: u8 = match s[i].to_ascii_lowercase()\
    \ {\n            \"a\" => 0x07,\n            \"b\" => 0x08,\n            \"c\"\
    \ => 0x09,\n            \"d\" => 0x0a,\n            \"e\" => 0x0b,\n         \
    \   \"f\" => 0x0c,\n            \"g\" => 0x0d,\n            \"h\" => 0x0e,\n \
    \           \"i\" => 0x0f,\n            \"j\" => 0x10,\n            \"k\" => 0x11,\n\
    \            \"l\" => 0x12,\n            \"m\" => 0x13,\n            \"n\" =>\
    \ 0x14,\n            \"o\" => 0x15,\n            \"p\" => 0x16,\n            \"\
    q\" => 0x17,\n            \"r\" => 0x18,\n            \"s\" => 0x19,\n       \
    \     \"t\" => 0x1a,\n            \"u\" => 0x1b,\n            \"v\" => 0x1c,\n\
    \            \"w\" => 0x1d,\n            \"x\" => 0x1e,\n            \"y\" =>\
    \ 0x1f,\n            \"z\" => 0x20,\n            _ => return \"\",\n        };\n\
    \        let mut n = i;\n        let mut k = 0;\n        while n != 0 {\n    \
    \        let mut n = n / 2;\n            let mut m = n - 1;\n            let mut\
    \ s = String::new();\n            while n != 0 {\n                if n & 1 !=\
    \ 1 {\n                    s.push('0');\n                }\n                n\
    \ /= 2;\n            }\n            s.push_str(&extensions[k]);\n            if\
    \ k != 0 {\n                s.push_str(&extensions[m]);\n            }\n     \
    \       k = m;\n        }\n        s.push_str(&class_name);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78yty08i.rs:18:9\n   |\n\
    18 |     for (i, s) in extensions {\n   |         ^^^^^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found tuple\n   |\n   = note: expected struct `String`\n               found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78yty08i.rs:46:25\n\
    \   |\n46 |             _ => return \"\",\n   |                         ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \ |\n   |                         expected struct `String`, found `&str`\n\nerror[E0271]:\
    \ type mismatch resolving `<usize as SliceIndex<[String]>>::Output == str`\n \
    \ --> /tmp/tmp78yty08i.rs:62:29\n   |\n62 |                 s.push_str(&extensions[m]);\n\
    \   |                             ^^^^^^^^^^^^^ expected struct `String`, found\
    \ `str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().enumerate().fold(class_name,\
    \ |a, b| if a.1.is_upper() {\n        a.1 + a.0.to_lowercase()\n    } else if\
    \ a.1.is_lowercase() {\n        a.0 + a.0.to_uppercase()\n    } else {\n     \
    \   a.0 + a.1\n    }).to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `1` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:17:64\n\
    \   |\n17 |     extensions.iter().enumerate().fold(class_name, |a, b| if a.1.is_upper()\
    \ {\n   |                                                                ^ unknown\
    \ field\n\nerror[E0609]: no field `1` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:18:11\n\
    \   |\n18 |         a.1 + a.0.to_lowercase()\n   |           ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:18:17\n\
    \   |\n18 |         a.1 + a.0.to_lowercase()\n   |                 ^ unknown field\n\
    \nerror[E0609]: no field `1` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:19:17\n\
    \   |\n19 |     } else if a.1.is_lowercase() {\n   |                 ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:20:11\n\
    \   |\n20 |         a.0 + a.0.to_uppercase()\n   |           ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:20:17\n\
    \   |\n20 |         a.0 + a.0.to_uppercase()\n   |                 ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:22:11\n\
    \   |\n22 |         a.0 + a.1\n   |           ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `String`\n  --> /tmp/tmp8oo4yypv.rs:22:17\n   |\n22 | \
    \        a.0 + a.1\n   |                 ^ unknown field\n\nerror: aborting due\
    \ to 8 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extension = extensions.iter().find_map(|ext|\
    \ ext.as_bytes()).unwrap_or(String::new());\n\n    let (mut class_name, mut extension)\
    \ = match &class_name {\n        &\"Slices\" => (\"\", \"\"),\n        &\"ABC\"\
    \ => (\"\", \"B\"),\n        &\"MNO\" => (\"\", \"O\"),\n        _ => (class_name,\
    \ extension)\n    };\n\n    let mut strength: usize = 0;\n    loop {\n       \
    \ if let Some(pos) = class_name.find('A') {\n            strength = pos + 1;\n\
    \            break;\n        }\n    }\n    loop {\n        let (mut class_name,\
    \ mut extension) = match &class_name {\n            &\"Slices\" => (\"\", \"S\"\
    ),\n            &\"ABC\" => (\"\", \"B\"),\n            &\"MNO\" => (\"\", \"\
    O\"),\n            _ => (class_name, extension)\n        };\n\n        if let\
    \ Some(pos) = class_name.find('Z') {\n            strength = pos + 1;\n      \
    \      break;\n        }\n    }\n\n    loop {\n        let (mut class_name, mut\
    \ extension) = match &class_name {\n            &\"Slices\" => (\"\", \"S\"),\n\
    \            &\"ABC\" => (\"\", \"B\"),\n            &\"MNO\" => (\"\", \"O\"\
    ),\n            _ => (class_name, extension)\n        };\n\n        if let Some(pos)\
    \ = class_name.find('a'..'z') {\n            strength = pos + 1;\n           \
    \ break;\n        }\n    }\n\n    loop {\n        let (mut class_name, mut extension)\
    \ = match &class_name {\n            &\"Slices\" => (\"\", \"S\"),\n         \
    \   &\"ABC\" => (\"\", \"B\"),\n            &\"MNO\" => (\"\", \"O\"),\n     \
    \       _ => (class_name, extension)\n        };\n\n        if let Some(pos) =\
    \ class_name.find('A'..'Z') {\n            strength = pos + 1;\n            break;\n\
    \        }\n    }\n\n    let mut strength = strength - extension.len();\n    while\
    \ strength < 0 {\n        extension = extension.chars().next().unwrap();\n   \
    \     strength += 1;\n    }\n\n    class_name.to_string().to_uppercase().to_string()\
    \ +\n    extension.to_string() +\n    &strength.to_string()[0..].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1lququ04.rs:17:58\n   |\n\
    17 |     let mut extension = extensions.iter().find_map(|ext| ext.as_bytes()).unwrap_or(String::new());\n\
    \   |                                                          ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&[u8]`\n   |\n   = note:   expected enum `Option<_>`\n\
    \           found reference `&[u8]`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |     let mut extension = extensions.iter().find_map(|ext| Some(ext.as_bytes())).unwrap_or(String::new());\n\
    \   |                                                          +++++         \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1lququ04.rs:20:10\n \
    \  |\n19 |     let (mut class_name, mut extension) = match &class_name {\n   |\
    \                                                 ----------- this expression\
    \ has type `&String`\n20 |         &\"Slices\" => (\"\", \"\"),\n   |        \
    \  ^^^^^^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1lququ04.rs:21:10\n   |\n19 |     let (mut class_name,\
    \ mut extension) = match &class_name {\n   |                                 \
    \                ----------- this expression has type `&String`\n20 |        \
    \ &\"Slices\" => (\"\", \"\"),\n21 |         &\"ABC\" => (\"\", \"B\"),\n   |\
    \          ^^^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1lququ04.rs:22:10\n   |\n19 |     let (mut class_name,\
    \ mut extension) = match &class_name {\n   |                                 \
    \                ----------- this expression has type `&String`\n...\n22 |   \
    \      &\"MNO\" => (\"\", \"O\"),\n   |          ^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp1lququ04.rs:23:14\n\
    \   |\n19 |       let (mut class_name, mut extension) = match &class_name {\n\
    \   |  ___________________________________________-\n20 | |         &\"Slices\"\
    \ => (\"\", \"\"),\n   | |                      -------- this is found to be of\
    \ type `(&str, &str)`\n21 | |         &\"ABC\" => (\"\", \"B\"),\n   | |     \
    \              --------- this is fo"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let (mut cap, mut sm) = (0, 0); \n\
    \    let mut best_strongest_extension = None;\n    for (i, ext_name) in extensions.iter().enumerate()\
    \ {\n        cap += ext_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        sm += ext_name.chars().filter(|c| c >= 'a' && c <= 'z').count();\n  \
    \      if cap >= sm {\n            cap -= sm;\n            best_strongest_extension\
    \ = ext_name.to_string();\n        }\n    }\n    \n    match best_strongest_extension\
    \ {\n        None => class_name.to_string() + \".NONE\",\n        Some(strongest_extension)\
    \ => class_name.to_string() + \".\" + strongest_extension,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqbjeb6ca.rs:20:49\n   |\n\
    20 |         cap += ext_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                 ^^^\n   |              \
    \                                   |\n   |                                  \
    \               expected `&char`, found `char`\n   |                         \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqbjeb6ca.rs:20:61\n   |\n20 |         cap +=\
    \ ext_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |           \
    \                                                  ^^^\n   |                 \
    \                                            |\n   |                         \
    \                                    expected `&char`, found `char`\n   |    \
    \                                                         help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbjeb6ca.rs:21:48\n\
    \   |\n21 |         sm += ext_name.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbjeb6ca.rs:21:60\n   |\n21 |         sm += ext_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \                     ^^^\n   |                                              \
    \              |\n   |                                                       \
    \     expected `&char`, found `char`\n   |                                   \
    \                         help: consider borrowing here: `&'z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqbjeb6ca.rs:24:40\n   |\n18 |     let mut best_strongest_extension\
    \ = None;\n   |                                        ---- expected due to this\
    \ value\n...\n24 |             best_st"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut maxStrongest = -1;\n    let\
    \ mut maxExtensionName = String::new();\n    for extension in extensions {\n \
    \       let count = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = match count {\n         \
    \   0 => 0,\n            1 => 1,\n            _ => count as f64 / extension.chars().count(),\n\
    \        };\n        if strength > maxStrongest {\n            maxStrongest =\
    \ strength;\n            maxExtensionName = extension;\n        }\n    }\n   \
    \ return format!(\"{}.{}\", class_name, maxExtensionName);\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpbq54cfli.rs:24:31\n\
    \   |\n24 |             _ => count as f64 / extension.chars().count(),\n   | \
    \                              ^ no implementation for `f64 / usize`\n   |\n \
    \  = help: the trait `Div<usize>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `Div<Rhs>`:\n             <&'a f32 as\
    \ Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n\
    \             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n    \
    \         <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n          \
    \   <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n     \
    \   return class_name;\n    }\n    let mut strength = -1;\n    let mut result\
    \ = class_name;\n\n    for extension in extensions {\n        if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() > strength {\n            strength = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            result = &format!(\"{}.{}\", &class_name,\
    \ &extension);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpjw84ta2v.rs:20:24\n\
    \   |\n20 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjw84ta2v.rs:26:22\n   |\n21 |     let mut result = class_name;\n\
    \   |                      ---------- expected due to this value\n...\n26 |  \
    \           result = &format!(\"{}.{}\", &class_name, &extension);\n   |     \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n26 -      \
    \       result = &format!(\"{}.{}\", &class_name, &extension);\n26 +         \
    \    result = format!(\"{}.{}\", &class_name, &extension);\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_set = extensions::HashSet::new();\n\
    \    for extension in extensions {\n        let cap_offset = match extension.chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            0 => break,\n            1 => 0,\n\
    \            _ => 1,\n        };\n        let sm_offset = match extension.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            0 => break,\n            1 => 0,\n\
    \            _ => 1,\n        };\n        extensions_set.insert(extension[cap_offset..].to_lowercase());\n\
    \    }\n    let mut result = \"\";\n    let mut strength = -1;\n    for extension\
    \ in extensions_set {\n        let cap_offset = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm_offset = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap_offset > sm_offset {\n            strength = cap_offset - sm_offset;\n\
    \            result = format!(\"{}.{}\", class_name, extension);\n           \
    \ break;\n        }\n    }\n    if extensions_set.len() > 1 {\n        for extension\
    \ in extensions_set {\n            let cap_offset = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            let sm_offset = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n            if cap_offset == sm_offset {\n     \
    \           result = format!(\"{}.{}\", class_name, extension);\n            \
    \    break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `extensions`\n\
    \  --> /tmp/tmp8a_eg9rk.rs:17:42\n   |\n17 |     let mut extensions_set = extensions::HashSet::new();\n\
    \   |                                          ^^^^^^^ not found in `extensions`\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\nhelp: if you import `HashSet`, refer to it directly\n   |\n17 -     let\
    \ mut extensions_set = extensions::HashSet::new();\n17 +     let mut extensions_set\
    \ = HashSet::new();\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8a_eg9rk.rs:38:22\n\
    \   |\n38 |             result = format!(\"{}.{}\", class_name, extension);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8a_eg9rk.rs:47:26\n   |\n47 |              \
    \   result = format!(\"{}.{}\", class_name, extension);\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `String`\n   |\n   = note: this error originates in the macro `format` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8a_eg9rk.rs:52:5\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                               ------ expected `String` because\
    \ of return type\n...\n52 |     result\n   |     ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extension_strength(extensions).max().unwrap().to_string()\
    \ + \".\" + class_name.to_owned()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `extension_strength` in this scope\n\
    \  --> /tmp/tmp6017kfw1.rs:17:5\n   |\n17 |     extension_strength(extensions).max().unwrap().to_string()\
    \ + \".\" + class_name.to_owned()\n   |     ^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let extension = extensions.iter().find(|s|\
    \ s == class_name)\n        .map(|s| s.to_lowercase()).unwrap();\n    String::from(&(class_name\
    \ + extension).to_uppercase().to_string())\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&String` with `String`\n  --> /tmp/tmp04oyrghp.rs:17:50\n\
    \   |\n17 |     let extension = extensions.iter().find(|s| s == class_name)\n\
    \   |                                                  ^^ no implementation for\
    \ `&&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp04oyrghp.rs:19:33\n\
    \   |\n19 |     String::from(&(class_name + extension).to_uppercase().to_string())\n\
    \   |                                 ^^^^^^^^^\n   |                        \
    \         |\n   |                                 expected `&str`, found struct\
    \ `String`\n   |                                 help: consider borrowing here:\
    \ `&extension`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut n = class_name.len();\n  \
    \  let mut sm = 0;\n    for &s in extensions {\n        if s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() > 0 {\n            sm = sm * 26 + (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() as i32) + 1;\n        }\n    }\n    n -= sm;\n\
    \    let mut c = class_name;\n    for (i, &s) in extensions.iter().enumerate()\
    \ {\n        if i < sm {\n            c = c.to_string() + \"_\" + s;\n       \
    \ } else {\n            c = c.to_string() + s;\n        }\n    }\n    c.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mug4q9d.rs:19:9\n   |\n\
    19 |     for &s in extensions {\n   |         ^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `s`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_mug4q9d.rs:28:39\n   |\n28 |\
    \             c = c.to_string() + \"_\" + s;\n   |                           \
    \            ^\n   |                                       |\n   |           \
    \                            expected `&str`, found struct `String`\n   |    \
    \                                   help: consider borrowing here: `&s`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_mug4q9d.rs:30:33\n   |\n30 |             c\
    \ = c.to_string() + s;\n   |                                 ^\n   |         \
    \                        |\n   |                                 expected `&str`,\
    \ found struct `String`\n   |                                 help: consider borrowing\
    \ here: `&s`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let extension_map: HashMap<usize,\
    \ usize> =\n        extensions.iter().fold(HashMap::new(), |m, s| m.entry(s.as_bytes().to_vec().count()).or_insert(s.as_bytes().to_vec().count()));\n\
    \n    let (mut class_name, mut extension_strength) = class_name.splitn(2, \".\"\
    ).map(|s| s.to_lowercase().chars().map(|b| b as char).collect()).unwrap_or((\"\
    \", 0))\n        .iter().enumerate();\n\n    let mut current_strength = -1;\n\
    \    loop {\n        let (mut current_class, _) = current_strength == -1 ? class_name\
    \ : (class_name.splitn(2, \".\").map(|s| s.to_lowercase().chars().map(|b| b as\
    \ char).collect()).unwrap_or((\"\", 0)).collect());\n        let mut current_extension_strength\
    \ = extension_strength.clone();\n\n        while current_class.is_none() {\n \
    \           let mut current_class: (String, usize) = current_extension_strength.iter().fold(\"\
    \", |a, b| a.chars().min(|a| *b));\n        }\n        let mut current_extension\
    \ = current_class.0;\n\n        while current_extension.chars().count() != 0 {\n\
    \            current_extension = &current_extension[..];\n            current_extension_strength\
    \ = current_extension_strength.iter().fold(current_strength, |a, b| {\n      \
    \          if *b >= *a {\n                    b\n                } else {\n  \
    \                  a\n                }\n            });\n        }\n\n      \
    \  if current_extension_strength >= current_strength {\n            let mut class_name\
    \ = current_class.0;\n            let mut extension_strength = current_extension_strength;\n\
    \            current_strength = current_extension_strength;\n        } else {\n\
    \            break;\n        }\n    }\n    class_name.to_lowercase().to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `class_name`\n\
    \  --> /tmp/tmp5l1johio.rs:25:63\n   |\n25 | ...   let (mut current_class, _)\
    \ = current_strength == -1 ? class_name : (class_name.splitn(2, \".\").map(|s|\
    \ s.to_lowercase().chars().map(...\n   |                                     \
    \                        ^^^^^^^^^^ expected one of `.`, `;`, `?`, `else`, or\
    \ an operator\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  -->\
    \ /tmp/tmp5l1johio.rs:17:24\n   |\n17 |     let extension_map: HashMap<usize,\
    \ usize> =\n   |                        ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp5l1johio.rs:18:32\n   |\n18 |         extensions.iter().fold(HashMap::new(),\
    \ |m, s| m.entry(s.as_bytes().to_vec().count()).or_insert(s.as_bytes().to_vec().count()));\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `unwrap_or` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp5l1johio.rs:20:141\n   |\n20 | ...).collect()).unwrap_or((\"\
    \", 0))\n   |                 ^^^^^^^^^ method not found in `Map<std::str::SplitN<'_,\
    \ &str>, [closure@/tmp/tmp5l1johio.rs:20:82: 20:139]>`\n\nwarning: unreachable\
    \ expression\n  --> /tmp/tmp5l1johio.rs:52:5\n   |\n24 | /     loop {\n25 | |\
    \         let (mut current_class, _) = current_strength == -1 ? class_name : (class_name.splitn(2,\
    \ \".\").map(|s| s.to_lowercase().chars().ma...\n26 | |         let mut current_extension_strength\
    \ = extension_strength.clone();\n27 | |\n...  |\n50 | |         }\n51 | |    \
    \ }\n   | |_____- any code following this expression is unreachable\n52 |    \
    \   class_name.to_lowercase().to_string()\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n    let\
    \ mut extensions: Vec<String> = extensions.iter().cloned().collect();\n    \n\
    \    for extension in extensions {\n        for c in extension.chars() {\n   \
    \         if c.is_upper() {\n                strength += 1;\n            }\n \
    \           if c.is_lower() {\n                strength += 1;\n            }\n\
    \        }\n    }\n    \n    match strength {\n        -1 => class_name + extensions[0],\n\
    \        0 => class_name + extensions[0],\n        1 => class_name + extensions[0],\n\
    \        2 => class_name + extensions[1],\n        _ => class_name + extensions[0]\
    \ + extensions[1],\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmphei5j1dx.rs:22:18\n   |\n22 |             if c.is_upper()\
    \ {\n   |                  ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmphei5j1dx.rs:25:18\n   |\n\
    25 |             if c.is_lower() {\n   |                  ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_lowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphei5j1dx.rs:32:28\n   |\n32 |         -1 =>\
    \ class_name + extensions[0],\n   |                            ^^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&extensions[0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphei5j1dx.rs:33:27\n\
    \   |\n33 |         0 => class_name + extensions[0],\n   |                   \
    \        ^^^^^^^^^^^^^\n   |                           |\n   |               \
    \            expected `&str`, found struct `String`\n   |                    \
    \       help: consider borrowing here: `&extensions[0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphei5j1dx.rs:34:27\n   |\n34 |         1 => class_name +\
    \ extensions[0],\n   |                           ^^^^^^^^^^^^^\n   |         \
    \                  |\n   |                           expected `&str`, found struct\
    \ `String`\n   |                           help: consider borrowing here: `&extensions[0]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphei5j1dx.rs:35:27\n   |\n35 |\
    \         2 => class_name + extensions[1],\n   |                           ^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&extensions[1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphei5j1dx.rs:36:27\n\
    \   |\n36 |         _ => class_name + extensions[0] + extensions[1],\n   |   \
    \              "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_strength = -1i32;\n\
    \    for e in extensions {\n        let class_len = e.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let class_len_lc = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let class_cap = class_len.to_string() + class_len_lc.to_string();\n \
    \       let class_sm = class_len.to_string();\n        let class_strength_fraction\
    \ =\n            (class_cap.to_string() - class_sm.to_string()).to_string();\n\
    \        if class_strength > class_strength_fraction {\n            class_strength\
    \ = class_strength_fraction;\n        }\n    }\n    class_strength.to_string().to_string()\
    \ + class_name.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0lmgyh6.rs:21:49\n   |\n\
    21 |         let class_cap = class_len.to_string() + class_len_lc.to_string();\n\
    \   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                 |\n   |                \
    \                                 expected `&str`, found struct `String`\n   |\
    \                                                 help: consider borrowing here:\
    \ `&class_len_lc.to_string()`\n\nerror[E0369]: cannot subtract `String` from `String`\n\
    \  --> /tmp/tmp_0lmgyh6.rs:24:36\n   |\n24 |             (class_cap.to_string()\
    \ - class_sm.to_string()).to_string();\n   |              ---------------------\
    \ ^ -------------------- String\n   |              |\n   |              String\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_0lmgyh6.rs:29:46\n   |\n29 |\
    \     class_strength.to_string().to_string() + class_name.to_string()\n   |  \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^\n   |    \
    \                                          |\n   |                           \
    \                   expected `&str`, found struct `String`\n   |             \
    \                                 help: consider borrowing here: `&class_name.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1;\n    for &name\
    \ in extensions.iter() {\n        let c = name.chars().filter(|c| *c >= 'A' &&\
    \ *c <= 'Z').count();\n        let s = name.chars().filter(|c| *c >= 'a' && *c\
    \ <= 'z').count();\n        if c >= strength {\n            strength = c;\n  \
    \      }\n        if s >= strength {\n            strength = s;\n        }\n \
    \   }\n    match strength {\n        -1 => class_name.to_owned(),\n        x =>\
    \ class_name.to_owned().to_string() + extensions[strength].to_owned()\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1wpsrqy4.rs:17:24\n\
    \   |\n17 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp1wpsrqy4.rs:29:9\n   |\n29 |  \
    \       -1 => class_name.to_owned(),\n   |         ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wpsrqy4.rs:30:50\n\
    \   |\n30 |         x => class_name.to_owned().to_string() + extensions[strength].to_owned()\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                  |\n   |               \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                                  help: consider borrowing\
    \ here: `&extensions[strength].to_owned()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: String\
    \ = format!(\"\");\n    let mut strength: i32 = 0;\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase().count() as\
    \ i32).count() as i32;\n        let sm = extension.chars().filter(|c| c.is_lowercase().count()\
    \ as i32).count() as i32;\n        let strength = cap - sm;\n        if strength\
    \ > strength {\n            strongest_extension = extension;\n            strength\
    \ = cap;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `bool` is not an iterator\n  --> /tmp/tmpaylyg5pk.rs:20:65\n\
    \   |\n20 |         let cap = extension.chars().filter(|c| c.is_uppercase().count()\
    \ as i32).count() as i32;\n   |                                              \
    \                   ^^^^^ `bool` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `bool: Iterator`\n           which\
    \ is required by `&mut bool: Iterator`\n\nerror[E0599]: `bool` is not an iterator\n\
    \  --> /tmp/tmpaylyg5pk.rs:21:64\n   |\n21 |         let sm = extension.chars().filter(|c|\
    \ c.is_lowercase().count() as i32).count() as i32;\n   |                     \
    \                                           ^^^^^ `bool` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ Iterator`\n           which is required by `&mut bool: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n\tlet mut class_name = String::from(class_name);\n\
    \tlet mut extensions = extensions.into_iter().cloned().collect::<Vec<_>>();\n\t\
    let mut min_strength = std::i32::MAX;\n\tlet mut strongest_extension = String::new();\n\
    \t\n\tfor extension in extensions.iter() {\n\t\tlet mut extension_strength = -1;\n\
    \t\tlet mut extension = String::from(extension);\n\t\tfor char in extension.chars()\
    \ {\n\t\t\tmatch char {\n\t\t\t\tc if c.is_uppercase() => extension_strength +=\
    \ 1,\n\t\t\t\tc if c.is_lowercase() => extension_strength += 2,\n\t\t\t\tc =>\
    \ (),\n\t\t\t}\n\t\t}\n\t\t\n\t\tif extension_strength < min_strength {\n\t\t\t\
    min_strength = extension_strength;\n\t\t\tstrongest_extension = extension;\n\t\
    \t}\n\t}\n\t\n\tformat!(\"{}.{}\", class_name, strongest_extension);\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp4fi41c7z.rs:18:46\n     |\n18   |     let mut extensions\
    \ = extensions.into_iter().cloned().collect::<Vec<_>>();\n     |             \
    \                                    ^^^^^^ expected reference, found struct `String`\n\
    \     |\n     = note: expected reference `&_`\n                   found struct\
    \ `String`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp4fi41c7z.rs:18:55\n   |\n18 |     \
    \  let mut extensions = extensions.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                            ^^^^^^^ method\
    \ cannot be called on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<std::vec::IntoIter<String> as Iterator>::Item = &_`\n          \
    \ which is required by `Cloned<std::vec::IntoIter<String>>: Iterator`\n      \
    \     `Cloned<std::vec::IntoIter<String>>: Iterator`\n           which is required\
    \ by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4fi41c7z.rs:16:72\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n39 |     format!(\"{}.{}\", class_name, strongest_extension);\n\
    \   |                                                      - help: remove this\
    \ semicolon\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counts: Vec<i32> = extensions.iter().map(|s|\
    \ s.chars().filter(|x| x.is_uppercase()).count() + 1).collect();\n    counts.sort_unstable();\n\
    \    let mut total_count = 0i32;\n    counts.iter().for_each(|&n| total_count\
    \ += n);\n    if total_count > 0 {\n        let total_strength: i32;\n       \
    \ let mut highest_strength: i32 = 0;\n        counts.iter().for_each(|&n| highest_strength\
    \ = n if n > highest_strength });\n        if highest_strength > 0 {\n       \
    \     for i in 0..(counts.size() - 1) {\n                if counts[i] > highest_strength\
    \ {\n                    highest_strength = counts[i];\n                    total_strength\
    \ = counts[i];\n                }\n            }\n        }\n        let name\
    \ = format!(\"{}.{}\", class_name, &extensions[counts[counts.size() - 1]]);\n\
    \        String::from(format!(\"{}.{}\", name, total_strength))\n    } else {\n\
    \        String::from(class_name)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpv005zaiy.rs:35:5\n\
    \   |\n25 |         if highest_strength > 0 {\n   |                          \
    \       - this opening brace...\n...\n32 |         }\n   |         - ...matches\
    \ this closing brace\n...\n35 |     } else {\n   |     ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpv005zaiy.rs:24:31\n\
    \   |\n24 |         counts.iter().for_each(|&n| highest_strength = n if n > highest_strength\
    \ });\n   |                               ^ unclosed delimiter               \
    \                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter:\
    \ `)`\n  --> /tmp/tmpv005zaiy.rs:16:79\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                                      ^ unclosed delimiter\n\
    ...\n24 |         counts.iter().for_each(|&n| highest_strength = n if n > highest_strength\
    \ });\n   |                                                                  \
    \                 ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_score = -1;\n    let\
    \ mut best_extension = String::new();\n    for extension in extensions {\n   \
    \     let (c_class, c_extension) = extension.split_ascii_uppercase();\n      \
    \  let (s_class, s_extension) = extension.split_ascii_lowercase();\n        let\
    \ score = c_class.cmp(&s_class).unwrap();\n        if score > best_score {\n \
    \           best_extension = extension;\n            best_score = score;\n   \
    \     }\n    }\n    class_name + best_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_ascii_uppercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpl_ivsetu.rs:20:48\n   |\n20 | \
    \        let (c_class, c_extension) = extension.split_ascii_uppercase();\n   |\
    \                                                ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror[E0599]:\
    \ no method named `split_ascii_lowercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpl_ivsetu.rs:21:48\n   |\n21 |         let (s_class, s_extension)\
    \ = extension.split_ascii_lowercase();\n   |                                 \
    \               ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_lowercase`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl_ivsetu.rs:28:18\n   |\n28 |     class_name + best_extension\n   |\
    \                  ^^^^^^^^^^^^^^\n   |                  |\n   |             \
    \     expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&best_extension`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter = Vec::new();\n  \
    \  for i in 0..extensions[0].len() {\n        let mut counter = Vec::new();\n\
    \        for j in 0..extensions[0].len() {\n            if class_name.chars().any(|c|\
    \ c == &extensions[0][i..j]) {\n                counter.push(i);\n           \
    \ }\n        }\n        if counter.len() > counter.max().unwrap() {\n        \
    \    counter.clear();\n            counter.push(i);\n        }\n    }\n    extensions[counter.iter().min().unwrap()]\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnl1eljo5.rs:21:48\n   |\n\
    21 |             if class_name.chars().any(|c| c == &extensions[0][i..j]) {\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpnl1eljo5.rs:25:36\n    |\n25  |         if counter.len()\
    \ > counter.max().unwrap() {\n    |                                    ^^^- supplied\
    \ 0 arguments\n    |                                    |\n    |             \
    \                       expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `unwrap` found for struct `Vec<usize>`\
    \ in the current scope\n  --> /tmp/tmpnl1eljo5.rs:25:42\n   |\n25 |         if\
    \ counter.len() > counter.max().unwrap() {\n   |                             \
    \             ^^^^^^ help: there is an associated function with a similar name:\
    \ `swap`\n\nerror[E0277]: the type `[String]` cannot be indexed by `&_`\n  -->\
    \ /tmp/tmpnl1eljo5.rs:30:5\n   |\n30 |     extensions[counter.iter().min().unwrap()]\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&_`\n   = note: required because of the requirements\
    \ on the impl of `Index<&_>` for `Vec<String>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = 0;\n    let mut\
    \ class_name = class_name.to_lowercase();\n    for extension in extensions.iter()\
    \ {\n        let mut name = extension.to_lowercase();\n        if class_name.contains(&name[..])\
    \ {\n            strength += 1;\n        }\n    }\n    let mut index = strength.min(strength).cmp(&strength);\n\
    \    match index {\n        None => class_name[..] + 'a',\n        Some(index)\
    \ => {\n            if class_name.contains(&name[..]) {\n                index\
    \ += 1;\n            }\n            let mut last_index = index + 1;\n        \
    \    if last_index < strength {\n                let mut result = &class_name[..];\n\
    \                while last_index < strength {\n                    result = &result[..]\
    \ + &extensions[last_index].to_lowercase()[..];\n                    last_index\
    \ += 1;\n                }\n                return result\n            }\n   \
    \     }\n    }\n    return class_name;\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpoc4oqa00.rs:29:37\n\
    \   |\n29 |             if class_name.contains(&name[..]) {\n   |            \
    \                         ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoc4oqa00.rs:27:9\n   |\n26 |     match index {\n   |  \
    \         ----- this expression has type `std::cmp::Ordering`\n27 |         None\
    \ => class_name[..] + 'a',\n   |         ^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoc4oqa00.rs:28:9\n   |\n26 |     match index {\n   |           -----\
    \ this expression has type `std::cmp::Ordering`\n27 |         None => class_name[..]\
    \ + 'a',\n28 |         Some(index) => {\n   |         ^^^^^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n\
    \              found enum `Option<_>`\n\nerror[E0369]: cannot add `char` to `str`\n\
    \  --> /tmp/tmpoc4oqa00.rs:27:32\n   |\n27 |         None => class_name[..] +\
    \ 'a',\n   |                 -------------- ^ --- char\n   |                 |\n\
    \   |                 str\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoc4oqa00.rs:39:24\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n...\n39 |    \
    \             return result\n   |                        ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    String::from(class_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmppmop3bt4.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut s = String::from(class_name);\n\
    \    let mut m = 1;\n    for &e in extensions {\n        let cap = e.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n        let sm = e.chars().filter(|&c| c.is_lowercase()).count();\n\
    \        m = cap - sm;\n        if m > 0 {\n            s.push_str(&e.to_string().to_lowercase());\n\
    \        }\n    }\n    return s.to_string();\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasy0yps0.rs:19:9\n   |\n\
    19 |     for &e in extensions {\n   |         ^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `e`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_name = class_name.replace(\"\
    .\", \"_\");\n    let mut extensions = extensions.iter().map(String::from);\n\
    \    extensions.sort();\n    for (i, e) in extensions {\n        if let Some(i)\
    \ = (i + 1) % extensions.len() {\n            if let Some(j) = (i + j + 1) % extensions.len()\
    \ {\n                if let Some(k) = (i + j + k + 1) % extensions.len() {\n \
    \                   if class_name.contains(&e) && class_name.contains(&extensions[(i\
    \ as usize) + (j as usize)]) && class_name.contains(&extensions[(i as usize) +\
    \ (j as usize) + (k as usize)]){\n                        class_name = &class_name[..(i\
    \ as usize)] + &extensions[(j as usize)] + &extensions[(k as usize)] + &class_name[(i\
    \ as usize) + (j as usize) + (k as usize)..];\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return &class_name[..];\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmp3hpl4co1.rs:22:35\n\
    \   |\n22 |             if let Some(j) = (i + j + 1) % extensions.len() {\n  \
    \ |                                   ^ help: a local variable with a similar\
    \ name exists: `e`\n\nerror[E0425]: cannot find value `k` in this scope\n   -->\
    \ /tmp/tmp3hpl4co1.rs:23:43\n    |\n23  |                 if let Some(k) = (i\
    \ + j + k + 1) % extensions.len() {\n    |                                   \
    \        ^ help: a tuple variant with a similar name exists: `Ok`\n\nerror[E0599]:\
    \ no method named `sort` found for struct `Map` in the current scope\n  --> /tmp/tmp3hpl4co1.rs:19:16\n\
    \   |\n19 |     extensions.sort();\n   |                ^^^^ method not found\
    \ in `Map<std::slice::Iter<'_, String>, fn(&String) -> String {<String as From<&String>>::from}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3hpl4co1.rs:20:9\n   |\n20 | \
    \    for (i, e) in extensions {\n   |         ^^^^^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found tuple\n   |\n   = note: expected struct `String`\n               found\
    \ tuple `(_, _)`\n\nerror[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_,\
    \ String>, fn(&String) -> String {<String as From<&String>>::from}>`\n  --> /tmp/tmp3hpl4co1.rs:24:72\n\
    \   |\n24 | ...   if class_name.contains(&e) && class_name.contains(&extensions[(i\
    \ as usize) + (j as usize)]) && class_name.contains(&extensions[(i a...\n   |\
    \                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_, String>,\
    \ fn(&String) -> String {<String as From<&String>>::from}>`\n  --> /tmp/tmp3hpl4co1.rs:24:137\n\
    \   |\n24 | ... (j as usize)]) && class_name.contains(&extensions[(i as usize)\
    \ + (j as usize) + (k as usize)]){\n   |                                     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Map<std::slice::Iter<'_, String>, fn(&String)\
    \ -> Strin"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n\n   \
    \ for mut extension in extensions.iter() {\n        let len = extension.len();\n\
    \        let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        if strength >= 0 && strength < min_strength\
    \ {\n            min_strength = strength;\n        }\n    }\n\n    let class_name\
    \ = &class_name.to_lowercase();\n    let mut class_name = class_name[..class_name.len()\
    \ - min_strength].to_string();\n    let mut new_class = class_name;\n\n    for\
    \ extension in extensions.iter() {\n        let len = extension.len();\n     \
    \   let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n  \
    \      let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        let index = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let extension = extension[..extension.len()\
    \ - index];\n        new_class.push('.');\n        new_class.push(extension.to_lowercase());\n\
    \        new_class.push('|');\n    }\n    new_class.pop();\n    new_class.pop();\n\
    \n    new_class.push(')');\n    new_class.push('(');\n    new_class.push(class_name);\n\
    \n    return new_class.to_owned();\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ezee487.rs:21:53\n   |\n\
    21 |         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                     ^^^\n   |          \
    \                                           |\n   |                          \
    \                           expected `&char`, found `char`\n   |             \
    \                                        help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8ezee487.rs:21:65\n   |\n21 |\
    \         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                                 ^^^\n  \
    \ |                                                                 |\n   |  \
    \                                                               expected `&char`,\
    \ found `char`\n   |                                                         \
    \        help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8ezee487.rs:22:52\n   |\n22 |         let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \             ^^^\n   |                                                    |\n\
    \   |                                                    expected `&char`, found\
    \ `char`\n   |                                                    help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ezee487.rs:22:64\n\
    \   |\n22 |         let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                                ^^^\n   |\
    \                                                                |\n   |     \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \       help: consider borrowing here: `&'z'`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp8ezee487.rs:17:28\n   |\n17 | \
    \    let mut min_strength = -1;\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Complete the code here\n    \n\
    \    let class_name_lowercase: String = class_name.to_lowercase();\n    let mut\
    \ class_name_uppercase = String::new();\n    let mut total_length = 0;\n    for\
    \ char of class_name_lowercase {\n        if char == '_' {\n            total_length\
    \ += 1;\n        }\n        else {\n            total_length += 2;\n        }\n\
    \    }\n    let mut strength_of_extension: usize = 0;\n    for extension in extensions\
    \ {\n        let mut extension_lowercase = extension.to_lowercase();\n       \
    \ let mut extension_uppercase = extension.to_uppercase();\n        let mut total_length\
    \ = 0;\n        for char of extension_lowercase {\n            if char == '_'\
    \ {\n                total_length += 1;\n            }\n            else {\n \
    \               total_length += 2;\n            }\n        }\n        strength_of_extension\
    \ +=\n            (class_name_uppercase.len() - total_length) * 2 + (extension_uppercase.len()\
    \ - total_length) * 2;\n    }\n    let strength = if strength_of_extension > 0\
    \ {\n        strength_of_extension\n    } else {\n        0\n    };\n    let mut\
    \ final_class_name = class_name;\n    let mut final_extension_name = String::new();\n\
    \    for extension in extensions {\n        let mut extension_lowercase = extension.to_lowercase();\n\
    \        let mut extension_uppercase = extension.to_uppercase();\n        let\
    \ mut total_length = 0;\n        for char of extension_lowercase {\n         \
    \   if char == '_' {\n                total_length += 1;\n            }\n    \
    \        else {\n                total_length += 2;\n            }\n        }\n\
    \        if final_extension_name.len() < total_length {\n            final_extension_name\
    \ += extension;\n        }\n    }\n    if final_extension_name.len() > total_length\
    \ {\n        final_extension_name = &final_extension_name[0..total_length]\n \
    \   }\n    let mut strength_fraction: f32 = strength / extension_lowercase.len();\n\
    \    let mut strength_string: String = String::new();\n    let mut final_strength_string\
    \ = String::new();\n    let mut strength_fraction_string = String::new();\n  \
    \  let mut lowest_extension: String = String::new();\n    let mut strength_of_lowest_extension:\
    \ usize = 0;\n    for extension in extensions {\n        let mut extension_lowercase\
    \ = extension.to_lowercase();\n        let mut extension_uppercase = extension.to_uppercase();\n\
    \        let mut total_length = 0;\n        for char of extension_lowercase {\n\
    \            if char == '_' {\n                total_length += 1;\n          \
    \  }\n            else {\n                total_length += 2;\n            }\n\
    \        }\n        if \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp118qpn95.rs:104:3\n\
    \    |\n16  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n78  |     for extension in extensions\
    \ {\n    |                                 - this delimiter might not be properly\
    \ closed...\n...\n91  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n104 | }\n    |   ^\n\nerror: missing `in` in `for` loop\n\
    \  --> /tmp/tmp118qpn95.rs:22:14\n   |\n22 |     for char of class_name_lowercase\
    \ {\n   |              ^^ help: try using `in` here instead\n\nerror: missing\
    \ `in` in `for` loop\n  --> /tmp/tmp118qpn95.rs:35:18\n   |\n35 |         for\
    \ char of extension_lowercase {\n   |                  ^^ help: try using `in`\
    \ here instead\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp118qpn95.rs:57:18\n\
    \   |\n57 |         for char of extension_lowercase {\n   |                  ^^\
    \ help: try using `in` here instead\n\nerror: missing `in` in `for` loop\n  -->\
    \ /tmp/tmp118qpn95.rs:82:18\n   |\n82 |         for char of extension_lowercase\
    \ {\n   |                  ^^ help: try using `in` here instead\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmp118qpn95.rs:91:1\n   |\n91 | }\n   | ^\
    \ expected expression\n\nerror[E0425]: cannot find value `extension_lowercase`\
    \ in this scope\n  --> /tmp/tmp118qpn95.rs:72:49\n   |\n72 |     let mut strength_fraction:\
    \ f32 = strength / extension_lowercase.len();\n   |                          \
    \                       ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp118qpn95.rs:22:17\n   |\n22 |   \
    \  for char of class_name_lowercase {\n   |                 ^^^^^^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // your code here\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45mqwee5.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_extension_strength = -1;\n\
    \    for extension in extensions {\n        let mut current_extension_strength\
    \ = extension.chars().filter(|x| x >= 'A' && x <= 'Z').count() - extension.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n        if current_extension_strength < min_extension_strength\
    \ {\n            min_extension_strength = current_extension_strength;\n      \
    \  }\n    }\n    \n    let mut current_strength = min_extension_strength;\n  \
    \  while current_strength != 0 {\n        for extension in extensions {\n    \
    \        let mut current_extension_strength = extension.chars().filter(|x| x >=\
    \ 'A' && x <= 'Z').count() - extension.chars().filter(|x| x >= 'a' && x <= 'z').count();\n\
    \            if current_extension_strength <= current_strength {\n           \
    \     break;\n            }\n        }\n        current_strength -= 1;\n    }\n\
    \n    class_name.to_string() + extensions.iter().find(|e| e.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count() - e.chars().filter(|x| x >= 'a' && x <= 'z').count()\
    \ == min_extension_strength).unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvfm2sz41.rs:19:80\n   |\n\
    19 | ...   let mut current_extension_strength = extension.chars().filter(|x| x\
    \ >= 'A' && x <= 'Z').count() - extension.chars().filter(|x| x >=...\n   |   \
    \                                                                           ^^^\n\
    \   |                                                                        \
    \      |\n   |                                                               \
    \               expected `&char`, found `char`\n   |                         \
    \                                                     help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvfm2sz41.rs:19:92\n\
    \   |\n19 | ...   let mut current_extension_strength = extension.chars().filter(|x|\
    \ x >= 'A' && x <= 'Z').count() - extension.chars().filter(|x| x >=...\n   | \
    \                                                                            \
    \             ^^^\n   |                                                      \
    \                                    |\n   |                                 \
    \                                                         expected `&char`, found\
    \ `char`\n   |                                                               \
    \                           help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvfm2sz41.rs:19:141\n   |\n19 | ...).count()\
    \ - extension.chars().filter(|x| x >= 'a' && x <= 'z').count();\n   |        \
    \                                          ^^^\n   |                         \
    \                         |\n   |                                            \
    \      expected `&char`, found `char`\n   |                                  \
    \                help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvfm2sz41.rs:19:153\n   |\n19 | ...extension.chars().filter(|x|\
    \ x >= 'a' && x <= 'z').count();\n   |                                       \
    \           ^^^\n   |                                                  |\n   |\
    \                                                  expected `&char`, "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut sorted_extensions = extensions.clone();\n\
    \    sorted_extensions.sort_by(|a, b| b.cmp(a));\n    let mut strength: i32 =\
    \ -1;\n    let mut cur = &mut sorted_extensions[0];\n    for &s in sorted_extensions\
    \ {\n        strength = match s.chars().filter(|c| c.is_uppercase()).count() -\
    \ s.chars().filter(|c| c.is_lowercase()).count() {\n            Some(c) => (c\
    \ as i32).abs(),\n            None => 0,\n        };\n        if strength == 0\
    \ {\n            strength = -1;\n        }\n        if strength == 1 {\n     \
    \       strength = 0;\n        }\n        if strength == 2 {\n            strength\
    \ = 1;\n        }\n        if strength > 2 {\n            strength = -1;\n   \
    \     }\n        cur = s;\n        if cur == class_name {\n            strength\
    \ = -1;\n            break;\n        }\n    }\n    sorted_extensions.remove(cur);\n\
    \    String::from(format!(\"{}.{}\", class_name, cur))\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpipx6kpvv.rs:21:9\n   |\n\
    21 |     for &s in sorted_extensions {\n   |         ^^    ----------------- this\
    \ expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `s`\n   |\n   = note: expected struct `String`\n      \
    \     found reference `&_`\n\nerror[E0277]: can't compare `&mut String` with `String`\n\
    \  --> /tmp/tmpipx6kpvv.rs:39:16\n   |\n39 |         if cur == class_name {\n\
    \   |                ^^ no implementation for `&mut String == String`\n   |\n\
    \   = help: the trait `PartialEq<String>` is not implemented for `&mut String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpipx6kpvv.rs:44:30\n   |\n44 |     sorted_extensions.remove(cur);\n\
    \   |                              ^^^ expected `usize`, found `&mut String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_map: HashMap<String,\
    \ u32> = HashMap::new();\n\n    for extension in extensions {\n        let c =\
    \ extension.chars().count();\n        let s = extension.chars().map(|c| c as u32).sum();\n\
    \        if extensions_map.contains_key(&extension) {\n            extensions_map.insert(extension,\
    \ extensions_map.get(&extension) - s);\n        } else {\n            extensions_map.insert(extension,\
    \ s);\n        }\n    }\n\n    let mut max_value: usize = 0;\n    let mut max_extension:\
    \ String = String::new();\n\n    for (extension, s) in extensions_map {\n    \
    \    if max_value == 0 {\n            max_value = s;\n            max_extension\
    \ = extension;\n        }\n        if s > max_value {\n            max_value =\
    \ s;\n            max_extension = extension;\n        }\n    }\n    return format!(\"\
    {}.{}\", class_name, max_extension);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpd9vpop2k.rs:17:29\n\
    \   |\n17 |     let mut extensions_map: HashMap<String, u32> = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpd9vpop2k.rs:17:52\n   |\n17 |     let mut extensions_map: HashMap<String,\
    \ u32> = HashMap::new();\n   |                                               \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut res = String::new();\n   \
    \ let mut max_strength = -1;\n    for ext in extensions {\n        let ex_str:\
    \ &str = ext.to_string();\n        let cap: usize = ex_str.chars().filter(|&x|\
    \ x >= 'A' && x <= 'Z').count();\n        let sm: usize = ex_str.chars().filter(|&x|\
    \ x >= 'a' && x <= 'z').count();\n        if cap - sm > max_strength {\n     \
    \       max_strength = cap - sm;\n            res = class_name + \".\" + ex_str;\n\
    \        }\n    }\n    if res.len() < class_name.len() {\n        res += class_name;\n\
    \    }\n    if max_strength == -1 {\n        return \"NONE\".to_string();\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi0iues0_.rs:20:28\n   |\n\
    20 |         let ex_str: &str = ext.to_string();\n   |                     ----\
    \   ^^^^^^^^^^^^^^^\n   |                     |      |\n   |                 \
    \    |      expected `&str`, found struct `String`\n   |                     |\
    \      help: consider borrowing here: `&ext.to_string()`\n   |               \
    \      expected due to this\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpi0iues0_.rs:18:28\n   |\n18 |     let mut max_strength\
    \ = -1;\n   |                            ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0iues0_.rs:29:16\n\
    \   |\n29 |         res += class_name;\n   |                ^^^^^^^^^^\n   | \
    \               |\n   |                expected `&str`, found struct `String`\n\
    \   |                help: consider borrowing here: `&class_name`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpi0iues0_.rs:31:24\n\
    \   |\n31 |     if max_strength == -1 {\n   |                        ^^\n   |\
    \                        |\n   |                        cannot apply unary operator\
    \ `-`\n   |                        help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_string = class_name.to_string();\n\
    \    let mut extensions_string = extensions.to_string();\n    let mut extension_length:\
    \ usize = 0;\n\n    while class_string.len() > 0 {\n        let mut class: u32\
    \ = 0;\n        if class_string.len() > 0 {\n            let mut letter_count\
    \ = 1;\n            for letter in class_string {\n                if letter >=\
    \ 'A' && letter <= 'Z' {\n                    letter_count *= 21;\n          \
    \      } else {\n                    letter_count *= 26;\n                }\n\
    \                class += u32::from(letter) - u32::from('A');\n            }\n\
    \            class += ((u32::from(class_name[class_string.len() - 1]) - u32::from('A'))\
    \ as u32 * letter_count) as u32;\n        }\n        let mut extension: u32 =\
    \ 0;\n        while extensions_string.len() > 0 {\n            let mut letter_count\
    \ = 1;\n            for letter in extensions_string {\n                if letter\
    \ >= 'A' && letter <= 'Z' {\n                    letter_count *= 21;\n       \
    \         } else {\n                    letter_count *= 26;\n                }\n\
    \                extension += u32::from(letter) - u32::from('A');\n          \
    \  }\n            extension += ((u32::from(extensions_string[extensions_string.len()\
    \ - 1]) - u32::from('A')) as u32 * letter_count) as u32;\n            extension_length\
    \ += 1\n        }\n        if class > extension {\n            class_string.pop();\n\
    \        } else {\n            extensions_string.pop();\n        }\n    }\n\n\
    \    format!(\"{}.{}\", class_name, extensions_string[extension_length - 1])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<String>` doesn't implement `std::fmt::Display`\n   -->\
    \ /tmp/tmpsyzijekg.rs:18:44\n    |\n18  |       let mut extensions_string = extensions.to_string();\n\
    \    |                                              ^^^^^^^^^ `Vec<String>` cannot\
    \ be formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<String>: std::fmt::Display`\n \
    \           which is required by `Vec<String>: ToString`\n            `[String]:\
    \ std::fmt::Display`\n            which is required by `[String]: ToString`\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsyzijekg.rs:25:27\n \
    \  |\n25 |             for letter in class_string {\n   |                    \
    \       ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsyzijekg.rs:33:34\n\
    \   |\n33 |             class += ((u32::from(class_name[class_string.len() - 1])\
    \ - u32::from('A')) as u32 * letter_count) as u32;\n   |                     \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut sorted_extensions = extensions.iter().sorted();\n\
    \    let mut strength = -1;\n    for &f in &mut sorted_extensions {\n        let\
    \ cap = f.len();\n        let sm = class_name.chars().filter(|c| c.is_lowercase()).count();\n\
    \        strength = cap - sm;\n        if strength == 0 {\n            break;\n\
    \        }\n    }\n    sorted_extensions[0].to_string() + \".\" + sorted_extensions[1].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpn4blqw84.rs:17:51\n   |\n17 |     let mut\
    \ sorted_extensions = extensions.iter().sorted();\n   |                      \
    \                             ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ String>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_ext: Vec<String>\
    \ = extensions;\n    strongest_ext.sort_by_key(|x| x.chars().filter(|c| c.is_uppercase()).count()\
    \ -\n        x.chars().filter(|c| c.is_lowercase()).count());\n    if extensions.len()\
    \ > strongest_ext.len() {\n        strongest_ext = extensions\n    }\n    let\
    \ mut strongest_ext_str = \"\";\n    for e in strongest_ext {\n        strongest_ext_str\
    \ += class_name.to_string();\n        strongest_ext_str += \".\".to_string();\n\
    \        strongest_ext_str += e.to_string();\n        strongest_ext_str += \"\
    .\".to_string();\n    }\n    strongest_ext_str\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmp_r9oqb3i.rs:25:9\n   |\n25 |         strongest_ext_str\
    \ += class_name.to_string();\n   |         -----------------^--^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |                 |\n   |         |                 `+` cannot be\
    \ used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on\
    \ type `&str`\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_r9oqb3i.rs:26:9\n   |\n26 |         strongest_ext_str\
    \ += \".\".to_string();\n   |         -----------------^--^^^^^^^^^^^^^^^^\n \
    \  |         |                 |\n   |         |                 `+` cannot be\
    \ used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on\
    \ type `&str`\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_r9oqb3i.rs:27:9\n   |\n27 |         strongest_ext_str\
    \ += e.to_string();\n   |         -----------------^--^^^^^^^^^^^^^^\n   |   \
    \      |                 |\n   |         |                 `+` cannot be used\
    \ to concatenate a `&str` with a `String`\n   |         cannot use `+=` on type\
    \ `&str`\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_r9oqb3i.rs:28:9\n   |\n28 |         strongest_ext_str\
    \ += \".\".to_string();\n   |         -----------------^--^^^^^^^^^^^^^^^^\n \
    \  |         |                 |\n   |         |                 `+` cannot be\
    \ used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on\
    \ type `&str`\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_r9oqb3i.rs:30:5\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                      "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_sorted = extensions.iter().cloned().collect::<Vec<String>>();\n\
    \    extensions_sorted.sort();\n    let mut class_name_uppercased = class_name\n\
    \        .chars()\n        .filter(|c| *c >= 'A' && *c <= 'Z')\n        .collect::<Vec<&'static\
    \ str>>();\n    let mut num_uppercase_letters = class_name_uppercased.len();\n\
    \    class_name_uppercased.sort_by_key(|c| {\n        let uppercase_letter = match\
    \ c {\n            'A' => 1,\n            'B' => 2,\n            'C' => 3,\n \
    \           'D' => 4,\n            'E' => 5,\n            'F' => 6,\n        \
    \    'G' => 7,\n            'H' => 8,\n            'I' => 9,\n            'J'\
    \ => 10,\n            'K' => 11,\n            'L' => 12,\n            'M' => 13,\n\
    \            'N' => 14,\n            'O' => 15,\n            'P' => 16,\n    \
    \        'Q' => 17,\n            'R' => 18,\n            'S' => 19,\n        \
    \    'T' => 20,\n            'U' => 21,\n            'V' => 22,\n            'W'\
    \ => 23,\n            'X' => 24,\n            'Y' => 25,\n            'Z' => 26,\n\
    \            _ => unreachable!(),\n        };\n        num_uppercase_letters.sort_by_key(|c|\
    \ {\n            *c >= uppercase_letter ? 1 : 0\n        });\n        *num_uppercase_letters\
    \ - uppercase_letter\n    });\n\n    num_uppercase_letters\n        .filter_map(|&x|\
    \ x.to_ascii_lowercase().as_bytes().iter().cloned().collect::<String>())\n   \
    \     .collect()\n        .join(\"\")\n        .to_lowercase()\n        .join(\"\
    \")\n        + extensions_sorted\n            .iter()\n            .filter(|&x|\
    \ x.len() > 0)\n            .map(|x| x.to_ascii_lowercase().as_bytes().iter().cloned().collect::<String>())\n\
    \            .max()\n            .unwrap()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpnc76lfxv.rs:73:1\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - this opening brace...\n...\n72 |     }\n   |     - ...matches\
    \ this closing brace\n73 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n    let\
    \ mut min_extension_str: String = class_name;\n\n    for extension in extensions\
    \ {\n        let mut class_extension = class_name.to_lowercase();\n        class_extension.insert(class_extension.len(),\
    \ extension.to_lowercase());\n        let mut strength = class_extension.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() - class_extension.chars().filter(|&c| *c >=\
    \ 'a' && *c <= 'z').count();\n        if strength < min_strength {\n         \
    \   min_strength = strength;\n            min_extension_str = class_extension.to_lowercase();\n\
    \        }\n    }\n\n    min_extension_str\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_utj_q4.rs:22:55\n   |\n\
    22 |         class_extension.insert(class_extension.len(), extension.to_lowercase());\n\
    \   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmp3_utj_q4.rs:23:64\n   |\n23 | ...   let mut strength\
    \ = class_extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count() - class_extension.chars().filter(|&c|\
    \ *c >= ...\n   |                                                            \
    \  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3_utj_q4.rs:23:77\n\
    \   |\n23 | ...   let mut strength = class_extension.chars().filter(|&c| *c >=\
    \ 'A' && *c <= 'Z').count() - class_extension.chars().filter(|&c| *c >= ...\n\
    \   |                                                                        \
    \   ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3_utj_q4.rs:23:134\n\
    \   |\n23 | ...   let mut strength = class_extension.chars().filter(|&c| *c >=\
    \ 'A' && *c <= 'Z').count() - class_extension.chars().filter(|&c| *c >= ...\n\
    \   |                                                                        \
    \                                                            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp3_utj_q4.rs:23:147\n   |\n\
    23 | ...= 'Z').count() - class_extension.chars().filter(|&c| *c >= 'a' && *c <=\
    \ 'z').count();\n   |                                                        \
    \              ^^\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp3_utj_q4.rs:17:28\n   |\n17 |     let mut min_strength = -1;\n\
    \   |                            ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed ex"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: Vec<String>\
    \ = vec![];\n    let mut total_strength: i32 = 0;\n\n    for extension in extensions.iter()\
    \ {\n        let (char_classes, strength) = split_class_and_extension(extension);\n\
    \n        let class_strength = if char_classes.len() == 0 {\n            0\n \
    \       } else {\n            char_classes.len()\n        };\n\n        let strength_difference\
    \ = strength - class_strength;\n\n        if strength_difference == 0 {\n    \
    \        // This is the case when all characters are in one class\n          \
    \  strongest_extension.push(extension);\n        } else {\n            // This\
    \ means there is more that one class of characters\n            if strength_difference\
    \ < total_strength {\n                // This is the case when two or more classes\
    \ of characters are \n                // stronger\n                total_strength\
    \ = strength_difference;\n                strongest_extension.clear();\n     \
    \           strongest_extension.push(extension);\n            } else {\n     \
    \           // This means there is only one class of characters\n            \
    \    strongest_extension.push(extension);\n            }\n        }\n    }\n\n\
    \    if total_strength == 0 {\n        // This means that there is no strong extension\n\
    \        class_name.to_owned()\n    } else {\n        // This means that there\
    \ is at least one extension with the strength we want\n        class_name.to_owned()\
    \ + strongest_extension.iter().max().to_string()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split_class_and_extension` in this\
    \ scope\n  --> /tmp/tmpek5ip6la.rs:21:40\n   |\n21 |         let (char_classes,\
    \ strength) = split_class_and_extension(extension);\n   |                    \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpek5ip6la.rs:33:38\n   |\n33 |             strongest_extension.push(extension);\n\
    \   |                                      ^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                      |\n   |  \
    \                                    expected struct `String`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpek5ip6la.rs:41:42\n   |\n41 |\
    \                 strongest_extension.push(extension);\n   |                 \
    \                         ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                          |\n   |                       \
    \                   expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpek5ip6la.rs:44:42\n   |\n44 |              \
    \   strongest_extension.push(extension);\n   |                               \
    \           ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n \
    \  |                                          |\n   |                        \
    \                  expected struct `String`, found `&String`\n\nerror[E0599]:\
    \ the method `to_string` exists for enum `Option<&String>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmpek5ip6la.rs:54:66\n    |\n54  |         \
    \  class_name.to_owned() + strongest_extension.iter().max().to_string()\n    |\
    \                                                                    ^^^^^^^^^\
    \ method cannot be called on `Option<&String>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<&String>: std::fmt::Display`\n            which is required by `Option<&String>:\
    \ ToString`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E03"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut result: String = \"\";\n \
    \   let mut count_upper = 0;\n    let mut count_lower = 0;\n    for &item in extensions\
    \ {\n        if item.chars().filter(|x| *x >= 'A' && *x <= 'Z').count() == count_upper\
    \ {\n            count_upper += 1;\n        }\n        if item.chars().filter(|x|\
    \ *x >= 'a' && *x <= 'z').count() == count_lower {\n            count_lower +=\
    \ 1;\n        }\n    }\n    if count_upper == count_lower {\n        return class_name.to_string()\
    \ + \".\" + extensions[0]\n    }\n    let strength = count_upper - count_lower;\n\
    \    if strength > 0 {\n        result = class_name.to_string() + \".\" + extensions[strength].to_string();\n\
    \    } else {\n        result = class_name.to_string() + \".\" + extensions[extensions.len()\
    \ - 1];\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv7_2p5cr.rs:17:30\n   |\n\
    17 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv7_2p5cr.rs:20:9\n   |\n20 |     for &item in extensions\
    \ {\n   |         ^^^^^    ---------- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `item`\n   |\n  \
    \ = note: expected struct `String`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv7_2p5cr.rs:29:47\n   |\n29 |         return\
    \ class_name.to_string() + \".\" + extensions[0]\n   |                       \
    \                        ^^^^^^^^^^^^^\n   |                                 \
    \              |\n   |                                               expected\
    \ `&str`, found struct `String`\n   |                                        \
    \       help: consider borrowing here: `&extensions[0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv7_2p5cr.rs:33:49\n   |\n33 |         result = class_name.to_string()\
    \ + \".\" + extensions[strength].to_string();\n   |                          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |               \
    \                                  |\n   |                                   \
    \              expected `&str`, found struct `String`\n   |                  \
    \                               help: consider borrowing here: `&extensions[strength].to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv7_2p5cr.rs:35:49\n   |\n35 |\
    \         result = class_name.to_string() + \".\" + extensions[extensions.len()\
    \ - 1];\n   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                 |\n   |                \
    \                                 expec"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: Option<String>\
    \ = None;\n    let mut strongest_extension_strength: usize = 0;\n    for (index,\
    \ extension) in extensions.iter().enumerate() {\n        let cap: usize = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm: usize = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = (cap - sm) as usize;\n\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension\
    \ = Some(extension);\n            strongest_extension_strength = strength;\n \
    \       }\n    }\n\n    strongest_extension.unwrap_or(class_name.to_string() +\
    \ \".NONE\")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc45n92sl.rs:25:40\n   |\n\
    25 |             strongest_extension = Some(extension);\n   |                \
    \                        ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `&String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_extension = extensions[0]\n\
    \    let mut best_strength = -1;\n    let mut best_index = -1;\n    for extension\
    \ in extensions {\n        let (strength, index) = get_strength(class_name, extension);\n\
    \        if strength > best_strength {\n            best_extension = extension;\n\
    \            best_strength = strength;\n            best_index = index;\n    \
    \    }\n    }\n    format!(\"{}{}.{}\", class_name, best_extension, best_index)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjhpqse7n.rs:17:43\n\
    \   |\n17 |     let mut best_extension = extensions[0]\n   |                 \
    \                          ^ help: add `;` here\n18 |     let mut best_strength\
    \ = -1;\n   |     --- unexpected token\n\nerror[E0425]: cannot find function `get_strength`\
    \ in this scope\n  --> /tmp/tmpjhpqse7n.rs:21:33\n   |\n21 |         let (strength,\
    \ index) = get_strength(class_name, extension);\n   |                        \
    \         ^^^^^^^^^^^^ help: a local variable with a similar name exists: `best_strength`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: Vec<String>\
    \ = extensions.iter().cloned().collect();\n    strongest_extension.sort_by_key(|x|\
    \ x.to_ascii_lowercase().len());\n    strongest_extension = strongest_extension.iter().cloned().collect();\n\
    \    let mut current_strength = -1;\n    let mut strongest_extension_str: Vec<String>\
    \ = strongest_extension.iter().cloned().collect();\n    strongest_extension_str.sort_by_key(|x|\
    \ x.to_ascii_lowercase().len());\n    strongest_extension_str = strongest_extension_str.iter().cloned().collect();\n\
    \    let mut i: usize = 0;\n    for s in strongest_extension_str {\n        if\
    \ s.to_ascii_lowercase().len() > current_strength {\n            current_strength\
    \ = s.to_ascii_lowercase().len();\n            i = 1;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let class_with_strongest_extension: String\
    \ = class_name.to_string();\n    for _ in 0..i {\n        class_with_strongest_extension\
    \ += strongest_extension_str[0].to_string();\n    }\n    class_with_strongest_extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphiwutem3.rs:20:32\n\
    \   |\n20 |     let mut current_strength = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphiwutem3.rs:35:43\n   |\n35 |  \
    \       class_with_strongest_extension += strongest_extension_str[0].to_string();\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                           |\n   |                      \
    \                     expected `&str`, found struct `String`\n   |           \
    \                                help: consider borrowing here: `&strongest_extension_str[0].to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n    let\
    \ mut max_index = 0;\n    extensions.iter().fold(&class_name[..], |i, e| {\n \
    \       let caps = e.len();\n        let sm = caps.saturating_sub(i).unwrap();\n\
    \        let strength = (caps - sm).min(|a, b| a.cmp(b));\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            max_index\
    \ = i;\n        }\n        return i;\n    });\n    class_name.to_string().to_string().split(|c|\
    \ c.is_uppercase()).last().unwrap().to_string() + \"_\" + extensions[max_index].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4v0yoime.rs:21:38\n   |\n\
    21 |         let sm = caps.saturating_sub(i).unwrap();\n   |                 \
    \                     ^ expected `usize`, found `&str`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp4v0yoime.rs:21:41\n\
    \   |\n21 |         let sm = caps.saturating_sub(i).unwrap();\n   |          \
    \                               ^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4v0yoime.rs:25:25\n   |\n18 |     let mut max_index\
    \ = 0;\n   |                         - expected due to this value\n...\n25 | \
    \            max_index = i;\n   |                         ^ expected integer,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4v0yoime.rs:29:104\n\
    \   |\n29 |     class_name.to_string().to_string().split(|c| c.is_uppercase()).last().unwrap().to_string()\
    \ + \"_\" + extensions[max_index].to_string()\n   |                          \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                                   \
    \                                                                     |\n   |\
    \                                                                            \
    \                            expected `&str`, found struct `String`\n   |    \
    \                                                                            \
    \                        help: consider borrowing here: `&extensions[max_index].to_string()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n\
    \    match extensions.iter().max_by_key(|x| x.len_utf8()) {\n        Some(val)\
    \ => match val.len_utf8() {\n            0 => {},\n            _ => {\n      \
    \          strongest_extension.push_str(&class_name);\n                strongest_extension.push_str(&val.to_ascii_lowercase());\n\
    \                strongest_extension.push('.')\n            }\n        },\n  \
    \      None => return strongest_extension,\n    }\n    return strongest_extension;\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len_utf8` found for reference `&&String`\
    \ in the current scope\n  --> /tmp/tmpjrii_h1d.rs:18:46\n   |\n18 |     match\
    \ extensions.iter().max_by_key(|x| x.len_utf8()) {\n   |                     \
    \                         ^^^^^^^^ method not found in `&&String`\n\nerror[E0599]:\
    \ no method named `len_utf8` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpjrii_h1d.rs:19:32\n   |\n19 |         Some(val) => match val.len_utf8()\
    \ {\n   |                                ^^^^^^^^ method not found in `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extension: Option<usize> =\
    \ None;\n    let mut strength = -1;\n    for extension in extensions.iter().cloned()\
    \ {\n        let cap = extension.len();\n        let sm = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = if cap > sm {\n         \
    \   cap - sm\n        } else {\n            sm\n        };\n        if strength\
    \ > 0 {\n            break;\n        }\n    }\n    extension.map_or(class_name,\
    \ |s| s.to_string())\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpryjgt9lx.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength_extension = 0;\n\
    \    let mut max_strength_extension_class = \"\";\n\n    for (index, &ext) in\
    \ extensions.iter().enumerate() {\n        let class_len = class_name.len();\n\
    \        let ext_len = ext.len();\n        let cap = ext_len as u8;\n        let\
    \ sm = class_len as u8;\n\n        let strength = (cap - sm) as u16;\n\n     \
    \   if strength > max_strength_extension {\n            max_strength_extension\
    \ = strength;\n            max_strength_extension_class = class_name + ext;\n\
    \        }\n    }\n    return max_strength_extension_class;\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3eooiwys.rs:30:57\n   |\n\
    30 |             max_strength_extension_class = class_name + ext;\n   |      \
    \                                                   ^^^\n   |                \
    \                                         |\n   |                            \
    \                             expected `&str`, found struct `String`\n   |   \
    \                                                      help: consider borrowing\
    \ here: `&ext`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3eooiwys.rs:30:44\n\
    \   |\n18 |     let mut max_strength_extension_class = \"\";\n   |           \
    \                                 -- expected due to this value\n...\n30 |   \
    \          max_strength_extension_class = class_name + ext;\n   |            \
    \                                ^^^^^^^^^^^^^^^^\n   |                      \
    \                      |\n   |                                            expected\
    \ `&str`, found struct `String`\n   |                                        \
    \    help: consider borrowing here: `&(class_name + ext)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3eooiwys.rs:33:12\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                               ------ expected `String` because\
    \ of return type\n...\n33 |     return max_strength_extension_class;\n   |   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_strength: i32 = -1;\n\
    \    let mut best_extension = String::new();\n    for e in extensions {\n    \
    \    let class_name = String::from(e);\n        if class_name.chars().filter(|x|\
    \ x > 'A').count() > 0 {\n            continue;\n        }\n        let len =\
    \ class_name.chars().filter(|x| x > 'A').count();\n        let class_name = class_name.to_ascii_lowercase();\n\
    \        let len = class_name.chars().filter(|x| x > 'A').count();\n        let\
    \ cap = len / class_name.len();\n        let low = class_name.chars().filter(|x|\
    \ x < 'A').count();\n        let sm = low / class_name.len();\n        let strength\
    \ = cap - sm;\n        if strength > best_strength {\n            best_strength\
    \ = strength;\n            best_extension = e;\n        }\n    }\n    class_name.to_ascii_lowercase()\
    \ + best_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9kyckd1.rs:21:46\n   |\n\
    21 |         if class_name.chars().filter(|x| x > 'A').count() > 0 {\n   |   \
    \                                           ^^^\n   |                        \
    \                      |\n   |                                              expected\
    \ `&char`, found `char`\n   |                                              help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9kyckd1.rs:24:53\n\
    \   |\n24 |         let len = class_name.chars().filter(|x| x > 'A').count();\n\
    \   |                                                     ^^^\n   |          \
    \                                           |\n   |                          \
    \                           expected `&char`, found `char`\n   |             \
    \                                        help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz9kyckd1.rs:26:53\n   |\n26 |\
    \         let len = class_name.chars().filter(|x| x > 'A').count();\n   |    \
    \                                                 ^^^\n   |                  \
    \                                   |\n   |                                  \
    \                   expected `&char`, found `char`\n   |                     \
    \                                help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz9kyckd1.rs:28:53\n   |\n28 |         let low\
    \ = class_name.chars().filter(|x| x < 'A').count();\n   |                    \
    \                                 ^^^\n   |                                  \
    \                   |\n   |                                                  \
    \   expected `&char`, found `char`\n   |                                     \
    \                help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz9kyckd1.rs:31:23\n   |\n31 |         if strength > best_strength\
    \ {\n   |                       ^^^^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |         if strength "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().all(|&x| x.is_empty())\
    \ { return class_name; }\n\n    let mut total_strength: i32;\n    for e in extensions\
    \ {\n        let cap: i32 = e.chars().filter(|x| *x >= 'A' && *x <= 'Z').count();\n\
    \        let sm: i32 = e.chars().filter(|x| *x >= 'a' && *x <= 'z').count();\n\
    \n        total_strength += (cap - sm) as i32;\n    }\n    \n    let strength\
    \ = total_strength / extensions.length;\n    \n    let mut best_index = -1;\n\
    \    let mut best_strength = std::i32::MIN;\n    for index, e in extensions {\n\
    \        if e == class_name {\n            return e.to_string();\n        }\n\
    \        let mut c = e.chars();\n        let mut total_strength: i32 = c.count();\n\
    \        for c in e.chars() {\n            total_strength -= (c.to_lowercase()\
    \ as i32) as i32;\n        }\n        if total_strength > best_strength {\n  \
    \          best_index = index;\n            best_strength = total_strength;\n\
    \        }\n    }\n    return class_name + &extensions[best_index].to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpep2t9p1_.rs:31:14\n   |\n\
    31 |     for index, e in extensions {\n   |              ^\n   |\nhelp: try adding\
    \ parentheses to match on a tuple\n   |\n31 |     for (index, e) in extensions\
    \ {\n   |         +        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpep2t9p1_.rs:21:24\n\
    \   |\n21 |         let cap: i32 = e.chars().filter(|x| *x >= 'A' && *x <= 'Z').count();\n\
    \   |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n   |                  |\n   |               \
    \   expected due to this\n   |\nhelp: you can convert a `usize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n21 |         let cap: i32 =\
    \ e.chars().filter(|x| *x >= 'A' && *x <= 'Z').count().try_into().unwrap();\n\
    \   |                                                                        \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpep2t9p1_.rs:22:23\n\
    \   |\n22 |         let sm: i32 = e.chars().filter(|x| *x >= 'a' && *x <= 'z').count();\n\
    \   |                 ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n   |                 |\n   |                \
    \ expected due to this\n   |\nhelp: you can convert a `usize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n22 |         let sm: i32 = e.chars().filter(|x|\
    \ *x >= 'a' && *x <= 'z').count().try_into().unwrap();\n   |                 \
    \                                                          ++++++++++++++++++++\n\
    \nerror[E0609]: no field `length` on type `Vec<String>`\n  --> /tmp/tmpep2t9p1_.rs:27:48\n\
    \   |\n27 |     let strength = total_strength / extensions.length;\n   |     \
    \                                           ^^^^^^ unknown field\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1;\n    let mut\
    \ class_name = class_name.to_string();\n    for extension in extensions {\n  \
    \      let name = extension.to_string();\n        let len = class_name.len();\n\
    \        let cap = name[0..len].chars().filter(|x| x.is_uppercase()).count();\n\
    \        let sm = name[0..len].chars().filter(|x| x.is_lowercase()).count();\n\
    \        if cap - sm > strength {\n            strength = cap - sm;\n        \
    \    class_name = name;\n        }\n    }\n    format!(\"{}\", class_name + \"\
    .\" + str::from_str(&strength).unwrap().to_string())\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl0m0dltj.rs:17:24\n\
    \   |\n17 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: no function or associated\
    \ item named `from_str` found for type `str` in the current scope\n  --> /tmp/tmpl0m0dltj.rs:29:43\n\
    \   |\n29 |     format!(\"{}\", class_name + \".\" + str::from_str(&strength).unwrap().to_string())\n\
    \   |                                           ^^^^^^^^ function or associated\
    \ item not found in `str`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    \n    let mut extension_strength =\
    \ Vec::new();\n    for ext in extensions {\n        let mut count = 1;\n     \
    \   let mut char_counter: char_count = String::new();\n        for c in ext.chars()\
    \ {\n            char_counter.push(c).unwrap();\n            count += 1;\n   \
    \     }\n        let cap_strlen = char_counter.chars().count();\n        let sm_strlen\
    \ = char_counter.clone();\n        let cap_num = cap_strlen.to_digits() - sm_strlen.to_digits();\n\
    \        let sm_num = sm_strlen.to_digits() - cap_strlen.to_digits();\n      \
    \  let ratio = cap_num / sm_num;\n        extension_strength.push(ratio.floor()\
    \ as usize);\n    }\n    \n    let mut min_strength = extension_strength.min();\n\
    \    for s in extension_strength {\n        if s == min_strength {\n         \
    \   return format!(\"{}.{}\", class_name, extensions[extensions.iter().find(|&x|x\
    \ == min_strength).unwrap()]);\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extensions[extensions.iter().find(|&x|x == min_strength).unwrap()]);\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `char_count` in this scope\n  --> /tmp/tmp0ckcik3e.rs:21:31\n\
    \   |\n21 |         let mut char_counter: char_count = String::new();\n   |  \
    \                             ^^^^^^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0ckcik3e.rs:34:47\n\
    \    |\n34  |     let mut min_strength = extension_strength.min();\n    |    \
    \                                           ^^^- supplied 0 arguments\n    | \
    \                                              |\n    |                      \
    \                         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0277]: can't compare `&String` with `Vec<_>`\n  --> /tmp/tmp0ckcik3e.rs:37:89\n\
    \   |\n37 |             return format!(\"{}.{}\", class_name, extensions[extensions.iter().find(|&x|x\
    \ == min_strength).unwrap()]);\n   |                                         \
    \                                                ^^ no implementation for `&String\
    \ == Vec<_>`\n   |\n   = help: the trait `PartialEq<Vec<_>>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[String]` cannot be indexed by `&String`\n  --> /tmp/tmp0ckcik3e.rs:37:49\n\
    \   |\n37 |             return format!(\"{}.{}\", class_name, extensions[extensions.iter().find(|&x|x\
    \ == min_strength).unwrap()]);\n   |                                         \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `&String`\n   = note: required\
    \ because of the re"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_name = class_name.to_lowercase();\n\
    \    class_name.chars().enumerate().filter(|(i, _)| i == 0 || i == class_name.length()).fold(\n\
    \        Vec::new(),\n        |mut v, &(extension, i) => {\n            v.push((&extension[..i],\
    \ i));\n            v\n        },\n    );\n\n    let mut max_strength_extension\
    \ = extensions[0].to_lowercase();\n\n    for (i, (_, j)) in extensions.iter().enumerate()\
    \ {\n        let mut char_count = class_name[j..].chars().count();\n        let\
    \ mut extension_strength = (char_count - i) / char_count;\n        if extension_strength\
    \ > max_strength_extension {\n            max_strength_extension = extension_strength;\n\
    \        }\n    }\n    class_name.insert(class_name.len() - max_strength_extension,\
    \ String::from(\".\"));\n    class_name.insert(0, String::from(class_name.chars().last().unwrap()));\n\
    \    return class_name;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmpwe9yjbss.rs:20:33\n\
    \   |\n20 |         |mut v, &(extension, i) => {\n   |                       \
    \          ^^ expected one of `,` or `:`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n    let\
    \ mut extension_strength: i32 = 0;\n    for extension in extensions.iter() {\n\
    \        if extension_strength > strength {\n            strength = extension_strength;\n\
    \        }\n        let cap: usize = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm: usize = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        extension_strength = cap - sm;\n    }\n    \n    class_name.to_string()\
    \ + \".\" + extensions[0].to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyruc7l5.rs:25:30\n   |\n\
    18 |     let mut extension_strength: i32 = 0;\n   |                          \
    \       --- expected due to this type\n...\n25 |         extension_strength =\
    \ cap - sm;\n   |                              ^^^^^^^^ expected `i32`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyruc7l5.rs:28:36\n\
    \   |\n28 |     class_name.to_string() + \".\" + extensions[0].to_string()\n \
    \  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |      \
    \                              |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extensions[0].to_string()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_strength = -1;\n    let\
    \ mut best_extension;\n    let mut current_extension;\n    let mut current_strength;\n\
    \n    current_extension = String::from(\"MyClass\");\n\n    for i in 0..extensions.len()\
    \ {\n        current_extension.push_str(&extensions[i]);\n\n        for j in 0..extensions.len()\
    \ {\n            if j == i {\n                continue;\n            }\n\n   \
    \         let current_extension_components = current_extension.split_str(..);\n\
    \            let current_extension_components_cap = current_extension_components[0].to_lowercase();\n\
    \            let current_extension_components_sm = current_extension_components[1].to_lowercase();\n\
    \n            current_strength = class_name.chars().filter(|c| c == current_extension_components_cap).count()\
    \ - class_name.chars().filter(|c| c == current_extension_components_sm).count();\n\
    \n            if current_strength > best_strength {\n                best_extension\
    \ = current_extension;\n                best_strength = current_strength;\n  \
    \          }\n\n            current_extension.push_str(&extensions[j]);\n    \
    \    }\n    }\n\n    best_extension.clone().to_string()\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpesdh2t_f.rs:32:66\n   |\n32 |             let\
    \ current_extension_components = current_extension.split_str(..);\n   |      \
    \                                                            ^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpesdh2t_f.rs:17:29\n\
    \   |\n17 |     let mut best_strength = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_name: Vec<_> = class_name.chars().map(|c|\
    \ c.to_lowercase()).collect();\n    let mut extensions: Vec<_> = extensions.iter().map(|e|\
    \ e.chars().map(|c| c.to_lowercase()).collect()).collect();\n    let mut strength:\
    \ usize = 0;\n    \n    for i in 0..extensions.len() {\n        if class_name.contains(&extensions[i].to_lowercase())\
    \ && class_name.len() != strength {\n            strength = class_name.len();\n\
    \        }\n    }\n\n    for i in 0..extensions.len() {\n        if class_name.contains(&extensions[i].to_lowercase())\
    \ && class_name.len() == strength {\n            strength += 1;\n        }\n \
    \   }\n    \n    class_name.iter().chain(extensions.iter()).enumerate().max_by_key(|(_,\
    \ n)| n.cmp(strength)).collect::<Vec<_>>()[&0]\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `ToLowercase` with `ToLowercase`\n    --> /tmp/tmppu06rd71.rs:22:23\n\
    \     |\n22   |         if class_name.contains(&extensions[i].to_lowercase())\
    \ && class_name.len() != strength {\n     |                       ^^^^^^^^ no\
    \ implementation for `ToLowercase == ToLowercase`\n     |\n     = help: the trait\
    \ `PartialEq` is not implemented for `ToLowercase`\nnote: required by a bound\
    \ in `core::slice::<impl [T]>::contains`\n\nerror[E0277]: can't compare `ToLowercase`\
    \ with `ToLowercase`\n    --> /tmp/tmppu06rd71.rs:28:23\n     |\n28   |      \
    \   if class_name.contains(&extensions[i].to_lowercase()) && class_name.len()\
    \ == strength {\n     |                       ^^^^^^^^ no implementation for `ToLowercase\
    \ == ToLowercase`\n     |\n     = help: the trait `PartialEq` is not implemented\
    \ for `ToLowercase`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n\
    \nerror[E0277]: `usize` is not an iterator\n    --> /tmp/tmppu06rd71.rs:33:86\n\
    \     |\n33   |     class_name.iter().chain(extensions.iter()).enumerate().max_by_key(|(_,\
    \ n)| n.cmp(strength)).collect::<Vec<_>>()[&0]\n     |                       \
    \                                                           --- ^^^^^^^^ `usize`\
    \ is not an iterator\n     |                                                 \
    \                                 |\n     |                                  \
    \                                                required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Iterator` is not implemented for\
    \ `usize`\n     = note: if you want to iterate between `start` until a value `end`,\
    \ use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\nerror[E0599]:\
    \ `Option<(usize, &ToLowercase)>` is not an iterator\n   --> /tmp/tmppu06rd71.rs:33:97\n\
    \    |\n33  |       class_name.iter().chain(extensions.iter()).enumerate().max_by_key(|(_,\
    \ n)| n.cmp(strength)).collect::<Vec<_>>()[&"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut result:\
    \ String = \"\".to_string();\n    let mut strength = -1;\n    for extension in\
    \ extensions {\n        let cap = extension.chars().filter(|x| x == x.upper()).count();\n\
    \        let sm = extension.chars().filter(|x| x == x.lower()).count();\n    \
    \    strength = if cap > sm { cap - sm } else { sm - cap };\n        if strength\
    \ > 0 {\n            let name_without_extension = extension.split_last_mut().unwrap();\n\
    \            let extension_name = name_without_extension.split_last()\n      \
    \          .expect(\"the extension is not in the name\");\n            result\
    \ += class_name + \".\" + extension_name.join(\"\");\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `upper` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmp85ppv63h.rs:21:55\n   |\n21 |         let cap =\
    \ extension.chars().filter(|x| x == x.upper()).count();\n   |                \
    \                                       ^^^^^ method not found in `&char`\n\n\
    error[E0599]: no method named `lower` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp85ppv63h.rs:22:54\n   |\n22 |         let sm = extension.chars().filter(|x|\
    \ x == x.lower()).count();\n   |                                             \
    \         ^^^^^ method not found in `&char`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp85ppv63h.rs:19:24\n   |\n19 |     let mut\
    \ strength = -1;\n   |                        ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: no method named `split_last_mut` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp85ppv63h.rs:25:52\n\
    \   |\n25 |             let name_without_extension = extension.split_last_mut().unwrap();\n\
    \   |                                                    ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `split_at`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp85ppv63h.rs:28:23\n   |\n28 |             result\
    \ += class_name + \".\" + extension_name.join(\"\");\n   |                   \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                       |\n\
    \   |                       expected `&str`, found struct `String`\n   |     \
    \                  help: consider borrowing here: `&(class_name + \".\" + extension_name.join(\"\
    \"))`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min = std::i32::MAX;\n   \
    \ let mut max_so_far = &class_name[..];\n    let mut so_far = &class_name[..];\n\
    \    for e in extensions {\n        let (mut min_, mut max_) = e.chars().collect::<Vec<_>>();\n\
    \        for (i, c) in min_.chars().enumerate().rev() {\n            if c == max_so_far[i]\
    \ {\n                min_[i] = i;\n                break;\n            }\n   \
    \     }\n        let len = min_.len();\n        if len > min {\n            min\
    \ = len;\n        }\n        if len > max_so_far.len() {\n            max_so_far\
    \ = e;\n        }\n    }\n    let strength = &class_name[..].chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count() - &class_name[..].chars().filter(|&c| c >= 'a'\
    \ && c <= 'z').count();\n    if strength == min {\n        return class_name\n\
    \    } else {\n        let mut new_class = &class_name[..];\n        while &new_class[..]\
    \ == max_so_far {\n            let mut new_class_so_far = &class_name[..];\n \
    \           let mut i = 0;\n            for _ in 0..new_class.len() - 1 {\n  \
    \              if &new_class[i..i + 1] == &max_so_far {\n                    new_class_so_far\
    \ += &new_class[i..i + 1];\n                    i += 1;\n                }\n \
    \           }\n            new_class = new_class_so_far;\n        }\n        new_class\
    \ += &max_so_far;\n        new_class += &class_name[..];\n        new_class\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5hylsr_e.rs:21:13\n   |\n\
    21 |         let (mut min_, mut max_) = e.chars().collect::<Vec<_>>();\n   | \
    \            ^^^^^^^^^^^^^^^^^^^^   ----------------------------- this expression\
    \ has type `Vec<char>`\n   |             |\n   |             expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<char>`\n               found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5hylsr_e.rs:32:18\n\
    \   |\n32 |         if len > max_so_far.len() {\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i32`\
    \ and panic if the converted value doesn't fit\n   |\n32 |         if len > max_so_far.len().try_into().unwrap()\
    \ {\n   |                                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5hylsr_e.rs:33:26\n   |\n18 |     let mut max_so_far\
    \ = &class_name[..];\n   |                          --------------- expected due\
    \ to this value\n...\n33 |             max_so_far = e;\n   |                 \
    \         ^\n   |                          |\n   |                          expected\
    \ `&str`, found struct `String`\n   |                          help: consider\
    \ borrowing here: `&e`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5hylsr_e.rs:37:20\n\
    \   |\n37 |     if strength == min {\n   |                    ^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n37 |     if strength == min.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmp5hylsr_e.rs:45:41\n   |\n45 |             \
    \    if &new_class[i..i + 1] == &max_so_far {\n   |                          \
    \               ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut classes: Vec<String> = extensions.iter().map(|e|\
    \ e + class_name).collect();\n    classes.sort_unstable();\n    let mut count:\
    \ isize = 0;\n    let mut previous: String = \"\".to_string();\n    for (index,\
    \ e) in classes.iter().enumerate() {\n        if index != 0 {\n            count\
    \ += 1;\n            previous = e;\n        }\n    }\n    return &previous.to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `String` to `&String`\n  --> /tmp/tmplzbdqr7f.rs:17:64\n\
    \   |\n17 |     let mut classes: Vec<String> = extensions.iter().map(|e| e + class_name).collect();\n\
    \   |                                                              - ^ ----------\
    \ String\n   |                                                              |\
    \ |\n   |                                                              | `+` cannot\
    \ be used to concatenate a `&str` with a `String`\n   |                      \
    \                                        &String\n   |\nhelp: create an owned\
    \ `String` on the left and add a borrow on the right\n   |\n17 |     let mut classes:\
    \ Vec<String> = extensions.iter().map(|e| e.to_owned() + &class_name).collect();\n\
    \   |                                                               +++++++++++\
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplzbdqr7f.rs:24:24\n   |\n\
    20 |     let mut previous: String = \"\".to_string();\n   |                  \
    \     ------ expected due to this type\n...\n24 |             previous = e;\n\
    \   |                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplzbdqr7f.rs:27:12\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n...\n27 |    \
    \ return &previous.to_string();\n   |            ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n27 -     return &previous.to_string();\n27 +     return previous.to_string();\n\
    \   | \n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max = -1;\n    for extension\
    \ in extensions {\n        let mut counter = 1;\n        for c in extension.chars().filter(|c|\
    \ *c >= 'A') { counter += *c as u64 }\n        if max < counter{\n           \
    \ max = counter;\n        }\n    }\n    return String::from(&class_name+\".\"\
    +extensions.iter().find(|x| x.chars().filter(|c| *c >= 'A').count() == max).unwrap());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp7edynzol.rs:20:71\n\
    \   |\n20 |         for c in extension.chars().filter(|c| *c >= 'A') { counter\
    \ += *c as u64 }\n   |                                                       \
    \                ^^\n\nerror[E0369]: cannot add `&str` to `&String`\n  --> /tmp/tmp7edynzol.rs:25:36\n\
    \   |\n25 |     return String::from(&class_name+\".\"+extensions.iter().find(|x|\
    \ x.chars().filter(|c| *c >= 'A').count() == max).unwrap());\n   |           \
    \              -----------^--- &str\n   |                         |          |\n\
    \   |                         |          `+` cannot be used to concatenate two\
    \ `&str` strings\n   |                         &String\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\nhelp: remove the borrow\
    \ to obtain an owned `String`\n   |\n25 -     return String::from(&class_name+\"\
    .\"+extensions.iter().find(|x| x.chars().filter(|c| *c >= 'A').count() == max).unwrap());\n\
    25 +     return String::from(class_name+\".\"+extensions.iter().find(|x| x.chars().filter(|c|\
    \ *c >= 'A').count() == max).unwrap());\n   | \n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp7edynzol.rs:17:19\n   |\n17 | \
    \    let mut max = -1;\n   |                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0369, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1;\n    let mut\
    \ extensions_set: HashSet<&str> = extensions.iter().cloned().collect();\n    if\
    \ extensions.len() == 0 {\n        extensions_set.insert(\"\");\n    }\n    for\
    \ e in extensions_set.iter() {\n        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength\
    \ = cmp::max(strength, cap - sm);\n    }\n    format!(\"{}.{}\", class_name, extensions[strength])\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp_jxyyuu9.rs:25:20\n   |\n25 |         strength = cmp::max(strength,\
    \ cap - sm);\n   |                    ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp_jxyyuu9.rs:18:29\n\
    \   |\n18 |     let mut extensions_set: HashSet<&str> = extensions.iter().cloned().collect();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp_jxyyuu9.rs:17:24\n\
    \   |\n17 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut extenstion_found = false;\n    for extension in extensions {\n        if\
    \ extension.chars().count() == 0 {\n            continue;\n        }\n\n     \
    \   if extension.chars().count() <= strength {\n            extenstion_found =\
    \ true;\n        }\n        if extension.chars().count() > strength {\n      \
    \      strength = extension.chars().count();\n        }\n    }\n\n    if extenstion_found\
    \ == true {\n        String::from(format!(\"{}.{}\", class_name, extensions[0]))\n\
    \    } else {\n        String::from(format!(\"{}\", class_name))\n    }\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp82skleda.rs:24:41\n   |\n\
    24 |         if extension.chars().count() <= strength {\n   |                \
    \                         ^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if extension.chars().count() <= strength.try_into().unwrap()\
    \ {\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82skleda.rs:27:40\n   |\n27 |\
    \         if extension.chars().count() > strength {\n   |                    \
    \                    ^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n27 |         if extension.chars().count() > strength.try_into().unwrap()\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82skleda.rs:28:24\n   |\n17 |\
    \     let mut strength = -1i32;\n   |                        ----- expected due\
    \ to this value\n...\n28 |             strength = extension.chars().count();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = std::i32::MAX;\n\
    \    let mut min_extension = \"\";\n\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        let cap: usize = ext.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let sm: usize = ext.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \        let strength: i32 = cap - sm;\n        if strength < min_strength {\n\
    \            min_strength = strength;\n            min_extension = ext;\n    \
    \    }\n    }\n\n    class_name + min_extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplicz4yyb.rs:23:29\n   |\n\
    23 |         let strength: i32 = cap - sm;\n   |                       ---   ^^^^^^^^\
    \ expected `i32`, found `usize`\n   |                       |\n   |          \
    \             expected due to this\n   |\nhelp: you can convert a `usize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n23 |         let strength:\
    \ i32 = (cap - sm).try_into().unwrap();\n   |                             +  \
    \      +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions_with_strengh(extensions,\
    \ |extension| {\n        match extension.chars().count(|c|c.to_lowercase().is_lowercase())\
    \ {\n            1 => -1,\n            _ => 2,\n        }\n    })\n    .iter().filter_map(|e|\
    \ &*e).max().unwrap().to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `extensions_with_strengh` in this scope\n\
    \  --> /tmp/tmpj__23vzt.rs:17:5\n   |\n17 |     extensions_with_strengh(extensions,\
    \ |extension| {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    \n    let mut\
    \ max_strength = 0;\n    let mut max_extension: Option<String> = None;\n\n   \
    \ for extension in extensions {\n        let mut strength = match class_name.chars().filter(|c|\
    \ c.is_uppercase()).count() - \n                            match class_name.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n                                1 => 0,\n     \
    \                           0 => -1,\n                                _ => 1\n\
    \                            };\n\n        if strength > max_strength {\n    \
    \        max_strength = strength;\n            max_extension = Some(extension);\n\
    \        }\n    }\n\n    if let Some(extension) = max_extension {\n        format!(\"\
    {}.{}\", class_name, extension);\n    } else {\n        format!(\"{}\", class_name);\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `;`\n  -->\
    \ /tmp/tmpj187zda7.rs:28:30\n   |\n23 |         let mut strength = match class_name.chars().filter(|c|\
    \ c.is_uppercase()).count() - \n   |                            -----\n   |  \
    \                          |\n   |                            while parsing this\
    \ `match` expression\n   |                            help: try removing this\
    \ `match`\n...\n28 |                             };\n   |                    \
    \          ^ expected one of `.`, `?`, `{`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj187zda7.rs:36:44\n   |\n36 |       if let Some(extension)\
    \ = max_extension {\n   |  ____________________________________________^\n37 |\
    \ |         format!(\"{}.{}\", class_name, extension);\n   | |               \
    \                                 - help: remove this semicolon\n38 | |     }\
    \ else {\n   | |_____^ expected struct `String`, found `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj187zda7.rs:38:12\n   |\n38 |       } else {\n   |  ____________^\n\
    39 | |         format!(\"{}\", class_name);\n   | |                          \
    \        - help: remove this semicolon\n40 | |     }\n   | |_____^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    for\
    \ extension in extensions.iter().filter_map(|s| {\n        match s.chars().map(|c|\
    \ c.to_uppercase().count() as i32) {\n            Some(count) if count > strength\
    \ => {\n                strength = count;\n                Some(s)\n         \
    \   },\n            _ => None,\n        }\n    }) {\n        if strength == 0\
    \ {\n            return class_name;\n        }\n    }\n    extensions.iter().filter_map(|s|\
    \ {\n        match s.chars().map(|c| c.to_lowercase().count() as i32) {\n    \
    \        Some(count) if count > strength => {\n                strength = count;\n\
    \                Some(s)\n            },\n            _ => None,\n        }\n\
    \    }).next().unwrap().clone()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpviq875d7.rs:20:13\n   |\n\
    19 |         match s.chars().map(|c| c.to_uppercase().count() as i32) {\n   |\
    \               --------------------------------------------------\n   |     \
    \          |             |\n   |               |             the expected closure\n\
    \   |               this expression has type `Map<Chars<'_>, [closure@/tmp/tmpviq875d7.rs:19:29:\
    \ 19:64]>`\n20 |             Some(count) if count > strength => {\n   |      \
    \       ^^^^^^^^^^^ expected struct `Map`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Map<Chars<'_>, [closure@/tmp/tmpviq875d7.rs:19:29: 19:64]>`\n\
    \                found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpviq875d7.rs:33:13\n   |\n32 |         match s.chars().map(|c| c.to_lowercase().count()\
    \ as i32) {\n   |               --------------------------------------------------\n\
    \   |               |             |\n   |               |             the expected\
    \ closure\n   |               this expression has type `Map<Chars<'_>, [closure@/tmp/tmpviq875d7.rs:32:29:\
    \ 32:64]>`\n33 |             Some(count) if count > strength => {\n   |      \
    \       ^^^^^^^^^^^ expected struct `Map`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Map<Chars<'_>, [closure@/tmp/tmpviq875d7.rs:32:29: 32:64]>`\n\
    \                found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: Option<String>\
    \ = None;\n    let mut num_capitals = 0;\n    let mut num_lowercases = 0;\n  \
    \  for ext in extensions.iter() {\n        if ext.chars().count() > num_capitals\
    \ {\n            num_capitals = ext.chars().count();\n        }\n        if ext.chars().count()\
    \ > num_lowercases {\n            num_lowercases = ext.chars().count();\n    \
    \    }\n    }\n\n    let cap = match class_name.chars().filter(|x| x.is_uppercase()).count()\
    \ {\n        0 => 0,\n        _ => class_name.chars().filter(|x| x.is_uppercase()).count()\n\
    \    };\n    let sm = match class_name.chars().filter(|x| x.is_lowercase()).count()\
    \ {\n        0 => 0,\n        _ => class_name.chars().filter(|x| x.is_lowercase()).count()\n\
    \    };\n\n    if cap - sm == 0 {\n        strongest_extension = None;\n    }\n\
    \    else if num_capitals <= (num_lowercases * (num_lowercases - 1)) / 2 {\n \
    \       strongest_extension = Some(class_name + &format!(\"{}\", extensions.iter().min_by_key(|s|\
    \ s.chars().count()).unwrap()))\n    }\n    else if num_capitals > num_lowercases\
    \ {\n        strongest_extension = Some(class_name + &format!(\"{}\", extensions.iter().max_by_key(|s|\
    \ s.chars().count()).unwrap()))\n    }\n    else {\n        strongest_extension\
    \ = Some(class_name + &format!(\"{}\", extensions.iter().max_by_key(|s| s.chars().count()).unwrap()))\n\
    \    }\n\n    strongest_extension.unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfw06e7o.rs:51:35\n   |\n\
    51 |     strongest_extension.unwrap_or(\"\")\n   |                           \
    \        ^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                            |\n   |                                   expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n\n    let\
    \ mut extensions_hash = hash_string(&extensions);\n    for ext_str in extensions\
    \ {\n        if let Some(extension_str) = extensions_hash.get(&ext_str) {\n  \
    \          if strength < extension_str {\n                strength = extension_str;\n\
    \            }\n        } else {\n            extensions_hash.insert(ext_str,\
    \ strength);\n        }\n    }\n\n    class_name.to_string() + \"#\".to_string(strength.to_string())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `hash_string` in this scope\n  --> /tmp/tmpq0ag979t.rs:19:31\n\
    \   |\n19 |     let mut extensions_hash = hash_string(&extensions);\n   |    \
    \                           ^^^^^^^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpq0ag979t.rs:30:34\n\
    \     |\n30   |     class_name.to_string() + \"#\".to_string(strength.to_string())\n\
    \     |                                  ^^^^^^^^^ -------------------- supplied\
    \ 1 argument\n     |                                  |\n     |              \
    \                    expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq0ag979t.rs:30:30\n  \
    \ |\n30 |     class_name.to_string() + \"#\".to_string(strength.to_string())\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   | \
    \                             |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&\"#\".to_string(strength.to_string())`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = 0;\n    let mut\
    \ longest_name = \"\";\n    for e in extensions {\n        let c_e = e.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let s_e = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        strength += (c_e - s_e);\n        if strength > longest_name.len() {\n\
    \            longest_name = e;\n        }\n    }\n    longest_name.to_string().to_string()\
    \ + class_name + longest_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp74djt6oc.rs:22:21\n\
    \   |\n22 |         strength += (c_e - s_e);\n   |                     ^     \
    \    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n22 -         strength += (c_e - s_e);\n22 +       \
    \  strength += c_e - s_e;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74djt6oc.rs:24:28\n\
    \   |\n18 |     let mut longest_name = \"\";\n   |                           \
    \ -- expected due to this value\n...\n24 |             longest_name = e;\n   |\
    \                            ^\n   |                            |\n   |      \
    \                      expected `&str`, found struct `String`\n   |          \
    \                  help: consider borrowing here: `&e`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp74djt6oc.rs:27:44\n   |\n27 |     longest_name.to_string().to_string()\
    \ + class_name + longest_name\n   |                                          \
    \  ^^^^^^^^^^\n   |                                            |\n   |       \
    \                                     expected `&str`, found struct `String`\n\
    \   |                                            help: consider borrowing here:\
    \ `&class_name`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut strength\
    \ = -1;\n    let mut className = class_name;\n    let mut slices = vec![];\n \
    \   extensions.iter().for_each(|extension| {\n        if let Ok(slice_count) =\
    \ slice_count(extension) {\n            slices.push(slice_count);\n          \
    \  match slice_count {\n                -1 => {}\n                x => {\n   \
    \                 strength = x;\n                }\n            }\n        }\n\
    \    });\n    \n    if slices.len() == 0 {\n        return \"\";\n    } else if\
    \ slices.len() == 1 {\n        match slices[0] {\n            -1 => {\n      \
    \          return class_name + \".\" + extensions[0];\n            }\n       \
    \     x => {\n                strength = x;\n            }\n        }\n    }\n\
    \    \n    if strength > 0 {\n        let strength_slice = slices.iter().filter(|x|\
    \ x > strength).first();\n        let slice_name = class_name + \".\" + extensions[strength_slice];\n\
    \        return slice_name;\n    }\n    \n    for i in 0..slices.len() {\n   \
    \     if i != strength_slice {\n            let slice_name = class_name + \".\"\
    \ + extensions[i];\n            return slice_name;\n        }\n    }\n    \n \
    \   return class_name;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `slice_count` in this scope\n  --> /tmp/tmpwhwd21kq.rs:22:34\n\
    \   |\n22 |         if let Ok(slice_count) = slice_count(extension) {\n   |  \
    \                                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `strength_slice` in this scope\n  --> /tmp/tmpwhwd21kq.rs:53:17\n\
    \   |\n53 |         if i != strength_slice {\n   |                 ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwhwd21kq.rs:34:16\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n...\n34 |    \
    \     return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwhwd21kq.rs:38:43\n\
    \   |\n38 |                 return class_name + \".\" + extensions[0];\n   | \
    \                                          ^^^^^^^^^^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected `&str`, found struct `String`\n   |                              \
    \             help: consider borrowing here: `&extensions[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwhwd21kq.rs:47:59\n   |\n47 |         let strength_slice\
    \ = slices.iter().filter(|x| x > strength).first();\n   |                    \
    \                                       ^^^^^^^^ expected `&&_`, found integer\n\
    \   |\n   = note: expected reference `&&_`\n                   found type `{integer}`\n\
    \nerror[E0599]: no method named `first` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpwhwd21kq.rs:47:69\n   |\n47 |         let strength_slice\
    \ = slices.iter().filter(|x| x > strength).first();\n   |                    \
    \                                                 ^^^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ {integer}>, [closure@/tmp/tmpwhwd21kq.rs:47:51: 47:67]>`\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: usize = 0;\n   \
    \ let mut last_extension = String::new();\n    for extension in extensions {\n\
    \        let mut extension_upper = extension.to_uppercase();\n        let mut\
    \ extension_lower = extension_upper.to_lowercase();\n        extension_upper +=\
    \ &extension_lower[0..extension.len() - 1];\n        let mut remainder: Vec<&str>\
    \ = extension.chars().collect();\n        let mut index = 0;\n        while index\
    \ < remainder.len() {\n            match remainder[index] {\n                'A'\
    \ => {\n                    remainder.remove(index);\n                    strength\
    \ += 1;\n                }\n                'B' => {\n                    remainder.remove(index);\n\
    \                    strength += 2;\n                }\n                'C' =>\
    \ {\n                    remainder.remove(index);\n                    strength\
    \ += 3;\n                }\n                _ => {\n                    remainder.remove(index);\n\
    \                }\n            }\n            index = index + 1\n        }\n\
    \        if strength > 0 {\n            last_extension = extension.to_string()\
    \ + \".\" + extension_upper;\n        } else {\n            last_extension = extension.to_string()\
    \ + \".\" + extension_lower;\n        }\n    }\n    return class_name + \".\"\
    \ + last_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpf3_xul6j.rs:23:58\n     |\n23\
    \   |         let mut remainder: Vec<&str> = extension.chars().collect();\n  \
    \   |                                                          ^^^^^^^ value of\
    \ type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n   \
    \  |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3_xul6j.rs:27:17\n\
    \   |\n26 |             match remainder[index] {\n   |                   ----------------\
    \ this expression has type `&str`\n27 |                 'A' => {\n   |       \
    \          ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf3_xul6j.rs:31:17\n   |\n26 |             match remainder[index]\
    \ {\n   |                   ---------------- this expression has type `&str`\n\
    ...\n31 |                 'B' => {\n   |                 ^^^ expected `str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3_xul6j.rs:35:17\n\
    \   |\n26 |             match remainder[index] {\n   |                   ----------------\
    \ this expression has type `&str`\n...\n35 |                 'C' => {\n   |  \
    \               ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf3_xul6j.rs:46:60\n   |\n46 |             last_extension = extension.to_string()\
    \ + \".\" + extension_upper;\n   |                                           \
    \                 ^^^^^^^^^^^^^^^\n   |                                      \
    \                      |\n   |                                               \
    \             expected `&str`, found struct `String`\n   |                   \
    \                                         help: consider borrowing here: `&extension_upper`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf3_xul6j.rs:48:60\n   |\n48 |\
    \             last_extension = extension.to_string() + \".\" + extension_lower;\n\
    \   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc7ad7jmw.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extensions = Vec::new();\n\
    \    for ext in extensions {\n        let mut extension = ext.to_lowercase();\n\
    \        let mut cap = 0;\n        let mut sm = 0;\n        for i in extension.chars()\
    \ {\n            if i.is_uppercase() {\n                cap += 1;\n          \
    \  } else if i.is_lowercase() {\n                sm += 1;\n            }\n   \
    \     }\n        strongest_extensions.push((cap - sm).to_string());\n    }\n \
    \   strongest_extensions.sort();\n    let mut min_strength = 0;\n    for (i, s)\
    \ in strongest_extensions.iter().enumerate() {\n        if s.to_string().to_ascii_lowercase().len()\
    \ > min_strength {\n            min_strength = s.to_string().to_ascii_lowercase().len();\n\
    \        }\n    }\n    if min_strength == 0 {\n        format!(\"{}.{}\", class_name,\
    \ extensions[0])\n    } else {\n        format!(\"{}.{}.{}\", class_name, extensions[strongest_extensions.iter().position(|&x|\
    \ *x == min_strength).unwrap()], min_strength)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `usize`\n  --> /tmp/tmphjh8dupa.rs:41:97\n\
    \   |\n41 |         format!(\"{}.{}.{}\", class_name, extensions[strongest_extensions.iter().position(|&x|\
    \ *x == min_strength).unwrap()], min_strength)\n   |                         \
    \                                                                        ^^ no\
    \ implementation for `str == usize`\n   |\n   = help: the trait `PartialEq<usize>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = std::i32::MAX;\n\
    \    let mut strongest_extension: String;\n    for extension in extensions {\n\
    \        let strength = class_name.chars().filter(|c| c.is_uppercase()).count()\
    \ - class_name.chars().filter(|c| c.is_lowercase()).count();\n        if strength\
    \ < min_strength {\n            min_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    strongest_extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa0wgjq47.rs:21:23\n   |\n\
    21 |         if strength < min_strength {\n   |                       ^^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         if strength\
    \ < min_strength.try_into().unwrap() {\n   |                                 \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0wgjq47.rs:22:28\n\
    \   |\n17 |     let mut min_strength = std::i32::MAX;\n   |                  \
    \          ------------- expected due to this value\n...\n22 |             min_strength\
    \ = strength;\n   |                            ^^^^^^^^ expected `i32`, found\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut best_extension = String::from(\"\");\n    extensions.iter().for_each(|extension|\
    \ {\n        let (class_len, _) = extension.chars().count();\n        let (_,\
    \ class_name) = extension.split_first();\n        match class_name.chars().count()\
    \ {\n            1 => {},\n            2 => {\n                strength = -1;\n\
    \            },\n            3 | _ => {\n                strength = match strength\
    \ {\n                    -1 => match class_name.chars().count() {\n          \
    \              0 => 0,\n                        1 => 1,\n                    \
    \    2 => 2,\n                        _ => {\n                            let\
    \ mut counter = 0;\n                            for letter in class_name {\n \
    \                               if letter >= 'A' && letter <= 'Z' {\n        \
    \                            counter += 1;\n                                }\n\
    \                            }\n                            counter.saturating_sub(class_len\
    \ as i32) as i32 / class_len as i32\n                        }\n             \
    \       },\n                    s => {\n                        match class_name.chars().count()\
    \ {\n                            1 => 1,\n                            2 => 2,\n\
    \                            3 => 3,\n                            _ => s\n   \
    \                     }\n                    }\n                };\n         \
    \   }\n        }\n    })\n    if strength > -1 {\n        best_extension = format!(\"\
    {}.{}\", class_name, best_extension);\n    }\n    return best_extension;\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpf9t3fstc.rs:54:7\n\
    \   |\n54 |     })\n   |       ^ help: add `;` here\n55 |     if strength > -1\
    \ {\n   |     -- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf9t3fstc.rs:20:13\n\
    \   |\n20 |         let (class_len, _) = extension.chars().count();\n   |    \
    \         ^^^^^^^^^^^^^^   ------------------------- this expression has type\
    \ `usize`\n   |             |\n   |             expected `usize`, found tuple\n\
    \   |\n   = note: expected type `usize`\n             found tuple `(_, _)`\n\n\
    error[E0599]: no method named `split_first` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpf9t3fstc.rs:21:41\n   |\n21 |         let (_, class_name)\
    \ = extension.split_first();\n   |                                         ^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror[E0689]:\
    \ can't call method `saturating_sub` on ambiguous numeric type `{integer}`\n \
    \ --> /tmp/tmpf9t3fstc.rs:40:37\n   |\n40 | ...                   counter.saturating_sub(class_len\
    \ as i32) as i32 / class_len as i32\n   |                               ^^^^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n34 |\
    \                             let mut counter: i32 = 0;\n   |                \
    \                 ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1;\n    let mut\
    \ extension = String::new();\n\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n     \
    \   let sm = e.chars().filter(|c| c.is_lowercase()).count();\n\n        match\
    \ cap - sm {\n            0 => (),\n            d => {\n                extension\
    \ = e.to_string() + extension;\n                strength = d;\n            }\n\
    \        }\n    }\n\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0sxgmev4.rs:27:45\n   |\n\
    27 |                 extension = e.to_string() + extension;\n   |            \
    \                                 ^^^^^^^^^\n   |                            \
    \                 |\n   |                                             expected\
    \ `&str`, found struct `String`\n   |                                        \
    \     help: consider borrowing here: `&extension`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp0sxgmev4.rs:17:24\n   |\n17 | \
    \    let mut strength = -1;\n   |                        ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: usize = 0;\n   \
    \ let mut extension = String::new();\n    for extension in extensions {\n    \
    \    if extension.chars().filter(|&x| x == &class_name.chars().first()).count()\
    \ > 0 {\n            strength -= extension.chars().filter(|&x| x == &class_name.chars().first()).count();\n\
    \            if strength < 1 {\n                break;\n            }\n      \
    \  }\n    }\n    \n    class_name.to_string() + extension.to_string() + extensions[extensions.len()\
    \ - strength].to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_w_f2eej.rs:20:67\n   |\n20 |         if extension.chars().filter(|&x|\
    \ x == &class_name.chars().first()).count() > 0 {\n   |                      \
    \                                             ^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_w_f2eej.rs:21:80\n   |\n21 |             strength -= extension.chars().filter(|&x|\
    \ x == &class_name.chars().first()).count();\n   |                           \
    \                                                     ^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_w_f2eej.rs:28:30\n\
    \   |\n28 |     class_name.to_string() + extension.to_string() + extensions[extensions.len()\
    \ - strength].to_string()\n   |                              ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                              |\n   |                              expected\
    \ `&str`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `&extension.to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_w_f2eej.rs:28:54\n   |\n28 |     class_name.to_string() + extension.to_string()\
    \ + extensions[extensions.len() - strength].to_string()\n   |                \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                      |\n   |           \
    \                                           expected `&str`, found struct `String`\n\
    \   |                                                      help: consider borrowing\
    \ here: `&extensions[extensions.len() - strength].to_string()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.len() <= 0 {\n     \
    \   return class_name;\n    }\n    let mut max = -1;\n    let mut max_index =\
    \ -1;\n    for (i, ext) in extensions.iter().enumerate() {\n        let mut current_ext\
    \ = ext;\n        let mut current_max = -1;\n        for (c, n) in ext.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').enumerate() {\n            if *n - c > current_max {\n\
    \                current_max = *n - c;\n                current_ext = String::from(\"\
    \\\n                \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n\
    \            }\n        }\n        if *current_max - max < 0 {\n            max_index\
    \ = i;\n            max = *current_max;\n        }\n    }\n    if max_index ==\
    \ -1 {\n        return class_name;\n    }\n    return &String::from(\"{}.{}\"\
    ).format(class_name, &extensions[max_index]);\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmps2_192uq.rs:26:16\n\
    \   |\n26 |             if *n - c > current_max {\n   |                ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmps2_192uq.rs:27:31\n\
    \   |\n27 |                 current_max = *n - c;\n   |                      \
    \         ^^\n\nerror[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmps2_192uq.rs:29:55\n\
    \   |\n29 |                 \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n\
    \   |                                                     - ^ - usize\n   |  \
    \                                                   |\n   |                  \
    \                                   char\n\nerror[E0599]: no method named `unwrap`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmps2_192uq.rs:29:73\n\
    \   |\n29 |                 \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n\
    \   |                                                                        \
    \ ^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2_192uq.rs:28:31\n\
    \   |\n23 |           let mut current_ext = ext;\n   |                       \
    \          --- expected due to this value\n...\n28 |                   current_ext\
    \ = String::from(\"\\\n   |  _______________________________^\n29 | |        \
    \         \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n\
    \   | |_________________________________________________________________________________^\
    \ expected `&String`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n28 ~                 current_ext = &String::from(\"\\\n29 ~           \
    \      \".to_string().push_str(&ext.chars()[n - c].to_string()).unwrap());\n \
    \  |\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmps2_192uq.rs:32:12\n\
    \   |\n32 |         if *current_max - max < 0 {\n   |            ^^^^^^^^^^^^\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmps2_192uq.rs:21:25\n\
    \   |\n21 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented f"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n    let\
    \ mut max_extension = String::new();\n    let mut counter = 1;\n    \n    for\
    \ extension in extensions {\n        let mut c = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let mut s = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let strength = if c > s { c - s } else\
    \ { s - c };\n        if strength > max_strength {\n            max_extension\
    \ = extension;\n            max_strength = strength;\n        } else if strength\
    \ == max_strength {\n            if counter == 1 {\n                max_extension\
    \ = extension;\n            } else {\n                if counter > 1 {\n     \
    \               max_extension = String::from(format!(\"{}.{}\", max_extension,\
    \ max_extension));\n                }\n            }\n            counter++;\n\
    \        }\n    }\n\n    let (className, extensionName) = class_name.split('.').collect::<Vec<&str>>();\n\
    \    if counter == 1 {\n        return format!(\"{}.{}\", className, max_extension);\n\
    \    } else {\n        return format!(\"{}.{}\", className, max_extension);\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpiq1zyeh2.rs:36:20\n\
    \   |\n36 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    36 -             counter++;\n36 +             counter += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiq1zyeh2.rs:22:55\n   |\n22 |         let mut\
    \ c = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |      \
    \                                                 ^^^\n   |                  \
    \                                     |\n   |                                \
    \                       expected `&char`, found `char`\n   |                 \
    \                                      help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiq1zyeh2.rs:22:67\n   |\n22 |\
    \         let mut c = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                                   ^^^\n\
    \   |                                                                   |\n  \
    \ |                                                                   expected\
    \ `&char`, found `char`\n   |                                                \
    \                   help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiq1zyeh2.rs:23:55\n   |\n23 |         let mut s = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                ^^^\n   |                                                   \
    \    |\n   |                                                       expected `&char`,\
    \ found `char`\n   |                                                       help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiq1zyeh2.rs:23:67\n\
    \   |\n23 |         let mut s = extension.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count();\n   |                                                        \
    \       "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1i32;\n  \
    \  let mut min_strength = MAX_INT;\n\n    for extension in extensions.iter() {\n\
    \        let len: usize = extension.chars().count();\n        let cap: usize =\
    \ extension.chars().filter(|&c| c.is_uppercase()).count();\n        let sm: usize\
    \ = extension.chars().filter(|&c| c.is_lowercase()).count();\n        let score:\
    \ i64 = len.abs() * cap.abs() - (cap.abs() + sm.abs()) as i64;\n        max_strength\
    \ = max(max_strength, score);\n        min_strength = min(min_strength, score);\n\
    \    }\n\n    let result = String::from(class_name);\n    max_strength\n     \
    \   .min(min_strength)\n        .unwrap_or(MAX_INT)\n        .to_string()\n  \
    \      + extensions[0].to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_INT` in this scope\n  --> /tmp/tmpgfsu2oy9.rs:18:28\n\
    \   |\n18 |     let mut min_strength = MAX_INT;\n   |                        \
    \    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `max`\
    \ in this scope\n  --> /tmp/tmpgfsu2oy9.rs:25:24\n   |\n25 |         max_strength\
    \ = max(max_strength, score);\n   |                        ^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpgfsu2oy9.rs:26:24\n\
    \   |\n26 |         min_strength = min(min_strength, score);\n   |           \
    \             ^^^\n...\n37 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    26 |         min_strength = main(min_strength, score);\n   |                 \
    \       ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find value `MAX_INT` in this scope\n  --> /tmp/tmpgfsu2oy9.rs:32:20\n\
    \   |\n32 |         .unwrap_or(MAX_INT)\n   |                    ^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `abs` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpgfsu2oy9.rs:24:30\n   |\n24 |         let\
    \ score: i64 = len.abs() * cap.abs() - (cap.abs() + sm.abs()) as i64;\n   |  \
    \                            ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmpgfsu2oy9.rs:24:42\n\
    \   |\n24 |         let score: i64 = len.abs() * cap.abs() - (cap.abs() + sm.abs())\
    \ as i64;\n   |                                          ^^^ method not found\
    \ in `usize`\n\nerror[E0599]: no method named `abs` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpgfsu2oy9.rs:24:55\n   |\n24 |         let score:\
    \ i64 = len.abs() * cap.abs() - (cap.abs() + sm.abs()) as i64;\n   |         \
    \                                              ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `abs` found for type `usize` in the "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut result: Option<String> = None;\n    for extension in extensions {\n    \
    \    let num_upper = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let num_lower = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let frac = num_upper - num_lower;\n        if frac > strength {\n   \
    \         strength = frac;\n            result = Some(String::from(extension));\n\
    \        }\n    }\n    result.unwrap_or(String::from(class_name + \".\"))\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkjz_lsgc.rs:23:19\n   |\n\
    23 |         if frac > strength {\n   |                   ^^^^^^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |         if frac > strength.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkjz_lsgc.rs:24:24\n   |\n17 |     let mut strength = -1i32;\n\
    \   |                        ----- expected due to this value\n...\n24 |     \
    \        strength = frac;\n   |                        ^^^^ expected `i32`, found\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter: Vec<i32> = vec![-1,\
    \ 0, 0];\n\n    for i in 0..extensions.len() {\n        counter[extensions[i].chars().filter(|&c|\
    \ c.is_uppercase()).count() - 1] += 1;\n    }\n\n    let mut max_counter = counter.iter().max().unwrap();\n\
    \    let mut max_i = -1;\n\n    for i in 0..counter.len() {\n        if counter[i]\
    \ >= max_counter {\n            max_counter = counter[i];\n            max_i =\
    \ i;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, extensions[max_i].to_lowercase())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78l60gmp.rs:27:26\n   |\n\
    27 |         if counter[i] >= max_counter {\n   |                          ^^^^^^^^^^^\
    \ expected `i32`, found `&i32`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |         if counter[i] >= *max_counter {\n   |                    \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78l60gmp.rs:28:27\n\
    \   |\n23 |     let mut max_counter = counter.iter().max().unwrap();\n   |   \
    \                        ----------------------------- expected due to this value\n\
    ...\n28 |             max_counter = counter[i];\n   |                        \
    \   ^^^^^^^^^^\n   |                           |\n   |                       \
    \    expected `&i32`, found `i32`\n   |                           help: consider\
    \ borrowing here: `&counter[i]`\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmp78l60gmp.rs:24:21\n   |\n24 |     let mut max_i\
    \ = -1;\n   |                     ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n    let\
    \ mut min_extension = String::new();\n    \n    for extension in extensions.iter()\
    \ {\n        let mut strength = 0;\n        let mut caps = String::new();\n  \
    \      let mut sms = String::new();\n        \n        for char in extension {\n\
    \            if char == 'A' {\n                caps += char.to_string();\n   \
    \         }\n            if char == 'S' {\n                sms += char.to_string();\n\
    \            }\n            strength += 1;\n        }\n        if strength > min_strength\
    \ {\n            min_strength = strength;\n            min_extension = extension;\n\
    \        }\n    }\n    class_name + \".\" + min_extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpt4on8ztg.rs:25:21\n\
    \   |\n25 |         for char in extension {\n   |                     ^^^^^^^^^\
    \ `&String` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4on8ztg.rs:36:29\n\
    \   |\n18 |     let mut min_extension = String::new();\n   |                 \
    \            ------------- expected due to this value\n...\n36 |             min_extension\
    \ = extension;\n   |                             ^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                             |\n   |\
    \                             expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt4on8ztg.rs:39:24\n   |\n39 |     class_name\
    \ + \".\" + min_extension\n   |                        ^^^^^^^^^^^^^\n   |   \
    \                     |\n   |                        expected `&str`, found struct\
    \ `String`\n   |                        help: consider borrowing here: `&min_extension`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_extension = Vec::new();\n\
    \    for ext in extensions {\n        let mut extension = ext.to_lowercase();\n\
    \        let mut cap_letters = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut sm_letters = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let strength = cap_letters - sm_letters;\n        if strength > 0 {\n\
    \            if let Some(mut index) = max_extension.iter().position(|&x| x ==\
    \ extension) {\n                *index = *index + 1;\n            } else {\n \
    \               max_extension.push(extension);\n            }\n        }\n   \
    \ }\n    if let Some(mut index) = max_extension.iter().position(|&x| x.to_lowercase()\
    \ == class_name) {\n        *index = *index + 1;\n    }\n    max_extension.iter().cloned().collect::<Vec<_>>().join(\"\
    .\") + Strongest_Extension_Strength(max_extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Strongest_Extension_Strength`\
    \ in this scope\n  --> /tmp/tmpt3eh2zd2.rs:34:67\n   |\n34 |     max_extension.iter().cloned().collect::<Vec<_>>().join(\"\
    .\") + Strongest_Extension_Strength(max_extension)\n   |                     \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0614]: type `usize` cannot be dereferenced\n \
    \ --> /tmp/tmpt3eh2zd2.rs:25:17\n   |\n25 |                 *index = *index +\
    \ 1;\n   |                 ^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpt3eh2zd2.rs:25:26\n   |\n25 |                 *index = *index +\
    \ 1;\n   |                          ^^^^^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmpt3eh2zd2.rs:32:9\n   |\n32 |         *index =\
    \ *index + 1;\n   |         ^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpt3eh2zd2.rs:32:18\n   |\n32 |         *index = *index + 1;\n  \
    \ |                  ^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut s = String::from(class_name);\n\
    \    for i in extensions.iter().rposition(|&x| x.is_upper()) {\n        let len:\
    \ isize = i.len();\n        let cap = i.as_str()[..len];\n        let sm = i.as_str()[len..];\n\
    \        s.push_str(&cap.to_lowercase(&));\n        s.push_str(&sm.to_lowercase(&));\n\
    \        s.push_str(&String::from(\".\").to_lowercase(&));\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpgie16m_r.rs:22:39\n\
    \   |\n22 |         s.push_str(&cap.to_lowercase(&));\n   |                  \
    \                     ^ expected expression\n\nerror[E0599]: no method named `is_upper`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpgie16m_r.rs:18:49\n\
    \   |\n18 |     for i in extensions.iter().rposition(|&x| x.is_upper()) {\n  \
    \ |                                                 ^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `len` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpgie16m_r.rs:19:28\n   |\n19 |         let len:\
    \ isize = i.len();\n   |                            ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `as_str` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpgie16m_r.rs:20:21\n   |\n20 |         let cap = i.as_str()[..len];\n\
    \   |                     ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `as_str` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpgie16m_r.rs:21:20\n   |\n21 |         let sm = i.as_str()[len..];\n\
    \   |                    ^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counters = vec![];\n    for\
    \ (i, name) in extensions.iter().enumerate() {\n        let c = name.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let s = name.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let mut c = c - s;\n        if c > 0 {\n            counters.push(c as\
    \ i64);\n        }\n    }\n    \n    let mut min = counters[0];\n    let mut max\
    \ = -1;\n    let mut maxix = -1;\n    for (i, &c) in counters.iter().enumerate()\
    \ {\n        if max < c {\n            max = c;\n            maxix = i;\n    \
    \    }\n    }\n    \n    let mut s = String::new();\n    format!(\"{}.{}\", class_name,\
    \ extensions[maxix]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpcnpio7fy.rs:29:21\n\
    \   |\n29 |     let mut maxix = -1;\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcnpio7fy.rs:16:72\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n38 |     format!(\"{}.{}\", class_name, extensions[maxix]);\n\
    \   |                                                    - help: remove this semicolon\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut n =\
    \ 0.0\n    let mut s = 0.0\n    for ext: &str in extensions {\n        let cap\
    \ = ext.chars().filter(|c| c.is_upper()).count();\n        let sm = ext.chars().filter(|c|\
    \ c.is_lower()).count();\n        let frac = cap - sm;\n        n = n + frac;\n\
    \        s = s + frac;\n    }\n    if n == 0.0 {\n        return \"\";\n    }\n\
    \    let n = n as f64;\n    let s = s as f64;\n    let cap = s.sqrt() as f64;\n\
    \    let sm = cap.sqrt();\n    if cap == sm {\n        return class_name.to_string();\n\
    \    }\n    let mut min_frac = 0.0;\n    let mut min_index = -1;\n    for index,\
    \ frac in extensions[0].chars().enumerate() {\n        let n = frac * cap as f64;\n\
    \        let s = frac * sm as f64;\n        if n == 0.0 || s == 0.0 {\n      \
    \      return class_name.to_string();\n        }\n        if n > min_frac {\n\
    \            min_frac = n;\n            min_index = index;\n        }\n    }\n\
    \    if min_index >= 0 {\n        return class_name.to_string();\n    }\n    for\
    \ index, frac in extensions[extensions.len() - 1].chars().enumerate() {\n    \
    \    let n = frac * cap as f64;\n        let s = frac * sm as f64;\n        if\
    \ n == 0.0 || s == 0.0 {\n            return class_name.to_string();\n       \
    \ }\n        if n < min_frac {\n            min_frac = n;\n            min_index\
    \ = index;\n        }\n    }\n    \n    return extensions[min_index].to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp6pmy145c.rs:18:20\n\
    \   |\n18 |     let mut n = 0.0\n   |                    ^ help: add `;` here\n\
    19 |     let mut s = 0.0\n   |     --- unexpected token\n\nerror: expected `;`,\
    \ found keyword `for`\n  --> /tmp/tmp6pmy145c.rs:19:20\n   |\n19 |     let mut\
    \ s = 0.0\n   |                    ^ help: add `;` here\n20 |     for ext: &str\
    \ in extensions {\n   |     --- unexpected token\n\nerror: missing `in` in `for`\
    \ loop\n  --> /tmp/tmp6pmy145c.rs:20:12\n   |\n20 |     for ext: &str in extensions\
    \ {\n   |            ^ help: try adding `in` here\n\nerror: expected expression,\
    \ found `:`\n  --> /tmp/tmp6pmy145c.rs:20:12\n   |\n20 |     for ext: &str in\
    \ extensions {\n   |            ^ expected expression\n\nerror: aborting due to\
    \ 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut counts\
    \ = vec![0; extensions.len()];\n\n    for &e in extensions {\n        for &c in\
    \ e.chars() {\n            match c {\n                'A' => {\n             \
    \       counts[1] += 1;\n                }\n                'B' => {\n       \
    \             counts[2] += 1;\n                }\n                'C' => {\n \
    \                   counts[3] += 1;\n                }\n                'D' =>\
    \ {\n                    counts[4] += 1;\n                }\n                'E'\
    \ => {\n                    counts[5] += 1;\n                }\n             \
    \   'F' => {\n                    counts[6] += 1;\n                }\n       \
    \         'G' => {\n                    counts[7] += 1;\n                }\n \
    \               'H' => {\n                    counts[8] += 1;\n              \
    \  }\n                'I' => {\n                    counts[9] += 1;\n        \
    \        }\n                'J' => {\n                    counts[10] += 1;\n \
    \               }\n                'K' => {\n                    counts[11] +=\
    \ 1;\n                }\n                'L' => {\n                    counts[12]\
    \ += 1;\n                }\n                'M' => {\n                    counts[13]\
    \ += 1;\n                }\n                'N' => {\n                    counts[14]\
    \ += 1;\n                }\n                'O' => {\n                    counts[15]\
    \ += 1;\n                }\n                'P' => {\n                    counts[16]\
    \ += 1;\n                }\n                'Q' => {\n                    counts[17]\
    \ += 1;\n                }\n                'R' => {\n                    counts[18]\
    \ += 1;\n                }\n                'S' => {\n                    counts[19]\
    \ += 1;\n                }\n                'T' => {\n                    counts[20]\
    \ += 1;\n                }\n                'U' => {\n                    counts[21]\
    \ += 1;\n                }\n                'V' => {\n                    counts[22]\
    \ += 1;\n                }\n                'W' => {\n                    counts[23]\
    \ += 1;\n                }\n                'X' => {\n                    counts[24]\
    \ += 1;\n                }\n                'Y' => {\n                    counts[25]\
    \ += 1;\n                }\n                'Z' => {\n                    counts[26]\
    \ += 1;\n                }\n                c => {\n                    counts[0]\
    \ += 1;\n                }\n            }\n        }\n    }\n\n    let strength\
    \ = counts[0] - counts[1] - counts[2] - counts[3] - counts[4] - counts[5] - counts[6]\
    \ - counts[7] - counts[8] - counts[9] - counts[10] - counts[11] - counts[12] -\
    \ counts[13] - counts[14] - counts[15] - counts[16] - counts[17] - counts[18]\
    \ - counts[19] - counts[20] - counts[21] - counts[22] - counts[23\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \   --> /tmp/tmp4pdwpy00.rs:109:1\n    |\n109 | }\n    | ^ expected one of `.`,\
    \ `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n\
    \   --> /tmp/tmp4pdwpy00.rs:108:315\n    |\n16  | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    |                        \
    \                                                       - closing delimiter possibly\
    \ meant for this\n...\n108 |     let strength = counts[0] - counts[1] - counts[2]\
    \ - counts[3] - counts[4] - counts[5] - counts[6] - counts[7] - counts[8] - counts[9]\
    \ - counts[10] - counts[11] - counts[12] - counts[13] - counts[14] - counts[15]\
    \ - counts[16] - counts[17] - counts[18] - counts[19] - counts[20] - counts[21]\
    \ - counts[22] - counts...\n    |                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                           ^ unclosed delimiter\n109 | }\n  \
    \  | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4pdwpy00.rs:20:9\n\
    \   |\n20 |     for &e in extensions {\n   |         ^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `e`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code goes here\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6w4l0yc.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength: i64 = -1;\n\
    \    let mut min_extension: Option<String> = None;\n    let mut min_extension_strength:\
    \ i64 = -1;\n    for extension in extensions {\n        let (mut cap, mut sm)\
    \ = (match class_name.chars().nth(0) \n                                    {Some(c)\
    \ => c, None} \n                                    {None => panic!(\"Capital\
    \ letters missing in class name\")});\n        for c in extension {\n        \
    \    match c.to_ascii_lowercase() {\n                Some('a'..'z') => cap = cap\
    \ - 1,\n                Some('A'..'Z') => cap = cap - 65,\n                _ =>\
    \ (),\n            }\n            match c.to_ascii_uppercase() {\n           \
    \     Some('a'..'z') => sm = sm - 1,\n                Some('A'..'Z') => sm = sm\
    \ - 65,\n                _ => (),\n            }\n        }\n        let (strength,\
    \ mut extension) = (match sm, cap {\n            (x, y) => {\n               \
    \ if x == 0 {\n                    min_strength = Some(-x + 1)\n             \
    \   } else {\n                    let strength = x - y;\n                    if\
    \ strength < min_strength {\n                        min_strength = Some(strength)\n\
    \                    } else {\n                        min_strength = None\n \
    \                   }\n                }\n                None\n            }\n\
    \            _ => panic!(\"Invalid extension name\"),\n        });\n        if\
    \ extension.is_some() {\n            if extension_strength(extension) == min_extension_strength\
    \ {\n                min_extension = Some(extension.unwrap())\n            } else\
    \ {\n                min_extension = None\n            }\n        }\n        min_extension_strength\
    \ = min_strength;\n    }\n    min_extension.take().unwrap()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `}`\n  --> /tmp/tmpo453bah6.rs:22:56\n\
    \   |\n22 | ...                   {Some(c) => c, None} \n   |                \
    \                          ^ expected one of `=>`, `@`, `if`, or `|`\n\nerror:\
    \ expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpo453bah6.rs:23:43\n   |\n23 | ...                   {None => panic!(\"\
    Capital letters missing in class name\")});\n   |                            \
    \ ^^ expected one of 8 possible tokens\n\nerror: expected one of `)`, `,`, `.`,\
    \ `?`, or an operator, found `{`\n  --> /tmp/tmpo453bah6.rs:23:37\n   |\n22 |\
    \ ...                   {Some(c) => c, None} \n   |                          \
    \                 -\n   |                                           |\n   |  \
    \                                         expected one of `)`, `,`, `.`, `?`,\
    \ or an operator\n   |                                           help: missing\
    \ `,`\n23 | ...                   {None => panic!(\"Capital letters missing in\
    \ class name\")});\n   |                       ^ unexpected token\n\nerror: expected\
    \ one of `!`, `.`, `::`, `?`, `{`, or an operator, found `,`\n  --> /tmp/tmpo453bah6.rs:36:50\n\
    \   |\n36 |         let (strength, mut extension) = (match sm, cap {\n   |   \
    \                                       -----   ^ expected one of `!`, `.`, `::`,\
    \ `?`, `{`, or an operator\n   |                                          |\n\
    \   |                                          while parsing this `match` expression\n\
    \nerror[E0425]: cannot find function `extension_strength` in this scope\n  -->\
    \ /tmp/tmpo453bah6.rs:53:16\n   |\n53 |             if extension_strength(extension)\
    \ == min_extension_strength {\n   |                ^^^^^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `min_extension_strength`\n\nerror[E0658]:\
    \ exclusive range pattern syntax is experimental\n  --> /tmp/tmpo453bah6.rs:26:22\n\
    \   |\n26 |                 Some('a'..'z') => cap = cap - 1,\n   |           \
    \           ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/3"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_extension = \"\";\n \
    \   let mut best_strength = -1;\n\n    for extension in extensions {\n       \
    \ let strength = Extension::to_string(class_name).unwrap().chars().filter(|c|\
    \ c.is_uppercase().is_ok()).count() - extension.chars().filter(|c| c.is_lowercase().is_ok()).count();\n\
    \n        if strength > best_strength {\n            best_strength = strength;\n\
    \            best_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Extension`\n \
    \ --> /tmp/tmpm7sz65of.rs:21:24\n   |\n21 | ...   let strength = Extension::to_string(class_name).unwrap().chars().filter(|c|\
    \ c.is_uppercase().is_ok()).count() - extension.chars().f...\n   |           \
    \           ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0599]: no method\
    \ named `is_ok` found for type `bool` in the current scope\n  --> /tmp/tmpm7sz65of.rs:21:167\n\
    \   |\n21 | ...() - extension.chars().filter(|c| c.is_lowercase().is_ok()).count();\n\
    \   |                                                       ^^^^^ method not found\
    \ in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7sz65of.rs:25:30\n\
    \   |\n17 |     let mut best_extension = \"\";\n   |                         \
    \     -- expected due to this value\n...\n25 |             best_extension = extension;\n\
    \   |                              ^^^^^^^^^\n   |                           \
    \   |\n   |                              expected `&str`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&extension`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_uppercase).count() as u32).max() > extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_lowercase).count() as u32).max() {\n        return class_name.concat(\"\
    .\").concat(extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase).count()\
    \ as u32).max().to_string());\n    }\n    if extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_uppercase).count() as u32).max() == 0 {\n        return class_name.concat(\"\
    .\").concat(extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase).count()\
    \ as u32).min().to_string());\n    }\n    return class_name.concat(\".\").concat(extensions.iter().map(|x|\
    \ x.chars().filter(|c| c.is_ascii_lowercase).count() as u32).min().to_string());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `is_ascii_uppercase` on\
    \ type `&char`\n  --> /tmp/tmphwcqd3sv.rs:17:57\n   |\n17 |     if extensions.iter().map(|x|\
    \ x.chars().filter(|c| c.is_ascii_uppercase).count() as u32).max() > extensions.iter().map(|x|\
    \ x.chars().f...\n   |                                                       \
    \  ^^^^^^^^^^^^^^^^^^ method, not a field\n   |\nhelp: use parentheses to call\
    \ the method\n   |\n17 |     if extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_uppercase()).count() as u32).max() > extensions.iter().map(|x| x.chars().filter(|c|\
    \ c.is_ascii_lowercase).count() as u32).max() {\n   |                        \
    \                                                   ++\n\nerror[E0615]: attempted\
    \ to take value of method `is_ascii_lowercase` on type `&char`\n  --> /tmp/tmphwcqd3sv.rs:17:150\n\
    \   |\n17 | ...xtensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase).count()\
    \ as u32).max() {\n   |                                                    ^^^^^^^^^^^^^^^^^^\
    \ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n\
    17 |     if extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_uppercase).count()\
    \ as u32).max() > extensions.iter().map(|x| x.chars().filter(|c| c.is_ascii_lowercase()).count()\
    \ as u32).max() {\n   |                                                      \
    \                                                                            \
    \                                      ++\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmphwcqd3sv.rs:18:27\n\
    \   |\n18 | ...   return class_name.concat(\".\").concat(extensions.iter().map(|x|\
    \ x.chars().filter(|c| c.is_ascii_lowercase).count() as u32).max().to_...\n  \
    \ |                         ^^^^^^ method not found in `String`\n\nerror[E0615]:\
    \ attempted to take value of method `is_ascii_lowercase` on type `&char`\n  -->\
    \ /tmp/tmphwcqd3sv.rs:18:95\n   |\n18 | ...   return class_name.concat(\".\").concat(extensions.iter().map(|x|\
    \ x.chars().filter(|c| c.is_ascii_lowercase).count() as u32).max().to_.."
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut s = class_name.to_string();\n\
    \    let mut num_upper = 0;\n    for e in extensions {\n        let cap = e.chars().filter(|c|c\
    \ == 'A'..='Z').count();\n        let sm = e.chars().filter(|c|c == 'a'..='z').count();\n\
    \        let diff = cap - sm;\n        if diff > num_upper {\n            num_upper\
    \ = diff;\n            s = e;\n        }\n    }\n    return s;\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwjgnjtyk.rs:20:41\n\
    \   |\n20 |         let cap = e.chars().filter(|c|c == 'A'..='Z').count();\n \
    \  |                                         ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwjgnjtyk.rs:20:50\n   |\n20 |         let cap = e.chars().filter(|c|c\
    \ == 'A'..='Z').count();\n   |                                               \
    \   ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwjgnjtyk.rs:20:39\n   |\n20 |         let cap = e.chars().filter(|c|c\
    \ == 'A'..='Z').count();\n   |                                       ^^^^^^^^^^^^^^\
    \ expected `bool`, found struct `RangeInclusive`\n   |\n   = note: expected type\
    \ `bool`\n            found struct `RangeInclusive<bool>`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpwjgnjtyk.rs:21:40\n   |\n21 |   \
    \      let sm = e.chars().filter(|c|c == 'a'..='z').count();\n   |           \
    \                             ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwjgnjtyk.rs:21:49\n   |\n21 |         let sm = e.chars().filter(|c|c\
    \ == 'a'..='z').count();\n   |                                               \
    \  ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwjgnjtyk.rs:21:38\n   |\n21 |         let sm = e.chars().filter(|c|c\
    \ == 'a'..='z').count();\n   |                                      ^^^^^^^^^^^^^^\
    \ expected `bool`, found struct `RangeInclusive`\n   |\n   = note: expected type\
    \ `bool`\n            found struct `RangeInclusive<bool>`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut strength\
    \ = -1;\n    let mut ext = String::new();\n    for e in extensions {\n       \
    \ if e.chars().filter(|&c| c.is_upper()).count() > strength {\n            ext\
    \ = e;\n            strength = e.chars().filter(|&c| c.is_upper()).count();\n\
    \        }\n    }\n    ext\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4mh4r_z3.rs:21:36\n   |\n21 |         if e.chars().filter(|&c|\
    \ c.is_upper()).count() > strength {\n   |                                   \
    \ ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp4mh4r_z3.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: no method named\
    \ `is_upper` found for type `char` in the current scope\n  --> /tmp/tmp4mh4r_z3.rs:23:48\n\
    \   |\n23 |             strength = e.chars().filter(|&c| c.is_upper()).count();\n\
    \   |                                                ^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_uppercase`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.len() <= 1 {\n     \
    \   return class_name;\n    }\n    let mut strength: i32;\n    for (i, s) in extensions.iter().enumerate()\
    \ {\n        if s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() >= 2 {\n\
    \            strength = i;\n            break;\n        }\n    }\n    if strength\
    \ == 0 {\n        return class_name;\n    }\n    let cap = match strength {\n\
    \        0 => 0,\n        1 => 1,\n        2 => 1,\n        _ => 0,\n    };\n\
    \    let sm = match strength {\n        0 => 0,\n        1 => 2,\n        2 =>\
    \ 3,\n        _ => 0,\n    };\n    let cap_extensions = extensions.iter().filter(|s|\
    \ s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() == cap);\n    let sm_extensions\
    \ = extensions.iter().filter(|s| s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ == sm);\n    if cap_extensions.iter().any(|s| s != class_name) && sm_extensions.iter().any(|s|\
    \ s != class_name) {\n        return class_name;\n    }\n    let mut strongest_extension\
    \ = extensions[cap - 1];\n    for i in 0..extensions.len() - 1 {\n        if strongest_extension\
    \ == extensions[i] {\n            strongest_extension = extensions[i - 1];\n \
    \       } else {\n            break;\n        }\n    }\n    match strongest_extension\
    \ {\n        Some(extension) => extension,\n        None => \"\",\n    }\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaw__ya7l.rs:23:24\n   |\n\
    20 |     let mut strength: i32;\n   |                       --- expected due to\
    \ this type\n...\n23 |             strength = i;\n   |                       \
    \ ^ expected `i32`, found `usize`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `Filter` in the current scope\n  --> /tmp/tmpaw__ya7l.rs:44:23\n\
    \   |\n44 |     if cap_extensions.iter().any(|s| s != class_name) && sm_extensions.iter().any(|s|\
    \ s != class_name) {\n   |                       ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `iter` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpaw__ya7l.rs:44:72\n   |\n44 |     if cap_extensions.iter().any(|s|\
    \ s != class_name) && sm_extensions.iter().any(|s| s != class_name) {\n   |  \
    \                                                                      ^^^^ private\
    \ field, not a method\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaw__ya7l.rs:56:9\n\
    \   |\n55 |     match strongest_extension {\n   |           -------------------\
    \ this expression has type `String`\n56 |         Some(extension) => extension,\n\
    \   |         ^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaw__ya7l.rs:57:9\n   |\n55 | \
    \    match strongest_extension {\n   |           ------------------- this expression\
    \ has type `String`\n56 |         Some(extension) => extension,\n57 |        \
    \ None => \"\",\n   |         ^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpaw__ya7l.rs:57:17\n\
    \   |\n55 | /     match strongest_extension {\n56 | |         Some(extension)\
    \ => extension,\n   | |                            --------- this is found to\
    \ be of type `String`\n57 | |         None => \"\",\n   | |                 ^^-\
    \ help: try using a conversion method: `.to_string()`\n   | |                \
    \ |\n   | |              "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1;\n    let\
    \ mut max_strength_class = \"\";\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        let mut ext_class = ext\n            .to_lowercase()\n          \
    \  .chars()\n            .map(|c| c.to_uppercase())\n            .collect::<Vec<String>>()\n\
    \            .iter()\n            .take(ext.len())\n            .collect::<Vec<_>>();\n\
    \        let strength = ext_class.iter().filter(|c| c.chars().count() > 0).count();\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_strength_class = ext;\n        }\n    }\n    let strength = max_strength;\n\
    \    let strongest_extension = format!(\"{}.{}\", class_name, max_strength_class);\n\
    \    if strength == 0 {\n        return format!(\"{}\", strongest_extension);\n\
    \    }\n    let mut max_strength_class: Vec<_> = extensions.iter().filter(|ext|\
    \ ext.chars().count() > 0).collect();\n    max_strength_class.pop();\n    for\
    \ (i, ext) in extensions.iter().enumerate() {\n        let ext_class = ext.to_lowercase().chars().filter(|c|\
    \ c.to_uppercase() == ext).collect::<Vec<_>>();\n        if ext_class.len() >\
    \ max_strength {\n            max_strength = ext_class.len();\n            max_strength_class\
    \ = ext;\n        }\n    }\n    let strength = max_strength;\n    let strongest_extension\
    \ = format!(\"{}.{}\", class_name, max_strength_class);\n    if strength == 0\
    \ {\n        return format!(\"{}\", strongest_extension);\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `ToUppercase`\n    --> /tmp/tmpn2ruyhlm.rs:24:14\n   \
    \  |\n24   |             .collect::<Vec<String>>()\n     |              ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=ToUppercase>`\n\
    \     |\n     = help: the trait `FromIterator<ToUppercase>` is not implemented\
    \ for `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpn2ruyhlm.rs:17:28\n   |\n\
    17 |     let mut max_strength = -1;\n   |                            ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0369]: binary operation\
    \ `==` cannot be applied to type `ToUppercase`\n  --> /tmp/tmpn2ruyhlm.rs:42:80\n\
    \   |\n42 |         let ext_class = ext.to_lowercase().chars().filter(|c| c.to_uppercase()\
    \ == ext).collect::<Vec<_>>();\n   |                                         \
    \                      ---------------- ^^ --- &String\n   |                 \
    \                                              |\n   |                       \
    \                                        ToUppercase\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn2ruyhlm.rs:45:34\n   |\n39 |     let mut max_strength_class:\
    \ Vec<_> = extensions.iter().filter(|ext| ext.chars().count() > 0).collect();\n\
    \   |                                 ------ expected due to this type\n...\n\
    45 |             max_strength_class = ext;\n   |                             \
    \     ^^^ expected struct `Vec`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<&String>`\n           found reference `&String`\n\nerror[E0277]: `Vec<&String>`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpn2ruyhlm.rs:49:60\n   |\n\
    49 |     let strongest_extension = "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut strongest_extension = None;\n    let mut i = 0;\n    while i < extensions.len()\
    \ {\n        if extensions[i].to_lowercase()\n            .chars()\n         \
    \   .filter(|c| c >= 'A' && c <= 'Z')\n            .count() == 1 {\n         \
    \   let char: u8 = extensions[i].to_lowercase().nth(i);\n            strength\
    \ += (char - 'A').min(char - 'a');\n            i += 1;\n        } else {\n  \
    \          if strength >= 0 {\n                strongest_extension = Some(extensions[i]);\n\
    \                break;\n            } else {\n                strongest_extension\
    \ = None;\n            }\n        }\n    }\n    strongest_extension.ok_or_else(||\
    \ format!(\"{}\", class_name))\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8nkv_en.rs:23:30\n   |\n\
    23 |             .filter(|c| c >= 'A' && c <= 'Z')\n   |                     \
    \         ^^^\n   |                              |\n   |                     \
    \         expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk8nkv_en.rs:23:42\n\
    \   |\n23 |             .filter(|c| c >= 'A' && c <= 'Z')\n   |              \
    \                            ^^^\n   |                                       \
    \   |\n   |                                          expected `&char`, found `char`\n\
    \   |                                          help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0599]: no method named `nth` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpk8nkv_en.rs:25:57\n   |\n25 |             let char:\
    \ u8 = extensions[i].to_lowercase().nth(i);\n   |                            \
    \                             ^^^ method not found in `String`\n\nerror[E0277]:\
    \ cannot subtract `char` from `u8`\n  --> /tmp/tmpk8nkv_en.rs:26:31\n   |\n26\
    \ |             strength += (char - 'A').min(char - 'a');\n   |              \
    \                 ^ no implementation for `u8 - char`\n   |\n   = help: the trait\
    \ `Sub<char>` is not implemented for `u8`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nerror[E0277]: cannot subtract `char`\
    \ from `u8`\n  --> /tmp/tmpk8nkv_en.rs:26:47\n   |\n26 |             strength\
    \ += (char - 'A').min(char - 'a');\n   |                                     \
    \          ^ no implementation for `u8 - char`\n   |\n   = help: the trait `Sub<char>`\
    \ is not implemented for `u8`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength: i32 = -1;\n\
    \    let mut best_name: String = class_name;\n    let mut first_extension: Option<String>\
    \ = None;\n    for (i, e) in extensions.iter().enumerate() {\n        let c =\
    \ e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n        let s = e.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if c < s {\n            if *c < min_strength\
    \ {\n                min_strength = *c;\n                best_name = class_name\
    \ + &e[0..(i + 1)];\n                first_extension = Some(e);\n            }\n\
    \        }\n    }\n    first_extension.as_ref().map_or(class_name, |e| &e + \"\
    .\" + first_extension.as_ref().unwrap_or(&e[1..]))\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpxhz27yc5.rs:24:16\n\
    \   |\n24 |             if *c < min_strength {\n   |                ^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpxhz27yc5.rs:25:32\n   |\n\
    25 |                 min_strength = *c;\n   |                                ^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxhz27yc5.rs:27:40\n   |\n27 |\
    \                 first_extension = Some(e);\n   |                           \
    \             ^- help: try using a conversion method: `.to_string()`\n   |   \
    \                                     |\n   |                                \
    \        expected struct `String`, found `&String`\n\nerror[E0369]: cannot add\
    \ `&str` to `&&String`\n  --> /tmp/tmpxhz27yc5.rs:31:56\n   |\n31 |     first_extension.as_ref().map_or(class_name,\
    \ |e| &e + \".\" + first_extension.as_ref().unwrap_or(&e[1..]))\n   |        \
    \                                             -- ^ --- &str\n   |            \
    \                                         |\n   |                            \
    \                         &&String\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhz27yc5.rs:31:99\n\
    \   |\n31 |     first_extension.as_ref().map_or(class_name, |e| &e + \".\" + first_extension.as_ref().unwrap_or(&e[1..]))\n\
    \   |                                                                        \
    \                           ^^^^^^^ expected struct `String`, found `str`\n  \
    \ |\n   = note: expected reference `&String`\n              found reference `&str`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_extensions = String::new();\n\
    \    let mut min_extensions_strength = -1;\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let c: &str = &e.to_string();\n        let c: &str = &c.to_string();\n\
    \        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_lowercase();\n        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n\
    \        let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n\
    \        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n   \
    \     let c = c.to_ascii_uppercase();\n        let c = c.to_string();\n      \
    \  let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n        let\
    \ c = c.to_ascii_uppercase();\n        let c = c.to_string();\n        let c =\
    \ c.to_ascii_lowercase();\n        let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n\
    \        let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n   \
    \     let c = c.to_string();\n        let c = c.to_ascii_uppercase();\n      \
    \  let c = c.to_string();\n        let c = c.to_ascii_lowercase();\n        let\
    \ c = c.to_string();\n        let c = c.to_ascii_uppercase();\n        let c =\
    \ c.to_string();\n        let c = c.to_ascii_lowercase();\n        let c = c.to_string();\n\
    \        let \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmcc8mrwa.rs:102:3\n\
    \    |\n16  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n19  |     for (i, e) in extensions.iter().enumerate()\
    \ {\n    |                                                 - this delimiter might\
    \ not be properly closed...\n...\n89  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n102 | }\n    |   ^\n\nerror: expected pattern,\
    \ found `}`\n  --> /tmp/tmpmcc8mrwa.rs:89:1\n   |\n89 | }\n   | ^ expected pattern\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmcc8mrwa.rs:16:72\n   |\n16 |\
    \ fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    \n    let mut strongest_extensions\
    \ = extensions.clone();\n    strongest_extensions.sort();\n    strongest_extensions.pop();\n\
    \    \n    if extensions.len() > 0 {\n        let mut class_name_len = 0;\n  \
    \      class_name_len = class_name.len();\n        \n        for extension in\
    \ strongest_extensions {\n            let mut count = 1;\n            for c in\
    \ extension {\n                if c >= 'A' && c <= 'Z' {\n                   \
    \ count += 1;\n                }\n                else if c >= 'a' && c <= 'z'\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \       let frac = class_name_len - count;\n            if frac > 0 {\n      \
    \          let mut count_cap = 0;\n                let mut count_sm = 0;\n   \
    \             for c in extension {\n                    if c >= 'A' && c <= 'Z'\
    \ {\n                        count_cap += 1;\n                    }\n        \
    \            else if c >= 'a' && c <= 'z' {\n                        count_sm\
    \ += 1;\n                    }\n                }\n                let frac =\
    \ frac / count_cap;\n                let frac = frac + (count_sm / count_cap);\n\
    \                strongest_extensions.insert(strongest_extensions.len() - 1, &format!(\"\
    {}.{}\", class_name, extension));\n                break;\n            }\n   \
    \     }\n    }\n    return strongest_extensions.last();\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpvfh7ifhz.rs:28:22\n\
    \   |\n28 |             for c in extension {\n   |                      ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpvfh7ifhz.rs:40:26\n   |\n40 |   \
    \              for c in extension {\n   |                          ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvfh7ifhz.rs:50:77\n   |\n50 |              \
    \   strongest_extensions.insert(strongest_extensions.len() - 1, &format!(\"{}.{}\"\
    , class_name, extension));\n   |                                             \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n50 -                 strongest_extensions.insert(strongest_extensions.len()\
    \ - 1, &format!(\"{}.{}\", class_name, extension));\n50 +                 strongest_extensions.insert(strongest_extensions.len()\
    \ - 1, format!(\"{}.{}\", class_name, extension));\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvfh7ifhz.rs:55:12\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                               ------ expected `String` because\
    \ of return type\n...\n55 |     return strongest_extensions.last();\n   |    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<&String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = 0;\n    extensions.sort_by_key(|x|x.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().iter().sum());\n\
    \    \n    match extensions.iter().find(|x|x.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().iter().sum()\
    \ >= strength){\n        Some(x) => x.to_string() + class_name,\n        None\
    \ => \"\".to_string() + class_name\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfuywqnug.rs:21:36\n   |\n\
    21 |         Some(x) => x.to_string() + class_name,\n   |                    \
    \                ^^^^^^^^^^\n   |                                    |\n   | \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                    help: consider borrowing here: `&class_name`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfuywqnug.rs:22:34\n   |\n22 |\
    \         None => \"\".to_string() + class_name\n   |                        \
    \          ^^^^^^^^^^\n   |                                  |\n   |         \
    \                         expected `&str`, found struct `String`\n   |       \
    \                           help: consider borrowing here: `&class_name`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_to_extensions = HashMap::new();\n\
    \    for extension in extensions {\n        let extension_class = String::from(extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>());\n        let extension_strength\
    \ = extension.chars().filter(|c| c >= 'a' && c <= 'z').count() - extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        class_to_extensions.insert(extension_class,\
    \ extension_strength);\n    }\n    let strength = class_to_extensions.get(&class_name).unwrap();\n\
    \    let max_strength = class_to_extensions.max_by_key(|&(_, strength)| strength).unwrap().1;\n\
    \    if max_strength == 0 {\n        return String::from(class_name);\n    }\n\
    \    let mut class_extensions = HashMap::new();\n    for (_, strength) in class_to_extensions\
    \ {\n        if strength == 0 {\n            continue;\n        }\n        class_extensions.insert(strength,\
    \ \"\");\n    }\n    let mut class_to_extensions_sorted_by_strength = class_extensions.iter().map(|(_,\
    \ value)| *value).collect::<Vec<_>>();\n    class_to_extensions_sorted_by_strength.sort_by_key(|&value|\
    \ value);\n    let mut class_name = class_name.to_string();\n    let mut strength_found\
    \ = false;\n    while !strength_found {\n        let extension = class_to_extensions_sorted_by_strength.first().unwrap();\n\
    \        let extension_strength = extension.len();\n        let mut class_extension\
    \ = String::from(extension.chars().filter(|c| c >= 'a' && c <= 'z').collect::<String>());\n\
    \        class_extension.truncate(class_extension.len() - extension_strength);\n\
    \        class_to_extensions.insert(class_extension, extension);\n        for\
    \ (_, value) in class_to_extensions {\n            if value == &extension {\n\
    \                strength_found = true;\n            }\n        }\n        class_to_extensions_sorted_by_strength.remove(&extension);\n\
    \        class_name.replace_range(class_name.len()+1, class_name.len()+extension_strength.to_string().len(),\
    \ &class_extension);\n    }\n    class_name\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpm5ievbyh.rs:17:35\n   |\n17 |     let mut class_to_extensions = HashMap::new();\n\
    \   |                                   ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpm5ievbyh.rs:28:32\n   |\n28 |     let mut class_extensions = HashMap::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5ievbyh.rs:19:78\n   |\n\
    19 |         let extension_class = String::from(extension.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z').collect::<String>());\n   |                            \
    \                                                  ^^^\n   |                 \
    \                                                             |\n   |        \
    \                                                                      expected\
    \ `&char`, found `char`\n   |                                                \
    \                              help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm5ievbyh.rs:19:90\n   |\n19 |         let extension_class\
    \ = String::from(extension.chars().filter(|c| c >= 'A' && c <= 'Z').collect::<String>());\n\
    \   |                                                                        \
    \                  ^^^\n   |                                                 \
    \                                         |\n   |                            \
    \                                                              expected `&char`,\
    \ found `char`\n   |                                                         \
    \                                 help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm5ievbyh.rs:20:68\n   |\n20 | ...   let extension_strength\
    \ = extension.chars().filter(|c| c >= 'a' && c <= 'z').count() - extension.chars().f"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest = Vec::new();\n\
    \    let mut num_caps = 0;\n    let mut num_sms = 0;\n\n    for e in extensions\
    \ {\n        let c = &e.chars().filter(|x| x.is_uppercase()).count();\n      \
    \  let s = &e.chars().filter(|x| x.is_lowercase()).count();\n        \n      \
    \  let cap_frac = &c - &s;\n        let cap_frac: i32 = cap_frac.to_i();\n   \
    \     \n        if cap_frac == 0 {\n            strongest.push(e);\n        }\
    \ else {\n            if cap_frac > num_caps {\n                num_caps = cap_frac;\n\
    \                strongest.clear();\n                strongest.push(e);\n    \
    \        } else if cap_frac == num_caps {\n                strongest.push(e);\n\
    \            }\n        }\n    }\n    \n    if num_caps > 0 {\n        let mut\
    \ c = 0.0;\n        \n        for s in strongest {\n            c += s.chars().filter(|x|\
    \ x.is_lowercase()).count();\n        }\n        \n        let strongest = &strongest.first().to_string();\n\
    \        let cap_frac: i32 = num_caps.to_i() - c.to_i();\n        \n        if\
    \ cap_frac == 0 {\n            return strongest;\n        } else {\n         \
    \   if cap_frac > num_caps {\n                return class_name.to_string() +\
    \ \". \" + strongest;\n            } else {\n                return class_name.to_string()\
    \ + \". \" + strongest + \". \";\n            }\n        }\n    } else {\n   \
    \     return class_name.to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `&&usize` from `&&usize`\n  --> /tmp/tmp5usnmyxp.rs:25:27\n\
    \   |\n25 |         let cap_frac = &c - &s;\n   |                        -- ^\
    \ -- &&usize\n   |                        |\n   |                        &&usize\n\
    \nerror[E0277]: cannot add-assign `usize` to `{float}`\n  --> /tmp/tmp5usnmyxp.rs:45:15\n\
    \   |\n45 |             c += s.chars().filter(|x| x.is_lowercase()).count();\n\
    \   |               ^^ no implementation for `{float} += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `{float}`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror[E0599]: the method\
    \ `to_string` exists for enum `Option<&String>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmp5usnmyxp.rs:48:44\n    |\n48  |           let strongest\
    \ = &strongest.first().to_string();\n    |                                   \
    \           ^^^^^^^^^ method cannot be called on `Option<&String>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&String>: std::fmt::Display`\n            which is required\
    \ by `Option<&String>: ToString`\n\nerror[E0599]: no method named `to_i` found\
    \ for type `i32` in the current scope\n  --> /tmp/tmp5usnmyxp.rs:49:38\n   |\n\
    49 |         let cap_frac: i32 = num_caps.to_i() - c.to_i();\n   |           \
    \                           ^^^^ method not found in `i32`\n\nerror[E0599]: no\
    \ method named `to_i` found for type `{float}` in the current scope\n  --> /tmp/tmp5usnmyxp.rs:49:49\n\
    \   |\n49 |         let cap_frac: i32 = num_caps.to_i() - c.to_i();\n   |    \
    \                                             ^^^^ method not found in `{float}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5usnmyxp.rs:55:56\n   |\n55 |\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // TODO: Implement this!\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjvu282zb.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    for\
    \ extension in extensions {\n        let (class_cap, class_sm) = extension.to_uppercase().chars().count();\n\
    \        let (extension_cap, extension_sm) =  extension.to_lowercase().chars().count();\n\
    \        let strength = if class_cap - class_sm > extension_cap - extension_sm\
    \ {\n            class_cap - class_sm\n        } else {\n            extension_cap\
    \ - extension_sm\n        }\n    }\n    class_name.to_string() + extensions[strength].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy090bsrf.rs:25:10\n   |\n\
    25 |         }\n   |          ^ help: add `;` here\n26 |     }\n   |     - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy090bsrf.rs:19:13\n \
    \  |\n19 |         let (class_cap, class_sm) = extension.to_uppercase().chars().count();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^   ----------------------------------------\
    \ this expression has type `usize`\n   |             |\n   |             expected\
    \ `usize`, found tuple\n   |\n   = note: expected type `usize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy090bsrf.rs:20:13\n\
    \   |\n20 |         let (extension_cap, extension_sm) =  extension.to_lowercase().chars().count();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ----------------------------------------\
    \ this expression has type `usize`\n   |             |\n   |             expected\
    \ `usize`, found tuple\n   |\n   = note: expected type `usize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0277]: the type `[String]` cannot be indexed by `i32`\n\
    \  --> /tmp/tmpy090bsrf.rs:27:30\n   |\n27 |     class_name.to_string() + extensions[strength].to_string()\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut extension = String::new();\n    for ext: &str in extensions {\n        let\
    \ cap = ext.chars().filter(|c| c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if cap > sm {\n            extension = ext;\n\
    \            strength = cap - sm;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmp4q4s72uk.rs:19:12\n  \
    \ |\n19 |     for ext: &str in extensions {\n   |            ^ help: try adding\
    \ `in` here\n\nerror: expected expression, found `:`\n  --> /tmp/tmp4q4s72uk.rs:19:12\n\
    \   |\n19 |     for ext: &str in extensions {\n   |            ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n     \
    \   String::from(class_name)\n    } else {\n        let mut best_strength = 0;\n\
    \        let mut best_extension = String::from(\"\");\n        for extension in\
    \ extensions {\n            let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \            let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \            let strength = cap - sm;\n            if strength > best_strength\
    \ {\n                best_strength = strength;\n                best_extension\
    \ = extension;\n            }\n        }\n        String::from(class_name) + &best_extension\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"WatashieIGHt8OKe\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp9rb3c8nf.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    \n    let mut class_name = String::from(class_name);\n\
    \    let mut extensions = extensions.iter().map(String::from).collect::<Vec<_>>();\n\
    \    let mut strength = 1;\n    \n    for &item in extensions {\n        let mut\
    \ char_counter: Vec<usize> = item.chars().map(|c| match c {\n            Some(c)\
    \ => {\n                char_counter.push(c.to_ascii_uppercase().len() - c.to_ascii_lowercase().len());\n\
    \                char_counter\n            }\n            _ => 0,\n        }).collect::<Vec<_>>();\n\
    \        let mut max_char_counter: usize = char_counter.iter().max().unwrap();\n\
    \        if char_counter.iter().any(|&item|item == max_char_counter) {\n     \
    \       char_counter.iter().filter(|&item|item == max_char_counter).count();\n\
    \        } else {\n            char_counter.push(0);\n        }\n        char_counter\
    \ = char_counter.iter().sum();\n        \n        let mut min_char_counter: usize\
    \ = char_counter.iter().min().unwrap();\n        if char_counter.iter().any(|&item|item\
    \ == min_char_counter) {\n            char_counter.iter().filter(|&item|item ==\
    \ min_char_counter).count();\n        } else {\n            char_counter.push(0);\n\
    \        }\n        char_counter = char_counter.iter().sum();\n        \n    \
    \    let mut max_char_counter_to_class = char_counter.iter().max().unwrap() -\
    \ char_counter.iter().min().unwrap();\n        let mut min_char_counter_to_class\
    \ = char_counter.iter().min().unwrap() - char_counter.iter().max().unwrap();\n\
    \        let mut max_char_counter_to_class_and_name = max_char_counter_to_class\
    \ * char_counter.iter().count() / char_counter.iter().sum();\n        let mut\
    \ min_char_counter_to_class_and_name = min_char_counter_to_class * char_counter.iter().count()\
    \ / char_counter.iter().sum();\n        \n        if char_counter_to_class_and_name\
    \ > max_char_counter_to_class_and_name {\n            strength = -1;\n       \
    \     break;\n        }\n        if char_counter_to_class_and_name == max_char_counter_to_class_and_name\
    \ {\n            if min_char_counter_to_class_and_name > max_char_counter_to_class_and_name\
    \ {\n                strength = -1;\n                break;\n            }\n \
    \       }\n        if char_counter_to_class_and_name == min_char_counter_to_class_and_name\
    \ {\n            if min_char_counter_to_class > max_char_counter_to_class {\n\
    \                strength = -1;\n                break;\n            }\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `char_counter` in this scope\n  --> /tmp/tmp9mjpqsdg.rs:25:17\n\
    \   |\n25 |                 char_counter.push(c.to_ascii_uppercase().len() - c.to_ascii_lowercase().len());\n\
    \   |                 ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `char_counter` in this scope\n  --> /tmp/tmp9mjpqsdg.rs:26:17\n \
    \  |\n26 |                 char_counter\n   |                 ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `char_counter_to_class_and_name`\
    \ in this scope\n  --> /tmp/tmp9mjpqsdg.rs:51:12\n   |\n51 |         if char_counter_to_class_and_name\
    \ > max_char_counter_to_class_and_name {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `max_char_counter_to_class_and_name`\n\
    \nerror[E0425]: cannot find value `char_counter_to_class_and_name` in this scope\n\
    \  --> /tmp/tmp9mjpqsdg.rs:55:12\n   |\n55 |         if char_counter_to_class_and_name\
    \ == max_char_counter_to_class_and_name {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `max_char_counter_to_class_and_name`\n\
    \nerror[E0425]: cannot find value `char_counter_to_class_and_name` in this scope\n\
    \  --> /tmp/tmp9mjpqsdg.rs:61:12\n   |\n61 |         if char_counter_to_class_and_name\
    \ == min_char_counter_to_class_and_name {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `max_char_counter_to_class_and_name`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9mjpqsdg.rs:22:9\n   |\n22 | \
    \    for &item in extensions {\n   |         ^^^^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `item`\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9mjpqsdg.rs:30:43\n  \
    \ |\n30 |         let mut max_char_counter: usize = char_counter.iter().max().unwrap();\n\
    \   |                                   -"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut result = String::new();\n\
    \    let mut strength = 0;\n    let mut prev_class = \"\";\n    let mut extensions\
    \ = extensions.clone();\n    let mut has_previous_class = false;\n    let mut\
    \ i = 0;\n    \n    // while we still have extensions\n    while i < extensions.len(){\n\
    \        let extension = extensions[i];\n        \n        // if the extension\
    \ is not the one that is already on the class\n        if !class_name.starts_with(extension){\n\
    \            \n            // if the extension has lower or uppercase letters\n\
    \            if extension.chars().any(|c| !c.is_uppercase() && !c.is_lowercase()){\n\
    \                strength -= 1;\n            }\n            \n            // if\
    \ the extension has more than one uppercase letter\n            if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() > 1 {\n                strength -= 1;\n          \
    \  }\n            \n            // if the extension has more than one lowercase\n\
    \            if extension.chars().filter(|c| c.is_lowercase()).count() > 1 {\n\
    \                strength -= 1;\n            }\n            \n            // if\
    \ the extension's name is empty\n            if extension.len() == 0 {\n     \
    \           strength -= 1;\n            }\n            \n            // if the\
    \ extension's name is one letter\n            if extension.len() == 1 {\n    \
    \            strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.len() {\n                strength += 1;\n            }\n        \
    \    \n            // if the extension's name is greater than the class\n    \
    \        if extension.len() > class_name.len() {\n                strength +=\
    \ 1;\n            }\n            \n            // if the extension's name is greater\
    \ than the class\n            if extension.len() > class_name.len() {\n      \
    \          strength += 1;\n            }\n            \n            // if the\
    \ extension's name is greater than the class\n            if extension.len() >\
    \ class_name.\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3syk3ocm.rs:116:3\n\
    \    |\n16  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n25  |     while i < extensions.len(){\n\
    \    |                               - unclosed delimiter\n...\n29  |        \
    \ if !class_name.starts_with(extension){\n    |                              \
    \                - this delimiter might not be properly closed...\n...\n103 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n116\
    \ | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmp3syk3ocm.rs:103:1\n\
    \    |\n103 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp3syk3ocm.rs:103:1\n\
    \    |\n102 |             if extension.len() > class_name.\n    |            \
    \ -- this `if` expression has a condition, but no block\n103 | }\n    | ^ expected\
    \ `{`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n \
    \   --> /tmp/tmp3syk3ocm.rs:29:36\n     |\n29   |         if !class_name.starts_with(extension){\n\
    \     |                        ----------- ^^^^^^^^^ expected an implementor of\
    \ trait `Pattern<'_>`\n     |                        |\n     |               \
    \         required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n29   |         if !class_name.starts_with(&extension){\n     |\
    \                                    +\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmp3syk3ocm.rs:25:5\n    |\n16  |   fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    |                        \
    \                                                  ------ expected `String` because\
    \ of return type\n...\n25  | /     while i < extensions.len(){\n26  | |      \
    \   let extension = extensions[i"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut classname = ClassName::new(&class_name);\n\
    \    let mut extension = Extension::new();\n    extension.strength = -1;\n   \
    \ let mut extension_strings = Vec::new();\n    let mut strength = extension.strength;\n\
    \n    for extension in extensions {\n        if classname.extension_exists(extension)\
    \ {\n            extension.strength = strength;\n            extension_strings.push(extension.to_string());\n\
    \        } else {\n            classname.add(extension.to_lowercase()).unwrap();\n\
    \            strength = -1;\n        }\n    }\n\n    classname.strongest_extension().unwrap()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `ClassName`\n \
    \ --> /tmp/tmppxl2h1_4.rs:17:25\n   |\n17 |     let mut classname = ClassName::new(&class_name);\n\
    \   |                         ^^^^^^^^^ use of undeclared type `ClassName`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Extension`\n  --> /tmp/tmppxl2h1_4.rs:18:25\n\
    \   |\n18 |     let mut extension = Extension::new();\n   |                  \
    \       ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0609]: no field\
    \ `strength` on type `String`\n  --> /tmp/tmppxl2h1_4.rs:25:23\n   |\n25 |   \
    \          extension.strength = strength;\n   |                       ^^^^^^^^\
    \ unknown field\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min = extensions[0].to_ascii_lowercase();\n\
    \    let mut max = extensions[0].to_ascii_lowercase();\n    for &extension in\
    \ extensions.iter() {\n        let mut counter = 0;\n        for &letter in extension.to_ascii_lowercase()\
    \ {\n            counter += if letter == min { 1 } else { -1 };\n        }\n \
    \       if counter == 0 {\n            min = extension.to_ascii_lowercase();\n\
    \        } else {\n            max = extension.to_ascii_lowercase();\n       \
    \ }\n    }\n    let mut strength = max[0].to_ascii_lowercase().chars().count()\
    \ - min[0].to_ascii_lowercase().chars().count();\n    if strength == 0 {\n   \
    \     class_name\n    } else {\n        class_name.to_ascii_lowercase().to_string()\
    \ + String::from(\"_\").to_string(strength + 1).to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpwuznm0s4.rs:21:24\n\
    \   |\n21 |         for &letter in extension.to_ascii_lowercase() {\n   |    \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpwuznm0s4.rs:30:24\n   |\n30\
    \ |     let mut strength = max[0].to_ascii_lowercase().chars().count() - min[0].to_ascii_lowercase().chars().count();\n\
    \   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpwuznm0s4.rs:30:70\n   |\n30 |     let mut strength = max[0].to_ascii_lowercase().chars().count()\
    \ - min[0].to_ascii_lowercase().chars().count();\n   |                       \
    \                                               ^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this fun"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().any(|&x| x.chars().filter(|&y|\
    \ y.is_uppercase()).count() > 1) {\n        assert!(false);\n    }\n    if extensions.iter().any(|&x|\
    \ x.chars().filter(|&y| y.is_lowercase()).count() > 1) {\n        assert!(false);\n\
    \    }\n    if extensions.iter().any(|&x| x.chars().filter(|&y| !y.is_lowercase()).count()\
    \ > 1) {\n        assert!(false);\n    }\n    if extensions.iter().any(|&x| x.chars().filter(|&y|\
    \ !y.is_uppercase()).count() > 1) {\n        assert!(false);\n    }\n    let mut\
    \ count = 1;\n    for e in extensions {\n        if e.chars().filter(|&c| c.is_lowercase()).count()\
    \ > 1 {\n            count += 1;\n        }\n        if e.chars().filter(|&c|\
    \ c.is_uppercase()).count() > 1 {\n            count += 1;\n        }\n    }\n\
    \    if count > 1 {\n        return format!(\"{}.{}\", class_name, extensions.iter().sorted().filter(|&x|\
    \ x.chars().filter(|&y| y.is_lowercase()).count() > 1).next().unwrap());\n   \
    \ }\n    if count == 1 {\n        return format!(\"{}.{}\", class_name, extensions.iter().sorted().filter(|&x|\
    \ x.chars().filter(|&y| y.is_uppercase()).count() > 1).next().unwrap());\n   \
    \ }\n    format!(\"{}.{}\", class_name, extensions.iter().sorted().filter(|&x|\
    \ x.chars().filter(|&y| !y.is_lowercase()).count() > 1).next().unwrap());\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpudswmifg.rs:39:63\n   |\n39 | ...   return\
    \ format!(\"{}.{}\", class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y|\
    \ y.is_lowercase()).count() > 1).nex...\n   |                                \
    \                             ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ String>`\n\nerror[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpudswmifg.rs:42:63\n   |\n42 | ...   return\
    \ format!(\"{}.{}\", class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y|\
    \ y.is_uppercase()).count() > 1).nex...\n   |                                \
    \                             ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ String>`\n\nerror[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpudswmifg.rs:44:52\n   |\n44 |     format!(\"\
    {}.{}\", class_name, extensions.iter().sorted().filter(|&x| x.chars().filter(|&y|\
    \ !y.is_lowercase()).count() > 1).next().unwr...\n   |                       \
    \                             ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudswmifg.rs:16:72\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_extension = 0.;\n    let\
    \ mut best_extension = String::new();\n    let mut best_index = -1;\n    for extension\
    \ in extensions.iter().cloned().take(extensions.len()) {\n        let strength\
    \ = extension.chars().filter(|c| c.is_uppercase().collect::<String>().len() -\
    \ c.is_lowercase().collect::<String>().len()).count();\n        if strength >\
    \ max_extension {\n            max_extension = strength;\n            best_extension\
    \ = extension;\n            best_index = extensions.iter().cloned().position(|e|\
    \ e == extension).unwrap();\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `bool` is not an iterator\n  --> /tmp/tmp_vkv3jic.rs:21:70\n\
    \   |\n21 | ...   let strength = extension.chars().filter(|c| c.is_uppercase().collect::<String>().len()\
    \ - c.is_lowercase().collect::<String>().len()...\n   |                      \
    \                                              ^^^^^^^ `bool` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ Iterator`\n           which is required by `&mut bool: Iterator`\n\nerror[E0599]:\
    \ `bool` is not an iterator\n  --> /tmp/tmp_vkv3jic.rs:21:115\n   |\n21 | ...se().collect::<String>().len()\
    \ - c.is_lowercase().collect::<String>().len()).count();\n   |               \
    \                                       ^^^^^^^ `bool` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ Iterator`\n           which is required by `&mut bool: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_vkv3jic.rs:22:23\n   |\n22 |         if strength\
    \ > max_extension {\n   |                       ^^^^^^^^^^^^^ expected `usize`,\
    \ found floating-point number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vkv3jic.rs:23:29\n\
    \   |\n17 |     let mut max_extension = 0.;\n   |                            \
    \ -- expected due to this value\n...\n23 |             max_extension = strength;\n\
    \   |                             ^^^^^^^^ expected floating-point number, found\
    \ `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmp_vkv3jic.rs:19:26\n   |\n19 |     let mut best_index = -1;\n   |   \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_extension = std::cmp::Ordering::Equal;\n\
    \    let mut min_strength = std::cmp::Ordering::Equal;\n    extensions.iter().filter(|&e|\
    \ e.is_ascii_lowercase()).for_each(|e| {\n        if e.is_ascii_uppercase() {\n\
    \            let cap_len = e.len() - e.to_ascii_lowercase().len();\n         \
    \   if cap_len < min_strength {\n                min_extension = std::cmp::Ordering::Less;\n\
    \                min_strength = cap_len;\n            }\n        } else {\n  \
    \          let sm_len = e.len() - e.to_ascii_uppercase().len();\n            if\
    \ sm_len < min_strength {\n                min_extension = std::cmp::Ordering::Less;\n\
    \                min_strength = sm_len;\n            }\n        }\n    });\n \
    \   match min_strength {\n        std::cmp::Ordering::Equal => class_name,\n \
    \       std::cmp::Ordering::Less => format!(\"{}.{}\", class_name, min_extension),\n\
    \        std::cmp::Ordering::Greater => format!(\"{}.{}\", class_name, min_extension),\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpafdssswe.rs:19:37\n   |\n19 |\
    \     extensions.iter().filter(|&e| e.is_ascii_lowercase()).for_each(|e| {\n \
    \  |                                     ^^^^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmpafdssswe.rs:20:14\n   |\n20 |         if e.is_ascii_uppercase()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpafdssswe.rs:22:26\n   |\n22 |             if cap_len < min_strength\
    \ {\n   |                          ^^^^^^^^^^^^ expected `usize`, found enum `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpafdssswe.rs:24:32\n   |\n18 |\
    \     let mut min_strength = std::cmp::Ordering::Equal;\n   |                \
    \            ------------------------- expected due to this value\n...\n24 | \
    \                min_strength = cap_len;\n   |                               \
    \ ^^^^^^^ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpafdssswe.rs:28:25\n   |\n28 |             if sm_len < min_strength\
    \ {\n   |                         ^^^^^^^^^^^^ expected `usize`, found enum `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpafdssswe.rs:30:32\n   |\n18 |\
    \     let mut min_strength = std::cmp::Ordering::Equal;\n   |                \
    \            ------------------------- expected due to this value\n...\n30 | \
    \                min_strength = sm_len;\n   |                                ^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0277]: `std::cmp::Ordering`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpafdssswe.rs:36:66\n   |\n\
    36 |         std::cmp::Ordering::Less => format!(\"{}.{}\", class_name, min_extension),\n\
    \   |                                                                  ^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max = -1;\n    for ext in\
    \ extensions.iter() {\n        let cap = ext.chars().count();\n        let sm\
    \ = ext.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let strength\
    \ = cap - sm;\n        if strength > max {\n            max = strength;\n    \
    \    }\n    }\n\n    let mut class = String::from(class_name);\n    let mut ex\
    \ = String::from(\"\");\n    match max {\n        -1 => {\n            return\
    \ class;\n        }\n        1 => ex = &extensions[0],\n        2 => ex = &extensions[1],\n\
    \        _ => ex = &extensions[extensions.len() - 1],\n    }\n    class.push(ex.as_str());\n\
    \    class\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc5ba38y.rs:20:46\n   |\n\
    20 |         let sm = ext.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                              ^^^\n   |                 \
    \                             |\n   |                                        \
    \      expected `&char`, found `char`\n   |                                  \
    \            help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplc5ba38y.rs:20:58\n   |\n20 |         let sm = ext.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                   ^^^\n   |                                                \
    \          |\n   |                                                          expected\
    \ `&char`, found `char`\n   |                                                \
    \          help: consider borrowing here: `&'Z'`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmplc5ba38y.rs:17:19\n   |\n17 | \
    \    let mut max = -1;\n   |                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmplc5ba38y.rs:30:9\n   |\n30 |         -1 => {\n   |\
    \         ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplc5ba38y.rs:33:19\n   |\n28 |\
    \     let mut ex = String::from(\"\");\n   |                  ----------------\
    \ expected due to this value\n...\n33 |         1 => ex = &extensions[0],\n  \
    \ |                   ^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: con"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_value = std::i32::MAX;\n\
    \    let mut min_extension = \"\".to_string();\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        let cap = ext.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let sm = ext.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n  \
    \      if cap < sm {\n            min_value = *ext < min_value ? -1 : *ext;\n\
    \            min_extension = ext;\n        } else if cap == sm {\n           \
    \ if *ext < min_value {\n                min_value = *ext;\n                min_extension\
    \ = ext;\n            }\n        }\n    }\n    class_name.to_string().to_lowercase()\
    \ + \".\" + min_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected mut or const in raw pointer type\n  --> /tmp/tmpmmk9la8m.rs:23:49\n\
    \   |\n23 |             min_value = *ext < min_value ? -1 : *ext;\n   |      \
    \                                           ^ expected mut or const in raw pointer\
    \ type\n   |\n   = help: use `*mut T` or `*const T` as appropriate\n\nerror[E0573]:\
    \ expected type, found local variable `ext`\n  --> /tmp/tmpmmk9la8m.rs:23:50\n\
    \   |\n23 |             min_value = *ext < min_value ? -1 : *ext;\n   |      \
    \                                            ^^^ expecting a type here because\
    \ of type ascription\n\nerror[E0277]: the `?` operator can only be applied to\
    \ values that implement `Try`\n  --> /tmp/tmpmmk9la8m.rs:23:32\n   |\n23 |   \
    \          min_value = *ext < min_value ? -1 : *ext;\n   |                   \
    \             ^^^^^^^^^^^ the `?` operator cannot be applied to type `i32`\n \
    \  |\n   = help: the trait `Try` is not implemented for `i32`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpmmk9la8m.rs:23:42\n\
    \   |\n16 | / fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n17 | |     let mut min_value = std::i32::MAX;\n18 | |     let mut\
    \ min_extension = \"\".to_string();\n19 | |     for (i, ext) in extensions.iter().enumerate()\
    \ {\n...  |\n23 | |             min_value = *ext < min_value ? -1 : *ext;\n  \
    \ | |                                          ^ cannot use the `?` operator in\
    \ a function that returns `String`\n...  |\n32 | |     class_name.to_string().to_lowercase()\
    \ + \".\" + min_extension\n33 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmk9la8m.rs:23:25\n\
    \   |\n17 |     let mut min_value = std::i32::MAX;\n   |                     \
    \    ------------- expected due to this value\n...\n23 |             min_value\
    \ = *ext < min_value ? -1 : *ext;\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expe"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength_map = HashMap::new();\n\
    \    \n    for extension in extensions {\n        let cap_len = extension.len();\n\
    \        let sml_len = class_name.len();\n        let strength = cap_len - sml_len;\n\
    \        if strength_map.contains_key(&strength) {\n            if let Some(existing)\
    \ = strength_map.get_mut(&strength) {\n                existing.push_front(&extension);\n\
    \            } else {\n                strength_map.insert(strength, vec![&extension]);\n\
    \            }\n        } else {\n            strength_map.insert(strength, vec![&extension]);\n\
    \        }\n    }\n\n    let strength_max: i64 = strength_map.iter().max().unwrap().len()\
    \ as i64;\n\n    let mut selected_extension: Vec<String> = vec![];\n    for (_,\
    \ elements) in strength_map.iter() {\n        let len: usize = elements.len();\n\
    \        if len == 1 {\n            selected_extension = elements[0];\n      \
    \      break;\n        }\n        if len > 1 {\n            break;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, selected_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6g0i37o9.rs:17:28\n   |\n17 |     let mut strength_map = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `Vec<String>` doesn't implement `std::fmt::Display`\n \
    \ --> /tmp/tmp6g0i37o9.rs:47:34\n   |\n47 |     format!(\"{}.{}\", class_name,\
    \ selected_extension)\n   |                                  ^^^^^^^^^^^^^^^^^^\
    \ `Vec<String>` cannot be formatted with the default formatter\n   |\n   = help:\
    \ the trait `std::fmt::Display` is not implemented for `Vec<String>`\n   = note:\
    \ in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let extensions: Vec<String> = extensions.into_iter().collect();\n\
    \    extensions.iter().fold(class_name, |a, b| {\n        let mut x = a.to_string();\n\
    \        let mut y = b.to_string();\n        for (c1, c2) in y.chars().zip(x.chars())\
    \ {\n            if c1 == c2 {\n                x = x.to_string() + c1.to_string();\n\
    \            }\n        }\n        x.to_string()\n    })\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvmlawthz.rs:23:37\n   |\n\
    23 |                 x = x.to_string() + c1.to_string();\n   |               \
    \                      ^^^^^^^^^^^^^^\n   |                                  \
    \   |\n   |                                     expected `&str`, found struct\
    \ `String`\n   |                                     help: consider borrowing\
    \ here: `&c1.to_string()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut c = String::from(\"\");\n\
    \    let mut exts = vec![];\n    for ext in extensions {\n        if ext.is_empty()\
    \ {\n            continue;\n        }\n        let mut n = ext.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        n += ext.chars().filter(|c| *c >=\
    \ 'a' && *c <= 'z').count();\n        if n < 2 {\n            continue;\n    \
    \    }\n        exts.push(ext);\n    }\n    let mut total_exts = exts.iter().filter(|ext|\
    \ *ext != \"_\").count();\n    let cap = total_exts.cmp(&total_exts).unwrap();\n\
    \    let sm = ext.chars().filter(|c| *c == '_').count();\n    let strength = cap\
    \ - sm;\n    if strength == 0 {\n        return format!(\"{}.{}\", class_name,\
    \ \"_\");\n    }\n    exts.sort_unstable_by(|a, b| b.cmp(a).unwrap());\n    for\
    \ ext in exts {\n        if ext.contains(\"_\") {\n            continue;\n   \
    \     }\n        c = c.to_string() + format!(\"{}.{}\", class_name, ext);\n  \
    \  }\n    return c;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ext` in this scope\n  --> /tmp/tmps7kiii8l.rs:32:14\n\
    \   |\n32 |     let sm = ext.chars().filter(|c| *c == '_').count();\n   |    \
    \          ^^^ help: a local variable with a similar name exists: `exts`\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmps7kiii8l.rs:31:43\n   |\n31 |     let cap = total_exts.cmp(&total_exts).unwrap();\n\
    \   |                                           ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmps7kiii8l.rs:37:43\n   |\n37 |     exts.sort_unstable_by(|a,\
    \ b| b.cmp(a).unwrap());\n   |                                           ^^^^^^\
    \ method not found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps7kiii8l.rs:42:29\n   |\n42 |         c = c.to_string() + format!(\"\
    {}.{}\", class_name, ext);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = -1i32;\n    let\
    \ mut extension = String::new();\n\n    for extension in extensions.iter() {\n\
    \        let s = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if s == strength {\n            return format!(\"\
    {}.{}\", class_name, extension);\n        }\n\n        if s < strength {\n   \
    \         strength = s;\n            extension = extension.to_owned();\n     \
    \   }\n    }\n\n    return format!(\"{}.{}\", class_name, extension);\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2y051ma0.rs:22:17\n   |\n\
    22 |         if s == strength {\n   |                 ^^^^^^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n22 |         if s == strength.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2y051ma0.rs:26:16\n   |\n26 |         if s < strength {\n\
    \   |                ^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n26 |         if s < strength.try_into().unwrap() {\n   |              \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2y051ma0.rs:27:24\n\
    \   |\n17 |     let mut strength = -1i32;\n   |                        ----- expected\
    \ due to this value\n...\n27 |             strength = s;\n   |               \
    \         ^ expected `i32`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2y051ma0.rs:28:25\n   |\n20 |     for extension in extensions.iter()\
    \ {\n   |         --------- expected due to the type of this binding\n...\n28\
    \ |             extension = extension.to_owned();\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^^^\n   |                         |\n   |               \
    \          expected `&String`, found struct `String`\n   |                   \
    \      help: consider borrowing here: `&extension.to_owned()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // write your code here\n    println!(\"\
    {}\", class_name);\n    for (index, s) in extensions.iter().enumerate() {\n  \
    \      println!(\"{:?} {:?}\", s, index);\n    }\n\n    if extensions.len() ==\
    \ 0 {\n        class_name\n    } else {\n        let mut num_cap = class_name.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let mut num_small = class_name.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        for (i, s) in extensions.iter().enumerate()\
    \ {\n            if s.is_lowercase() {\n                num_small -= 1;\n    \
    \        } else {\n                num_cap -= 1;\n            }\n        }\n \
    \       let strength = num_cap - num_small;\n        if strength < 0 {\n     \
    \       format!(\"{}.{}\", class_name, extensions.iter().next().unwrap())\n  \
    \      } else {\n            format!(\"{}.{}\", class_name, extensions[strength].clone())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpacsdq5je.rs:29:18\n   |\n29 |          \
    \   if s.is_lowercase() {\n   |                  ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().any(|e| e.is_empty())\
    \ {\n        panic!(\"An extension can not be empty\");\n    }\n    let mut total_strength:\
    \ usize = 0;\n    let mut max_extension = &extensions.iter().cloned().max().unwrap();\n\
    \    for extension in extensions {\n        let mut letters = 0;\n        for\
    \ letter in extension {\n            if letter == 'A' || letter == 'B' || letter\
    \ == 'C' || letter == 'D' || letter == 'E' || letter == 'F' ||\n             \
    \   letter == 'G' || letter == 'H' || letter == 'I' || letter == 'J' || letter\
    \ == 'K' || letter == 'L' ||\n                letter == 'M' || letter == 'N' ||\
    \ letter == 'O' || letter == 'P' || letter == 'Q' || letter == 'R' ||\n      \
    \          letter == 'S' || letter == 'T' || letter == 'U' || letter == 'V' ||\
    \ letter == 'W' || letter == 'X' ||\n                letter == 'Y' || letter ==\
    \ 'Z' {\n                letters += 1;\n            }\n        }\n        let\
    \ strength = letters - total_strength;\n        total_strength += strength;\n\
    \        if strength > 0 {\n            continue;\n        }\n        max_extension\
    \ = extension;\n    }\n    class_name.to_string() + \".\" + max_extension.cloned()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpfp9p53va.rs:24:23\n\
    \   |\n24 |         for letter in extension {\n   |                       ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfp9p53va.rs:38:25\n   |\n21 |     let mut max_extension\
    \ = &extensions.iter().cloned().max().unwrap();\n   |                        \
    \     ------------------------------------------ expected due to this value\n\
    ...\n38 |         max_extension = extension;\n   |                         ^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&String`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&extension`\n\nerror[E0599]: `&String` is not an iterator\n   --> /tmp/tmpfp9p53va.rs:40:50\n\
    \    |\n40  |       class_name.to_string() + \".\" + max_extension.cloned()\n\
    \    |                                                    ^^^^^^ `&String` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `&String: Iterator`\n            which is required by `&mut &String:\
    \ Iterator`\n            `String: Iterator`\n            which is required by\
    \ `&mut String: Iterator`\n            `str: Iterator`\n            which is required\
    \ by `&mut str: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_with_extension = class_name.to_lowercase();\n\
    \    let mut extensions_with_strength = vec![];\n    \n    for extension in extensions\
    \ {\n        let mut extension_with_strength = extension.to_lowercase();\n   \
    \     let mut upper_case_letters = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut lowercase_letters = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        \n        if upper_case_letters == lowercase_letters {\n            extensions_with_strength.push(extension_with_strength);\n\
    \        }\n    }\n    \n    let mut current_strength = -1;\n    let mut current_extension\
    \ = String::new();\n    for extension in extensions_with_strength {\n        if\
    \ let Some(strength) = extension.chars().count() {\n            if strength >\
    \ current_strength {\n                current_strength = strength;\n         \
    \       current_extension = extension;\n            }\n        }\n    }\n    return\
    \ class_with_extension.concat(\".\").concat(current_extension);\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjv1weir_.rs:33:16\n   |\n\
    33 |         if let Some(strength) = extension.chars().count() {\n   |       \
    \         ^^^^^^^^^^^^^^   ------------------------- this expression has type\
    \ `usize`\n   |                |\n   |                expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<_>`\n\nerror[E0599]: no method named `concat` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjv1weir_.rs:40:33\n   |\n40 |     return\
    \ class_with_extension.concat(\".\").concat(current_extension);\n   |        \
    \                         ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut sorted_extensions = extensions.iter().cloned().sort_by_key(|x|x.to_lowercase());\n\
    \    let strength = sorted_extensions.len();\n    let class_extension = sorted_extensions.iter().filter(|x|\
    \ x.to_lowercase() == class_name.to_lowercase()).nth(strength);\n    let mut class_name\
    \ = class_name.to_string();\n    class_name = class_name.to_string().to_lowercase();\n\
    \    class_name = &class_name.to_lowercase().replace(class_extension.to_lowercase(),\
    \ \"\");\n    class_name += &class_extension.to_lowercase();\n    class_name =\
    \ &class_name.to_string();\n    class_name = &class_name.to_string().to_lowercase();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string();\n    class_name = &class_name.to_string();\n\
    \    class_name = &class_name.to_string\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpikv_b5vr.rs:17:60\n   |\n17 |     let mut sorted_extensions\
    \ = extensions.iter().cloned().sort_by_key(|x|x.to_lowercase());\n   |       \
    \                                                     ^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, String>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpikv_b5vr.rs:22:18\n   |\n20 |     let mut class_name = class_name.to_string();\n\
    \   |                          ---------------------- expected due to this value\n\
    21 |     class_name = class_name.to_string().to_lowercase();\n22 |     class_name\
    \ = &class_name.to_lowercase().replace(class_extension.to_lowercase(), \"\");\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n22 -     class_name = &class_name.to_lowercase().replace(class_extension.to_lowercase(),\
    \ \"\");\n22 +     class_name = class_name.to_lowercase().replace(class_extension.to_lowercase(),\
    \ \"\");\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpikv_b5vr.rs:24:18\n\
    \   |\n20 |     let mut class_name = class_name.to_string();\n   |           \
    \               ---------------------- expected due to this value\n...\n24 | \
    \    class_name = &class_name.to_string();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n24 -     class_name = &class_name.to_string();\n24 +     class_name\
    \ = class_name.to_string();\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpikv_b5vr.rs:25:18\n\
    \   |\n20 |     let mut class_name = class_name.to_string();\n   |           \
    \               ---------------------- expected due to this value\n...\n25 | \
    \    class_name = &class_name.to_string().to_lowercase();\n   |              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n25 -     class_name = &class_name.to_string().to_lowe"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extension = Vec::new();\n\
    \    let mut max_strength = 0;\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        extension.insert(i, class_name[i]);\n        let cap = extension.iter().filter(|&x|\
    \ x == x.to_uppercase()).count();\n        let sm = extension.iter().filter(|&x|\
    \ x == x.to_lowercase()).count();\n        let strength = cap - sm;\n        if\
    \ strength > max_strength {\n            max_strength = strength;\n        }\n\
    \    }\n    extension.iter().filter(|&x| x == x.to_lowercase()).nth(max_strength).cloned()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7p7_dl50.rs:20:29\n\
    \   |\n20 |         extension.insert(i, class_name[i]);\n   |                \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmp7p7_dl50.rs:21:29\n   |\n21 |         let cap = extension.iter().filter(|&x|\
    \ x == x.to_uppercase()).count();\n   |                             ^^^^ method\
    \ not found in `&String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n21 |         let cap = extension.chars().filter(|&x| x == x.to_uppercase()).count();\n\
    \   |                             ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmp7p7_dl50.rs:22:28\n\
    \   |\n22 |         let sm = extension.iter().filter(|&x| x == x.to_lowercase()).count();\n\
    \   |                            ^^^^ method not found in `&String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n22 |         let sm = extension.chars().filter(|&x|\
    \ x == x.to_lowercase()).count();\n   |                            ~~~~~\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut max\
    \ = String::new();\n    \n    for el in extensions {\n        let mut num_caps\
    \ = 0;\n        let mut num_sms = 0;\n        let mut num_others = 0;\n      \
    \  for c in el.chars() {\n            if c.is_uppercase() {\n                num_caps\
    \ += 1;\n            } else if c.is_lowercase() {\n                num_sms +=\
    \ 1;\n            } else {\n                num_others += 1;\n            }\n\
    \        }\n        let strength = num_caps - num_sms;\n        if strength >\
    \ 0 {\n            let mut name = el.clone();\n            name.to_string().chars().sort_by_key(|x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>().pop().to_string();\n           \
    \ max = match max {\n                Some(max) => match max {\n              \
    \      max if max == name => max,\n                    max if max.len() > name.len()\
    \ => max\n                },\n                None => name\n            }\n  \
    \      }\n    }\n    max + &class_name + &extensions[0]\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpifzwe9ja.rs:36:38\n   |\n36 |             name.to_string().chars().sort_by_key(|x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>().pop().to_string();\n   |       \
    \                               ^^^^^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpifzwe9ja.rs:38:17\n   |\n37 |  \
    \           max = match max {\n   |                         --- this expression\
    \ has type `String`\n38 |                 Some(max) => match max {\n   |     \
    \            ^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n \
    \  = note: expected struct `String`\n                found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpifzwe9ja.rs:42:17\n   |\n37 |  \
    \           max = match max {\n   |                         --- this expression\
    \ has type `String`\n...\n42 |                 None => name\n   |            \
    \     ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note: expected\
    \ struct `String`\n                found enum `Option<_>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_name = class_name.to_uppercase();\n\
    \    class_name.chars().enumerate().for_each(|(i, c)| {\n        if let Some(mut\
    \ c) = c.to_lowercase() {\n            class_name.insert(i, c);\n        }\n \
    \   })\n    .collect::<Vec<_>>();\n    let mut sorted_extensions = extensions;\n\
    \    sorted_extensions.sort();\n    \n    if class_name.len() < sorted_extensions.len()\
    \ {\n        return class_name.to_string() + \".\" + sorted_extensions[0].to_string();\n\
    \    }\n    \n    let mut strength = 0;\n    for i in 0..class_name.len() - 1\
    \ {\n        if class_name.chars()[i..(i + 1)].iter().all(|c| c.is_uppercase())\
    \ {\n            strength += 1;\n        }\n    }\n    \n    for i in 1..sorted_extensions.len()\
    \ {\n        if sorted_extensions[i - 1].chars()[i..(i + 1)].iter().all(|c| c.is_lowercase())\
    \ {\n            strength -= 1;\n        }\n    }\n    \n    String::from(class_name.to_string()\
    \ + \n                \n                // The Strongest Extension must be the\
    \ one with the most lowercase letters\n                match strength {\n    \
    \                // If we have two or more of the same characters (same uppercase\
    \ and lowercase ones)\n                    -1 => sorted_extensions[strength -\
    \ 1].chars()[i..(i + 1)].iter().filter(|c| c.is_lowercase()).count(),\n      \
    \              _ => sorted_extensions[strength].chars()[i..(i + 1)].iter().filter(|c|\
    \ c.is_lowercase()).count()\n                }.to_string() + \"\\n\")\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpmtictpl1.rs:49:67\n\
    \   |\n49 |                     -1 => sorted_extensions[strength - 1].chars()[i..(i\
    \ + 1)].iter().filter(|c| c.is_lowercase()).count(),\n   |                   \
    \                                                ^ not found in this scope\n\n\
    error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpmtictpl1.rs:49:71\n\
    \   |\n49 |                     -1 => sorted_extensions[strength - 1].chars()[i..(i\
    \ + 1)].iter().filter(|c| c.is_lowercase()).count(),\n   |                   \
    \                                                    ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpmtictpl1.rs:50:62\n\
    \   |\n50 |                     _ => sorted_extensions[strength].chars()[i..(i\
    \ + 1)].iter().filter(|c| c.is_lowercase()).count()\n   |                    \
    \                                          ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpmtictpl1.rs:50:66\n   |\n\
    50 |                     _ => sorted_extensions[strength].chars()[i..(i + 1)].iter().filter(|c|\
    \ c.is_lowercase()).count()\n   |                                            \
    \                      ^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtictpl1.rs:19:16\n   |\n19 |         if let Some(mut c) = c.to_lowercase()\
    \ {\n   |                ^^^^^^^^^^^   ---------------- this expression has type\
    \ `ToLowercase`\n   |                |\n   |                expected struct `ToLowercase`,\
    \ found enum `Option`\n   |\n   = note: expected struct `ToLowercase`\n      \
    \          found enum `Option<_>`\n\nerror[E0599]: `()` is not an iterator\n \
    \ --> /tmp/tmpmtictpl1.rs:23:6\n   |\n23 |     .collect::<Vec<_>>();\n   |   \
    \   ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtictpl1.rs:28:47\n\
    \   |\n28 |         return class_name.to_string() + \".\" + sorted_exten"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strengths = HashMap::new();\n\
    \    for (i, ext) in extensions.iter().enumerate() {\n        let c = ext.chars().map(|c|\
    \ c.to_lowercase()).count();\n        let s = ext.chars().map(|c| c.to_lowercase()).filter(|c|\
    \ c.is_upper()).count();\n        if c > s {\n            strengths.insert(ext,\
    \ -1);\n        } else {\n            strengths.insert(ext, c);\n        }\n \
    \   }\n    let strength = match strengths.get(&class_name).cloned() {\n      \
    \  Some(s) => s,\n        None => 0,\n    };\n    let mut s = class_name.to_owned();\n\
    \    strengths.entry(&class_name).or_insert(strength).for_each(|r| s += &r.to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp61lklv9_.rs:17:25\n   |\n17 |     let mut strengths = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `is_upper` found for reference `&ToLowercase` in the current\
    \ scope\n  --> /tmp/tmp61lklv9_.rs:20:68\n   |\n20 |         let s = ext.chars().map(|c|\
    \ c.to_lowercase()).filter(|c| c.is_upper()).count();\n   |                  \
    \                                                  ^^^^^^^^ method not found in\
    \ `&ToLowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n  \n  let mut strength = -1;\n  let mut\
    \ extension = &extensions[0];\n  \n  for e in extensions {\n    if e.chars().count()\
    \ > strength {\n      strength = e.chars().count();\n      extension = &e;\n \
    \   }\n  }\n  \n  format!(\"{}{}\", class_name, extension)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpzuxowvtp.rs:18:22\n\
    \   |\n18 |   let mut strength = -1;\n   |                      ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n    for\
    \ extension in extensions {\n        let (first_letter, second_letter) = extension.chars().nth(1).unwrap().to_ascii_uppercase().chars().nth(1).unwrap().to_ascii_lowercase();\n\
    \        let first_letter = first_letter.unwrap();\n        let second_letter\
    \ = second_letter.unwrap();\n        strength = (strength * 26) + first_letter\
    \ - second_letter;\n    }\n    strength\n        .checked_mul(extensions.length)\n\
    \        .checked_add(1)\n        .unwrap_or(-1)\n        .toString()\n      \
    \  .to_string() + class_name + extensions.to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3s9fsc7b.rs:19:100\n   |\n19 | ...   let (first_letter,\
    \ second_letter) = extension.chars().nth(1).unwrap().to_ascii_uppercase().chars().nth(1).unwrap().to_ascii_lowerca...\n\
    \   |                                                                        \
    \                          ^^^^^ method not found in `char`\n\nerror[E0609]: no\
    \ field `length` on type `Vec<String>`\n  --> /tmp/tmp3s9fsc7b.rs:25:33\n   |\n\
    25 |         .checked_mul(extensions.length)\n   |                           \
    \      ^^^^^^ unknown field\n\nerror[E0599]: no method named `checked_add` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp3s9fsc7b.rs:26:10\n  \
    \ |\n26 |         .checked_add(1)\n   |          ^^^^^^^^^^^ method not found\
    \ in `Option<i32>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n    let\
    \ mut min_extension = String::from(\"\");\n    let mut extension_count = 0;\n\
    \    for (i, ext) in extensions.iter().enumerate() {\n        let cap = ext.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let strength = cap - sm;\n        if strength < min_strength {\n    \
    \        min_strength = strength;\n            min_extension = ext;\n        }\n\
    \        if i == extensions.len() - 1 {\n            extension_count = i;\n  \
    \      }\n    }\n    let strength = min_strength;\n    let extension = min_extension;\n\
    \    String::from(class_name) + String::from(extension) + \".\" + extensions[extension_count]\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpchdxfnyz.rs:26:29\n   |\n\
    18 |     let mut min_extension = String::from(\"\");\n   |                   \
    \          ---------------- expected due to this value\n...\n26 |            \
    \ min_extension = ext;\n   |                             ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                             |\n  \
    \ |                             expected struct `String`, found `&String`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpchdxfnyz.rs:17:28\n\
    \   |\n17 |     let mut min_strength = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpchdxfnyz.rs:34:32\n   |\n34 |     String::from(class_name)\
    \ + String::from(extension) + \".\" + extensions[extension_count]\n   |      \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \           |\n   |                                expected `&str`, found struct\
    \ `String`\n   |                                help: consider borrowing here:\
    \ `&String::from(extension)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpchdxfnyz.rs:34:64\n\
    \   |\n34 |     String::from(class_name) + String::from(extension) + \".\" + extensions[extension_count]\n\
    \   |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                |\n   | \
    \                                                               expected `&str`,\
    \ found struct `String`\n   |                                                \
    \                help: consider borrowing here: `&extensions[extension_count]`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E027"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Solution below is very similar\
    \ to the solution presented in the question, \n    // but the code was modified\
    \ in the following ways: \n    // - Instead of using map() function, used collect()\
    \ method. \n    // - Modified the logic in two places.\n    let mut extensions_cap\
    \ = extensions.iter().map(|e| e.chars().filter(|c| *c == c).count()).collect::<Vec<_>>();\n\
    \    let mut extensions_sm = extensions.iter().map(|e| e.chars().filter(|c| *c\
    \ != c).count()).collect::<Vec<_>>();\n    let mut max = extensions_cap.iter().max().unwrap();\n\
    \    let mut min = extensions_sm.iter().min().unwrap();\n\n    let mut min_extensions\
    \ = extensions_sm.iter().cloned().collect::<Vec<_>>();\n    let mut max_extensions\
    \ = extensions_cap.iter().cloned().collect::<Vec<_>>();\n    for element in extensions_cap\
    \ {\n        if element < min {\n            min = element;\n            match\
    \ max_extensions.iter().position(|x| x == element) {\n                Some(_)\
    \ => min_extensions.pop(),\n                None => ()\n            }\n      \
    \  }\n        if element > max {\n            max = element;\n            match\
    \ min_extensions.iter().position(|x| x == element) {\n                Some(_)\
    \ => max_extensions.pop(),\n                None => ()\n            }\n      \
    \  }\n    }\n    // The next line is added to ensure that the extension list has\
    \ the\n    // same number of elements as the original extension list.\n    min_extensions.extend(max_extensions.iter().cloned());\n\
    \    \n    format!(\"{}.{}\", class_name, min_extensions)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2w0off0u.rs:21:83\n   |\n\
    21 |     let mut extensions_cap = extensions.iter().map(|e| e.chars().filter(|c|\
    \ *c == c).count()).collect::<Vec<_>>();\n   |                               \
    \                                                    ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |     let mut\
    \ extensions_cap = extensions.iter().map(|e| e.chars().filter(|c| *c == *c).count()).collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2w0off0u.rs:22:82\n\
    \   |\n22 |     let mut extensions_sm = extensions.iter().map(|e| e.chars().filter(|c|\
    \ *c != c).count()).collect::<Vec<_>>();\n   |                               \
    \                                                   ^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |     let mut extensions_sm\
    \ = extensions.iter().map(|e| e.chars().filter(|c| *c != *c).count()).collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2w0off0u.rs:29:22\n\
    \   |\n29 |         if element < min {\n   |                      ^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    29 |         if element < *min {\n   |                      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2w0off0u.rs:30:19\n   |\n24 |     let mut min\
    \ = extensions_sm.iter().min().unwrap();\n   |                   -----------------------------------\
    \ expected due to this value\n...\n30 |             min = element;\n   |     \
    \              ^^^^^^^\n   |                   |\n   |                   expected\
    \ `&usize`, found `usize`\n   |                   help: consider borrowing here:\
    \ `&element`\n\nerror[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmp2w0off0u.rs:31:56\n\
    \   |\n31 |             match max_extensions.iter().position(|x| x == element)\
    \ {\n   |                                              "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().fold(\n        \"\
    \",\n        |mut last_extension, ext| {\n            let mut next_letter = ext.to_lowercase();\n\
    \            let cap = next_letter.chars().filter(|c| c.is_uppercase()).count();\n\
    \            let sm = next_letter.chars().filter(|c| c.is_lowercase()).count();\n\
    \            let strength = cap - sm;\n            assert!(strength >= 0);\n \
    \           if strength > 0 {\n                if last_extension == \"\" {\n \
    \                   return &format!(\"{}.{}\", class_name, ext);\n           \
    \     } else {\n                    if last_extension.contains(&'.') {\n     \
    \                   last_extension = &format!(\"{}.{}{}\", last_extension, ext,\
    \ last_extension[..]);\n                    } else {\n                       \
    \ last_extension = &format!(\"{}.{}\", last_extension, ext);\n               \
    \     }\n                }\n            } else {\n                last_extension\
    \ = ext;\n            }\n            last_extension\n        },\n    )\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4u8h2z4.rs:18:9\n   |\n\
    18 |         \"\",\n   |         ^^- help: try using a conversion method: `.to_string()`\n\
    \   |         |\n   |         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4u8h2z4.rs:27:28\n   |\n27 |              \
    \       return &format!(\"{}.{}\", class_name, ext);\n   |                   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n27 -                     return\
    \ &format!(\"{}.{}\", class_name, ext);\n27 +                     return format!(\"\
    {}.{}\", class_name, ext);\n   | \n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmpx4u8h2z4.rs:29:48\n     |\n29   |            \
    \         if last_extension.contains(&'.') {\n     |                         \
    \              -------- ^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                                       |\n     |                      \
    \                 required by a bound introduced by this call\n     |\n     =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n29   |                     if last_extension.contains(*&'.')\
    \ {\n     |                                                +\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpx4u8h2z4.rs:30:83\n    |\n30  |                         last_extension\
    \ = &format!(\"{}.{}{}\", last_extension, ext, last_extension[..]);\n    |   \
    \                                                                            \
    \    ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n   \
    \ = help: the trait `Sized` is not implemented for `str`\nnote: required by a\
    \ bound in `ArgumentV1::<'a>::new_displa"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().filter(|ext| ext.contains(&class_name.to_lowercase())).max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppza5c42e.rs:17:5\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n17 |     extensions.iter().filter(|ext|\
    \ ext.contains(&class_name.to_lowercase())).max().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut s = String::from(class_name);\n\
    \    for i in 0..extensions.len() {\n        let mut s = String::from(s);\n  \
    \      let letters = extensions[i].chars().count();\n        let strength = letters\
    \ - i;\n        s = format!(\"{}.{}\", s, strength);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `s` is never read\n  --> /tmp/tmpk0wllzk8.rs:22:9\n\
    \   |\n22 |         s = format!(\"{}.{}\", s, strength);\n   |         ^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: variable does not need to be mutable\n\
    \  --> /tmp/tmpk0wllzk8.rs:17:9\n   |\n17 |     let mut s = String::from(class_name);\n\
    \   |         ----^\n   |         |\n   |         help: remove this `mut`\n  \
    \ |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved\
    \ value: `s`\n  --> /tmp/tmpk0wllzk8.rs:19:34\n   |\n17 |     let mut s = String::from(class_name);\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n18 |     for i in 0..extensions.len() {\n19 |  \
    \       let mut s = String::from(s);\n   |                                  ^\
    \ value moved here, in previous iteration of loop\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut best_extensions\
    \ = Vec::new();\n    for e in extensions {\n        let cap_len = e.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm_len = e.chars().filter(|&c| c\
    \ >= 'a' && c <= 'z').count();\n        if cap_len < sm_len {\n            let\
    \ mut cur_len = 0;\n            let mut cur_char = e[cur_len..].to_lowercase();\n\
    \            for c in e.chars() {\n                cur_len = cur_len + c.len_of();\n\
    \                cur_char = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count()\
    \ as String;\n            }\n            best_extensions.insert(cur_len + sm_len,\
    \ e.clone());\n        }\n    }\n\n    if best_extensions.len() > 0 {\n      \
    \  let mut cur_len = 0;\n        let mut cur_char = class_name.to_lowercase();\n\
    \        for c in class_name.chars() {\n            cur_len = cur_len + c.len_of();\n\
    \            cur_char = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count()\
    \ as String;\n        }\n        best_extensions.sort().nth(best_extensions.len()).unwrap()\n\
    \    } else {\n        class_name\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len_of` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptn3u8vjs.rs:26:39\n   |\n26 |                 cur_len =\
    \ cur_len + c.len_of();\n   |                                       ^^^^^^ help:\
    \ there is an associated function with a similar name: `len_utf8`\n\nerror[E0599]:\
    \ no method named `len_of` found for type `char` in the current scope\n  --> /tmp/tmptn3u8vjs.rs:37:35\n\
    \   |\n37 |             cur_len = cur_len + c.len_of();\n   |                \
    \                   ^^^^^^ help: there is an associated function with a similar\
    \ name: `len_utf8`\n\nerror[E0599]: no method named `nth` found for unit type\
    \ `()` in the current scope\n  --> /tmp/tmptn3u8vjs.rs:40:32\n   |\n40 |     \
    \    best_extensions.sort().nth(best_extensions.len()).unwrap()\n   |        \
    \                        ^^^ method not found in `()`\n\nerror[E0605]: non-primitive\
    \ cast: `usize` as `String`\n  --> /tmp/tmptn3u8vjs.rs:27:28\n   |\n27 |     \
    \            cur_char = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count()\
    \ as String;\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `usize`\
    \ as `String`\n  --> /tmp/tmptn3u8vjs.rs:38:24\n   |\n38 |             cur_char\
    \ = cur_char.chars().filter(|&c| c >= 'a' && c <= 'z').count() as String;\n  \
    \ |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min_strength = -1;\n    for\
    \ extension in extensions {\n        let (class_name, extension) = extension.split_terminator('.');\n\
    \        let class_name = class_name.trim_left_matches('_');\n        let class_name\
    \ = class_name.to_lowercase();\n        let class_name = class_name.to_uppercase();\n\
    \        let class_name = &class_name + \"_\";\n        let class_name = class_name.to_string();\n\
    \        if class_name != class_name.chars().map(|c| *c).collect::<String>() {\n\
    \            continue;\n        }\n        let strength = extension.chars().filter(|c|\
    \ *c == c).count();\n        let strength = strength.to_f64().unwrap_or(0.0);\n\
    \        if strength < min_strength {\n            min_strength = strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, min_strength.ceil() as String)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv1shre2t.rs:19:13\n   |\n\
    19 |         let (class_name, extension) = extension.split_terminator('.');\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^   ------------------------------- this\
    \ expression has type `SplitTerminator<'_, char>`\n   |             |\n   |  \
    \           expected struct `SplitTerminator`, found tuple\n   |\n   = note: expected\
    \ struct `SplitTerminator<'_, char>`\n               found tuple `(_, _)`\n\n\
    error[E0277]: cannot add `&str` to `&_`\n  --> /tmp/tmpv1shre2t.rs:23:38\n   |\n\
    23 |         let class_name = &class_name + \"_\";\n   |                     \
    \                 ^ no implementation for `&_ + &str`\n   |\n   = help: the trait\
    \ `Add<&str>` is not implemented for `&_`\n\nerror[E0689]: can't call method `ceil`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpv1shre2t.rs:34:47\n   |\n\
    34 |     format!(\"{}.{}\", class_name, min_strength.ceil() as String)\n   | \
    \                                              ^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n17 |     let mut min_strength: i32\
    \ = -1;\n   |         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0689.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions\n        .iter()\n    \
    \    .fold(String::new(), |mut acc, e| acc.push_str(&format!(\"{}.{}\", class_name,\
    \ e)))\n        .chars()\n        .fold(String::new(), |mut acc, c| acc.push_str(c.to_ascii_lowercase()))\n\
    \        .chars()\n        .fold(String::new(), |mut acc, c| acc.push_str(c.to_ascii_uppercase()))\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_929bzgo.rs:19:43\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n...\n19 |         .fold(String::new(),\
    \ |mut acc, e| acc.push_str(&format!(\"{}.{}\", class_name, e)))\n   |       \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp_929bzgo.rs:19:47\n   |\n19 |         .fold(String::new(),\
    \ |mut acc, e| acc.push_str(&format!(\"{}.{}\", class_name, e)))\n   |       \
    \                                    --- ^^^^^^^^ this call modifies `acc` in-place\n\
    \   |                                           |\n   |                      \
    \                     you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_929bzgo.rs:21:56\n   |\n21 |         .fold(String::new(),\
    \ |mut acc, c| acc.push_str(c.to_ascii_lowercase()))\n   |                   \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_929bzgo.rs:21:43\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n...\n21 |    \
    \     .fold(String::new(), |mut acc, c| acc.push_str(c.to_ascii_lowercase()))\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp_929bzgo.rs:21:47\n   |\n21 |         .fold(String::new(),\
    \ |mut acc, c| acc.push_str(c.to_ascii_lowercase()))\n   |                   \
    \                        --- ^^^^^^^^ this call modifies `acc` in-place\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.len() == 0 {\n     \
    \   return class_name;\n    }\n    let mut min_extensions: Vec<String> = Vec::new();\n\
    \    for (i, &ext) in extensions.iter().enumerate() {\n        if ext.chars().count()\
    \ == 0 {\n            continue;\n        }\n        if ext.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() < ext.chars().filter(|&c| *c >= 'a' && *c <=\
    \ 'z').count() {\n            continue;\n        }\n        let num = ext.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() + ext.chars().filter(|&c| *c >= 'a' && *c <=\
    \ 'z').count();\n        let cap = ext.chars().filter(|&c| *c == *c.upcase()).count();\n\
    \        let sm = ext.chars().filter(|&c| *c == *c.downcase()).count();\n    \
    \    let strength = (num - cap - sm) as i32 / num;\n        min_extensions.push((ext.to_string(),\
    \ strength));\n    }\n    min_extensions.sort_by_key(|&(key, _)| key.1);\n   \
    \ min_extensions.iter().next().unwrap().0\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp73pvghge.rs:25:36\n\
    \   |\n25 |         if ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count()\
    \ < ext.chars().filter(|&c| *c >= 'a' && *c <= 'z').count() {\n   |          \
    \                          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp73pvghge.rs:25:49\n   |\n25 |         if ext.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() < ext.chars().filter(|&c| *c >= 'a' && *c <=\
    \ 'z').count() {\n   |                                                 ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp73pvghge.rs:25:94\n\
    \   |\n25 |         if ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count()\
    \ < ext.chars().filter(|&c| *c >= 'a' && *c <= 'z').count() {\n   |          \
    \                                                                            \
    \        ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp73pvghge.rs:25:107\n\
    \   |\n25 |         if ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count()\
    \ < ext.chars().filter(|&c| *c >= 'a' && *c <= 'z').count() {\n   |          \
    \                                                                            \
    \                     ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp73pvghge.rs:28:43\n   |\n28 |         let num = ext.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() + ext.chars().filter(|&c| *c >= 'a' && *c <=\
    \ 'z').count();\n   |                                           ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp73pvghge.rs:28:56\n   |\n\
    28 |         let num = ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count()\
    \ + ext.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n   |           \
    \                                             ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp73pvghge.rs:28:101\n   |\n28 |       \
    \  let num = ext.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count() + ext.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').count();\n   |                                     \
    \                            "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut strength:\
    \ i32 = -1;\n    let mut best_extension = String::new();\n    for (i, extension)\
    \ in extensions.iter().enumerate() {\n        let extension = extension.trim_right_matches('A'..'Z').to_lowercase();\n\
    \        if i > 0 && extension <= best_extension {\n            continue;\n  \
    \      }\n        let c: i32 = (class_name.len()-extension.len()) as i32 / 2;\n\
    \        if strength < c {\n            strength = c;\n            best_extension\
    \ = extension;\n        }\n    }\n    class_name\n        + String::from(best_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmp_8c8s74o.rs:21:35\n   |\n21\
    \ |         let extension = extension.trim_right_matches('A'..'Z').to_lowercase();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^ help: replace the use\
    \ of the deprecated associated function: `trim_end_matches`\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `std::ops::Range<char>`\n  --> /tmp/tmp_8c8s74o.rs:21:54\n  \
    \ |\n21 |         let extension = extension.trim_right_matches('A'..'Z').to_lowercase();\n\
    \   |                                   ------------------ ^^^^^^^^ expected an\
    \ `FnMut<(char,)>` closure, found `std::ops::Range<char>`\n   |              \
    \                     |\n   |                                   required by a\
    \ bound introduced by this call\n   |\n   = help: the trait `FnMut<(char,)>` is\
    \ not implemented for `std::ops::Range<char>`\n   = help: the following other\
    \ types implement trait `Pattern<'a>`:\n             &'b String\n            \
    \ &'b [char; N]\n             &'b [char]\n             &'b str\n             &'c\
    \ &'b str\n             [char; N]\n             char\n             pattern::MultiCharEqPattern<C>\n\
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_8c8s74o.rs:32:11\n\
    \   |\n32 |         + String::from(best_extension)\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected `&str`, found struct `String`\n   |\
    \           help: consider borrowing here: `&String::from(best_extension)`\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n  extensions_count => {\n    let mut strongest_extension\
    \ = &class_name[..class_name.length()];\n    for i in 0..extensions_count {\n\
    \      strongest_extension = &class_name[..strongest_extension.len() - extensions[i].len()];\n\
    \      if extensions[i].chars().filter(|&c| c.is_uppercase() == true).count()\
    \ > 0 {\n        break;\n      }\n      if extensions[i].chars().filter(|&c| c.is_lowercase()\
    \ == true).count() > 0 {\n        break;\n      }\n    }\n    strongest_extension\n\
    \  }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpgulo0iop.rs:17:20\n   |\n17 |   extensions_count =>\
    \ {\n   |                    ^^ expected one of 8 possible tokens\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_sorted = extensions.clone();\n\
    \    extensions_sorted.sort();\n    let mut strongest_extension: String = String::from(\"\
    \");\n    let mut strength: i32 = 0;\n    for extension in extensions_sorted {\n\
    \        let cap: usize = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let sm: usize = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        if strength > 0 {\n            if strongest_extension.is_empty()\
    \ {\n                strongest_extension = class_name + \".\" + extension;\n \
    \           } else {\n                if strength > strength {\n             \
    \       strongest_extension = class_name + \".\" + extension;\n              \
    \      strength = strength;\n                }\n            }\n        }\n   \
    \ }\n    return strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjtga_yt6.rs:22:60\n   |\n\
    22 |         let cap: usize = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                            ^^^\n   |   \
    \                                                         |\n   |            \
    \                                                expected `&char`, found `char`\n\
    \   |                                                            help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjtga_yt6.rs:22:72\n\
    \   |\n22 |         let cap: usize = extension.chars().filter(|c| c >= 'A' &&\
    \ c <= 'Z').count();\n   |                                                   \
    \                     ^^^\n   |                                              \
    \                          |\n   |                                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                                             help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjtga_yt6.rs:23:59\n\
    \   |\n23 |         let sm: usize = extension.chars().filter(|c| c >= 'a' && c\
    \ <= 'z').count();\n   |                                                     \
    \      ^^^\n   |                                                           |\n\
    \   |                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \  help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpjtga_yt6.rs:23:71\n   |\n23 |         let sm: usize = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \                                ^^^\n   |                                   \
    \                                    |\n   |                                 \
    \                                      expected `&char`, found `char`\n   |  \
    \                                                                     help: consider\
    \ borrowing here: `&'z'`\n\ner"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = 0u8;\n    let mut\
    \ found: usize = 0;\n\n    for e in extensions {\n        if e == class_name {\n\
    \            return format!(\"{}.{}\", class_name, extensions[found]);\n     \
    \   }\n\n        if e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() == 1\
    \ {\n            let c = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \            strength += c as u8;\n            found += 1;\n        }\n    }\n\
    \n    format!(\"{}.{}\", class_name, extensions[found])\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: variable `strength` is assigned to, but never used\n  --> /tmp/tmp7h7m_l70.rs:17:13\n\
    \   |\n17 |     let mut strength = 0u8;\n   |             ^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_strength`\
    \ instead\n\nerror[E0382]: borrow of moved value: `extensions`\n   --> /tmp/tmp7h7m_l70.rs:22:49\n\
    \    |\n16  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                            ---------- move\
    \ occurs because `extensions` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for e in extensions {\n    |              ----------\
    \ `extensions` moved due to this implicit call to `.into_iter()`\n21  |      \
    \   if e == class_name {\n22  |             return format!(\"{}.{}\", class_name,\
    \ extensions[found]);\n    |                                                 ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `extensions`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n20  |     for e in &extensions {\n    |              +\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().any(|x| !x.is_empty())\
    \ {\n        extensions.iter().filter(|x| !x.is_empty()).sort_by_key(|x| x.chars().count()).next().unwrap()\n\
    \    } else {\n        class_name\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpvaayvzqf.rs:18:53\n   |\n18 |         extensions.iter().filter(|x|\
    \ !x.is_empty()).sort_by_key(|x| x.chars().count()).next().unwrap()\n   |    \
    \                                                 ^^^^^^^^^^^ method not found\
    \ in `Filter<std::slice::Iter<'_, String>, [closure@/tmp/tmpvaayvzqf.rs:18:34:\
    \ 18:51]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions\n        .iter()\n    \
    \    .fold(String::new(), |acc: &String, ext: &str| {\n            let first_char\
    \ = ext.chars().next().unwrap();\n            acc.to_string()\n              \
    \  .split_last_mut()\n                .filter(|c| c != first_char)\n         \
    \       .collect::<Vec<_>>()\n                .sort_by(|a, b| b.cmp(a)).first()\n\
    \                .to_string()\n        })\n        .to_string() + String::from(class_name)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp13lqx55p.rs:22:18\n   |\n22 |          \
    \       .split_last_mut()\n   |                  ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_at`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp13lqx55p.rs:28:24\n   |\n28 |         .to_string() + String::from(class_name)\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                  \
    \      |\n   |                        expected `&str`, found struct `String`\n\
    \   |                        help: consider borrowing here: `&String::from(class_name)`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut classes: Vec<(String, usize)>\
    \ = extensions.iter().cloned().map(\n        |x| {\n            let mut split\
    \ = x.splitn(2, |&x| x.is_ascii_uppercase());\n            (split[0].to_lowercase(),\
    \ split[1] as usize)\n        }\n    ).collect();\n    classes.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n    let mut strength = -1;\n    let mut class = \"\";\n   \
    \ for (class_name, class_count) in classes {\n        if class_name.starts_with(class_name.to_lowercase())\
    \ {\n            let mut class_extensions = class_name.split(&class_name[0]).last().unwrap().splitn(2,\
    \ |&x| x.is_ascii_uppercase());\n            if strength < class_extensions[0].to_lowercase().len_utf8()\
    \ {\n                class = class_name.to_lowercase();\n                strength\
    \ = class_extensions[0].to_lowercase().len_utf8();\n            }\n        }\n\
    \    }\n    class.to_string().to_string().as_bytes().to_vec().to_string()\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmphsoab2vp.rs:19:42\n\
    \   |\n19 |             let mut split = x.splitn(2, |&x| x.is_ascii_uppercase());\n\
    \   |                                          ^^ consider giving this closure\
    \ parameter the explicit type `&_`, with the type parameters specified\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0608]: cannot index into\
    \ a value of type `std::str::SplitN<'_, _>`\n  --> /tmp/tmphsoab2vp.rs:20:14\n\
    \   |\n20 |             (split[0].to_lowercase(), split[1] as usize)\n   |   \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `std::str::SplitN<'_,\
    \ _>`\n  --> /tmp/tmphsoab2vp.rs:20:39\n   |\n20 |             (split[0].to_lowercase(),\
    \ split[1] as usize)\n   |                                       ^^^^^^^^\n\n\
    error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmphsoab2vp.rs:27:35\n\
    \     |\n27   |         if class_name.starts_with(class_name.to_lowercase()) {\n\
    \     |                       ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected an\
    \ implementor of trait `Pattern<'_>`\n     |                       |\n     | \
    \                      required by a bound introduced by this call\n     |\n \
    \    = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n27   |         if class_name.starts_with(&class_name.to_lowercase())\
    \ {\n     |                                   +\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmphsoab2vp.rs:28:58\n   |\n28\
    \ |             let mut class_extensions = class_name.split(&class_name[0]).last().unwrap().splitn(2,\
    \ |&x| x.is_ascii_uppercase());\n   |                                        \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `I"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().filter(|&e| e.is_ascii()).count()\
    \ > 2 || extensions.iter().filter(|&e| e.is_lowercase()).count() > 2 {\n     \
    \   panic!(\"More than two extensions given to Strongest_Extension!\");\n    }\n\
    \n    let mut extensions_map = Vec::new();\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        if e.is_ascii() {\n            extensions_map.push(e.to_ascii_lowercase());\n\
    \        } else {\n            extensions_map.push(e.to_lowercase());\n      \
    \  }\n    }\n    let mut extensions_sorted = extensions_map.iter().sorted();\n\
    \    let mut max_strength = -1;\n    let mut max_extension = \"\";\n    for extension\
    \ in extensions_sorted {\n        if extensions_map.len() > 0 {\n            let\
    \ (class_str, _) = extension.splitn(2, \".\");\n            let mut class_map\
    \ = vec![class_name.to_string()];\n            let mut class_extension = extension;\n\
    \            if i < extensions_map.len() - 1 {\n                let (class_str,\
    \ _) = extensions_sorted[i + 1].splitn(2, \".\");\n                let mut class_map\
    \ = vec![class_name.to_string()];\n                let mut class_extension = extensions_sorted[i\
    \ + 1];\n            }\n            let class_id = class_map.iter().position(|&v|\
    \ v == class_str).unwrap();\n            let extension_id = extensions_map.iter().position(|&v|\
    \ v == extension).unwrap();\n            let strength = extension_id - class_id;\n\
    \            if strength > max_strength {\n                max_strength = strength;\n\
    \                max_extension = class_extension.to_string();\n            }\n\
    \        }\n    }\n    return max_extension.to_string();\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpqdl740e_.rs:37:16\n\
    \   |\n37 |             if i < extensions_map.len() - 1 {\n   |              \
    \  ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmpqdl740e_.rs:38:56\n   |\n38 |                 let (class_str, _)\
    \ = extensions_sorted[i + 1].splitn(2, \".\");\n   |                         \
    \                               ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `i` in this scope\n  --> /tmp/tmpqdl740e_.rs:40:61\n   |\n40 |  \
    \               let mut class_extension = extensions_sorted[i + 1];\n   |    \
    \                                                         ^ not found in this\
    \ scope\n\nerror[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpqdl740e_.rs:17:99\n   |\n17 |     if extensions.iter().filter(|&e|\
    \ e.is_ascii()).count() > 2 || extensions.iter().filter(|&e| e.is_lowercase()).count()\
    \ > 2 {\n   |                                                                \
    \                                   ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `sorted` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpqdl740e_.rs:29:55\n\
    \   |\n29 |     let mut extensions_sorted = extensions_map.iter().sorted();\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `std::slice::Iter<'_, String>`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpqdl740e_.rs:30:28\n   |\n30 |     let mut\
    \ max_strength = -1;\n   |                            ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor\
    \ more information ab"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_extension_strength = -1;\n\
    \n    for extension in extensions {\n        let cap = extension.chars().filter(|&c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|&c| c.is_lowercase()).count();\n\
    \n        let strength = if cap > sm {\n            cap - sm\n        } else {\n\
    \            sm - cap\n        };\n\n        if strength > max_extension_strength\
    \ {\n            max_extension_strength = strength;\n        }\n    }\n\n    format!(\"\
    {}.{}\", class_name, max_extension_strength)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpw3a7tbly.rs:17:38\n\
    \   |\n17 |     let mut max_extension_strength = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class_name = String::from(class_name);\n\
    \    class_name = &class_name[0..class_name.length() as usize];\n    let mut strength_counter\
    \ = vec![];\n    for &x in extensions {\n        let mut y = String::from(x);\n\
    \        y = &y[0..y.len() as usize];\n        strength_counter.push(y.len() as\
    \ u8);\n    }\n    strength_counter.sort_unstable_by(|x, y| x.cmp(y));\n    let\
    \ mut extension_str = \"\".to_string();\n    let mut current_strength = 0;\n \
    \   for &s in strength_counter {\n        if s == 1 {\n            extension_str.append(&class_name[0..current_strength]);\n\
    \            current_strength += 1;\n        }\n    }\n    extension_str.append(&class_name[0..current_strength]);\n\
    \    extension_str\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpywlyyj4t.rs:18:44\n   |\n18 |     class_name =\
    \ &class_name[0..class_name.length() as usize];\n   |                        \
    \                    ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpywlyyj4t.rs:18:18\n\
    \   |\n17 |     let mut class_name = String::from(class_name);\n   |         \
    \                 ------------------------ expected due to this value\n18 |  \
    \   class_name = &class_name[0..class_name.length() as usize];\n   |         \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n18 |     class_name\
    \ = (&class_name[0..class_name.length() as usize]).to_string();\n   |        \
    \          +                                            +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpywlyyj4t.rs:20:9\n   |\n20 |     for &x in extensions\
    \ {\n   |         ^^    ---------- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `x`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpywlyyj4t.rs:22:13\n   |\n21 |         let mut y = String::from(x);\n\
    \   |                     --------------- expected due to this value\n22 |   \
    \      y = &y[0..y.len() as usize];\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |         y = (&y[0..y.len() as usize]).to_string();\n   |         \
    \    +                       +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpywlyyj4t.rs:28:9\n   |\n28 |     for &s in strength_counter {\n\
    \   |         ^^    ---------------- this expression has type `Option<u8>`\n \
    \  |         |\n   |         expected `u8`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `s`"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n\tlet mut extensions_count = extensions_count(extensions);\n\
    \textensions_count += 1;\n\t\n\tlet mut extension_count = extensions_count(extensions);\n\
    \textension_count -= 1;\n\t\n\tif extension_count > extensions_count {\n\t\treturn\
    \ format!(\"{}.{}\", class_name, extensions[0]);\n\t}\n\t\n\tlet mut strength\
    \ = -1;\n\tlet mut index = 0;\n\tlet mut current_strength = 0;\n\t\n\tloop {\n\
    \t\tif current_strength == 0 {\n\t\t\treturn format!(\"{}.{}\", class_name, extensions[index]);\n\
    \t\t}\n\t\t\n\t\tlet cap = index / 2;\n\t\tlet sm = index - cap;\n\t\t\n\t\tcurrent_strength\
    \ = extension_count / cap - extension_count / sm;\n\t\t\n\t\tif current_strength\
    \ > strength {\n\t\t\tstrength = current_strength;\n\t\t}\n\t\t\n\t\tindex = index\
    \ + 1;\n\t}\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `extensions_count` in this scope\n \
    \ --> /tmp/tmpl49mha15.rs:17:29\n   |\n17 |     let mut extensions_count = extensions_count(extensions);\n\
    \   |                                ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut num_upper = String::new();\n\
    \    let mut num_lower = String::new();\n    let mut num = 0;\n\n    for extension\
    \ in extensions {\n        let mut temp_str = extension.to_string();\n       \
    \ let mut temp_str = temp_str.chars();\n        while let Some(c) = temp_str.next()\
    \ {\n            match c {\n                'A'..='Z' => num_upper.push_str(c.to_string()),\n\
    \                'a'..='z' => num_upper.push_str(c.to_string()),\n           \
    \     '0'..='9' => num_upper.push_str(c.to_string()),\n                c => num_upper.push_str(c.to_string()),\n\
    \            }\n        }\n        temp_str = temp_str.collect::<String>();\n\
    \        temp_str = temp_str.chars();\n        while let Some(c) = temp_str.next()\
    \ {\n            match c {\n                'a'..='z' => num_lower.push_str(c.to_string()),\n\
    \                '0'..='9' => num_lower.push_str(c.to_string()),\n           \
    \     c => num_lower.push_str(c.to_string()),\n            }\n        }\n    \
    \    temp_str = temp_str.collect::<String>();\n        temp_str = temp_str.chars();\n\
    \        num = num_upper.chars().filter(|c| *c != c).count() + num_lower.chars().filter(|c|\
    \ *c != c).count();\n        num_upper = num_upper.to_string();\n        num_lower\
    \ = num_lower.to_string();\n    }\n\n    if num == 0 {\n        String::from(class_name.to_string())\n\
    \    } else {\n        let mut num_upper = num_upper.chars().filter(|c| *c !=\
    \ c).count();\n        num_upper = String::from(format!(\"{}.{}\", class_name.to_string(),\
    \ num_upper.to_string()))\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmyid3h5o.rs:26:49\n   |\n\
    26 |                 'A'..='Z' => num_upper.push_str(c.to_string()),\n   |   \
    \                                              ^^^^^^^^^^^^^\n   |           \
    \                                      |\n   |                               \
    \                  expected `&str`, found struct `String`\n   |              \
    \                                   help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmyid3h5o.rs:27:49\n   |\n27 |\
    \                 'a'..='z' => num_upper.push_str(c.to_string()),\n   |      \
    \                                           ^^^^^^^^^^^^^\n   |              \
    \                                   |\n   |                                  \
    \               expected `&str`, found struct `String`\n   |                 \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmyid3h5o.rs:28:49\n   |\n28 |\
    \                 '0'..='9' => num_upper.push_str(c.to_string()),\n   |      \
    \                                           ^^^^^^^^^^^^^\n   |              \
    \                                   |\n   |                                  \
    \               expected `&str`, found struct `String`\n   |                 \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmyid3h5o.rs:29:41\n   |\n29 |\
    \                 c => num_upper.push_str(c.to_string()),\n   |              \
    \                           ^^^^^^^^^^^^^\n   |                              \
    \           |\n   |                                         expected `&str`, found\
    \ struct `String`\n   |                                         help: consider\
    \ borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyid3h5o.rs:32:20\n\
    \   |\n23 |         let mut temp_str = temp_str.chars();\n   |               \
    \             ---------------- expected due to this value\n...\n32 |         temp_str\
    \ = temp_str.collect::<String>();\n   |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength = String::new();\n\
    \    for extension in extensions.iter() {\n        let c = extension.chars().filter(|x|x.is_uppercase()).count();\n\
    \        let s = extension.chars().filter(|x|x.is_lowercase()).count();\n    \
    \    let diff = c.saturating_sub(s).unwrap_or(0);\n        if diff > 0 {\n   \
    \         strength.push_str(extension);\n        }\n    }\n    match strength.chars().count()\
    \ {\n        0 => class_name.to_string(),\n        _ => class_name.to_string().to_string()\
    \ + &format!(\"{}.{}\", strength, &extensions[0]),\n    }\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmppvoen1g0.rs:21:40\n   |\n21 |         let diff\
    \ = c.saturating_sub(s).unwrap_or(0);\n   |                                  \
    \      ^^^^^^^^^ method not found in `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extensions = Vec::new();\n\
    \n    for extension in extensions {\n        let (c_name, extension_name) = extension.split('.');\n\
    \        let cap_n = c_name.chars().filter(|c| c.is_uppercase()).count();\n  \
    \      let sm_n = c_name.chars().filter(|c| c.is_lowercase()).count();\n     \
    \   let strength = cap_n.checked_sub(sm_n).unwrap().to_string();\n        strongest_extensions.push((&c_name,\
    \ &extension_name, strength));\n    }\n\n    match strongest_extensions.iter().min_by_key(|(_,\
    \ _, strength)| strength) {\n        Some((c, _, _)) => &class_name + c.to_uppercase()\
    \ + &\"_\".to_lowercase() + &strongest_extensions.iter().filter(|(_, _, strength)|\
    \ strength == 0).min_by_key(|(_, _, strength)| strength).unwrap().0,\n       \
    \ None => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ddmdktq.rs:20:13\n   |\n\
    20 |         let (c_name, extension_name) = extension.split('.');\n   |      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^   -------------------- this expression has type\
    \ `std::str::Split<'_, char>`\n   |             |\n   |             expected struct\
    \ `std::str::Split`, found tuple\n   |\n   = note: expected struct `std::str::Split<'_,\
    \ char>`\n               found tuple `(_, _)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq1iexyh5.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut max_strength = -1i32;\n  \
    \  let mut max_extension = String::new();\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c == 'A' || c == 'B' || c == 'C').count();\n\
    \        let sm = extension.chars().filter(|c| c == 'a' || c == 'b' || c == 'c').count();\n\
    \        let strength = cap - sm;\n        if strength > max_strength {\n    \
    \        max_strength = strength;\n            max_extension = extension;\n  \
    \      }\n    }\n    class_name.concat(\".\").concat(max_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbs53h9c_.rs:20:50\n\
    \   |\n20 |         let cap = extension.chars().filter(|c| c == 'A' || c == 'B'\
    \ || c == 'C').count();\n   |                                                \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbs53h9c_.rs:20:62\n\
    \   |\n20 |         let cap = extension.chars().filter(|c| c == 'A' || c == 'B'\
    \ || c == 'C').count();\n   |                                                \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpbs53h9c_.rs:20:74\n   |\n20 |         let cap = extension.chars().filter(|c|\
    \ c == 'A' || c == 'B' || c == 'C').count();\n   |                           \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpbs53h9c_.rs:21:49\n   |\n21\
    \ |         let sm = extension.chars().filter(|c| c == 'a' || c == 'b' || c ==\
    \ 'c').count();\n   |                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbs53h9c_.rs:21:61\n\
    \   |\n21 |         let sm = extension.chars().filter(|c| c == 'a' || c == 'b'\
    \ || c == 'c').count();\n   |                                                \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extension_strongest: String\
    \ = &class_name;\n    let mut extension_strength: i64 = 1;\n    for extension\
    \ in extensions {\n        let mut temp_extension_strongest: String = extension;\n\
    \        let mut temp_extension_strength: i64 = 1;\n        for c in temp_extension_strongest\
    \ {\n            if c >= 'A' && c <= 'Z' {\n                temp_extension_strength\
    \ *= 10;\n                temp_extension_strength += c - 'A' + 1;\n          \
    \  } else {\n                temp_extension_strength *= 10;\n                temp_extension_strength\
    \ += c - 'a' + 1;\n            }\n        }\n        if temp_extension_strength\
    \ > extension_strength {\n            extension_strongest = temp_extension_strongest;\n\
    \            extension_strength = temp_extension_strength;\n        }\n    }\n\
    \    extension_strongest.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4rjn89x9.rs:17:43\n   |\n\
    17 |     let mut extension_strongest: String = &class_name;\n   |            \
    \                      ------   ^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |                                  |\n   |                               \
    \   expected due to this\n   |\nhelp: consider removing the borrow\n   |\n17 -\
    \     let mut extension_strongest: String = &class_name;\n17 +     let mut extension_strongest:\
    \ String = class_name;\n   | \n\nerror[E0277]: `String` is not an iterator\n \
    \ --> /tmp/tmp4rjn89x9.rs:22:18\n   |\n22 |         for c in temp_extension_strongest\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.iter().filter(|&x| x.chars().any(|x|\
    \ *x == x))\n        .count() > 1\n    {\n        let mut min_strength: i32 =\
    \ i32::MAX;\n        let mut min_extension: Vec<&str> = Vec::new();\n        for\
    \ extension in &extensions {\n            let cap = extension.chars().filter(|x|\
    \ *x == x).count();\n            let sm = extension.chars().filter(|x| *x != x).count();\n\
    \            let strength = cap - sm;\n            if strength < min_strength\
    \ {\n                min_strength = strength;\n                min_extension =\
    \ vec![&extension];\n            }\n            else {\n                if strength\
    \ == min_strength {\n                    min_extension.push(&extension);\n   \
    \             }\n            }\n        }\n        // Find the one that comes\
    \ first in the list.\n        let mut min_extension = min_extension\n        \
    \    .iter()\n            .cloned()\n            .enumerate()\n            .min_by_key(|i,\
    \ &x| {\n                if *i == 0 {\n                    1\n               \
    \ } else {\n                    *i\n                }\n            });\n     \
    \   let mut strongest_extension = String::new();\n        for (i, extension) in\
    \ min_extension {\n            if i == 0 {\n                strongest_extension.push_str(&extension);\n\
    \            }\n            else {\n                strongest_extension.push_str(&class_name).push_str(&extension);\n\
    \            }\n        }\n        strongest_extension.clone().to_string()\n \
    \   }\n    else {\n        let mut min_strength: i32 = i32::MAX;\n        let\
    \ mut min_extension: Vec<&str> = Vec::new();\n        for extension in &extensions\
    \ {\n            let cap = extension.chars().filter(|x| *x == x).count();\n  \
    \          let sm = extension.chars().filter(|x| *x != x).count();\n         \
    \   let strength = cap - sm;\n            if strength < min_strength {\n     \
    \           min_strength = strength;\n                min_extension = vec![&extension];\n\
    \            }\n            else {\n                if strength == min_strength\
    \ {\n                    min_extension.push(&extension);\n                }\n\
    \            }\n        }\n        let mut min_extension = min_extension\n   \
    \         .iter()\n            .cloned()\n            .enumerate()\n         \
    \   .min_by_key(|i, &x| {\n                if *i == 0 {\n                    1\n\
    \                } else {\n                    *i\n                }\n       \
    \     });\n        let mut strongest_extension = String::new();\n        for (i,\
    \ extension) in min_extension {\n            if i == 0 {\n                strongest_extension.push_str(&extension);\n\
    \            }\n\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwj9fylob.rs:106:3\n\
    \    |\n16  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n59  |     else {\n    |    \
    \      - unclosed delimiter\n...\n88  |         for (i, extension) in min_extension\
    \ {\n    |                                             - this delimiter might\
    \ not be properly closed...\n...\n93  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n106 | }\n    |   ^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpwj9fylob.rs:17:56\n   |\n17 |     if extensions.iter().filter(|&x|\
    \ x.chars().any(|x| *x == x))\n   |                                          \
    \              ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwj9fylob.rs:23:58\n\
    \   |\n23 |             let cap = extension.chars().filter(|x| *x == x).count();\n\
    \   |                                                          ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |   \
    \          let cap = extension.chars().filter(|x| *x == *x).count();\n   |   \
    \                                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwj9fylob.rs:24:57\n   |\n24 |             let sm = extension.chars().filter(|x|\
    \ *x != x).count();\n   |                                                    \
    \     ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n24 |             let sm = extension.chars().filter(|x| *x != *x).count();\n\
    \   |                                                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwj9fylob.rs:26:27\n   |\n26 |             if\
    \ strength < min_strength {\n   |                           ^^^^^^^^^^^^ expected\
    \ `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and\
    \ panic if the converted value doesn't fit\n   |\n26 |             if strength\
    \ < min_strength.try_into().unwrap() {\n   |                                 "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions = extensions\n\
    \        .iter()\n        .filter_map(|e| e.to_lowercase())\n        .collect::<Vec<String>>();\n\
    \    let mut class_name = class_name.to_lowercase();\n\n    let mut num: i64 =\
    \ 0;\n    let mut prev_num: i64 = 0;\n    let mut cur_max: i64 = extensions[0].to_lowercase().chars().count()\
    \ - 1;\n    let mut best_name = \"\";\n    for e in extensions {\n        let\
    \ c = e.to_lowercase().chars().count();\n        if c < cur_max {\n          \
    \  return format!(\"{}\", class_name.to_lowercase());\n        }\n        num\
    \ += c - cur_max;\n        prev_num = cur_max;\n        cur_max = c;\n       \
    \ if num > best_name.chars().count() {\n            best_name = format!(\"{}.{}\"\
    , class_name, e);\n        }\n    }\n    format!(\"{}.{}\", class_name, best_name);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6unkvp3.rs:19:25\n   |\n\
    19 |         .filter_map(|e| e.to_lowercase())\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<_>`\n            found struct `String`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n19 |         .filter_map(|e| Some(e.to_lowercase()))\n   |\
    \                         +++++                +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd6unkvp3.rs:25:28\n   |\n25 |     let mut cur_max: i64 = extensions[0].to_lowercase().chars().count()\
    \ - 1;\n   |                      ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i64`, found `usize`\n   |                      |\n   |           \
    \           expected due to this\n   |\nhelp: you can convert a `usize` to an\
    \ `i64` and panic if the converted value doesn't fit\n   |\n25 |     let mut cur_max:\
    \ i64 = (extensions[0].to_lowercase().chars().count() - 1).try_into().unwrap();\n\
    \   |                            +                                           \
    \     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6unkvp3.rs:29:16\n\
    \   |\n29 |         if c < cur_max {\n   |                ^^^^^^^ expected `usize`,\
    \ found `i64`\n   |\nhelp: you can convert an `i64` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n29 |         if c < cur_max.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd6unkvp3.rs:32:20\n   |\n32 |         num += c - cur_max;\n\
    \   |                    ^^^^^^^ expected `usize`, found `i64`\n\nerror[E0277]:\
    \ cannot subtract `i64` from `usize`\n  --> /tmp/tmpd6unkvp3.rs:32:18\n   |\n\
    32 |         num += c - cur_max;\n   |                  ^ no implementation for\
    \ `usize - i64`\n   |\n   = help: the trait `Sub<i64>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut current_strength = -1;\n\n\
    \    for &extension in extensions.iter() {\n        let strength = extension.chars().filter(|c|\
    \ c.is_uppercase()).count() as usize\n             - extension.chars().filter(|c|\
    \ c.is_lowercase()).count() as usize;\n        if strength > current_strength\
    \ {\n            current_strength = strength;\n        }\n    }\n\n    if current_strength\
    \ > 0 {\n        format!(\"{}.{}\", class_name, extensions[extensions.iter().filter(|e|\
    \ e.chars().count() == current_strength).next()].to_uppercase())\n    } else {\n\
    \        format!(\"{}\", class_name)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpx524a66c.rs:17:32\n\
    \   |\n17 |     let mut current_strength = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the type `[String]` cannot be indexed by `Option<&String>`\n  -->\
    \ /tmp/tmpx524a66c.rs:28:38\n   |\n28 |         format!(\"{}.{}\", class_name,\
    \ extensions[extensions.iter().filter(|e| e.chars().count() == current_strength).next()].to_uppercase())\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `Option<&String>`\n   =\
    \ note: required because of the requirements on the impl of `Index<Option<&String>>`\
    \ for `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut counter:\
    \ usize = 0;\n    for &e in extensions {\n        counter += e.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n    }\n\n    if counter > 0 {\n        let\
    \ cap = class_name.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n     \
    \   let sm = class_name.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n\
    \        let strength = (cap - sm) as usize;\n        let mut pos = 0;\n     \
    \   let mut max_pos = 0;\n        for &e in extensions {\n            pos += e.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n            if pos > strength {\n        \
    \        max_pos = pos;\n            }\n        }\n\n        let mut max_extension\
    \ = &class_name[..max_pos];\n        for &e in extensions {\n            if *e\
    \ >= max_extension {\n                let mut pos = 0;\n                let mut\
    \ max_pos = 0;\n                for &e in extensions {\n                    pos\
    \ += e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n                 \
    \   if pos > strength {\n                        max_pos = pos;\n            \
    \        }\n                }\n                max_extension = &class_name[..max_pos];\n\
    \            }\n        }\n        return class_name + &max_extension;\n    }\
    \ else {\n        return class_name;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzzwr7gd.rs:19:9\n   |\n\
    19 |     for &e in extensions {\n   |         ^^    ---------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `e`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmzzwr7gd.rs:29:13\n   |\n29 |\
    \         for &e in extensions {\n   |             ^^    ---------- this expression\
    \ has type `Option<String>`\n   |             |\n   |             expected struct\
    \ `String`, found reference\n   |             help: you can probably remove the\
    \ explicit borrow: `e`\n   |\n   = note: expected struct `String`\n          \
    \ found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmzzwr7gd.rs:37:13\n\
    \   |\n37 |         for &e in extensions {\n   |             ^^    ----------\
    \ this expression has type `Option<String>`\n   |             |\n   |        \
    \     expected struct `String`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `e`\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmzzwr7gd.rs:41:21\n\
    \   |\n41 |                 for &e in extensions {\n   |                     ^^\
    \    ---------- this expression has type `Option<String>`\n   |              \
    \       |\n   |                     expected struct `String`, found reference\n\
    \   |                     help: you can probably remove the explicit borrow: `e`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: Vec<String>\
    \ = Vec::new();\n\n    for extension in extensions.iter() {\n        let mut fractional_cap\
    \ = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let mut fractional_sm = extension.chars().filter(|c|\
    \ !c.is_uppercase()).count() - extension.chars().filter(|c| !c.is_lowercase()).count();\n\
    \        let mut strength: usize = 0;\n        if fractional_cap > fractional_sm\
    \ {\n            strength = fractional_cap;\n        } else {\n            strength\
    \ = fractional_sm;\n        }\n        strongest_extension.push((extension.clone(),\
    \ strength));\n    }\n\n    let mut min_strength = std::i32::MAX;\n    let mut\
    \ min_extension: Option<String> = None;\n\n    for entry in strongest_extension.iter()\
    \ {\n        if entry.1.unwrap() <= min_strength {\n            min_extension\
    \ = Some(entry.0);\n            min_strength = entry.1.unwrap();\n        }\n\
    \    }\n    min_extension.cloned()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp81j5q78b.rs:28:34\n   |\n\
    28 |         strongest_extension.push((extension.clone(), strength));\n   |  \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found tuple\n   |\n   = note: expected struct `String`\n         \
    \      found tuple `(String, usize)`\n\nerror[E0609]: no field `1` on type `&String`\n\
    \  --> /tmp/tmp81j5q78b.rs:35:18\n   |\n35 |         if entry.1.unwrap() <= min_strength\
    \ {\n   |                  ^ unknown field\n\nerror[E0609]: no field `0` on type\
    \ `&String`\n  --> /tmp/tmp81j5q78b.rs:36:40\n   |\n36 |             min_extension\
    \ = Some(entry.0);\n   |                                        ^ unknown field\n\
    \nerror[E0609]: no field `1` on type `&String`\n  --> /tmp/tmp81j5q78b.rs:37:34\n\
    \   |\n37 |             min_strength = entry.1.unwrap();\n   |               \
    \                   ^ unknown field\n\nerror[E0599]: `Option<String>` is not an\
    \ iterator\n   --> /tmp/tmp81j5q78b.rs:40:19\n    |\n40  |       min_extension.cloned()\n\
    \    |                     ^^^^^^ `Option<String>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class1 = class_name.chars();\n\
    \    let mut class2 = class1.cloned();\n    let mut extension1 = extensions.iter().cloned();\n\
    \    let mut extension2 = extension1.clone();\n    \n    let mut s = String::new();\n\
    \    \n    // Get the number of uppercase letters in class2\n    let cap = class2.count();\n\
    \    \n    // Get the number of lowercase letters in class2\n    let sm = class1.count();\n\
    \    \n    // Calculate the strength of the extension\n    let strength = (cap\
    \ - sm) as i32;\n    \n    \n    // Sort extensions by strength\n    extension1.sort_by_key(|x|\
    \ *x.chars().count());\n    extension2.sort_by_key(|x| *x.chars().count());\n\
    \    \n    // Check if extensions have the same strength\n    let mut same = true;\n\
    \    for (i, v1) in extension1.iter().enumerate() {\n        let mut v2 = extension2[i];\n\
    \        if v1 != v2 {\n            same = false;\n            break;\n      \
    \  }\n    }\n    \n    // If there are two extensions with the same strength choose\
    \ the one that\n    // comes first in the list\n    if same {\n        // Check\
    \ if extension2 has any elements\n        let mut has_elements = false;\n    \
    \    for (i, v) in extension2.iter().enumerate() {\n            has_elements =\
    \ true;\n            break;\n        }\n        if !has_elements {\n         \
    \   return String::from(\"\");\n        }\n        return String::from(&class_name.to_string()\
    \ + &extension2[0]);\n    }\n    \n    // Extensions have different strengths\
    \ so choose the one that comes first\n    for (i, v1) in extension1.iter().enumerate()\
    \ {\n        let mut v2 = extension2[i];\n        if v1 < v2 {\n            return\
    \ String::from(&class_name.to_string() + &v1);\n        }\n    }\n    return String::from(\"\
    \");\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpt3auol4n.rs:18:29\n     |\n18   |     let mut class2 =\
    \ class1.cloned();\n     |                             ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `count` exists for struct `Cloned<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpt3auol4n.rs:25:22\n   |\n25 |       let cap\
    \ = class2.count();\n   |                        ^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0599]: no method named `sort_by_key` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpt3auol4n.rs:35:16\n   |\n35 |     extension1.sort_by_key(|x|\
    \ *x.chars().count());\n   |                ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror[E0599]: no method named `sort_by_key` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpt3auol4n.rs:36:16\n   |\n36 |     extension2.sort_by_key(|x|\
    \ *x.chars().count());\n   |                ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpt3auol4n.rs:40:31\n   |\n40 |     for (i,\
    \ v1) in extension1.iter().enumerate() {\n   |                               ^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Cloned<std::slice::Iter<'_, String>>`\n \
    \ --> /tmp/tmpt3auol4n.rs:41:22\n   |\n41 |         let mut v2 = extension2[i];\n\
    \   |                      ^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter`\
    \ found for struct `Cloned` in the c"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().fold(class_name,\
    \ |class_name, extension| {\n        // find the extension that has highest strength\
    \ value\n        let strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()).count();\n        if strength\
    \ == 0 {\n            class_name + extension\n        } else {\n            class_name\
    \ + extension.to_uppercase().to_string() + extension.chars().filter(|c| c.is_lowercase()).count()\
    \ + strength.to_string()\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfe969bs.rs:23:26\n   |\n\
    23 | ...   class_name + extension.to_uppercase().to_string() + extension.chars().filter(|c|\
    \ c.is_lowercase()).count() + strength.to_string()\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&extension.to_uppercase().to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdfe969bs.rs:23:65\n   |\n23 |\
    \ ...percase().to_string() + extension.chars().filter(|c| c.is_lowercase()).count()\
    \ + strength.to_string()\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdfe969bs.rs:23:122\n\
    \   |\n23 | ... c.is_lowercase()).count() + strength.to_string()\n   |       \
    \                          ^^^^^^^^^^^^^^^^^^^^\n   |                        \
    \         |\n   |                                 expected `&str`, found struct\
    \ `String`\n   |                                 help: consider borrowing here:\
    \ `&strength.to_string()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n\
    \    let mut letter_counter = vec![String::new(), String::new(), String::new()];\n\
    \    for extension in extensions {\n        let letter_counter = extension.chars().collect::<Vec<_>>().zip([CAP,\
    \ SM]).collect();\n        let strength = letter_counter.get(0).unwrap() - letter_counter.get(1).unwrap();\n\
    \        strongest_extension.push_str(&format!(\"{}.{}\", class_name, extension));\n\
    \        strongest_extension.push_str(&format!(\"{:?}\", strength));\n       \
    \ strongest_extension.push_str(\",\");\n    }\n    strongest_extension.truncate(format!(\"\
    {}\", strongest_extension.len()).len());\n    strongest_extension.clone_from_slice(strongest_extension.chars().collect::<String>().clone());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `CAP` in this scope\n  --> /tmp/tmpm54enk1z.rs:20:73\n\
    \   |\n20 |         let letter_counter = extension.chars().collect::<Vec<_>>().zip([CAP,\
    \ SM]).collect();\n   |                                                      \
    \                   ^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `SM` in this scope\n  --> /tmp/tmpm54enk1z.rs:20:78\n   |\n20 |         let\
    \ letter_counter = extension.chars().collect::<Vec<_>>().zip([CAP, SM]).collect();\n\
    \   |                                                                        \
    \      ^^ not found in this scope\n\nerror[E0599]: `Vec<char>` is not an iterator\n\
    \   --> /tmp/tmpm54enk1z.rs:20:68\n    |\n20  |           let letter_counter =\
    \ extension.chars().collect::<Vec<_>>().zip([CAP, SM]).collect();\n    |     \
    \                                                                 ^^^ `Vec<char>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>:\
    \ Iterator`\n            `[char]: Iterator`\n            which is required by\
    \ `&mut [char]: Iterator`\n\nerror[E0599]: no method named `clone_from_slice`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpm54enk1z.rs:27:25\n\
    \   |\n27 |     strongest_extension.clone_from_slice(strongest_extension.chars().collect::<String>().clone());\n\
    \   |                         ^^^^^^^^^^^^^^^^ method not found in `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpm54enk1z.rs:16:72\n   |\n16 | fn\
    \ Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n\
    \   |    -------------------                                                 ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().fold(class_name,\
    \ |mut cur_class, &mut ext| {\n        let num_upper = ext.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let num_lower = ext.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let cap = num_upper.max(num_lower);\n\
    \        let sm = num_lower.max(num_upper);\n        let strength = cap - sm;\n\
    \        cur_class + \".\" + ext.to_string() + &\".\"[strength];\n    });\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbduk6sk.rs:17:56\n   |\n\
    17 |     extensions.iter().fold(class_name, |mut cur_class, &mut ext| {\n   |\
    \                                                        ^^^^^----\n   |     \
    \                                                   |    |\n   |             \
    \                                           |    expected due to this\n   |  \
    \                                                      types differ in mutability\n\
    \   |                                                        help: did you mean\
    \ `ext`: `&&String`\n   |\n   = note:      expected reference `&String`\n    \
    \       found mutable reference `&mut _`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmplbduk6sk.rs:17:66\n   |\n17 |       extensions.iter().fold(class_name,\
    \ |mut cur_class, &mut ext| {\n   |  __________________________________________________________________^\n\
    18 | |         let num_upper = ext.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    19 | |         let num_lower = ext.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    20 | |         let cap = num_upper.max(num_lower);\n...  |\n23 | |         cur_class\
    \ + \".\" + ext.to_string() + &\".\"[strength];\n   | |                      \
    \                                     - help: remove this semicolon\n24 | |  \
    \   });\n   | |_____^ expected struct `String`, found `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplbduk6sk.rs:16:72\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n24 |     });\n   |       - help: remove this semicolon\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_len = extensions.len();\n\
    \    let mut max_strength = -1;\n    let mut max_extension = String::new();\n\
    \    for &e in extensions {\n        let mut cur_len = e.len();\n        let mut\
    \ cur_max_strength = -1;\n        for i in 0..cur_len {\n            if e.chars().any(|c|c.is_uppercase()\
    \ && i >= cur_len/2) {\n                if cur_max_strength == -1 {\n        \
    \            cur_max_strength = i;\n                } else {\n               \
    \     cur_max_strength = cmp::min(cur_max_strength, i);\n                }\n \
    \           }\n        }\n        if cur_max_strength > max_strength {\n     \
    \       max_strength = cur_max_strength;\n            max_extension = e;\n   \
    \     }\n    }\n    format!(\"{}.{}\", class_name, max_extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp74e2pdn_.rs:28:40\n   |\n28 |                     cur_max_strength\
    \ = cmp::min(cur_max_strength, i);\n   |                                     \
    \   ^^^ use of undeclared crate or module `cmp`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp74e2pdn_.rs:20:9\n   |\n20 |     for &e in extensions {\n   | \
    \        ^^    ---------- this expression has type `Option<String>`\n   |    \
    \     |\n   |         expected struct `String`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `e`\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n    let\
    \ mut extension: String = String::from(\"\");\n    for extension in extensions\
    \ {\n        if extension.chars().filter(|c| c == c.to_ascii_uppercase()).count()\
    \ > 0 {\n            if strength == -1 {\n                strength = extension.chars().filter(|c|\
    \ c == c.to_ascii_lowercase()).count()\n            } else {\n               \
    \ strength = min(strength, extension.chars().filter(|c| c == c.to_ascii_lowercase()).count());\n\
    \            }\n        }\n    }\n    extension.to_lowercase() + class_name.to_lowercase()\
    \ + extensions[extensions.len() - strength].to_lowercase()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp_ms0n1ri.rs:24:28\n\
    \   |\n24 |                 strength = min(strength, extension.chars().filter(|c|\
    \ c == c.to_ascii_lowercase()).count());\n   |                            ^^^\n\
    ...\n31 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n24 |        \
    \         strength = main(strength, extension.chars().filter(|c| c == c.to_ascii_lowercase()).count());\n\
    \   |                            ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmp_ms0n1ri.rs:20:43\n   |\n20 |         if extension.chars().filter(|c|\
    \ c == c.to_ascii_uppercase()).count() > 0 {\n   |                           \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp_ms0n1ri.rs:22:59\n   |\n22 |                 strength\
    \ = extension.chars().filter(|c| c == c.to_ascii_lowercase()).count()\n   |  \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_ms0n1ri.rs:22:28\n   |\n17 |  \
    \   let mut strength: i32 = -1;\n   |                       --- expected due to\
    \ this type\n...\n22 |                 strength = extension.chars().filter(|c|\
    \ c == c.to_ascii_lowercase()).count()\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp_ms0n1ri.rs:24:73\n   |\n24 |                 strength = min(strength,\
    \ extension.chars().filter(|c| c == c.to_ascii_lowercase()).count());\n   |  \
    \                             "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut result = String::new();\n\n\
    \    let mut cap_len = 0.0;\n    let mut sm_len = 0.0;\n    for e in extensions\
    \ {\n        match e.chars().count(|&x| x >= 'A' && x <= 'Z') {\n            1\
    \ => cap_len += 1.0,\n            2 => cap_len += 0.5,\n            _ => (),\n\
    \        }\n        match e.chars().count(|&x| x >= 'a' && x <= 'z') {\n     \
    \       1 => sm_len += 1.0,\n            2 => sm_len += 0.5,\n            _ =>\
    \ (),\n        }\n    }\n\n    let cap = cap_len as f64 / extensions.len() as\
    \ f64;\n    let sm = sm_len as f64 / extensions.len() as f64;\n    if cap >= sm\
    \ {\n        result.append(&format!(\"{}.{}\", class_name, &extensions[extensions.len()\
    \ - 1]));\n    } else {\n        result.append(&format!(\"{}..{}\", &extensions[0],\
    \ &extensions[extensions.len() - 1]));\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp7l5lm0af.rs:22:25\n    |\n22  |         match e.chars().count(|&x|\
    \ x >= 'A' && x <= 'Z') {\n    |                         ^^^^^ -------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp7l5lm0af.rs:27:25\n    |\n27  |         match e.chars().count(|&x|\
    \ x >= 'a' && x <= 'z') {\n    |                         ^^^^^ -------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp7l5lm0af.rs:37:16\n   |\n37 |         result.append(&format!(\"\
    {}.{}\", class_name, &extensions[extensions.len() - 1]));\n   |              \
    \  ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp7l5lm0af.rs:39:16\n\
    \   |\n39 |         result.append(&format!(\"{}..{}\", &extensions[0], &extensions[extensions.len()\
    \ - 1]));\n   |                ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    debug!(\"Strongest_Extension start\"\
    );\n    let mut strongest_extension: String = String::from(\"\");\n\n    for extension\
    \ in extensions {\n        let mut class_extension: String = String::from(\"\"\
    );\n        let mut extension_length: usize = 0;\n        let mut counter: usize\
    \ = 0;\n\n        for char in extension.chars() {\n            match char {\n\
    \                'A' as char => counter += 1,\n                'B' as char =>\
    \ counter += 1,\n                'C' as char => counter += 1,\n              \
    \  'D' as char => counter += 1,\n                'E' as char => counter += 1,\n\
    \                'F' as char => counter += 1,\n                'G' as char =>\
    \ counter += 1,\n                'H' as char => counter += 1,\n              \
    \  'I' as char => counter += 1,\n                'J' as char => counter += 1,\n\
    \                'K' as char => counter += 1,\n                'L' as char =>\
    \ counter += 1,\n                'M' as char => counter += 1,\n              \
    \  'N' as char => counter += 1,\n                'O' as char => counter += 1,\n\
    \                'P' as char => counter += 1,\n                'Q' as char =>\
    \ counter += 1,\n                'R' as char => counter += 1,\n              \
    \  'S' as char => counter += 1,\n                'T' as char => counter += 1,\n\
    \                'U' as char => counter += 1,\n                'V' as char =>\
    \ counter += 1,\n                'W' as char => counter += 1,\n              \
    \  'X' as char => counter += 1,\n                'Y' as char => counter += 1,\n\
    \                'Z' as char => counter += 1,\n                _ => counter +=\
    \ 1,\n            }\n        }\n\n        match class_name.chars().count(|c| *c\
    \ == char) {\n            1 => strongest_extension += class_name + extension,\n\
    \            _ => class_extension += class_name + extension,\n        }\n\n  \
    \      if class_extension == strongest_extension {\n            strongest_extension\
    \ += extension;\n        }\n    }\n\n    debug!(\"Strongest_Extension end\");\n\
    \    strongest_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpq1ij_1lq.rs:27:21\n   |\n27 |                 'A' as char\
    \ => counter += 1,\n   |                     ^^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror: cannot find macro `debug` in this scope\n\
    \  --> /tmp/tmpq1ij_1lq.rs:17:5\n   |\n17 |     debug!(\"Strongest_Extension start\"\
    );\n   |     ^^^^^\n\nerror: cannot find macro `debug` in this scope\n  --> /tmp/tmpq1ij_1lq.rs:67:5\n\
    \   |\n67 |     debug!(\"Strongest_Extension end\");\n   |     ^^^^^\n\nerror[E0423]:\
    \ expected value, found builtin type `char`\n  --> /tmp/tmpq1ij_1lq.rs:57:50\n\
    \   |\n57 |         match class_name.chars().count(|c| *c == char) {\n   |   \
    \                                               ^^^^ not a value\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpq1ij_1lq.rs:57:34\n\
    \    |\n57  |         match class_name.chars().count(|c| *c == char) {\n    |\
    \                                  ^^^^^ -------------- supplied 1 argument\n\
    \    |                                  |\n    |                             \
    \     expected 0 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpq1ij_1lq.rs:58:54\n   |\n58 |  \
    \           1 => strongest_extension += class_name + extension,\n   |        \
    \                                              ^^^^^^^^^\n   |               \
    \                                       |\n   |                              \
    \                        expected `&str`, found struct `String`\n   |        \
    \                                              help: consider borrowing here:\
    \ `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ij_1lq.rs:58:41\n\
    \   |\n58 |             1 => strongest_extension += class_name + extension,\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \                                      |\n   |                               \
    \          expected `&str`, found struct `String`\n   |                      \
    \                   help: consider borrowing here: "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt4pd9y0.rs:16:72\n   |\n\
    16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut total_strength: usize = 0;\n\
    \    let mut current_class: &'static str = class_name;\n    let mut extensions:\
    \ &'static [String] = extensions.iter().collect::<Vec<_>>();\n    for (index,\
    \ extension) in extensions.iter().enumerate().rev() {\n        let (name_char,\
    \ extension_char) = (extension[0].chars(), extension.chars());\n        let (name_char_len,\
    \ extension_char_len) = (name_char.len(), extension_char.len());\n        let\
    \ cap_diff = name_char_len - extension_char_len;\n        let strength = cap_diff\
    \ / cap_diff.min(name_char.len(), extension_char.len());\n        total_strength\
    \ += strength;\n        if total_strength > 0 {\n            current_class = class_name\
    \ + &extension[index];\n        }\n    }\n    current_class\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeg5gykqa.rs:18:43\n   |\n\
    18 |     let mut current_class: &'static str = class_name;\n   |             \
    \               ------------   ^^^^^^^^^^\n   |                            | \
    \             |\n   |                            |              expected `&str`,\
    \ found struct `String`\n   |                            |              help:\
    \ consider borrowing here: `&class_name`\n   |                            expected\
    \ due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeg5gykqa.rs:19:45\n\
    \   |\n19 |     let mut extensions: &'static [String] = extensions.iter().collect::<Vec<_>>();\n\
    \   |                         -----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&[String]`, found struct `Vec`\n   |                         |\n \
    \  |                         expected due to this\n   |\n   = note: expected reference\
    \ `&'static [String]`\n                 found struct `Vec<&String>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpeg5gykqa.rs:21:44\n\
    \   |\n21 |         let (name_char, extension_char) = (extension[0].chars(), extension.chars());\n\
    \   |                                            ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeg5gykqa.rs:27:43\n   |\n27 |             current_class = class_name\
    \ + &extension[index];\n   |                                           ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   ="
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().fold(class_name,\
    \ |best_str, extension| {\n        let mut best_len = best_str.len();\n      \
    \  for suffix in extensions.iter() {\n            if suffix.len() > best_len {\n\
    \                best_len = suffix.len();\n                best_str = suffix;\n\
    \            }\n        }\n        best_str\n    })\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpglvcm8xt.rs:22:28\n   |\n\
    17 |     extensions.iter().fold(class_name, |best_str, extension| {\n   |    \
    \                                     -------- expected due to this parameter\
    \ type\n...\n22 |                 best_str = suffix;\n   |                   \
    \         ^^^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                          |\n   |                            expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    let mut min_strength\
    \ = std::cmp::min(0., extensions.iter().map(|s| s.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count() - s.chars().filter(|c| c >= 'a' && c <= 'z').count()).sum());\n\
    \    extensions.iter().for_each(|s| {\n        let c = s.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z').count() - s.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        min_strength = std::cmp::min(min_strength, c.floor());\n    });\n   \
    \ let mut best_extension = String::from(\"\");\n    extensions.iter().for_each(|s|\
    \ {\n        let c = s.chars().filter(|c| c >= 'A' && c <= 'Z').count() - s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        if min_strength <= c {\n           \
    \ best_extension = s;\n            min_strength = c;\n        }\n    });\n   \
    \ return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `{float}: Ord` is not satisfied\n    -->\
    \ /tmp/tmp7z9vuec0.rs:18:28\n     |\n18   |     let mut min_strength = std::cmp::min(0.,\
    \ extensions.iter().map(|s| s.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ - s.chars().fil...\n     |                            ^^^^^^^^^^^^^ the trait\
    \ `Ord` is not implemented for `{float}`\n     |\n     = help: the following other\
    \ types implement trait `Ord`:\n               i128\n               i16\n    \
    \           i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::cmp::min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7z9vuec0.rs:18:98\n\
    \   |\n18 | ...ions.iter().map(|s| s.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ - s.chars().filter(|c| c >= 'a' && c <= 'z').count()).sum());\n   |        \
    \                                          ^^^\n   |                         \
    \                         |\n   |                                            \
    \      expected `&char`, found `char`\n   |                                  \
    \                help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7z9vuec0.rs:18:110\n   |\n18 | ...map(|s| s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - s.chars().filter(|c| c >= 'a' && c <= 'z').count()).sum());\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |                      \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7z9vuec0.rs:18:151\n   |\n18 | ...c <= 'Z').count()\
    \ - s.chars().filter(|c| c >= 'a' && c <= 'z').count()).sum());\n   |        \
    \                                          ^^^\n   |                         \
    \                         |\n   |                                            \
    \      expected `&char`, found `char`\n   |                                  \
    \                hel"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let extensions = extensions.iter().cloned().collect();\n\
    \    let mut strength = -1;\n    let mut extension: &mut String;\n    for extension\
    \ in extensions {\n        if extension.chars().filter(|c| c.is_ascii_uppercase()).count()\
    \ > strength {\n            strength = extension.chars().filter(|c| c.is_ascii_uppercase()).count();\n\
    \            extension = &mut extensions[extensions.iter().position(|x| x == extension).unwrap()]\n\
    \        };\n    }\n    class_name.to_string() + extension.to_string()\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpn_m543x2.rs:21:12\n\
    \   |\n20 |     for extension in extensions {\n   |                      ----------\
    \ the element type for this iterator is not specified\n21 |         if extension.chars().filter(|c|\
    \ c.is_ascii_uppercase()).count() > strength {\n   |            ^^^^^^^^^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_m543x2.rs:26:30\n   |\n26 |     class_name.to_string()\
    \ + extension.to_string()\n   |                              ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                              |\n   |                              expected\
    \ `&str`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `&extension.to_string()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut strongest_extension: String\
    \ = class_name;\n    for extension in extensions {\n        let strength = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n        strongest_extension += extension.chars().filter(|c| c\
    \ >= 'A' && c <= 'Z').count() + extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count() as char;\n        if strength != 0 {\n            let strength_ratio\
    \ = (strength / extensions.len()) as char;\n            strongest_extension +=\
    \ (strength_ratio as isize);\n        }\n    }\n    strongest_extension.chars().filter(|c|\
    \ *c == 0).count() as char\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpe0qze86v.rs:23:36\n\
    \   |\n23 |             strongest_extension += (strength_ratio as isize);\n  \
    \ |                                    ^                       ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    23 -             strongest_extension += (strength_ratio as isize);\n23 +     \
    \        strongest_extension += strength_ratio as isize;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe0qze86v.rs:19:58\n   |\n19 | ...   let strength\
    \ = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').coun...\n   |                                        \
    \                ^^^\n   |                                                   \
    \     |\n   |                                                        expected\
    \ `&char`, found `char`\n   |                                                \
    \        help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe0qze86v.rs:19:70\n   |\n19 | ...   let strength = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').coun...\n   |                                                         \
    \           ^^^\n   |                                                        \
    \            |\n   |                                                         \
    \           expected `&char`, found `char`\n   |                             \
    \                                       help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe0qze86v.rs:19:119\n   |\n19 |\
    \ ...).count() - extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |                      \
    \                            help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut best_extension = String::new();\n\
    \    let mut best_score = -1;\n    for (i, s) in extensions.iter().enumerate()\
    \ {\n        let cap = s.chars().filter(|c| c >= 'A').count();\n        let sm\
    \ = s.chars().filter(|c| c >= 'a').count();\n        let score = cap - sm;\n \
    \       if score > best_score {\n            best_score = score;\n           \
    \ best_extension = s;\n        }\n    }\n    class_name.to_string() + best_extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp196z7k8w.rs:20:45\n   |\n\
    20 |         let cap = s.chars().filter(|c| c >= 'A').count();\n   |         \
    \                                    ^^^\n   |                               \
    \              |\n   |                                             expected `&char`,\
    \ found `char`\n   |                                             help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp196z7k8w.rs:21:44\n\
    \   |\n21 |         let sm = s.chars().filter(|c| c >= 'a').count();\n   |   \
    \                                         ^^^\n   |                          \
    \                  |\n   |                                            expected\
    \ `&char`, found `char`\n   |                                            help:\
    \ consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp196z7k8w.rs:25:30\n\
    \   |\n17 |     let mut best_extension = String::new();\n   |                \
    \              ------------- expected due to this value\n...\n25 |           \
    \  best_extension = s;\n   |                              ^- help: try using a\
    \ conversion method: `.to_string()`\n   |                              |\n   |\
    \                              expected struct `String`, found `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp196z7k8w.rs:18:26\n\
    \   |\n18 |     let mut best_score = -1;\n   |                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp196z7k8w.rs:28:30\n   |\n28 |     class_name.to_string()\
    \ + best_extension.to_string()\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                              |\n   |                              expected\
    \ `&str`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let (class_name, extensions) = str_to_vec((class_name,\
    \ extensions)).unwrap();\n    let mut max_strength = -1;\n    let mut best_extension:\
    \ Option<String> = None;\n    for ext in extensions.iter() {\n        let (classname,\
    \ _) = str_to_vec(ext.clone()).unwrap();\n        let ext = classname.to_lowercase();\n\
    \        let strength = ext.chars().count();\n        if strength > max_strength\
    \ {\n            max_strength = strength;\n            best_extension = Some(ext);\n\
    \        }\n    }\n    if let Some(ext) = best_extension {\n        format!(\"\
    {}.{}\", class_name, ext)\n    } else {\n        format!(\"{}.\", class_name)\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `str_to_vec` in this scope\n  --> /tmp/tmphokhfdbo.rs:17:36\n\
    \   |\n17 |     let (class_name, extensions) = str_to_vec((class_name, extensions)).unwrap();\n\
    \   |                                    ^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `str_to_vec` in this scope\n  --> /tmp/tmphokhfdbo.rs:21:30\n\
    \   |\n21 |         let (classname, _) = str_to_vec(ext.clone()).unwrap();\n \
    \  |                              ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter: u32 = 0;\n    let\
    \ mut max_strongest = String::from(\"\");\n    for ext:String in extensions {\n\
    \        if ext.chars().map(|c|c).count() > 2 { \n            continue;\n    \
    \    }\n        let mut counter = ext.chars().map(|c|c).count();\n        counter\
    \ /= class_name.chars().map(|c|c).count();\n        max_strongest = if counter\
    \ > max_strongest.chars().map(|c|c).count() {\n            max_strongest.push_str(&ext);\n\
    \        }\n    }\n    if max_strongest.is_empty() {\n        max_strongest =\
    \ \"None\";\n    }\n    class_name\n        + &max_strongest\n        .chars()\n\
    \        .map(|c|c)\n        .collect()\n        .join(\".\")\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `@` or `|`, found `:`\n  --> /tmp/tmp4bvnbao2.rs:19:12\n\
    \   |\n19 |     for ext:String in extensions {\n   |            ^\n   |      \
    \      |\n   |            expected one of `@` or `|`\n   |            help: maybe\
    \ write a path separator here: `::`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared crate or module `ext`\n  --> /tmp/tmp4bvnbao2.rs:19:9\n   |\n19 |\
    \     for ext:String in extensions {\n   |         ^^^ use of undeclared crate\
    \ or module `ext`\n\nerror[E0425]: cannot find value `ext` in this scope\n  -->\
    \ /tmp/tmp4bvnbao2.rs:20:12\n   |\n20 |         if ext.chars().map(|c|c).count()\
    \ > 2 { \n   |            ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ext` in this scope\n  --> /tmp/tmp4bvnbao2.rs:23:27\n   |\n23 |\
    \         let mut counter = ext.chars().map(|c|c).count();\n   |             \
    \              ^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ext` in this scope\n  --> /tmp/tmp4bvnbao2.rs:26:37\n   |\n26 |           \
    \  max_strongest.push_str(&ext);\n   |                                     ^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4bvnbao2.rs:25:78\n\
    \   |\n25 |           max_strongest = if counter > max_strongest.chars().map(|c|c).count()\
    \ {\n   |  ______________________________________________________________________________^\n\
    26 | |             max_strongest.push_str(&ext);\n27 | |         }\n   | |_________^\
    \ expected struct `String`, found `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4bvnbao2.rs:30:25\n   |\n18 |     let mut max_strongest = String::from(\"\
    \");\n   |                             ---------------- expected due to this value\n\
    ...\n30 |         max_strongest = \"None\";\n   |                         ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \       |\n   |                         expected struct `String`, found `&str`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut class = String::from(class_name);\n\
    \    let mut max_extension_strength: i32 = -1;\n    for extension in extensions\
    \ {\n        let mut s = String::from(extension);\n        let mut cap: i32 =\
    \ 0;\n        let mut sm: i32 = 0;\n        for x in s.chars() {\n           \
    \ if x.to_ascii_lowercase() == x {\n                sm++;\n            } else\
    \ if x.to_ascii_uppercase() == x {\n                cap++;\n            }\n  \
    \      }\n        if cap > sm {\n            cap = cap - sm;\n        } else {\n\
    \            sm = sm - cap;\n        }\n        if cap > max_extension_strength\
    \ {\n            max_extension_strength = cap;\n            class += &s.to_ascii_lowercase();\n\
    \        }\n    }\n    return class + \".\" + max_extension_strength.to_string();\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0hiwvbey.rs:25:19\n\
    \   |\n25 |                 sm++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |                 { let tmp\
    \ = sm; sm += 1; tmp };\n   |                 +++++++++++   ~~~~~~~~~~~~~~~~\n\
    25 -                 sm++;\n25 +                 sm += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp0hiwvbey.rs:27:20\n   |\n27\
    \ |                 cap++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n27 |                 { let tmp = cap; cap\
    \ += 1; tmp };\n   |                 +++++++++++    ~~~~~~~~~~~~~~~~~\n27 -  \
    \               cap++;\n27 +                 cap += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hiwvbey.rs:40:26\n   |\n40 |     return class\
    \ + \".\" + max_extension_strength.to_string();\n   |                        \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                          |\n   | \
    \                         expected `&str`, found struct `String`\n   |       \
    \                   help: consider borrowing here: `&max_extension_strength.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter = String::new();\n\
    \n    for extension in extensions {\n        let mut counter = String::new();\n\
    \n        for letter in extension {\n            if letter == letter[0] {\n  \
    \              counter.push('-');\n            } else {\n                counter.push(letter);\n\
    \            }\n        }\n\n        let strength = counter.chars().count();\n\
    \n        if strength > 0 {\n            counter.push_str(&format!(\"{}.{}\",\
    \ class_name, extension));\n            break;\n        } else {\n           \
    \ counter.push_str(&format!(\"{}.{}\", class_name, extension));\n        }\n \
    \   }\n\n    match (counter.chars().count(), counter) {\n        (_, _) if counter.len()\
    \ == 2 => format!(\"{}.{}\", class_name, counter.clone()),\n        _ => format!(\"\
    {}.{}\", class_name, counter.clone()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdlkxqnjc.rs:22:23\n\
    \   |\n22 |         for letter in extension {\n   |                       ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut total_class_length = class_name.chars().count();\n\
    \    let mut total_extension_length = 0;\n\n    for extension in extensions {\n\
    \        total_extension_length += extension.chars().count();\n    }\n\n    let\
    \ (class_strength, extension_strength) = if class_name.len() > total_class_length\
    \ {\n        (class_name.chars().count() - total_class_length, 0)\n    } else\
    \ {\n        (0, extensions.chars().count() - total_extension_length)\n    };\n\
    \n    if class_strength < extension_strength {\n        let mut class_length =\
    \ class_name.chars().count();\n        let mut extension_length = 0;\n       \
    \ let mut index = 0;\n\n        while index < class_length {\n            let\
    \ c = class_name[index];\n            if !c.is_uppercase() {\n               \
    \ class_length -= 1;\n            } else {\n                extension_length +=\
    \ 1;\n            }\n            index +=1;\n        }\n\n        (class_strength,\
    \ extension_length / class_length)\n    } else {\n        (extension_strength,\
    \ extension_length)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `extension_length` in this scope\n  -->\
    \ /tmp/tmpqdrnurf9.rs:47:30\n   |\n47 |         (extension_strength, extension_length)\n\
    \   |                              ^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `extension_strength`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpqdrnurf9.rs:27:24\n\
    \   |\n27 |         (0, extensions.chars().count() - total_extension_length)\n\
    \   |                        ^^^^^ method not found in `Vec<String>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqdrnurf9.rs:36:21\n\
    \   |\n36 |             let c = class_name[index];\n   |                     ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqdrnurf9.rs:45:9\n\
    \   |\n16 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \              ------ expected `String` because of return type\n...\n45 |    \
    \     (class_strength, extension_length / class_length)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `String`\n\
    \               found tuple `(_, usize)`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    debugln!(\"{} -> {}\", class_name,\
    \ extensions.iter().map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>());\n  \
    \  let mut max_strength = -1;\n    let mut best_extension = String::new();\n \
    \   for extension in extensions {\n        let sb = String::from(\"{}.{}\", class_name,\
    \ extension);\n        let sc = String::from_utf8(sb);\n        if sc.contains(&class_name.to_ascii_lowercase())\
    \ {\n            if let Ok(strength) = Extension::strength_from_name(extension)\
    \ {\n                if strength > max_strength {\n                    best_extension\
    \ = sb;\n                    max_strength = strength;\n                }\n   \
    \         }\n        }\n    }\n    debugln!(\"{} -> {}\", class_name, best_extension);\n\
    \    \n    if max_strength == -1 {\n        return class_name;\n    }\n    \n\
    \    best_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmp1xmnemb6.rs:17:5\n\
    \   |\n17 |     debugln!(\"{} -> {}\", class_name, extensions.iter().map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \   |     ^^^^^^^\n\nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmp1xmnemb6.rs:32:5\n\
    \   |\n32 |     debugln!(\"{} -> {}\", class_name, best_extension);\n   |    \
    \ ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `Extension`\n\
    \  --> /tmp/tmp1xmnemb6.rs:24:35\n   |\n24 |             if let Ok(strength) =\
    \ Extension::strength_from_name(extension) {\n   |                           \
    \        ^^^^^^^^^ use of undeclared type `Extension`\n\nerror[E0061]: this function\
    \ takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmp1xmnemb6.rs:21:18\n\
    \    |\n21  |         let sb = String::from(\"{}.{}\", class_name, extension);\n\
    \    |                  ^^^^^^^^^^^^ -------  ----------  --------- supplied 3\
    \ arguments\n    |                  |\n    |                  expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1xmnemb6.rs:22:36\n   |\n22 |         let sc = String::from_utf8(sb);\n\
    \   |                                    ^^ expected struct `Vec`, found struct\
    \ `String`\n   |\n   = note: expected struct `Vec<u8>`\n              found struct\
    \ `String`\n\nerror[E0658]: use of unstable library feature 'option_result_contains'\n\
    \  --> /tmp/tmp1xmnemb6.rs:23:15\n   |\n23 |         if sc.contains(&class_name.to_ascii_lowercase())\
    \ {\n   |               ^^^^^^^^\n   |\n   = note: see issue #62358 <https://github.com/rust-lang/rust/issues/62358>\
    \ for more information\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308, E0433, E0658.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n     \
    \   return class_name;\n    }\n\n    let mut best_strength = -1;\n    let mut\
    \ best_extension = String::new();\n\n    for extension in extensions {\n     \
    \   let count = extension.chars().filter(|c| c.is_upper()).count();\n        let\
    \ count_lower_case = extension.chars().filter(|c| c.is_lower()).count();\n\n \
    \       let strength = count - count_lower_case;\n\n        if strength > best_strength\
    \ {\n            best_extension = extension;\n            best_strength = strength;\n\
    \        }\n    }\n\n    format!(\"{}{}.{}\", class_name, best_extension, best_strength)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp7_tu2821.rs:25:52\n   |\n25 |         let count\
    \ = extension.chars().filter(|c| c.is_upper()).count();\n   |                \
    \                                    ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp7_tu2821.rs:26:63\n\
    \   |\n26 |         let count_lower_case = extension.chars().filter(|c| c.is_lower()).count();\n\
    \   |                                                               ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_lowercase`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp7_tu2821.rs:21:29\n\
    \   |\n21 |     let mut best_strength = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    \n    for (i, ext) in extensions.iter().enumerate() {\n        let mut ext\
    \ = ext.to_lowercase();\n        if i > 0 {\n            if ext.chars().any(|c|\
    \ c != ext.chars().nth(i).unwrap()) {\n                ext.push((ext.chars().nth(i).unwrap()\
    \ + ext.chars().nth(i - 1).unwrap()) as u8);\n                ext.pop();\n   \
    \         }\n        }\n        extensions_map.insert(ext, i as usize);\n    }\n\
    \    \n    let strength = extensions_map.values().iter().fold(0, |acc, x| acc\
    \ + (x.0.to_lowercase().chars().count() - x.1.to_lowercase().chars().count()));\n\
    \    \n    let mut ret = \"\";\n    \n    for (i_str, i) in extensions_map.iter().enumerate()\
    \ {\n        let mut ext = \"\";\n        for (j, c) in i_str.chars().enumerate()\
    \ {\n            if i == j {\n                ext.push(c);\n            } else\
    \ {\n                ext.push(c);\n            }\n        }\n        ret += class_name\
    \ + \".\" + ext.to_string();\n    }\n    \n    let mut max_strength = extensions_map.iter().map(|x|\
    \ x.1).max().unwrap();\n    for i_ret in ret.split('.').skip(1).filter(|x| !x.is_empty())\
    \ {\n        if ret[i_ret].chars().count() > max_strength {\n            max_strength\
    \ = ret[i_ret].chars().count();\n        }\n    }\n    \n    ret + \".\" + max_strength.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwtkk35mv.rs:17:30\n   |\n17 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpwtkk35mv.rs:23:55\n\
    \   |\n23 |                 ext.push((ext.chars().nth(i).unwrap() + ext.chars().nth(i\
    \ - 1).unwrap()) as u8);\n   |                           ---------------------------\
    \ ^ ------------------------------- char\n   |                           |\n \
    \  |                           char\n\nerror[E0599]: no method named `push` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpwtkk35mv.rs:38:21\n\
    \   |\n38 |                 ext.push(c);\n   |                     ^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `push` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpwtkk35mv.rs:40:21\n   |\n40 |   \
    \              ext.push(c);\n   |                     ^^^^ method not found in\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwtkk35mv.rs:43:35\n\
    \   |\n43 |         ret += class_name + \".\" + ext.to_string();\n   |       \
    \                            ^^^^^^^^^^^^^^^\n   |                           \
    \        |\n   |                                   expected `&str`, found struct\
    \ `String`\n   |                                   help: consider borrowing here:\
    \ `&ext.to_string()`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmpwtkk35mv.rs:43:9\n   |\n43 |      \
    \   ret += class_name + \".\" + ext.to_string();\n   |         ---^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |   |\n   |         |   `+` cannot be used to concatenate a `&str`\
    \ with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `&str`\n  --> /tmp/tmpwtkk35mv.rs:48:12\n\
    \   |\n48 |         if ret[i_ret].chars().cou"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut classes: Vec<String> = extensions.iter().cloned().collect();\n\
    \    classes.sort();\n    let mut highest_strength = -1;\n    let mut current_strength\
    \ = 0;\n    for &x in classes {\n        if x.len() < class_name.len() {\n   \
    \         continue;\n        }\n        let strength = x.len().chars().map(|c|\
    \ *c).filter(|c| *c >= 'A' && *c <= 'Z').count() - x.len().chars().map(|c| *c).filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if strength > current_strength {\n\
    \            current_strength = strength;\n            highest_strength = current_strength;\n\
    \        }\n    }\n    format!(\"{}{}\", class_name, highest_strength)\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqqsupq9.rs:21:9\n   |\n\
    21 |     for &x in classes {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    \n    let mut strength: i32 = 0;\n\
    \    let mut cur_extension: Option<String> = None;\n    for e in extensions {\n\
    \        let letters = e.chars().filter(|c| !c.is_lowercase()).count();\n    \
    \    strength = (letters as f64 - cur_extension.unwrap().chars().filter(|c| c.is_lowercase()).count())\
    \ / letters as i32;\n        if strength > 0 {\n            cur_extension = Some(e);\n\
    \        }\n    }\n    cur_extension.take().unwrap() + &class_name + &extensions[extensions.len()\
    \ - 1];\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmp0cad9b7q.rs:22:36\n\
    \   |\n22 |         strength = (letters as f64 - cur_extension.unwrap().chars().filter(|c|\
    \ c.is_lowercase()).count()) / letters as i32;\n   |                         \
    \           ^ no implementation for `f64 - usize`\n   |\n   = help: the trait\
    \ `Sub<usize>` is not implemented for `f64`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0cad9b7q.rs:16:72\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n27 |     cur_extension.take().unwrap() + &class_name\
    \ + &extensions[extensions.len() - 1];\n   |                                 \
    \                                                   - help: remove this semicolon\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n  assert!(extensions.iter().all(|&e| e.chars().all(|c|\
    \ ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))), \"Invalid class name\");\n\
    \  assert!(extensions.iter().all(|&e| e.chars().all(|c| ('0' <= c && c <= '9'))),\
    \ \"Invalid class name\");\n\n  let mut min_strength: i64 = std::cmp::Ordering::Less::default();\n\
    \  let mut strength: i64 = 0;\n\n  for ext in extensions {\n    let mut c = ext.chars().map(|c|\
    \ if ('A' <= c && c <= 'Z') then c - 'A' else c - 'a').collect::<Vec<u8>>();\n\
    \    if c.len() == 1 {\n      c = c.iter().cloned().collect::<Vec<u8>>();\n  \
    \  }\n    for c in c {\n      strength += (c.to_digit(16) - c.to_digit(10));\n\
    \      if strength > min_strength {\n        min_strength = strength;\n      }\n\
    \    }\n  }\n\n  format!(\"{}.{}\", class_name, min_strength)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmpx9b1vtsh.rs:24:63\n  \
    \ |\n24 |     let mut c = ext.chars().map(|c| if ('A' <= c && c <= 'Z') then c\
    \ - 'A' else c - 'a').collect::<Vec<u8>>();\n   |                            \
    \         --                        ^^^^ expected `{`\n   |                  \
    \                   |\n   |                                     this `if` expression\
    \ has a condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n24 |     let mut c = ext.chars().map(|c| if ('A' <= c && c <= 'Z') { then\
    \ } c - 'A' else c - 'a').collect::<Vec<u8>>();\n   |                        \
    \                                       +      +\n\nerror[E0433]: failed to resolve:\
    \ `Less` is a variant, not a module\n  --> /tmp/tmpx9b1vtsh.rs:20:51\n   |\n20\
    \ |   let mut min_strength: i64 = std::cmp::Ordering::Less::default();\n   | \
    \                                                  ^^^^ `Less` is a variant, not\
    \ a module\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut counter: u32 = class_name.to_ascii_uppercase().chars().count();\n\
    \    for extension in extensions {\n        if extension.chars().count() > counter\
    \ {\n            counter = extension.chars().count();\n        }\n    }\n    let\
    \ strength = (-counter).saturating_add(1);\n    \"{}.{}\".to_string(&class_name).format(class_name,\
    \ extensions[0][strength..]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbw0m6_au.rs:17:28\n   |\n\
    17 |     let mut counter: u32 = class_name.to_ascii_uppercase().chars().count();\n\
    \   |                      ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |                      |\n   |           \
    \           expected due to this\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut counter:\
    \ u32 = class_name.to_ascii_uppercase().chars().count().try_into().unwrap();\n\
    \   |                                                                        \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbw0m6_au.rs:19:40\n\
    \   |\n19 |         if extension.chars().count() > counter {\n   |           \
    \                             ^^^^^^^ expected `usize`, found `u32`\n   |\nhelp:\
    \ you can convert a `u32` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |         if extension.chars().count() > counter.try_into().unwrap()\
    \ {\n   |                                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbw0m6_au.rs:20:23\n   |\n17 |\
    \     let mut counter: u32 = class_name.to_ascii_uppercase().chars().count();\n\
    \   |                      --- expected due to this type\n...\n20 |          \
    \   counter = extension.chars().count();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `u32`\n  --> /tmp/tmpbw0m6_au.rs:23:20\n   |\n23 |     let strength\
    \ = (-counter).saturating_add(1);\n   |                    ^^^^^^^^^^ cannot apply\
    \ unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpbw0m6_au.rs:24:13\n\
    \     |\n24   |     \"{}.{}\".to_string(&class_name).format(class_name, extensions[0][strength..]);\n\
    \     |             ^^^^^^^^^ ----------- supplied 1 argument\n     |        \
    \     |\n     |             expected 0 arguments\n     |\nnote: associated"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    extensions.iter().\n        filter_map(|&s|\
    \ s.chars().count(|c| c.is_uppercase() / c.is_lowercase())).\n        max(|a,\
    \ b| a.cmp(b)).\n        cloned()\n        .unwrap_or(String::new())\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpm31ra251.rs:18:42\n\
    \   |\n18 |         filter_map(|&s| s.chars().count(|c| c.is_uppercase() / c.is_lowercase())).\n\
    \   |                                          ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpm31ra251.rs:18:35\n\
    \    |\n18  |         filter_map(|&s| s.chars().count(|c| c.is_uppercase() / c.is_lowercase())).\n\
    \    |                                   ^^^^^ ---------------------------------------\
    \ supplied 1 argument\n    |                                   |\n    |      \
    \                             expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm31ra251.rs:18:25\n\
    \   |\n18 |         filter_map(|&s| s.chars().count(|c| c.is_uppercase() / c.is_lowercase())).\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         filter_map(|&s| Some(s.chars().count(|c| c.is_uppercase()\
    \ / c.is_lowercase()))).\n   |                         +++++                 \
    \                                       +\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmpm31ra251.rs:19:9\n\
    \     |\n19   |         max(|a, b| a.cmp(b)).\n     |         ^^^ ---------------\
    \ supplied 1 argument\n     |         |\n     |         expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0034]: multiple applicable\
    \ items in scope\n  --> /tmp/tmpm31ra251.rs:20:9\n   |\n20 |         cloned()\n\
    \   |         ^^^^^^ multiple `cloned` found\n   |\n   = note: candidate #1 is\
    \ defined in an impl for the type `Option<&T>`\n   = note: candidate #2 is defined\
    \ in an impl for the type `Option<&mut T>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    // Your code here\n    \n    let mut\
    \ min_strength = extensions[0][..].chars().filter(|x|x.is_uppercase()).count()\
    \ - extensions[0][..].chars().filter(|x|x.is_lowercase()).count();\n    let mut\
    \ max_strength = extensions[0][..].chars().filter(|x|x.is_lowercase()).count()\
    \ - extensions[0][..].chars().filter(|x|x.is_uppercase()).count();\n    let mut\
    \ max_strength_extension = extensions[0];\n    for ext in extensions.iter() {\n\
    \        let num_upper = ext[..].chars().filter(|x|x.is_uppercase()).count();\n\
    \        let num_lower = ext[..].chars().filter(|x|x.is_lowercase()).count();\n\
    \        let strength = num_upper - num_lower;\n        if strength < min_strength\
    \ {\n            min_strength = strength;\n            max_strength_extension\
    \ = ext;\n        }\n        if strength > max_strength {\n            max_strength\
    \ = strength;\n        }\n    }\n    \n    \"{}.{}\".format(class_name, max_strength_extension);\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8aumq8rj.rs:28:38\n   |\n\
    21 |     let mut max_strength_extension = extensions[0];\n   |               \
    \                       ------------- expected due to this value\n...\n28 |  \
    \           max_strength_extension = ext;\n   |                              \
    \        ^^^- help: try using a conversion method: `.to_string()`\n   |      \
    \                                |\n   |                                     \
    \ expected struct `String`, found `&String`\n\nerror[E0599]: no method named `format`\
    \ found for reference `&'static str` in the current scope\n  --> /tmp/tmp8aumq8rj.rs:35:13\n\
    \   |\n35 |     \"{}.{}\".format(class_name, max_strength_extension);\n   |  \
    \           ^^^^^^ method not found in `&'static str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8aumq8rj.rs:16:72\n   |\n16 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfn Strongest_Extension(class_name: String,\
    \ extensions: Vec<String>) -> String {\n    let mut min: i32 = -1;\n    let mut\
    \ strongest: Option<String> = None;\n    for extension in extensions {\n     \
    \   let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n  \
    \      let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        if min == -1 || strength > min {\n\
    \            min = strength;\n            strongest = Some(extension.clone());\n\
    \        }\n    }\n    let new_str = strongest.unwrap_or(class_name.clone());\n\
    \    new_str.push_str(min);\n    new_str\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9jn15el.rs:20:53\n   |\n\
    20 |         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                     ^^^\n   |          \
    \                                           |\n   |                          \
    \                           expected `&char`, found `char`\n   |             \
    \                                        help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd9jn15el.rs:20:65\n   |\n20 |\
    \         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                                 ^^^\n  \
    \ |                                                                 |\n   |  \
    \                                                               expected `&char`,\
    \ found `char`\n   |                                                         \
    \        help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd9jn15el.rs:21:52\n   |\n21 |         let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \             ^^^\n   |                                                    |\n\
    \   |                                                    expected `&char`, found\
    \ `char`\n   |                                                    help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd9jn15el.rs:21:64\n\
    \   |\n21 |         let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                                ^^^\n   |\
    \                                                                |\n   |     \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \       help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd9jn15el.rs:23:36\n   |\n23 |         if min == -1 || strength\
    \ > min {\n   |                        "
  exit_code: 1
  status: SyntaxError
