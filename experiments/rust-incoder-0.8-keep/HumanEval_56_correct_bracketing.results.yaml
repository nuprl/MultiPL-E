name: HumanEval_56_correct_bracketing
language: rust
results:
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == '>')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpshsn608e.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '>')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_chars = HashSet::new();\n    let mut\
    \ closed_chars = HashSet::new();\n    let mut opening_brackets = HashSet::new();\n\
    \    let mut closing_brackets = HashSet::new();\n    let mut char_pos = 0;\n \
    \   for c in &brackets {\n        if c.is_ascii_alphanumeric() {\n           \
    \ if char_pos > 0 {\n                if char_pos == opening_chars.len() {\n  \
    \                  opening_chars.insert(opening_chars.last().unwrap());\n    \
    \            }\n                let open_char = opening_chars.remove(opening_chars.last().unwrap());\n\
    \                let close_char = closed_chars.remove(closed_chars.last().unwrap());\n\
    \                let opening_bracket = opening_brackets.remove(opening_brackets.last().unwrap());\n\
    \                let closing_bracket = closing_brackets.remove(closing_brackets.last().unwrap());\n\
    \                if c == close_char {\n                    closed_chars.insert(close_char);\n\
    \                    opening_brackets.insert(opening_bracket);\n             \
    \       closing_brackets.insert(closing_bracket);\n                    char_pos\
    \ += 1;\n                } else if c == open_char {\n                    opening_chars.insert(open_char);\n\
    \                    closing_brackets.insert(closing_bracket);\n             \
    \       opening_brackets.insert(opening_bracket);\n                    char_pos\
    \ += 1;\n                }\n            }\n            char_pos += 1;\n      \
    \  } else {\n            if char_pos > 0 {\n                if char_pos == opening_chars.len()\
    \ {\n                    opening_chars.insert(opening_chars.last().unwrap());\n\
    \                }\n                let open_char = opening_chars.remove(opening_chars.last().unwrap());\n\
    \                let close_char = closed_chars.remove(closed_chars.last().unwrap());\n\
    \                let opening_bracket = opening_brackets.remove(opening_brackets.last().unwrap());\n\
    \                let closing_bracket = closing_brackets.remove(closing_brackets.last().unwrap());\n\
    \                if c == close_char {\n                    closed_chars.insert(close_char);\n\
    \                    opening_brackets.insert(opening_bracket);\n             \
    \       closing_brackets.insert(closing_bracket);\n                    char_pos\
    \ += 1;\n                } else if c == open_char {\n                    opening_chars.insert(open_char);\n\
    \                    closing_brackets.insert(closing_bracket);\n             \
    \       opening_brackets.insert(opening_bracket);\n                    char_pos\
    \ += 1;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpggtits1a.rs:75:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n17 |     for\
    \ c in &brackets {\n   |                        - unclosed delimiter\n...\n40\
    \ |         } else {\n   |                - unclosed delimiter\n41 |         \
    \    if char_pos > 0 {\n   |                             - unclosed delimiter\n\
    ...\n54 |                 } else if c == open_char {\n   |                   \
    \                       - this delimiter might not be properly closed...\n...\n\
    59 | }\n   | - ...as it matches this but it has different indentation\n...\n75\
    \ | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpggtits1a.rs:12:29\n   |\n12 |     let mut opening_chars = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpggtits1a.rs:13:28\n   |\n13 |     let mut closed_chars = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpggtits1a.rs:14:32\n   |\n14 |     let mut opening_brackets = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpggtits1a.rs:15:32\n   |\n15 |     let mut closing_brackets = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpggtits1a.rs:17:14\n\
    \   |\n17 |     for c in &brackets {\n   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7hzprgq8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut result = false;\n    for i in 0..brackets.len()\
    \ - 2 {\n        let opening = brackets[i];\n        let closing = brackets[i\
    \ + 1];\n        let opening_end = brackets[i + 2];\n        let opening_end =\
    \ if opening_end == \"<\" {\n            \"<\"\n        } else {\n           \
    \ opening_end\n        };\n        if opening == \">\" && closing == \"<\" {\n\
    \            i += 2;\n        } else {\n            if opening != \">\" || closing\
    \ != opening_end {\n                result = false;\n                break;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41bhtka7.rs:14:23\n\
    \   |\n14 |         let opening = brackets[i];\n   |                       ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp41bhtka7.rs:15:23\n   |\n15 |         let closing = brackets[i\
    \ + 1];\n   |                       ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp41bhtka7.rs:16:27\n   |\n16 |         let opening_end = brackets[i\
    \ + 2];\n   |                           ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::R"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = String::new();\n    let mut stack =\
    \ Vec::new();\n    stack.resize(brackets.len(), false);\n    for c in &brackets\
    \ {\n        if *c == '>' {\n            while let Some(popped) = stack.pop()\
    \ {\n                *popped = true;\n            }\n            current.push('>');\n\
    \            stack.resize(stack.len() + 1, true);\n        }\n        *current\
    \ += *c;\n    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp4nznyzt2.rs:15:14\n\
    \   |\n15 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmp4nznyzt2.rs:18:17\n\
    \   |\n18 |                 *popped = true;\n   |                 ^^^^^^^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0inyxsjc.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    brackets.split(|c| {\n        if c ==\
    \ '<' {\n            opening_brackets.push(c);\n        } else if c == '>' {\n\
    \            closing_brackets.push(c);\n        } else if c == '<' || c == '>'\
    \ {\n            opening_brackets.push(c);\n            closing_brackets.push(c);\n\
    \        }\n        false\n    }).is_ok()\n        && (opening_brackets.len()\
    \ == closing_brackets.len())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp8fklk115.rs:24:8\n   |\n24 |     }).is_ok()\n\
    \   |        ^^^^^ method not found in `std::str::Split<'_, [closure@/tmp/tmp8fklk115.rs:14:20:\
    \ 24:6]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    let mut\
    \ is_open = false;\n    loop {\n        if brackets.len() == 0 {\n           \
    \ return is_open;\n        }\n        if brackets[0] == '>' {\n            brackets\
    \ = &brackets[1..];\n        } else {\n            is_open = brackets[0] == '<';\n\
    \            brackets = &brackets[1..];\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpl2sfnuiy.rs:18:12\n   |\n18 |         if brackets[0] == '>' {\n   |\
    \            ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   =\
    \ help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl2sfnuiy.rs:19:24\n   |\n12 |     let mut brackets\
    \ = brackets.to_string();\n   |                        -------------------- expected\
    \ due to this value\n...\n19 |             brackets = &brackets[1..];\n   |  \
    \                      ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n19 |             brackets =\
    \ (&brackets[1..]).to_string();\n   |                        +              +++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpl2sfnuiy.rs:21:23\n\
    \   |\n21 |             is_open = brackets[0] == '<';\n   |                  \
    \     ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl2sfnuiy.rs:22:24\n   |\n12 |     let mut brackets\
    \ = brackets.to_string();\n   |                        -------------------"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opens = String::new();\n    let mut closes =\
    \ String::new();\n    for ch in brackets {\n        if ch.is_digit(|| ch < '0'\
    \ || ch > '9') {\n            opens.push('0' + ch.to_digit(10));\n        } else\
    \ {\n            opens.push(ch);\n        }\n    }\n    for ch in brackets.chars().rev()\
    \ {\n        if ch.is_digit(|| ch < '0' || ch > '9') {\n            closes.push('0'\
    \ + ch.to_digit(10));\n        } else {\n            closes.push(ch);\n      \
    \  }\n    }\n    opens.len() != closes.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_txg63y5.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_txg63y5.rs:22:24\n   |\n22 |         if ch.is_digit(||\
    \ ch < '0' || ch > '9') {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found closure\n   |\n   = note: expected type `u32`\n      \
    \     found closure `[closure@/tmp/tmp_txg63y5.rs:22:24: 22:47]`\n\nerror[E0369]:\
    \ cannot add `Option<u32>` to `char`\n  --> /tmp/tmp_txg63y5.rs:23:29\n   |\n\
    23 |             closes.push('0' + ch.to_digit(10));\n   |                   \
    \      --- ^ --------------- Option<u32>\n   |                         |\n   |\
    \                         char\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c < '<' || c > '>')\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkoy5hk5_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n\n    let mut pos = 0;\n    while pos < brackets.len()\
    \ {\n        let mut found_opening = false;\n        let mut found_closing = false;\n\
    \n        if brackets[pos] == '<' {\n            opening_brackets.push(brackets[pos]);\n\
    \            found_opening = true;\n        }\n        else {\n            if\
    \ opening_brackets.is_empty() {\n                return false;\n            }\n\
    \n            if found_opening {\n                closing_brackets.push(brackets[pos]);\n\
    \                found_closing = true;\n            }\n            else {\n  \
    \              // this brackets doesn't close any opening bracket\n          \
    \      return false;\n            }\n        }\n\n        pos += 1;\n    }\n\n\
    \    if opening_brackets.is_empty() {\n        // we're just left with the opening\
    \ bracket\n        return !closing_brackets.is_empty();\n    }\n\n    if closing_brackets.is_empty()\
    \ {\n        // we're just left with just one closing bracket\n        return\
    \ opening_brackets.len() == 1;\n    }\n\n    // we're left with two or more closing\
    \ brackets\n    opening_brackets.len() >= closing_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9_4pn12z.rs:20:12\n\
    \   |\n20 |         if brackets[pos] == '<' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_4pn12z.rs:21:35\n   |\n21 |             opening_brackets.push(brackets[pos]);\n\
    \   |                                   ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_4pn12z.rs:30:39\n   |\n30 |                 closing_brackets.push(brackets[pos]);\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \         "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets: Vec<_> = brackets.chars().collect();\n\
    \    open_brackets.sort();\n    let mut close_brackets: Vec<_> = open_brackets.clone();\n\
    \    close_brackets.pop();\n    let mut open_bracket: Vec<_> = Vec::new();\n \
    \   let mut close_bracket: Vec<_> = Vec::new();\n    let mut open: usize = 0;\n\
    \    let mut close: usize = 0;\n    let mut c: char = ' ';\n    while open_brackets.len()\
    \ > 0 || close_brackets.len() > 0 {\n        match open_brackets.len() {\n   \
    \         0 => match close_brackets.len() {\n                0 => true,\n    \
    \            1 => false,\n                2 => close_bracket.pop(),\n        \
    \        _ => false,\n            },\n            1 => close_bracket.pop(),\n\
    \            _ => {\n                open_bracket = open_bracket.clone();\n  \
    \              close_bracket = close_bracket.clone();\n                open =\
    \ open_bracket.len();\n                close = close_bracket.len();\n        \
    \        open_bracket.pop();\n                close_bracket.pop();\n         \
    \       c = open_brackets.len() > close ? '<' : '>';\n            }\n        }\n\
    \    }\n    open_brackets.contains(&c) && open_brackets.contains(&c)\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `'<'`\n\
    \  --> /tmp/tmpaci_gqrt.rs:37:51\n   |\n37 |                 c = open_brackets.len()\
    \ > close ? '<' : '>';\n   |                                                 \
    \  ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpaci_gqrt.rs:26:22\n   |\n23 |  \
    \             0 => match close_brackets.len() {\n   |  __________________-\n24\
    \ | |                 0 => true,\n   | |                      ---- this is found\
    \ to be of type `bool`\n25 | |                 1 => false,\n   | |           \
    \           ----- this is found to be of type `bool`\n26 | |                 2\
    \ => close_bracket.pop(),\n   | |                      ^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n27 | |                 _ => false,\n28 | |    \
    \         },\n   | |_____________- `match` arms have incompatible types\n   |\n\
    \   = note: expected type `bool`\n              found enum `Option<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left_bracket = String::new();\n    let mut right_bracket\
    \ = String::new();\n\n    for bracket in brackets.chars() {\n        match bracket\
    \ {\n            '<' => left_bracket.push('<'),\n            '>' => right_bracket.push('>'),\n\
    \            _ => {}\n        }\n    }\n    (left_bracket.len() == 1) && (right_bracket.len()\
    \ == 1)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp33kckji.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() == 0 {\n        return false;\n   \
    \ }\n    \n    let mut last: usize = 0;\n    let mut first: usize = brackets.len();\n\
    \    let mut opening_found = false;\n    let mut closing_found = false;\n    \n\
    \    while first < brackets.len() {\n        let mut current = first;\n      \
    \  \n        while current < brackets.len() {\n            if brackets[current]\
    \ == \">\" {\n                closing_found = true;\n            } else {\n  \
    \              opening_found = true;\n            }\n            \n          \
    \  current += 1;\n        }\n        \n        if opening_found && closing_found\
    \ {\n            return false;\n        }\n        \n        last = current -\
    \ 1;\n        \n        if opening_found {\n            if brackets[last] == \"\
    >\" {\n                opening_found = false;\n            } else {\n        \
    \        opening_found = true;\n            }\n        }\n        \n        if\
    \ closing_found {\n            if brackets[last] == \"<\" {\n                closing_found\
    \ = false;\n            } else {\n                closing_found = true;\n    \
    \        }\n        }\n        \n        first += 1;\n    }\n    \n    opening_found\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq048vkza.rs:25:16\n\
    \   |\n25 |             if brackets[current] == \">\" {\n   |                ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq048vkza.rs:41:16\n   |\n41 |             if brackets[last] ==\
    \ \">\" {\n   |                ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq048vkza.rs:49:16\n   |\n49 |             if brackets[last] ==\
    \ \"<\" {\n   |                ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut in_bracket = false;\n    let mut last_open_bracket\
    \ = Some(String::new());\n    for ch in brackets {\n        if ch == '<' {\n \
    \           if !in_bracket {\n                last_open_bracket = Some(String::new());\n\
    \            }\n            in_bracket = true;\n        } else {\n           \
    \ if in_bracket {\n                last_open_bracket = Some(String::new());\n\
    \            }\n            in_bracket = false;\n        }\n        last_open_bracket.unwrap().push(ch);\n\
    \    }\n    if last_open_bracket.is_some() {\n        // last opening bracket\
    \ was never closed\n        return false;\n    }\n    for ch in brackets {\n \
    \       if !in_bracket && ch != '<' {\n            // brackets are all closed\n\
    \            return false;\n        }\n    }\n    // brackets are all open\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpi0mj4qoi.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpi0mj4qoi.rs:32:15\n   |\n32 |   \
    \  for ch in brackets {\n   |               ^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = 0;\n    let mut close = 0;\n\n    for\
    \ ch in brackets {\n        if ch == '<' {\n            open += 1;\n        }\
    \ else {\n            close += 1;\n        }\n    }\n\n    (open >= close)\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmprp6si4jo.rs:23:5\n\
    \   |\n23 |     (open >= close)\n   |     ^             ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n23 -     (open >= close)\n\
    23 +     open >= close\n   | \n\nerror[E0277]: `String` is not an iterator\n \
    \ --> /tmp/tmprp6si4jo.rs:15:15\n   |\n15 |     for ch in brackets {\n   |   \
    \            ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9tzfmq1j.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening = brackets.chars();\n    let mut closing\
    \ = brackets.chars();\n    let mut next_open = String::new();\n    let mut next_close\
    \ = String::new();\n    let mut last_open = String::new();\n    let mut last_close\
    \ = String::new();\n    let mut in_double_bracket = false;\n    let mut open =\
    \ opening.next().unwrap();\n    let mut close = closing.next().unwrap();\n   \
    \ while open != close {\n        last_open = open;\n        last_close = close;\n\
    \        open = opening.next().unwrap();\n        close = closing.next().unwrap();\n\
    \    }\n    if last_open != last_close {\n        closing = brackets.chars().skip(opening.next());\n\
    \        closing = closing.take_while(|&c| c != '<');\n        closing = closing.collect::<String>();\n\
    \        last_close = closing;\n    }\n    for c in opening.chars() {\n      \
    \  next_open = String::new();\n        next_close = String::new();\n        in_double_bracket\
    \ = false;\n        if c == close {\n            if last_close == last_open {\n\
    \                next_open = \">\";\n            } else {\n                next_open\
    \ = \"<\";\n                in_double_bracket = true;\n            }\n       \
    \     next_close = close;\n        } else if c == open {\n            if last_open\
    \ == last_close {\n                next_close = open;\n            } else {\n\
    \                next_open = open;\n                in_double_bracket = true;\n\
    \            }\n            next_close = close;\n        }\n        open = next_open;\n\
    \        close = next_close;\n    }\n    if in_double_bracket {\n        false\n\
    \    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjaf7eufp.rs:22:21\n   |\n\
    16 |     let mut last_open = String::new();\n   |                         -------------\
    \ expected due to this value\n...\n22 |         last_open = open;\n   |      \
    \               ^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                     |\n   |                     expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjaf7eufp.rs:23:22\n\
    \   |\n17 |     let mut last_close = String::new();\n   |                    \
    \      ------------- expected due to this value\n...\n23 |         last_close\
    \ = close;\n   |                      ^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                      |\n   |                      expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjaf7eufp.rs:28:41\n\
    \   |\n28 |         closing = brackets.chars().skip(opening.next());\n   |   \
    \                                      ^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjaf7eufp.rs:28:19\n\
    \   |\n13 |     let mut closing = brackets.chars();\n   |                    \
    \   ---------------- expected due to this value\n...\n28 |         closing = brackets.chars().skip(opening.next());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Chars`, found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \              found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjaf7eufp.rs:29:19\n   |\n13 |     let mut closing = brackets.chars();\n\
    \   |                       ---------------- expected due to this value\n...\n\
    29 |         closing = closing.take_while(|&c| c != '<');\n   |              \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct\
    \ `TakeWhile`\n   |\n   = note: expected struct `Chars<'_>`\n              found\
    \ struct `TakeWhile<Chars<'_>, [closure@/tmp/tmpjaf7eufp.rs:29:38: 29:51]>`\n\n\
    error[E0308"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().skip_while(|c| c != '<').all(|c| c ==\
    \ '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu25_u0v3.rs:12:39\n\
    \   |\n12 |     brackets.chars().skip_while(|c| c != '<').all(|c| c == '>')\n\
    \   |                                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter(|x| x == '<').any() && brackets.chars().filter(|x|\
    \ x == '>').any()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpksuxsiz0.rs:12:35\n\
    \   |\n12 |     brackets.chars().filter(|x| x == '<').any() && brackets.chars().filter(|x|\
    \ x == '>').any()\n   |                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \   --> /tmp/tmpksuxsiz0.rs:12:43\n     |\n12   |     brackets.chars().filter(|x|\
    \ x == '<').any() && brackets.chars().filter(|x| x == '>').any()\n     |     \
    \                                      ^^^- supplied 0 arguments\n     |     \
    \                                      |\n     |                             \
    \              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpksuxsiz0.rs:12:82\n\
    \   |\n12 |     brackets.chars().filter(|x| x == '<').any() && brackets.chars().filter(|x|\
    \ x == '>').any()\n   |                                                      \
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpksuxsiz0.rs:12:90\n\
    \     |\n12   |     brackets.chars().filter(|x| x == '<').any() && brackets.chars().filter(|x|\
    \ x == '>').any()\n     |                                                    \
    \                                      ^^^- supplied 0 arguments\n     |     \
    \                                                                            \
    \         |\n     |                                                          \
    \                                expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277.\nFor more information about an error,\
    \ try `ru"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt4rwduml.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '<')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut it = brackets.chars();\n    let mut has_closing_bracket\
    \ = false;\n    let mut open_bracket: char = '\\0';\n    let mut close_bracket:\
    \ char = '\\0';\n    loop {\n        let next = it.next();\n        match next\
    \ {\n            Some('>') => {\n                open_bracket = next.unwrap();\n\
    \                has_closing_bracket = true;\n            }\n            Some('<')\
    \ => {\n                close_bracket = next.unwrap();\n                has_closing_bracket\
    \ = has_closing_bracket\n                    && (open_bracket == close_bracket);\n\
    \            }\n            _ => break,\n        }\n    }\n    has_closing_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb5h51a3o.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4pwvko5x.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.chars().all(|c| *c < '<' || *c > '>') {\n\
    \        panic!(\"Not a valid character set: {}\", brackets);\n    }\n    let\
    \ mut found = false;\n    for c in brackets {\n        if *c == '<' {\n      \
    \      found = true;\n        } else if *c == '>' {\n            found = false;\n\
    \        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpd5p8g41t.rs:12:33\n\
    \   |\n12 |     if brackets.chars().all(|c| *c < '<' || *c > '>') {\n   |    \
    \                             ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpd5p8g41t.rs:12:45\n   |\n12 |     if brackets.chars().all(|c| *c\
    \ < '<' || *c > '>') {\n   |                                             ^^\n\n\
    error[E0277]: `String` is not an iterator\n  --> /tmp/tmpd5p8g41t.rs:16:14\n \
    \  |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.chars().any(|c| !c.is_ascii_letter()) {\n\
    \        return false;\n    }\n\n    let mut has_correct_bracketing = false;\n\
    \n    let mut open_tags = vec!['b'];\n    while let Some(open_tag) = open_tags.next()\
    \ {\n        if let Some(close_tag) = open_tags.last_mut() {\n            let\
    \ close_tag_index = close_tag - 1;\n            if let Some(close_tag) = (\n \
    \               brackets\n                    .char_indices()\n              \
    \      .skip_while(|&&(idx, _)| idx < open_tag.len())\n                    .next()\n\
    \            ) {\n                let close_tag_char: char = close_tag[close_tag_index];\n\
    \                if open_tag != close_tag_char {\n                    has_correct_bracketing\
    \ = false;\n                    break;\n                }\n            } else\
    \ {\n                has_correct_bracketing = false;\n                break;\n\
    \            }\n        }\n    }\n\n    has_correct_bracketing\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmpv9_9bd8_.rs:22:38\n   |\n22 |               if let Some(close_tag) =\
    \ (\n   |  ______________________________________^\n23 | |                 brackets\n\
    \   | |________________^\n...\n26 |                       .next()\n   |  ____________________________^\n\
    27 | |             ) {\n   | |_____________^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 ~             if let\
    \ Some(close_tag) = brackets\n23 |                     .char_indices()\n24 | \
    \                    .skip_while(|&&(idx, _)| idx < open_tag.len())\n25 ~    \
    \                 .next() {\n   |\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpv9_9bd8_.rs:12:36\n\
    \   |\n12 |     if brackets.chars().any(|c| !c.is_ascii_letter()) {\n   |    \
    \                                ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `next`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpv9_9bd8_.rs:19:42\n\
    \   |\n19 |     while let Some(open_tag) = open_tags.next() {\n   |          \
    \                                ^^^^ method not found in `Vec<char>`\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `&mut char`\n  --> /tmp/tmpv9_9bd8_.rs:21:45\n\
    \   |\n21 |             let close_tag_index = close_tag - 1;\n   |           \
    \                        --------- ^ - {integer}\n   |                       \
    \            |\n   |                                   &mut char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv9_9bd8_.rs:25:35\n   |\n25 |              \
    \       .skip_while(|&&(idx, _)| idx < open_tag.len())\n   |                 \
    \                  ^^^^^^^^-\n   |                                   |       |\n\
    \   |                                   |       expected due to this\n   |   \
    \                                expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(usize, char)`\n           found reference `&_`\n\nerror[E0608]:\
    \ cannot index into a value "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_pair = false;\n    let mut found = false;\n\
    \n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n \
    \       if c == \">\" || c == \"<\" {\n            if stack.len() == 2 {\n   \
    \             has_pair = true;\n                found = true;\n            } else\
    \ {\n                stack.push(c);\n            }\n        } else {\n       \
    \     stack.push(c);\n        }\n    }\n\n    has_pair && found\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjt3cl_29.rs:17:17\n   |\n\
    17 |         if c == \">\" || c == \"<\" {\n   |                 ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n17 |         if c == '>' || c == \"<\" {\n   |        \
    \         ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjt3cl_29.rs:17:29\n\
    \   |\n17 |         if c == \">\" || c == \"<\" {\n   |                      \
    \       ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a\
    \ `char` literal, use single quotes\n   |\n17 |         if c == \">\" || c ==\
    \ '<' {\n   |                             ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjt3cl_29.rs:22:28\n   |\n22 |                 stack.push(c);\n\
    \   |                            ^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjt3cl_29.rs:25:24\n   |\n25 |             stack.push(c);\n\
    \   |                        ^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptmx0pf0w.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjplshydu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if !brackets.chars().any(|c| *c == '<') {\n        true\n\
    \    } else if !brackets.chars().any(|c| *c == '>') {\n        false\n    } else\
    \ {\n        if let Some(i) = brackets.find('<') {\n            if let Some(j)\
    \ = brackets.find('>') {\n                if i == j {\n                    false\n\
    \                } else {\n                    let rest = brackets.to_string()[i..].to_string();\n\
    \                    rest.chars().any(|c| c != '<')\n                }\n     \
    \       } else {\n                false\n            }\n        } else {\n   \
    \         false\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp33l3thij.rs:12:34\n\
    \   |\n12 |     if !brackets.chars().any(|c| *c == '<') {\n   |              \
    \                    ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp33l3thij.rs:14:41\n   |\n14 |     } else if !brackets.chars().any(|c|\
    \ *c == '>') {\n   |                                         ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_iter = brackets.chars().filter_map(|c|\
    \ {\n        if c == '<' {\n            Some('>')\n        } else if c == '>'\
    \ {\n            Some('<')\n        } else {\n            None\n        }\n  \
    \  });\n    let mut current_opening_bracket: Option<char> = None;\n    for c in\
    \ brackets_iter {\n        if c.is_none() {\n            return false;\n     \
    \   } else if c.unwrap() == '<' {\n            if current_opening_bracket.is_none()\
    \ {\n                current_opening_bracket = Some(c);\n            }\n     \
    \   } else {\n            if current_opening_bracket.is_none() {\n           \
    \     return false;\n            } else if current_opening_bracket.unwrap() ==\
    \ '<' {\n                current_opening_bracket = None;\n            }\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_none` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpojvad3j1.rs:23:14\n   |\n23 |         if c.is_none() {\n\
    \   |              ^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpojvad3j1.rs:25:21\n\
    \   |\n25 |         } else if c.unwrap() == '<' {\n   |                     ^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // This uses a simple stack to determine whether the\
    \ brackets are balanced.\n    let mut stack: Vec<_> = Vec::new();\n    stack.append(vec![']']);\n\
    \n    for bracket in brackets.chars() {\n        match stack.pop() {\n       \
    \     None => return false,\n            Some(last) => if bracket == last {\n\
    \                stack.append(vec![']']);\n            } else {\n            \
    \    return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4pdlnbkz.rs:14:18\n   |\n\
    14 |     stack.append(vec![']']);\n   |                  ^^^^^^^^^ expected `&mut\
    \ Vec<_>`, found struct `Vec`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                         found struct `Vec<char>`\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4pdlnbkz.rs:20:30\n\
    \   |\n20 |                 stack.append(vec![']']);\n   |                   \
    \           ^^^^^^^^^ expected `&mut Vec<char>`, found struct `Vec`\n   |\n  \
    \ = note: expected mutable reference `&mut Vec<char>`\n                      \
    \   found struct `Vec<char>`\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"<\") && brackets.contains(\">\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp50krhuq2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 1;\n    let mut open = brackets.find(\"\
    <\");\n    let mut close = brackets.find(\">\");\n    while close < open {\n \
    \       open += 1;\n        close += 1;\n        if close < open {\n         \
    \   open -= 1;\n        } else {\n            count += 1;\n        }\n    }\n\
    \    count > 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Option<usize>`\n  --> /tmp/tmpsk1g57tg.rs:16:9\n   |\n16 |         open +=\
    \ 1;\n   |         ----^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `Option<usize>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Option<usize>`\n  --> /tmp/tmpsk1g57tg.rs:17:9\n   |\n17\
    \ |         close += 1;\n   |         -----^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `Option<usize>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpsk1g57tg.rs:19:13\n\
    \   |\n19 |             open -= 1;\n   |             ----^^^^^\n   |         \
    \    |\n   |             cannot use `-=` on type `Option<usize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<bool> = vec![];\n    for c in &brackets\
    \ {\n        stack.push(!stack.contains(c));\n    }\n    stack.pop().unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp96kw7ydf.rs:13:14\n\
    \   |\n13 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().take_while(|c| c.is_ascii()).all(|c|\
    \ {\n        c != '<' && c != '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdqgjiise.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = VecDeque::new();\n    stack.push_back(\"\
    \");\n    for (i, c) in brackets.chars().enumerate() {\n        if c == '<' {\n\
    \            let mut b = String::new();\n            let mut s = String::new();\n\
    \            while !stack.empty() && stack.front().len() == i {\n            \
    \    b.push('<');\n                s.push('>');\n                stack.pop_front();\n\
    \            }\n            stack.push_back(b.into());\n        } else {\n   \
    \         let mut b = String::new();\n            let mut s = String::new();\n\
    \            while !stack.empty() && stack.front().len() == i {\n            \
    \    b.push('>');\n                s.push('<');\n                stack.pop_front();\n\
    \            }\n            stack.push_back(b.into());\n        }\n    }\n   \
    \ stack.last().is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpq9_r414p.rs:12:21\n   |\n12 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<Vec<bool>> = Vec::new();\n\n    for\
    \ bracket in brackets {\n        if bracket == '<' {\n            stack.push(Vec::new());\n\
    \        } else {\n            let mut last_item = stack.last().unwrap();\n  \
    \          if last_item.len() != 0 {\n                last_item.push(false);\n\
    \            }\n            stack.last_mut().unwrap().push(true);\n        }\n\
    \    }\n\n    for mut stack in stack.iter_mut() {\n        if !stack.is_empty()\
    \ {\n            *stack.last_mut().unwrap() = false;\n        }\n    }\n\n   \
    \ stack.iter().all(|&x| x).unwrap_or(false)\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpumbg9zd9.rs:14:20\n\
    \   |\n14 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpumbg9zd9.rs:32:27\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                            ---- expected\
    \ `bool` because of return type\n...\n32 |     stack.iter().all(|&x| x).unwrap_or(false)\n\
    \   |                           ^ expected `bool`, found struct `Vec`\n   |\n\
    \   = note: expected type `bool`\n            found struct `Vec<bool>`\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmpumbg9zd9.rs:32:30\n   |\n32 |     stack.iter().all(|&x| x).unwrap_or(false)\n\
    \   |                              ^^^^^^^^^ method not found in `bool`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = String::from(brackets);\n    while\
    \ let Some(b) = brackets.chars().next() {\n        if b != '<' {\n           \
    \ return false;\n        }\n        if let Some(next) = brackets.chars().next()\
    \ {\n            if next == '>' {\n                // closing bracket not present,\
    \ so not correct.\n                return false;\n            }\n            if\
    \ next == '<' {\n                // closing bracket present, but no opening bracket.\n\
    \                return false;\n            }\n            // closing bracket\
    \ present, but opening bracket missing.\n            brackets = &brackets[..(brackets.len()\
    \ - b + 1)];\n        } else {\n            // closing bracket present, and no\
    \ opening bracket.\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `char` from `usize`\n  --> /tmp/tmprih0d9wb.rs:27:52\n\
    \   |\n27 |             brackets = &brackets[..(brackets.len() - b + 1)];\n  \
    \ |                                                    ^ no implementation for\
    \ `usize - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprih0d9wb.rs:27:24\n\
    \   |\n12 |     let mut brackets = String::from(brackets);\n   |             \
    \           ---------------------- expected due to this value\n...\n27 |     \
    \        brackets = &brackets[..(brackets.len() - b + 1)];\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n27 |             brackets\
    \ = (&brackets[..(brackets.len() - b + 1)]).to_string();\n   |               \
    \         +                                     +++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .chars()\n        .filter(|c| *c !=\
    \ '<')\n        .any(|c| *c != '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy7muv_63.rs:15:18\n\
    \   |\n15 |         .any(|c| *c != '>')\n   |                  ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"<\") && brackets.contains(\">\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvsab1t0y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .chars()\n        .any(|b| b == b'<'\
    \ || b == b'>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1g7378j2.rs:14:23\n   |\n\
    14 |         .any(|b| b == b'<' || b == b'>')\n   |                       ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g7378j2.rs:14:36\n\
    \   |\n14 |         .any(|b| b == b'<' || b == b'>')\n   |                   \
    \                 ^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left_brackets = String::new();\n    let mut right_brackets\
    \ = String::new();\n\n    let mut opening_brackets = String::new();\n    let mut\
    \ opening_left_brackets = String::new();\n    let mut opening_right_brackets =\
    \ String::new();\n\n    let mut closing_left_brackets = String::new();\n    let\
    \ mut closing_right_brackets = String::new();\n\n    for b in brackets.chars()\
    \ {\n        if b == '<' {\n            left_brackets.push_str(\"<<\");\n    \
    \        opening_left_brackets.push_str(\"<<\");\n            opening_brackets.push_str(\"\
    <<\");\n            opening_right_brackets.push_str(\"<<\");\n            closing_left_brackets.push_str(\"\
    <<\");\n            closing_right_brackets.push_str(\"<<\");\n        }\n    \
    \    if b == '>' {\n            left_brackets.push_str(\">>\");\n            opening_left_brackets.push_str(\"\
    >>\");\n            opening_brackets.push_str(\">>\");\n            opening_right_brackets.push_str(\"\
    >>\");\n            closing_left_brackets.push_str(\">>\");\n            closing_right_brackets.push_str(\"\
    >>\");\n        }\n        if b == '{' {\n            left_brackets.push_str(\"\
    {\");\n            opening_left_brackets.push_str(\"{\");\n            opening_brackets.push_str(\"\
    {\");\n            opening_right_brackets.push_str(\"{\");\n            closing_left_brackets.push_str(\"\
    {\");\n            closing_right_brackets.push_str(\"{\");\n        }\n      \
    \  if b == '}' {\n            left_brackets.push_str(\"}\");\n            opening_left_brackets.push_str(\"\
    }\");\n            opening_brackets.push_str(\"}\");\n            opening_right_brackets.push_str(\"\
    }\");\n            closing_left_brackets.push_str(\"}\");\n            closing_right_brackets.push_str(\"\
    }\");\n        }\n    }\n\n    if left_brackets.len() != right_brackets.len()\
    \ {\n        return false;\n    }\n\n    let mut stack = vec![left_brackets, right_brackets];\n\
    \n    while !stack.is_empty() {\n        let mut cur = stack.pop().unwrap();\n\
    \        let mut next = stack.pop().unwrap();\n\n        if cur.len() != next.len()\
    \ {\n            return false;\n        }\n\n        for (i, c) in cur.chars().zip(next.chars()).skip(1)\
    \ {\n            if c != b' ' {\n                return false;\n            }\n\
    \        }\n    }\n\n    if opening_left_brackets.len() != opening_right_brackets.len()\
    \ {\n        return false;\n    }\n\n    if \n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpqs2ll379.rs:83:1\n\
    \   |\n83 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqs2ll379.rs:72:21\n   |\n72 |             if c != b' ' {\n   |\
    \                     ^^^^ expected `char`, found `u8`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut closed = false;\n    let mut open = brackets.chars().enumerate().filter(|(_,\
    \ b)| {\n        if b == '>' {\n            closed = true;\n            false\n\
    \        } else {\n            true\n        }\n    });\n    for (b, e) in open\
    \ {\n        if closed.unwrap() && b == '>' {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptpoqspfy.rs:14:14\n\
    \   |\n14 |         if b == '>' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `unwrap` found for type `bool` in the current scope\n\
    \  --> /tmp/tmptpoqspfy.rs:22:19\n   |\n22 |         if closed.unwrap() && b ==\
    \ '>' {\n   |                   ^^^^^^ method not found in `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptpoqspfy.rs:22:36\n   |\n22 |         if closed.unwrap()\
    \ && b == '>' {\n   |                                    ^^^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    brackets.split('<').filter_map(|x| {\n        if x.chars().count()\
    \ == 1 {\n            open_brackets.push_str(x);\n            Some(String::new())\n\
    \        } else {\n            closed_brackets.push_str(x);\n            Some(String::new())\n\
    \        }\n    }).count();\n    if open_brackets.len() != closed_brackets.len()\
    \ {\n        return false;\n    }\n    for i in 0..open_brackets.len() {\n   \
    \     let opening_bracket = open_brackets[i];\n        if opening_bracket != closed_brackets[i]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiwmoni_l.rs:27:31\n\
    \   |\n27 |         let opening_bracket = open_brackets[i];\n   |            \
    \                   ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpiwmoni_l.rs:28:31\n   |\n28 |         if opening_bracket != closed_brackets[i]\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == 1 && *brackets.unwrap() == '<' &&\n\
    \        !brackets.chars().any(|c| c == '>')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgjya5b1p.rs:12:38\n   |\n12 |     brackets.len()\
    \ == 1 && *brackets.unwrap() == '<' &&\n   |                                 \
    \     ^^^^^^ method not found in `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.split_whitespace().count() > 0 && brackets.chars().any(|c|\
    \ !c.is_alphanumeric())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpugh3k5jd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|b| b == '<' || b == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplcq33_ez.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    let mut found\
    \ = false;\n    for ch in brackets.chars().filter_map(|ch| ch == ' ' || ch ==\
    \ '>' || ch == '<') {\n        match ch {\n            '>' => {\n            \
    \    if !found || stack.contains(stack.len() - 1) {\n                    found\
    \ = false;\n                    stack.push(i);\n                }\n          \
    \  }\n            '<' => {\n                if !found || stack.contains(stack.len()\
    \ - 1) {\n                    found = false;\n                    stack.push(i);\n\
    \                }\n            }\n            ' ' => {\n                if !found\
    \ || stack.contains(stack.len() - 1) {\n                    found = false;\n \
    \                   stack.push(i);\n                }\n            }\n       \
    \     _ => {\n                if !found || stack.contains(stack.len() - 1) {\n\
    \                    found = false;\n                    stack.push(i);\n    \
    \            }\n            }\n        }\n    }\n\n    stack.contains(stack.len())\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmppqm5aa6v.rs:19:32\n\
    \   |\n19 |                     stack.push(i);\n   |                         \
    \       ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this\
    \ scope\n  --> /tmp/tmppqm5aa6v.rs:25:32\n   |\n25 |                     stack.push(i);\n\
    \   |                                ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmppqm5aa6v.rs:31:32\n   |\n\
    31 |                     stack.push(i);\n   |                                ^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmppqm5aa6v.rs:37:32\n   |\n37 |                     stack.push(i);\n\
    \   |                                ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppqm5aa6v.rs:14:48\n   |\n14 |     for ch in\
    \ brackets.chars().filter_map(|ch| ch == ' ' || ch == '>' || ch == '<') {\n  \
    \ |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |     for ch in brackets.chars().filter_map(|ch| Some(ch == ' ' || ch\
    \ == '>' || ch == '<')) {\n   |                                              \
    \  +++++                                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppqm5aa6v.rs:17:45\n   |\n17 |                 if !found || stack.contains(stack.len()\
    \ - 1) {\n   |                                             ^^^^^^^^^^^^^^^\n \
    \  |                                             |\n   |                     \
    \                        expected `&usize`, found `usize`\n   |              \
    \                               help: consider borrowing here: `&(stack.len()\
    \ - 1)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqm5aa6v.rs:23:45\n \
    \  |\n23 |                 if !found || stack.contains(stack.len() - 1) {\n  \
    \ |                                             ^^^^^^^^^^^^^^^\n   |        \
    \                                     |\n "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = String::from(brackets);\n    let mut\
    \ open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for b in brackets.chars() {\n        if b == '<' {\n            open_brackets.push(b);\n\
    \        } else {\n            close_brackets.push(b);\n        }\n    }\n   \
    \ close_brackets.reverse();\n    if open_brackets != close_brackets {\n      \
    \  return false;\n    }\n    for b in open_brackets.chars() {\n        if b !=\
    \ '>' {\n            return false;\n        }\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3kajacr2.rs:22:20\n   |\n22 |     close_brackets.reverse();\n\
    \   |                    ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut pos = 0;\n    let mut bracket_pos = 0;\n    let\
    \ mut bracket_end = 0;\n    let mut depth = 0;\n\n    loop {\n        let chars:\
    \ Vec<char> = brackets.chars().collect();\n        bracket_end += 1;\n       \
    \ pos %= brackets.len();\n        let next_opening = chars[pos] == '<';\n    \
    \    let next_closing = chars[pos] == '>';\n        let next_closed = chars[pos]\
    \ == '<';\n\n        if next_opening {\n            bracket_pos += 1;\n      \
    \      depth += 1;\n        }\n\n        if next_closing {\n            depth\
    \ -= 1;\n        }\n\n        pos %= brackets.len();\n        if depth == 0 {\n\
    \            if bracket_pos == bracket_end {\n                return true;\n \
    \           }\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for s in brackets.chars()\
    \ {\n        if s.is_empty() {\n            continue;\n        }\n        stack.push(s);\n\
    \        if !is_paired(&stack, s.chars().nth(0)) {\n            return false;\n\
    \        }\n    }\n    stack.as_slice() == brackets\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_paired` in this scope\n  --> /tmp/tmpkfdlkahv.rs:18:13\n\
    \   |\n18 |         if !is_paired(&stack, s.chars().nth(0)) {\n   |          \
    \   ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_empty`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpkfdlkahv.rs:14:14\n\
    \   |\n14 |         if s.is_empty() {\n   |              ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpkfdlkahv.rs:18:33\n   |\n18 |         if !is_paired(&stack,\
    \ s.chars().nth(0)) {\n   |                                 ^^^^^ method not found\
    \ in `char`\n\nerror[E0277]: can't compare `&[char]` with `String`\n  --> /tmp/tmpkfdlkahv.rs:22:22\n\
    \   |\n22 |     stack.as_slice() == brackets\n   |                      ^^ no\
    \ implementation for `&[char] == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&[char]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut closed = false;\n    let mut open = false;\n\
    \    for ch in brackets {\n        if ch == \"<\" {\n            open = !open;\n\
    \        } else if ch == \">\" {\n            closed = !closed;\n        }\n \
    \   }\n    open && closed\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp6kk1rgbs.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Special case: if nothing, then do nothing.\n    if\
    \ brackets.is_empty() {\n        return true\n    }\n\n    // Handle case where\
    \ brackets are balanced.\n    let mut current = String::new();\n    let mut next\
    \ = String::new();\n    if brackets.starts_with(\"<>\") {\n        // This handles\
    \ <> case because we only use <>\n        // as a way to determine balanced.\n\
    \        let mut opening_open = true;\n        let mut opening_close = true;\n\
    \        let mut closing_open = true;\n        let mut closing_close = true;\n\
    \        for i in 0..brackets.len() {\n            let mut current_char = brackets[i];\n\
    \            let mut next_char = brackets[i + 1];\n\n            // Handle opening\
    \ bracket.\n            if current_char == '>' {\n                opening_close\
    \ = false;\n                closing_open = false;\n            }\n           \
    \ if current_char == '<' {\n                opening_open = false;\n          \
    \      closing_close = false;\n            }\n            if current_char == '('\
    \ && !opening_open && !closing_close {\n                // This handles the case\
    \ where there's an opening bracket\n                // but no corresponding closing\
    \ bracket.\n                current = next.clone();\n                next = String::new();\n\
    \                opening_open = true;\n                opening_close = true;\n\
    \                closing_close = true;\n                continue;\n          \
    \  }\n            if current_char == ')' && opening_close && !opening_open {\n\
    \                // This handles the case where there's a closing bracket\n  \
    \              // but no corresponding opening bracket.\n                opening_open\
    \ = true;\n                closing_open = true;\n                current = next.clone();\n\
    \                next = String::new();\n                opening_close = true;\n\
    \                closing_close = true;\n                continue;\n          \
    \  }\n\n            // Handle closing bracket.\n            if current_char ==\
    \ ')' {\n                opening_open = true;\n                closing_open =\
    \ true;\n                closing_close = false;\n            }\n            if\
    \ current_char == '<' {\n                opening_open = true;\n              \
    \  closing_close = true;\n                closing_open = false;\n            }\n\
    \n            // Handle opening bracket and closing bracket.\n            if opening_open\
    \ {\n                next = next_char;\n                current = current_char;\n\
    \                opening_open = true;\n            }\n            if opening_close\
    \ {\n                next = next_char;\n                current = current_char;\n\
    \                opening_close = true;\n            }\n            if closing_open\
    \ {\n                next = next_char;\n                current = current_char;\n\
    \                closing_open = true;\n            }\n            if closing_close\
    \ {\n                next = next_char;\n                current = current_char;\n\
    \                closing_close = true;\n            }\n\n            // Handle\
    \ opening bracket.\n\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpf35sp25h.rs:114:3\n\
    \    |\n11  | fn correct_bracketing(brackets: String) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n20  |  \
    \   if brackets.starts_with(\"<>\") {\n    |                                 \
    \  - unclosed delimiter\n...\n27  |         for i in 0..brackets.len() {\n   \
    \ |                                    - this delimiter might not be properly\
    \ closed...\n...\n98  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n114 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpf35sp25h.rs:28:36\n   |\n28 |         \
    \    let mut current_char = brackets[i];\n   |                               \
    \     ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf35sp25h.rs:29:33\n   |\n29 |             let mut next_char = brackets[i\
    \ + 1];\n   |                                 ^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `String` with `char`\n  -->"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Test for empty brackets.\n    if !brackets.is_empty()\
    \ {\n        let mut opening_stack: Vec<&str> = vec![];\n        let mut closed_stack:\
    \ Vec<&str> = vec![];\n        for bracket_char in brackets {\n            if\
    \ bracket_char == \"<\" {\n                opening_stack.pop().unwrap();\n   \
    \             closed_stack.push(bracket_char);\n            } else if bracket_char\
    \ == \">\" {\n                let mut next_char_str = closed_stack.pop().unwrap();\n\
    \                next_char_str = String::from(next_char_str) + String::from(bracket_char);\n\
    \                opening_stack.push(next_char_str);\n            } else {\n  \
    \              opening_stack.push(bracket_char);\n            }\n        }\n \
    \       if opening_stack.len() != closed_stack.len() {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpacfyoy7w.rs:16:29\n\
    \   |\n16 |         for bracket_char in brackets {\n   |                     \
    \        ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpacfyoy7w.rs:22:63\n   |\n22 |\
    \                 next_char_str = String::from(next_char_str) + String::from(bracket_char);\n\
    \   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                               |\n   |  \
    \                                                             expected `&str`,\
    \ found struct `String`\n   |                                                \
    \               help: consider borrowing here: `&String::from(bracket_char)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpacfyoy7w.rs:22:33\n   |\n21 |\
    \                 let mut next_char_str = closed_stack.pop().unwrap();\n   | \
    \                                        --------------------------- expected\
    \ due to this value\n22 |                 next_char_str = String::from(next_char_str)\
    \ + String::from(bracket_char);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&(String::from(next_char_str) + String::from(bracket_char))`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm1a4cev_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter_map(|c| match c {\n        '<'\
    \ => Some('>'),\n        '>' => Some('<'),\n        _ => None,\n    }).count()\
    \ > 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmeomd3dd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().enumerate().any(|(i, c)| {\n       \
    \ if c == '>' {\n            i > 0 && brackets[i - 1] == '<'\n        } else {\n\
    \            c == '<' && brackets[i + 1] == '>'\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdbj2ycv.rs:14:22\n\
    \   |\n14 |             i > 0 && brackets[i - 1] == '<'\n   |                \
    \      ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbdbj2ycv.rs:16:25\n   |\n16 |             c == '<' && brackets[i\
    \ + 1] == '>'\n   |                         ^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for opening in brackets.chars().take(8)\
    \ {\n        for closing in brackets.chars().skip(8).take(8) {\n            if\
    \ opening != closing {\n                count += 1;\n            }\n        }\n\
    \    }\n    count == brackets.chars().count() + 8\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8j6xqmkb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut found = false;\n    let mut stack = Vec::new();\n\
    \    let mut iter = brackets.chars();\n    let mut open_bracket = String::new();\n\
    \    let mut closed_bracket = String::new();\n    let mut chars = Vec::new();\n\
    \n    // While there are characters remaining in iter.\n    while let Some(mut\
    \ c) = iter.next() {\n        chars.push(c);\n        if c == '<' {\n        \
    \    // Set current open/closed bracket.\n            open_bracket = String::new();\n\
    \            closed_bracket = String::new();\n        }\n        if c == '>' {\n\
    \            // If open_bracket/close_bracket are empty, this is a \"</>\", so\
    \ we\n            // can just continue.\n            if !open_bracket.is_empty()\
    \ && closed_bracket.is_empty() {\n                continue;\n            }\n \
    \           // Otherwise, add the close bracket to the stack and continue.\n \
    \           stack\n                .push_back(closed_bracket)\n              \
    \  .expect(\"stack overflow\");\n            continue;\n        }\n\n        //\
    \ If open_bracket/close_bracket are empty, this is a \"<\", so add the\n     \
    \   // open bracket to the stack and continue.\n        if !open_bracket.is_empty()\
    \ && closed_bracket.is_empty() {\n            stack.push_back(open_bracket);\n\
    \            continue;\n        }\n\n        // If open_bracket/close_bracket\
    \ are not empty, we are in the middle of\n        // an open/close bracket, so\
    \ just add this character to the\n        // current open bracket and continue.\n\
    \        open_bracket.push(c);\n    }\n\n    // If stack is empty, we just got\
    \ to the end of the string.\n    if stack.len() == 0 {\n        found = true;\n\
    \    }\n\n    // Otherwise, we need to check if the last element of the stack\
    \ is the open\n    // bracket.\n    else {\n        let stack_string = stack.last().to_string();\n\
    \        if stack_string == open_bracket.to_string() {\n            found = true;\n\
    \        }\n    }\n\n    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmpp4x0lsx2.rs:35:18\n   |\n35 |             \
    \    .push_back(closed_bracket)\n   |                  ^^^^^^^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpp4x0lsx2.rs:43:19\n   |\n43 |          \
    \   stack.push_back(open_bracket);\n   |                   ^^^^^^^^^ method not\
    \ found in `Vec<_>`\n\nerror[E0599]: the method `to_string` exists for enum `Option<&_>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpp4x0lsx2.rs:61:41\n\
    \    |\n61  |           let stack_string = stack.last().to_string();\n    |  \
    \                                         ^^^^^^^^^ method cannot be called on\
    \ `Option<&_>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<&_>: std::fmt::Display`\n\
    \            which is required by `Option<&_>: ToString`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == b'<' || c == b'>')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzcj9iue.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == b'<' || c == b'>')\n   |              \
    \                     ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmzcj9iue.rs:12:48\n   |\n12 |     brackets.chars().all(|c|\
    \ c == b'<' || c == b'>')\n   |                                              \
    \  ^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = false;\n    let mut closed = false;\n\
    \    let mut opening_brackets = brackets.chars().filter(|c| c == '<');\n    for\
    \ opening in &mut opening_brackets {\n        if !close {\n            closed\
    \ = true;\n        }\n        if !open {\n            open = true;\n        }\n\
    \        if opening == '>' && !close {\n            close = true;\n        }\n\
    \        if opening == '<' && !open {\n            open = true;\n        }\n \
    \   }\n    open == closed\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `close` in this scope\n  --> /tmp/tmpyu6p7tzy.rs:16:13\n\
    \   |\n16 |         if !close {\n   |             ^^^^^ help: a local variable\
    \ with a similar name exists: `closed`\n\nerror[E0425]: cannot find value `close`\
    \ in this scope\n  --> /tmp/tmpyu6p7tzy.rs:22:31\n   |\n22 |         if opening\
    \ == '>' && !close {\n   |                               ^^^^^ help: a local variable\
    \ with a similar name exists: `closed`\n\nerror[E0425]: cannot find value `close`\
    \ in this scope\n  --> /tmp/tmpyu6p7tzy.rs:23:13\n   |\n23 |             close\
    \ = true;\n   |             ^^^^^ help: a local variable with a similar name exists:\
    \ `closed`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyu6p7tzy.rs:14:62\n\
    \   |\n14 |     let mut opening_brackets = brackets.chars().filter(|c| c == '<');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets: Vec<&str> = brackets.split_ascii_whitespace().collect();\n\
    \    open_brackets.sort_unstable();\n    open_brackets.dedup();\n    let mut closed_brackets:\
    \ Vec<&str> = open_brackets.clone();\n    loop {\n        if closed_brackets.len()\
    \ < open_brackets.len() {\n            if closed_brackets.iter().zip(open_brackets.iter())\n\
    \                .all(|(a, b)| a == b) {\n                return true;\n     \
    \       }\n        }\n        closed_brackets.dedup();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_opening = false;\n    let mut has_closing\
    \ = false;\n\n    brackets.split_whitespace().forEach(|char| {\n        if char\
    \ == '<' {\n            has_opening = true;\n        } else if char == '>' {\n\
    \            has_closing = true;\n        }\n    });\n\n    has_opening && has_closing\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `forEach` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2p4bzvpb.rs:15:33\n   |\n15 |     brackets.split_whitespace().forEach(|char|\
    \ {\n   |                                 ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() < 2 {\n        return false;\n    }\n\
    \    let mut found = false;\n    let mut opening_brackets: Vec<_> = brackets.chars().map(|c|\
    \ c.to_digit(10)).collect();\n    let mut closing_brackets: Vec<_> = brackets.chars().map(|c|\
    \ c.to_digit(10)).collect();\n    loop {\n        let opening_bracket = opening_brackets.remove(0).unwrap();\n\
    \        let closing_bracket = closing_brackets.remove(0).unwrap();\n        if\
    \ opening_bracket < closing_bracket {\n            if !found {\n             \
    \   found = true;\n            }\n            return false;\n        }\n     \
    \   opening_brackets.push(opening_bracket);\n        closing_brackets.push(closing_bracket);\n\
    \    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hft0xza.rs:27:31\n   |\n\
    27 |         opening_brackets.push(opening_bracket);\n   |                   \
    \            ^^^^^^^^^^^^^^^ expected enum `Option`, found `u32`\n   |\n   = note:\
    \ expected enum `Option<u32>`\n              found type `u32`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n27 |         opening_brackets.push(Some(opening_bracket));\n\
    \   |                               +++++               +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6hft0xza.rs:28:31\n   |\n28 |         closing_brackets.push(closing_bracket);\n\
    \   |                               ^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `u32`\n   |\n   = note: expected enum `Option<u32>`\n              found type\
    \ `u32`\nhelp: try wrapping the expression in `Some`\n   |\n28 |         closing_brackets.push(Some(closing_bracket));\n\
    \   |                               +++++               +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5ziwl8a5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut prev_bracket = None;\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        if prev_bracket == Some(c.to_string()) {\n            prev_bracket\
    \ = None;\n            continue;\n        }\n        if prev_bracket == None {\n\
    \            prev_bracket = Some(c.to_string());\n        }\n        prev_bracket\
    \ = Some(c.to_string());\n    }\n    prev_bracket.is_none()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp5sswtd8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.find('<') != brackets.find('>') && brackets.len()\
    \ > 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx9fjpt8a.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Use a map so we can easily check if any brackets are\
    \ opened.\n    let mut map = HashMap::new();\n    for b in brackets.chars() {\n\
    \        if !map.contains_key(&b) {\n            map.insert(b, true);\n      \
    \  }\n    }\n\n    // Traverse the map and check if any brackets are closed.\n\
    \    // If so, return false. Otherwise return true.\n    for (b, closed) in map.into_iter().zip(map.into_iter().rev())\
    \ {\n        if closed {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2anihi55.rs:13:19\n   |\n13 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    stack.push(brackets.len());\n\
    \    while stack.len() > 0 {\n        match stack.pop() {\n            0 => return\
    \ false,\n            1 => {\n                let new_stack = stack;\n       \
    \         let len = stack.len();\n                let mut i = len;\n         \
    \       while i >= 0 && i < len && stack[i] == len - 1 {\n                   \
    \ i--;\n                }\n                if i == -1 {\n                    return\
    \ true;\n                }\n                let next_len = len - 1;\n        \
    \        let mut j = next_len;\n                let mut found = false;\n     \
    \           while j > 0 && j < next_len && stack[j] == new_stack[j] {\n      \
    \              j++;\n                }\n                if j == new_stack.len()\
    \ {\n                    return true;\n                }\n                stack.push(j);\n\
    \                stack.push(next_len);\n            }\n            _ => {}\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpugjlajkt.rs:22:24\n\
    \   |\n22 |                     i--;\n   |                        ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpugjlajkt.rs:31:22\n\
    \   |\n31 |                     j++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |               \
    \      { let tmp = j; j += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    31 -                     j++;\n31 +                     j += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpugjlajkt.rs:16:13\n   |\n15 |         match\
    \ stack.pop() {\n   |               ----------- this expression has type `Option<usize>`\n\
    16 |             0 => return false,\n   |             ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpugjlajkt.rs:17:13\n\
    \   |\n15 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<usize>`\n16 |             0 => return false,\n17 |        \
    \     1 => {\n   |             ^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpugjlajkt.rs:24:25\n\
    \   |\n24 |                 if i == -1 {\n   |                         ^^\n  \
    \ |                         |\n   |                         cannot apply unary\
    \ operator `-`\n   |                         help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut correct = true;\n    for i in 0..brackets.len()\
    \ {\n        if brackets.chars().nth(i) != '>' {\n            correct = false;\n\
    \            break;\n        }\n    }\n    correct\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkw851zhp.rs:14:39\n   |\n\
    14 |         if brackets.chars().nth(i) != '>' {\n   |                       \
    \                ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n14 |         if brackets.chars().nth(i) != Some('>')\
    \ {\n   |                                       +++++   +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<&str> = vec![\"\".to_string()];\n\
    \    let mut open_brackets: Vec<&str> = vec![\"\".to_string()];\n\n    for bracket\
    \ in brackets.chars().filter_map(|c| {\n        if c == '<' {\n            stack.push(bracket);\n\
    \            None\n        } else if c == '>' {\n            assert!(stack.pop().unwrap()\
    \ == \"<\");\n            None\n        } else {\n            Some(String::from(c))\n\
    \        }\n    }) {\n        open_brackets.push(bracket);\n    }\n\n    stack.iter().all(|x|\
    \ open_brackets.iter().all(|y| x == y))\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpsprw7ywf.rs:17:24\n\
    \   |\n17 |             stack.push(bracket);\n   |                        ^^^^^^^\
    \ help: a local variable with a similar name exists: `brackets`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsprw7ywf.rs:12:37\n   |\n12 |     let mut stack:\
    \ Vec<&str> = vec![\"\".to_string()];\n   |                                  \
    \   ^^^^^^^^^^^^^^\n   |                                     |\n   |         \
    \                            expected `&str`, found struct `String`\n   |    \
    \                                 help: consider borrowing here: `&\"\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsprw7ywf.rs:13:45\n   |\n13 |\
    \     let mut open_brackets: Vec<&str> = vec![\"\".to_string()];\n   |       \
    \                                      ^^^^^^^^^^^^^^\n   |                  \
    \                           |\n   |                                          \
    \   expected `&str`, found struct `String`\n   |                             \
    \                help: consider borrowing here: `&\"\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsprw7ywf.rs:26:28\n   |\n26 |         open_brackets.push(bracket);\n\
    \   |                            ^^^^^^^\n   |                            |\n\
    \   |                            expected `&str`, found struct `String`\n   |\
    \                            help: consider borrowing here: `&bracket`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut in_bracket = false;\n    let mut cur_position\
    \ = 0;\n    let mut num_openings = 0;\n    for c in brackets {\n        if c ==\
    \ '<' {\n            in_bracket = true;\n            cur_position += 1;\n    \
    \    } else if c == '>' {\n            in_bracket = false;\n            cur_position\
    \ += 1;\n        } else {\n            if !in_bracket {\n                return\
    \ false;\n            }\n        }\n\n        if !in_bracket {\n            num_openings\
    \ += 1;\n        }\n        if num_openings > 3 {\n            return false;\n\
    \        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5d48rcec.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![0usize];\n    let mut\
    \ pos = 0;\n    while pos < brackets.len() {\n        match &brackets[pos] {\n\
    \            \"<\" => stack.pop(),\n            \">\" => stack.push(0usize),\n\
    \            \"(\" => stack.push(stack.len() as usize),\n            \")\" =>\
    \ stack.pop(),\n            _ => panic!(\"'{}' is not a valid bracket pattern.\"\
    , brackets[pos]),\n        }\n        pos += 1;\n    }\n    if stack.len() !=\
    \ 0 {\n        panic!(\"Not all brackets are correctly matched.\");\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5hlkj7kj.rs:15:16\n\
    \   |\n15 |         match &brackets[pos] {\n   |                ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp5hlkj7kj.rs:17:20\n\
    \   |\n15 | /         match &brackets[pos] {\n16 | |             \"<\" => stack.pop(),\n\
    \   | |                    ----------- this is found to be of type `Option<usize>`\n\
    17 | |             \">\" => stack.push(0usize),\n   | |                    ^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `()`\n18 | |             \"(\" => stack.push(stack.len()\
    \ as usize),\n19 | |             \")\" => stack.pop(),\n20 | |             _ =>\
    \ panic!(\"'{}' is not a valid bracket pattern.\", brackets[pos]),\n21 | |   \
    \      }\n   | |_________- `match` arms have incompatible types\n   |\n   = note:\
    \   expected enum `Option<usize>`\n           found unit type `()`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5hlkj7kj.rs:20:65\n\
    \   |\n20 |             _ => panic!(\"'{}' is not a valid bracket pattern.\",\
    \ brackets[pos]),\n   |                                                      \
    \           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for ch in brackets {\n      \
    \  if ch == \"<\" {\n            count += 1;\n        } else if ch == \">\" {\n\
    \            count -= 1;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2nkvwoqu.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [false; MAX_SLOT];\n    for ch in &brackets\
    \ {\n        stack[ch as usize] = true;\n    }\n    for i in 0..MAX_SLOT {\n \
    \       if !stack[i] {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_SLOT` in this scope\n  --> /tmp/tmp252u3vgb.rs:12:29\n\
    \   |\n12 |     let mut stack = [false; MAX_SLOT];\n   |                     \
    \        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_SLOT`\
    \ in this scope\n  --> /tmp/tmp252u3vgb.rs:16:17\n   |\n16 |     for i in 0..MAX_SLOT\
    \ {\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmp252u3vgb.rs:13:15\n   |\n13 |     for ch in\
    \ &brackets {\n   |               ^^^^^^^^^ `&String` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = VecDeque::new();\n    let mut opening_brackets\
    \ = Vec::new();\n    let mut opening_tag = false;\n\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            if !opening_tag {\n                stack.push_back(c.to_string());\n\
    \                opening_tag = true;\n            }\n        } else {\n      \
    \      if opening_tag && stack.len() > 0 && stack.back().chars().next().unwrap()\
    \ == c {\n                stack.pop_back();\n            }\n\n            if stack.len()\
    \ == 0 {\n                opening_brackets.push(c.to_string());\n            }\
    \ else {\n                let last = stack.last_mut().unwrap();\n            \
    \    if last == &c {\n                    stack.back().extend_from_slice(&c);\n\
    \                }\n            }\n        }\n    }\n\n    let expected = opening_brackets.iter().all(|v|\
    \ v.chars().next().unwrap() == '<');\n    let actual = stack.iter().all(|v| v.chars().next().unwrap()\
    \ == '<');\n\n    expected && actual\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp1c_f66vo.rs:12:21\n   |\n12 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // A stack of brackets.\n    let mut stack = Vec::new();\n\
    \    let mut bracket_level = Vec::new();\n\n    // Initialize the stack.\n   \
    \ for bracket in brackets.chars() {\n        stack.push(bracket);\n        bracket_level.push(0);\n\
    \    }\n\n    // Start matching bracket levels.\n    while !stack.is_empty() {\n\
    \        // Pop the top bracket off of the stack.\n        let top = stack.pop().unwrap();\n\
    \        let level = bracket_level.pop();\n\n        if level == 0 {\n       \
    \     if top == '<' {\n                stack.push('>');\n            }\n     \
    \   } else {\n            if top == '>' {\n                stack.push('<');\n\
    \            }\n        }\n\n        bracket_level.push(level + 1);\n    }\n\n\
    \    // If stack is not empty, there is a mismatch\n    !stack.is_empty()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkif9rxfc.rs:28:21\n   |\n\
    28 |         if level == 0 {\n   |                     ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<{integer}>`\n        \
    \      found type `{integer}`\nhelp: try wrapping the expression in `Some`\n \
    \  |\n28 |         if level == Some(0) {\n   |                     +++++ +\n\n\
    error[E0369]: cannot add `{integer}` to `Option<{integer}>`\n  --> /tmp/tmpkif9rxfc.rs:38:34\n\
    \   |\n38 |         bracket_level.push(level + 1);\n   |                     \
    \       ----- ^ - {integer}\n   |                            |\n   |         \
    \                   Option<{integer}>\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == \">\" || c == \"<\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5g16g0di.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == \">\" || c == \"<\")\n   |            \
    \                       ^^^ expected `char`, found `&str`\n   |\nhelp: if you\
    \ meant to write a `char` literal, use single quotes\n   |\n12 |     brackets.chars().all(|c|\
    \ c == '>' || c == \"<\")\n   |                                   ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5g16g0di.rs:12:47\n   |\n12 |     brackets.chars().all(|c|\
    \ c == \">\" || c == \"<\")\n   |                                            \
    \   ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n12 |     brackets.chars().all(|c| c == \"\
    >\" || c == '<')\n   |                                               ~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    let mut i = 0;\n   \
    \ while i < brackets.len() {\n        if brackets[i] == '<' {\n            stack.push(true);\n\
    \        } else {\n            if stack.len() < 2 {\n                stack.push(false);\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \        i += 1;\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk1w87d06.rs:15:12\n\
    \   |\n15 |         if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpk_23kj_2.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '<')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opens = brackets.char_indices();\n    let mut\
    \ closes = brackets.char_indices();\n    opens = opens.map(|i| {\n        let\
    \ open = i[1];\n        let close = opens[open - 1];\n        (open, close)\n\
    \    });\n    closes = closes.map(|i| {\n        let open = i[1];\n        let\
    \ close = closes[open - 1];\n        (open, close)\n    });\n    for open in\n\
    \        opens\n            .iter()\n            .skip(1)\n            .filter_map(|(open,\
    \ close)| {\n                if open != close {\n                    Some((open,\
    \ close))\n                } else {\n                    None\n              \
    \  }\n            })\n    {\n        if opens.contains(&(open, open)) {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `(usize, char)`\n  -->\
    \ /tmp/tmprce9na9u.rs:15:20\n   |\n15 |         let open = i[1];\n   |       \
    \             ^^^^ help: to access tuple elements, use: `i.1`\n\nerror[E0608]:\
    \ cannot index into a value of type `CharIndices<'_>`\n  --> /tmp/tmprce9na9u.rs:16:21\n\
    \   |\n16 |         let close = opens[open - 1];\n   |                     ^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprce9na9u.rs:14:13\n   |\n12 |\
    \       let mut opens = brackets.char_indices();\n   |                       -----------------------\
    \ expected due to this value\n13 |       let mut closes = brackets.char_indices();\n\
    14 |       opens = opens.map(|i| {\n   |  _____________^\n15 | |         let open\
    \ = i[1];\n16 | |         let close = opens[open - 1];\n17 | |         (open,\
    \ close)\n18 | |     });\n   | |______^ expected struct `CharIndices`, found struct\
    \ `Map`\n   |\n   = note: expected struct `CharIndices<'_>`\n              found\
    \ struct `Map<CharIndices<'_>, [closure@/tmp/tmprce9na9u.rs:14:23: 18:6]>`\n\n\
    error[E0608]: cannot index into a value of type `(usize, char)`\n  --> /tmp/tmprce9na9u.rs:20:20\n\
    \   |\n20 |         let open = i[1];\n   |                    ^^^^ help: to access\
    \ tuple elements, use: `i.1`\n\nerror[E0608]: cannot index into a value of type\
    \ `CharIndices<'_>`\n  --> /tmp/tmprce9na9u.rs:21:21\n   |\n21 |         let close\
    \ = closes[open - 1];\n   |                     ^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprce9na9u.rs:19:14\n   |\n13 |       let mut\
    \ closes = brackets.char_indices();\n   |                        -----------------------\
    \ expected due to this value\n...\n19 |       closes = closes.map(|i| {\n   |\
    \  ______________^\n20 | |         let open = i[1];\n21 | |         let close\
    \ = closes[open - 1];\n22 | |         (open, close)\n23 | |     });\n   | |______^\
    \ expected struct `CharIndices`, found struct `Map`\n   |\n   = note: expected\
    \ struct `CharIndices<'_>`\n              found struct `Map<CharIndices<'_>, [closure@/tmp/tmprce9na9u.rs:19:25:\
    \ 23:6]>`\n\nerror[E0599]: no method named `iter` "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut position = 0;\n    let mut last_char = char::From('0');\n\
    \n    while position < brackets.len() {\n        if brackets[position] == '>'\
    \ {\n            last_char = char::From('1');\n        }\n\n        if brackets[position]\
    \ == '<' {\n            last_char = char::From('0');\n        }\n\n        position\
    \ += 1;\n\n        if brackets[position] == '>' {\n            position += 1;\n\
    \            if position >= brackets.len() {\n                return false;\n\
    \            }\n        }\n\n        if brackets[position] == '<' {\n        \
    \    position += 1;\n            if position >= brackets.len() {\n           \
    \     return false;\n            }\n        }\n\n        if brackets[position]\
    \ == '='\n            || brackets[position] == '<'\n            || brackets[position]\
    \ == '>'\n            || brackets[position] == '&'\n            || brackets[position]\
    \ == '~'\n            || brackets[position] == '#'\n        {\n            return\
    \ false;\n        }\n\n        if brackets[position] == last_char {\n        \
    \    return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `From` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpwf7vaq8r.rs:13:31\n   |\n13 |     let mut last_char\
    \ = char::From('0');\n   |                               ^^^^ associated item\
    \ not found in `char`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpwf7vaq8r.rs:16:12\n   |\n16 |         if brackets[position]\
    \ == '>' {\n   |            ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no associated item named `From` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpwf7vaq8r.rs:17:31\n   |\n17 |          \
    \   last_char = char::From('1');\n   |                               ^^^^ associated\
    \ item not found in `char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwf7vaq8r.rs:20:12\n   |\n20 |         if brackets[position]\
    \ == '<' {\n   |            ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no associated item named `From` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpwf7vaq8r.rs:21:31\n   |\n21 |          \
    \   last_char = char::From('0')"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| {\n        c.is_digit(10) ||\
    \ c >= '<' && c <= '<'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpks82p241.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    for (i,\
    \ c) in brackets.chars().enumerate() {\n        if c != '<' && c != '>' && c !=\
    \ '=' {\n            return false;\n        }\n        stack.push(i as usize);\n\
    \    }\n    for c in brackets.chars() {\n        if stack.len() != 0 {\n     \
    \       match c {\n                '<' => stack.pop(),\n                '>' =>\
    \ stack.pop(),\n                '=' => stack.pop(),\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrfw94_w.rs:21:13\n   |\n\
    20 |  /         if stack.len() != 0 {\n21 |  |             match c {\n   |  |_____________^\n\
    22 | ||                 '<' => stack.pop(),\n23 | ||                 '>' => stack.pop(),\n\
    24 | ||                 '=' => stack.pop(),\n25 | ||             }\n   | ||_____________^\
    \ expected `()`, found enum `Option`\n26 |  |         } else {\n27 |  |      \
    \       return false;\n28 |  |         }\n   |  |_________- expected this to be\
    \ `()`\n   |\n   = note: expected unit type `()`\n                   found enum\
    \ `Option<usize>`\nhelp: consider using a semicolon here\n   |\n25 |         \
    \    };\n   |              +\nhelp: consider using a semicolon here\n   |\n28\
    \ |         };\n   |          +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty()\n        || (brackets.chars().count(|c|\
    \ c == '<') > 0 && brackets.chars().count(|c| c == '>')) > 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp917pxoav.rs:13:30\n    |\n13  |         || (brackets.chars().count(|c|\
    \ c == '<') > 0 && brackets.chars().count(|c| c == '>')) > 0\n    |          \
    \                    ^^^^^ ------------ supplied 1 argument\n    |           \
    \                   |\n    |                              expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp917pxoav.rs:13:74\n\
    \    |\n13  |         || (brackets.chars().count(|c| c == '<') > 0 && brackets.chars().count(|c|\
    \ c == '>')) > 0\n    |                                                      \
    \                    ^^^^^ ------------ supplied 1 argument\n    |           \
    \                                                               |\n    |     \
    \                                                                     expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp917pxoav.rs:13:57\n   |\n13 |         || (brackets.chars().count(|c|\
    \ c == '<') > 0 && brackets.chars().count(|c| c == '>')) > 0\n   |           \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp917pxoav.rs:13:97\n\
    \   |\n13 |         || (brackets.chars().count(|c| c == '<') > 0 && brackets.chars().count(|c|\
    \ c == '>')) > 0\n   |                                                       \
    \                                          ^ expected `bool`, found integer\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut index = 0;\n    while index < brackets.len()\
    \ {\n        let next_index = brackets.find(&\">\", index);\n        if next_index\
    \ == Some(0) {\n            break;\n        }\n        let next_char = brackets[next_index].chars().next().unwrap();\n\
    \        if next_char == '>' {\n            let mut index = next_index + 1;\n\
    \            while index < brackets.len() {\n                if brackets[index]\
    \ == '>' {\n                    break;\n                }\n                index\
    \ += 1;\n            }\n        } else {\n            let mut index = next_index;\n\
    \            while index < brackets.len() {\n                if brackets[index]\
    \ == '<' {\n                    break;\n                }\n                index\
    \ += 1;\n            }\n        }\n    }\n    index > 0\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp1zvord8c.rs:14:35\n     |\n14   |         let next_index = brackets.find(&\"\
    >\", index);\n     |                                   ^^^^ ----  ----- supplied\
    \ 2 arguments\n     |                                   |\n     |            \
    \                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmp1zvord8c.rs:18:25\n   |\n18 |         let next_char = brackets[next_index].chars().next().unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `Option<usize>`\n   |\n   = help: the trait `Index<Option<usize>>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  -->\
    \ /tmp/tmp1zvord8c.rs:20:40\n   |\n20 |             let mut index = next_index\
    \ + 1;\n   |                             ---------- ^ - {integer}\n   |      \
    \                       |\n   |                             Option<usize>\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1zvord8c.rs:29:27\n   |\n29 |  \
    \           while index < brackets.len() {\n   |                           ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |             while index < Some(brackets.len()) {\n   |           \
    \                +++++              +\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `Option<usize>`\n  --> /tmp/tmp1zvord8c.rs:30:20\n   |\n30 | \
    \                if brackets[index] == '<' {\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c >= '<' && c <= '<') &&\n \
    \       brackets.chars().all(|c| c >= '>' && c <= '>')\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkkkeqfyv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut pos = 0;\n    let mut i = 0;\n    let mut open_char\
    \ = None;\n    let mut close_char = None;\n    while i < brackets.len() {\n  \
    \      match brackets.chars().nth(i) {\n            Some('{') => {\n         \
    \       open_char = Some(brackets.chars().nth(i));\n                i += 1;\n\
    \                pos = i;\n            }\n            Some('}') => {\n       \
    \         close_char = Some(brackets.chars().nth(i));\n                i += 1;\n\
    \                pos = i;\n            }\n            Some('>') => {\n       \
    \         // Reached the closing bracket. Check if its opening.\n            \
    \    if open_char == Some('{') {\n                    // If its opening, then\
    \ this closing bracket is not correct.\n                    return false;\n  \
    \              } else {\n                    // If its not opening, then this\
    \ closing bracket is correct.\n                    open_char = None;\n       \
    \             close_char = None;\n                }\n            }\n         \
    \   Some('<') => {\n                // Reached the opening bracket. Check if its\
    \ closing.\n                if close_char == Some('}') {\n                   \
    \ // If its closing, then this opening bracket is not correct.\n             \
    \       return false;\n                } else {\n                    // If its\
    \ not closing, then this opening bracket is correct.\n                    open_char\
    \ = None;\n                    close_char = None;\n                }\n       \
    \     }\n            None => (),\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5kuttwqh.rs:30:38\n   |\n\
    30 |                 if open_char == Some('{') {\n   |                       \
    \               ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n30 |                 if open_char == Some(Some('{'))\
    \ {\n   |                                      +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5kuttwqh.rs:41:39\n   |\n41 |                 if close_char\
    \ == Some('}') {\n   |                                       ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n41 |                 if close_char == Some(Some('}')) {\n   |           \
    \                            +++++   +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"<\") && (brackets.contains(\">\"\
    ) || brackets.contains(\"<=\"))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmperorvf3w.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_depth = 0;\n    for ch in brackets.chars().skip_while(|c|\
    \ !is_valid_open_bracket(c)) {\n        if let Some(depth) = bracket_depth {\n\
    \            match ch {\n                Some('>') => {\n                    let\
    \ is_closed = (depth + 1 < bracket_depth);\n                    if !is_closed\
    \ {\n                        debug_assert!(!is_closed);\n                    \
    \    bracket_depth += 1;\n                    }\n                }\n         \
    \       Some('<') => {\n                    let is_closed = (depth > bracket_depth);\n\
    \                    if !is_closed {\n                        debug_assert!(!is_closed);\n\
    \                        bracket_depth -= 1;\n                    }\n        \
    \        }\n                None => return false,\n            }\n        } else\
    \ {\n            bracket_depth = 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_valid_open_bracket` in this scope\n\
    \  --> /tmp/tmprrh5pmtv.rs:13:48\n   |\n13 |     for ch in brackets.chars().skip_while(|c|\
    \ !is_valid_open_bracket(c)) {\n   |                                         \
    \       ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around assigned value\n  --> /tmp/tmprrh5pmtv.rs:17:37\n   |\n17\
    \ |                     let is_closed = (depth + 1 < bracket_depth);\n   |   \
    \                                  ^                         ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    17 -                     let is_closed = (depth + 1 < bracket_depth);\n17 +  \
    \                   let is_closed = depth + 1 < bracket_depth;\n   | \n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmprrh5pmtv.rs:24:37\n\
    \   |\n24 |                     let is_closed = (depth > bracket_depth);\n   |\
    \                                     ^                     ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n24 -                     let is_closed = (depth > bracket_depth);\n\
    24 +                     let is_closed = depth > bracket_depth;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprrh5pmtv.rs:14:16\n   |\n14 |         if let\
    \ Some(depth) = bracket_depth {\n   |                ^^^^^^^^^^^   -------------\
    \ this expression has type `{integer}`\n   |                |\n   |          \
    \      expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprrh5pmtv.rs:16:17\n   |\n15 |             match ch {\n   |         \
    \          -- this expression has type `char`\n16 |                 Some('>')\
    \ => {\n   |                 ^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprrh5pmtv.rs:23:17\n   |\n15 |\
    \             match ch {\n   |                   -- this expression has type `char`\n\
    ...\n23 |                 Some('<') => {\n "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut i = 1;\n    let mut open_count = String::new();\n\
    \    let mut close_count = String::new();\n    open_count.push(brackets[0]);\n\
    \    close_count.push(brackets[0]);\n    while i < brackets.len() {\n        if\
    \ brackets[i] == brackets[i-1] {\n            open_count.push(brackets[i]);\n\
    \            i += 1;\n        } else {\n            if open_count.contains(&brackets[i-1])\
    \ {\n                if close_count.contains(&brackets[i]) {\n               \
    \     i += 1;\n                } else {\n                    close_count.push(brackets[i]);\n\
    \                }\n            } else {\n                if close_count.contains(&brackets[i])\
    \ {\n                    open_count.push(brackets[i]);\n                }\n  \
    \          }\n        }\n    }\n    open_count.len() == close_count.len()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp46yg2r0u.rs:15:21\n   |\n15 |     open_count.push(brackets[0]);\n  \
    \ |                     ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp46yg2r0u.rs:16:22\n   |\n16 |     close_count.push(brackets[0]);\n\
    \   |                      ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp46yg2r0u.rs:18:12\n   |\n18 |         if brackets[i] == brackets[i-1]\
    \ {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usi"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3v24gnc6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_iter = brackets.chars();\n    loop {\n\
    \        let char = match brackets_iter.next() {\n            Some('>') => '>',\n\
    \            Some('<') => '<',\n            None => panic!(\"unrecognized opening\
    \ bracket\"),\n        };\n        match brackets_iter.next() {\n            Some('>')\
    \ => true,\n            Some('<') => true,\n            None => panic!(\"unrecognized\
    \ closing bracket\"),\n        };\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0004]: non-exhaustive patterns: `Some('\\0'..=';')`, `Some('=')`,\
    \ `Some('?'..='\\u{d7ff}')` and 1 more not covered\n   --> /tmp/tmpww8d7shw.rs:14:26\n\
    \    |\n14  |         let char = match brackets_iter.next() {\n    |         \
    \                 ^^^^^^^^^^^^^^^^^^^^ patterns `Some('\\0'..=';')`, `Some('=')`,\
    \ `Some('?'..='\\u{d7ff}')` and 1 more not covered\n    |\nnote: `Option<char>`\
    \ defined here\n    = note: the matched value is of type `Option<char>`\nhelp:\
    \ ensure that all possible cases are being handled by adding a match arm with\
    \ a wildcard pattern as shown, or multiple match arms\n    |\n17  ~          \
    \   None => panic!(\"unrecognized opening bracket\")\n18  ~             _ => todo!(),\n\
    \    |\n\nerror[E0004]: non-exhaustive patterns: `Some('\\0'..=';')`, `Some('=')`,\
    \ `Some('?'..='\\u{d7ff}')` and 1 more not covered\n   --> /tmp/tmpww8d7shw.rs:19:15\n\
    \    |\n19  |         match brackets_iter.next() {\n    |               ^^^^^^^^^^^^^^^^^^^^\
    \ patterns `Some('\\0'..=';')`, `Some('=')`, `Some('?'..='\\u{d7ff}')` and 1 more\
    \ not covered\n    |\nnote: `Option<char>` defined here\n    = note: the matched\
    \ value is of type `Option<char>`\nhelp: ensure that all possible cases are being\
    \ handled by adding a match arm with a wildcard pattern as shown, or multiple\
    \ match arms\n    |\n22  ~             None => panic!(\"unrecognized closing bracket\"\
    )\n23  ~             _ => todo!(),\n    |\n\nwarning: unused variable: `char`\n\
    \  --> /tmp/tmpww8d7shw.rs:14:13\n   |\n14 |         let char = match brackets_iter.next()\
    \ {\n   |             ^^^^ help: if this is intentional, prefix it with an underscore:\
    \ `_char`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0004`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_positions: Vec<_> = brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => 0,\n        '>' => 0,\n        _ => 1,\n    }).collect();\n\
    \    open_positions.sort_unstable();\n    let mut close_positions: Vec<_> = brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => 1,\n        '>' => 1,\n        _ => 0,\n    }).collect();\n\
    \    close_positions.sort_unstable();\n    for open in open_positions.into_iter()\
    \ {\n        assert!(!close_positions.contains(&open), \"Found duplicate opening-bracket\
    \ at position\");\n    }\n    for open in close_positions.into_iter() {\n    \
    \    assert!(!open_positions.contains(&open), \"Found duplicate closing-bracket\
    \ at position\");\n    }\n    for open in open_positions.into_iter() {\n     \
    \   let close = close_positions.remove(open);\n        if close == open {\n  \
    \          // We've found two matching opening-brackets.\n            assert!(open_positions.contains(&close),\
    \ \"Found unmatching closing-brackets at position\");\n        }\n    }\n    open_positions.is_empty()\
    \ && close_positions.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb1iutljo.rs:13:16\n   |\n\
    13 |         '<' => 0,\n   |                ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n13 |         '<' => Some(0),\n\
    \   |                +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1iutljo.rs:19:16\n\
    \   |\n19 |         '<' => 1,\n   |                ^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n19 |       \
    \  '<' => Some(1),\n   |                +++++ +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Find the first opening bracket.\n    let first_open_bracket:\
    \ usize = brackets.find('<') - 1;\n\n    // Find the last closing bracket.\n \
    \   let last_close_bracket: usize = brackets.rfind('>') - 1;\n\n    // Return\
    \ whether all the brackets are properly closed.\n    first_open_bracket < last_close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmppd5qr1fb.rs:13:56\n\
    \   |\n13 |     let first_open_bracket: usize = brackets.find('<') - 1;\n   |\
    \                                     ------------------ ^ - {integer}\n   | \
    \                                    |\n   |                                 \
    \    Option<usize>\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmppd5qr1fb.rs:16:57\n   |\n16 |     let last_close_bracket: usize\
    \ = brackets.rfind('>') - 1;\n   |                                     -------------------\
    \ ^ - {integer}\n   |                                     |\n   |            \
    \                         Option<usize>\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().enumerate().all(|(i, &c)| c.is_ascii_alphanumeric()\
    \ && c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg9a4741l.rs:12:43\n   |\n\
    12 |     brackets.chars().enumerate().all(|(i, &c)| c.is_ascii_alphanumeric()\
    \ && c == '<')\n   |                                           ^^- expected due\
    \ to this\n   |                                           |\n   |            \
    \                               expected `char`, found reference\n   |       \
    \                                    help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Test for non-empty string\n    if brackets.is_empty()\
    \ {\n        return false;\n    }\n\n    // Loop through all chars except '<'\n\
    \    for pos in 0..brackets.len() - 1 {\n        // Test if previous char and\
    \ current char are '<'\n        if pos <= 0 || !brackets[pos - 1].as_char() ==\
    \ '<' {\n            break;\n        }\n\n        // Test if next char and current\
    \ char are '<'\n        if pos >= brackets.len() - 2 || !brackets[pos + 1].as_char()\
    \ == '<' {\n            return false;\n        }\n\n        // If so, return true\n\
    \        return true;\n    }\n\n    // If nothing happened, return true\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2ysw5c_t.rs:20:25\n\
    \   |\n20 |         if pos <= 0 || !brackets[pos - 1].as_char() == '<' {\n   |\
    \                         ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2ysw5c_t.rs:25:42\n   |\n25 |         if pos >= brackets.len()\
    \ - 2 || !brackets[pos + 1].as_char() == '<' {\n   |                         \
    \                 ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut chars = String::new();\n    for c in brackets\
    \ {\n        chars.push(c);\n    }\n    for char in chars.chars() {\n        if\
    \ !is_open_bracket(char) {\n            return false;\n        }\n    }\n    for\
    \ char in chars.chars() {\n        if !is_close_bracket(char) {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_open_bracket` in this scope\n  -->\
    \ /tmp/tmp19ht58ea.rs:17:13\n   |\n17 |         if !is_open_bracket(char) {\n\
    \   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_close_bracket` in this scope\n  --> /tmp/tmp19ht58ea.rs:22:13\n\
    \   |\n22 |         if !is_close_bracket(char) {\n   |             ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmp19ht58ea.rs:13:14\n   |\n13 |     for c in brackets {\n   |        \
    \      ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    let mut bracket_strings = brackets.split('>');\n    for bracket_str\
    \ in bracket_strings {\n        if bracket_str.chars().next() != Some('>') {\n\
    \            return false;\n        }\n        match bracket_str {\n         \
    \   \">>\" => closed_brackets++;\n            \"<\" => open_brackets--;\n    \
    \        x => panic!(\"Unexpected bracket: {}\", x),\n        }\n    }\n    open_brackets\
    \ == closed_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7hkog51x.rs:20:36\n\
    \   |\n20 |             \">>\" => closed_brackets++;\n   |                  --\
    \                ^^ not a valid postfix operator\n   |                  |\n  \
    \ |                  while parsing the `match` arm starting here\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n20 |             \">>\" => { let tmp = closed_brackets;\
    \ closed_brackets += 1; tmp };\n   |                     +++++++++++         \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             \">>\" => closed_brackets++;\n\
    20 +             \">>\" => closed_brackets += 1;\n   | \n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .split_whitespace()\n        .into_iter()\n\
    \        .filter_map(|b| if b == \">\" { Some(0) } else { None })\n        .all(|b|\
    \ b == Some(0))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `{integer}` with `Option<{integer}>`\n  -->\
    \ /tmp/tmpucpkxxu0.rs:16:20\n   |\n16 |         .all(|b| b == Some(0))\n   | \
    \                   ^^ no implementation for `{integer} == Option<{integer}>`\n\
    \   |\n   = help: the trait `PartialEq<Option<{integer}>>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() != 2 {\n        return false;\n   \
    \ }\n    let mut found_brackets = false;\n    let mut last_open_bracket = 0;\n\
    \    for c in brackets.chars() {\n        if c == '<' {\n            if found_brackets\
    \ {\n                return false;\n            }\n            found_brackets\
    \ = true;\n            last_open_bracket = c;\n        } else if c == '>' {\n\
    \            found_brackets = !found_brackets;\n        } else {\n           \
    \ return false;\n        }\n    }\n    !found_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt61v4oz.rs:23:33\n   |\n\
    16 |     let mut last_open_bracket = 0;\n   |                                \
    \ - expected due to this value\n...\n23 |             last_open_bracket = c;\n\
    \   |                                 ^ expected integer, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|&c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6z91_g_e.rs:12:27\n   |\n\
    12 |     brackets.chars().all(|&c| c == '<' || c == '>')\n   |               \
    \            ^--\n   |                           ||\n   |                    \
    \       |expected due to this\n   |                           expected `char`,\
    \ found reference\n   |                           help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c.is_ascii_letter() || c.is_ascii_digit())\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpl69b0j4n.rs:12:32\n   |\n12 |     brackets.chars().all(|c|\
    \ c.is_ascii_letter() || c.is_ascii_digit())\n   |                           \
    \     ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        return false;\n   \
    \ }\n    let mut counter = 0;\n    let mut open_brackets = 0;\n    let mut close_brackets\
    \ = 0;\n    for c in brackets {\n        if c == '<' {\n            open_brackets\
    \ += 1;\n        } else {\n            close_brackets += 1;\n        }\n     \
    \   counter += 1;\n        if counter == 2 {\n            break;\n        }\n\
    \    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3z29g82l.rs:18:14\n\
    \   |\n18 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Iterate through the characters in brackets.\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        // Get the character at\
    \ the current index.\n        let cur = brackets[i];\n        // If cur is \"\
    <\", increment the index.\n        if cur == '<' {\n            i += 1;\n    \
    \        // If cur is \">\", decrement the index.\n        } else if cur == \"\
    >\" {\n            i -= 1;\n        } else {\n            // Otherwise, exit the\
    \ loop.\n            break;\n        }\n    }\n    // If brackets has length 0,\
    \ then return false.\n    brackets.len() > i\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2w0tq301.rs:16:19\n\
    \   |\n16 |         let cur = brackets[i];\n   |                   ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| !brackets.chars().any(|b| b\
    \ == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5836hnst.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for ch in brackets {\n    \
    \    if ch == \">\" {\n            counter += 1;\n        } else if ch == \"<\"\
    \ {\n            counter -= 1;\n        }\n\n        if counter == 0 {\n     \
    \       return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpjv3df_r0.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.find(\"<\") < brackets.find(\">\") { return\
    \ false; }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxuvs_fsm.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = vec![];\n    for c in &brackets {\n\
    \        match c {\n            '>' => {\n                current.push('>');\n\
    \                current.push('>');\n                current.push('>');\n    \
    \            current.push('>');\n                current.push('>');\n        \
    \    }\n            '<' => {\n                current.push('>');\n           \
    \     current.push('>');\n                current.push('>');\n               \
    \ current.push('>');\n                current.push('>');\n                current.push('<');\n\
    \            }\n            _ => {\n                current.push(c);\n       \
    \     }\n        }\n    }\n    current.len() == brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpw9l12dym.rs:13:14\n\
    \   |\n13 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c < '<' || c > '>')\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5k1tx2_4.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.split(\"<<\").len() == brackets.split(\">>\"\
    ).len() ||\n        brackets.split(\"<\").len() == brackets.split(\">\").len()\
    \ ||\n        brackets.split(\"<\").len() == brackets.split(\">\").len() ||\n\
    \        brackets.split(\"<\").len() == brackets.split(\">\").len() ||\n     \
    \   brackets.split(\"<<\").len() == brackets.split(\">>\").len() ||\n        brackets.split(\"\
    <\").len() == brackets.split(\"<\").len() ||\n        brackets.split(\"<\").len()\
    \ == brackets.split(\">\").len() ||\n        brackets.split(\"<\").len() == brackets.split(\"\
    >\").len() ||\n        brackets.split(\"<\").len() == brackets.split(\"<\").len()\
    \ ||\n        brackets.split(\"<\").len() == brackets.split(\">\").len() ||\n\
    \        brackets.split(\">\").len() == brackets.split(\"<\").len() ||\n     \
    \   brackets.split(\">\").len() == brackets.split(\">\").len() ||\n        brackets.split(\"\
    >\").len() == brackets.split(\"<\").len() ||\n        brackets.split(\">\").len()\
    \ == brackets.split(\">\").len() ||\n        brackets.split(\">\").len() == brackets.split(\"\
    <\").len() ||\n        brackets.split(\">\").len() == brackets.split(\">\").len()\
    \ ||\n        brackets.split(\">\").len() == brackets.split(\"<\").len() ||\n\
    \        brackets.split(\">\").len() == brackets.split(\">\").len() ||\n     \
    \   brackets.split(\">\").len() == brackets.split(\"<\").len() ||\n        brackets.split(\"\
    >\").len() == brackets.split(\">\").len() ||\n        brackets.split(\">\").len()\
    \ == brackets.split(\"<\").len() ||\n        brackets.split(\">\").len() == brackets.split(\"\
    >\").len() ||\n        brackets.split(\">\").len() == brackets.split(\"<\").len()\
    \ ||\n        brackets.split(\">\").len() == brackets.split(\">\").len() ||\n\
    \        brackets.split(\">\").len() == brackets.split(\"<\").len() ||\n     \
    \   brackets.split(\">\").len() == brackets.split(\">\").len() ||\n        brackets.split(\"\
    >\").len() == brackets.split(\"<\").len() ||\n        brackets.split(\">\").len()\
    \ == brackets.split(\">\").len() ||\n        brackets.split(\">\").len() == brackets.split(\"\
    <\").len() ||\n        brackets.split(\">\").len() == brackets.split(\">\").len()\
    \ ||\n        brackets.split(\">\").len() == brackets.split(\"<\").len() ||\n\
    \        brackets.split(\">\").len() == brackets.split(\">\").len() ||\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpswbrfz5k.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for (index, char) in brackets.chars().enumerate() {\n\
    \        if char == '<' {\n            if open_brackets.is_empty() {\n       \
    \         open_brackets.append(&char);\n            } else {\n               \
    \ close_brackets.append(&char);\n            }\n        } else {\n           \
    \ if close_brackets.is_empty() {\n                close_brackets.append(&char);\n\
    \            } else {\n                open_brackets.append(&char);\n        \
    \    }\n        }\n    }\n\n    open_brackets.chars().all(|c| close_brackets.chars().any(|c|\
    \ *c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpanee6ghv.rs:18:31\n   |\n18 |                 open_brackets.append(&char);\n\
    \   |                               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpanee6ghv.rs:20:32\n   |\n20 |                 close_brackets.append(&char);\n\
    \   |                                ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpanee6ghv.rs:24:32\n   |\n24 |                 close_brackets.append(&char);\n\
    \   |                                ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpanee6ghv.rs:26:31\n   |\n26 |                 open_brackets.append(&char);\n\
    \   |                               ^^^^^^ method not found in `String`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpanee6ghv.rs:31:66\n   |\n\
    31 |     open_brackets.chars().all(|c| close_brackets.chars().any(|c| *c == c))\n\
    \   |                                                                  ^^\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    stack.push((&mut \"\", false));\n\
    \    loop {\n        let (mut s, open) = stack.pop();\n        let mut pos = 0;\n\
    \        let mut done = false;\n        for c in brackets.chars() {\n        \
    \    if c == open {\n                if pos == 0 {\n                    done =\
    \ true;\n                } else {\n                    pos += 1;\n           \
    \     }\n            } else {\n                if pos == 0 {\n               \
    \     s += c;\n                    pos += 1;\n                } else {\n     \
    \               pos += 1;\n                    s += c;\n                }\n  \
    \          }\n            if done && pos == 0 {\n                stack.push((s,\
    \ open));\n            }\n        }\n        if !done {\n            stack.push((s,\
    \ open));\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3updy2zi.rs:15:13\n   |\n\
    15 |         let (mut s, open) = stack.pop();\n   |             ^^^^^^^^^^^^^\
    \   ----------- this expression has type `Option<(&mut &'static str, bool)>`\n\
    \   |             |\n   |             expected enum `Option`, found tuple\n  \
    \ |\n   = note: expected enum `Option<(&mut &'static str, bool)>`\n          \
    \   found tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut position = 0;\n    while position < brackets.len()\
    \ {\n        let opening_position = position;\n        while opening_position\
    \ < brackets.len() && brackets[opening_position] != '<' {\n            opening_position\
    \ += 1;\n        }\n\n        let closing_position = opening_position;\n     \
    \   while closing_position < brackets.len() && brackets[closing_position] != '>'\
    \ {\n            closing_position += 1;\n        }\n\n        if opening_position\
    \ < closing_position {\n            return true;\n        }\n\n        position\
    \ +=1;\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd0psxopq.rs:15:52\n\
    \   |\n15 |         while opening_position < brackets.len() && brackets[opening_position]\
    \ != '<' {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd0psxopq.rs:20:52\n   |\n20 |         while closing_position <\
    \ brackets.len() && brackets[closing_position] != '>' {\n   |                \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n\n    for ch in brackets.chars() {\n    \
    \    if ch == '<' {\n            opening_brackets.push('>');\n            closing_brackets.push('<');\n\
    \        } else if ch == '>' {\n            opening_brackets.push('<');\n    \
    \        closing_brackets.push('>');\n        } else {\n            opening_brackets.push(ch);\n\
    \            closing_brackets.push(ch);\n        }\n    }\n\n    for opening_bracket\
    \ in opening_brackets.chars() {\n        if closing_brackets.contains(&opening_bracket)\
    \ == false {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpdetf59m6.rs:29:38\n\
    \     |\n29   |         if closing_brackets.contains(&opening_bracket) == false\
    \ {\n     |                             -------- ^^^^^^^^^^^^^^^^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n     |                             |\n\
    \     |                             required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n29   |         if closing_brackets.contains(*&opening_bracket)\
    \ == false {\n     |                                      +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter(|b| b == '<').count() == brackets.chars().filter(|b|\
    \ b == '>').count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpib8efw_z.rs:12:35\n\
    \   |\n12 |     brackets.chars().filter(|b| b == '<').count() == brackets.chars().filter(|b|\
    \ b == '>').count()\n   |                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpib8efw_z.rs:12:84\n\
    \   |\n12 |     brackets.chars().filter(|b| b == '<').count() == brackets.chars().filter(|b|\
    \ b == '>').count()\n   |                                                    \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![\"<\"];\n\n    for c in brackets\
    \ {\n        if c == '<' {\n            stack.pop();\n        }\n        if c\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(c);\n        }\n        stack.push(c);\n\
    \    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpwc5d6ce0.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't\
    \ compare `&str` with `char`\n  --> /tmp/tmpwc5d6ce0.rs:15:14\n   |\n15 |    \
    \     if c == '<' {\n   |              ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpwc5d6ce0.rs:18:14\n   |\n18 |         if c\
    \ == '>' {\n   |              ^^ no implementation for `&str == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        if let Some(open)\
    \ = OPENING_BRACKETS.get(c) {\n            !open\n        } else {\n         \
    \   false\n        }\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `OPENING_BRACKETS` in this scope\n  -->\
    \ /tmp/tmp1z80njpi.rs:13:29\n   |\n13 |         if let Some(open) = OPENING_BRACKETS.get(c)\
    \ {\n   |                             ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.push_str(\"\
    />\");\n    brackets.truncate(0);\n\n    let mut open_brackets = false;\n    let\
    \ mut i = 1;\n    while i < brackets.len() {\n        if brackets[i as usize]\
    \ == '<' {\n            if open_brackets {\n                return false;\n  \
    \          }\n            open_brackets = true;\n        }\n        if brackets[i\
    \ as usize] == '>' {\n            open_brackets = false;\n        }\n        i\
    \ += 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9gaswg4n.rs:19:12\n\
    \   |\n19 |         if brackets[i as usize] == '<' {\n   |            ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9gaswg4n.rs:25:12\n   |\n25 |         if brackets[i as usize] ==\
    \ '>' {\n   |            ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_opening_bracket = false;\n    let mut has_closing_bracket\
    \ = false;\n\n    for c in brackets.chars() {\n        if c == '<' {\n       \
    \     has_opening_bracket = true;\n        } else if c == '>' {\n            has_closing_bracket\
    \ = true;\n        } else if c == ' ' {\n            continue;\n        } else\
    \ if c == ',' {\n            continue;\n        } else if c == '\\n' {\n     \
    \       continue;\n        } else {\n            return false;\n        }\n  \
    \  }\n\n    has_opening_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphtuj3zt1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_pos: usize = 0;\n    let mut close_brackets_pos:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut char_pos: usize = 0;\n\n    while char_pos < brackets.len()\
    \ {\n        let c: char = brackets[char_pos];\n        if c == '<' {\n      \
    \      if close_brackets_pos == open_brackets_pos {\n                close_brackets\
    \ += &c;\n                close_brackets_pos += 1;\n            } else {\n   \
    \             open_brackets += &c;\n                open_brackets_size += 1;\n\
    \            }\n        } else {\n            if close_brackets_pos == open_brackets_pos\
    \ {\n                open_brackets += &c;\n                open_brackets_pos +=\
    \ 1;\n            } else {\n                close_brackets += &c;\n          \
    \      close_brackets_size += 1;\n            }\n        }\n        char_pos +=\
    \ 1;\n    }\n\n    let open_brackets_len = open_brackets.len();\n    if open_brackets_len\
    \ != close_brackets_size {\n        return false;\n    }\n    let open_brackets_pos_len\
    \ = open_brackets.len() - open_brackets_size;\n    let mut open_brackets_start\
    \ = open_brackets.rfind(\"<\");\n    let mut close_brackets_start = open_brackets.rfind(\"\
    >\");\n\n    if open_brackets_start == -1 && close_brackets_start == -1 {\n  \
    \      if open_brackets_size != close_brackets_size {\n            return false;\n\
    \        }\n        if open_brackets_size == 0 && close_brackets_size == 0 {\n\
    \            return true;\n        }\n        open_brackets_start = open_brackets.rfind(\"\
    <<\");\n        close_brackets_start = open_brackets.rfind(\">>\");\n    }\n \
    \   if open_brackets_start == -1 {\n        return false;\n    }\n    let open_brackets_end\
    \ = open_brackets_start + open_brackets_len;\n    let close_brackets_end = close_brackets_start\
    \ + close_brackets_size;\n    if open_brackets_end >= close_brackets_start {\n\
    \        return false;\n    }\n    let open\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprm4s0a3a.rs:68:13\n   |\n\
    68 |     let open\n   |             ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmprm4s0a3a.rs:21:23\n   |\n21 |         let c: char = brackets[char_pos];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprm4s0a3a.rs:24:35\n\
    \   |\n24 |                 close_brackets += &c;\n   |                      \
    \             ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprm4s0a3a.rs:27:34\n   |\n27 |                 open_brackets +=\
    \ &c;\n   |                                  ^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprm4s0a3a.rs:32:34\n   |\n32 |\
    \                 open_brackets += &c;\n   |                                 \
    \ ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprm4s0a3a.rs:35:35\n   |\n35 |                 close_brackets += &c;\n\
    \   |                                   ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprm4s0a3a.rs:50:31\n   |\n50 |\
    \     if open_brackets_start == -1 && close_brackets_start == -1 {\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c != '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpagu2r0fk.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut it = brackets.char_indices().filter_map(|(_,\
    \ b)| b != 0).collect::<Vec<_>>();\n    it.sort_unstable_by_key(|b| b);\n    for\
    \ (_, b) in it {\n        assert!(\n            b < brackets.chars().count(),\n\
    \            \"The brackets '{}' are not correctly paired.\",\n            &brackets[b],\n\
    \        );\n    }\n\n    let mut it2 = it.clone();\n    let mut last_open_bracket\
    \ = None;\n    let mut last_close_bracket = None;\n    let mut open_brackets =\
    \ Vec::new();\n    let mut close_brackets = Vec::new();\n    let mut found_open_bracket\
    \ = false;\n    let mut found_close_bracket = false;\n\n    while let Some(next_bracket)\
    \ = it2.next() {\n        if let Some(open_bracket) = open_brackets.pop() {\n\
    \            if open_bracket.char() == next_bracket.char() {\n               \
    \ found_open_bracket = false;\n            } else {\n                found_open_bracket\
    \ = true;\n                open_brackets.push(open_bracket);\n            }\n\
    \        }\n        if let Some(close_bracket) = close_brackets.pop() {\n    \
    \        if close_bracket.char() == next_bracket.char() {\n                found_close_bracket\
    \ = false;\n            } else {\n                found_close_bracket = true;\n\
    \                close_brackets.push(close_bracket);\n            }\n        }\n\
    \        if found_close_bracket {\n            if last_close_bracket.is_none()\
    \ {\n                last_close_bracket = Some(next_bracket);\n            } else\
    \ {\n                return false;\n            }\n        } else if found_open_bracket\
    \ {\n            if last_open_bracket.is_none() {\n                last_open_bracket\
    \ = Some(next_bracket);\n            } else {\n                return false;\n\
    \            }\n        } else {\n            if last_open_bracket.is_none() &&\
    \ last_close_bracket.is_none() {\n                if next_bracket.char() != ','\
    \ {\n                    return false;\n                }\n            } else\
    \ if last_open_bracket.is_none() && (next_bracket.char() == ',' || next_bracket.char()\
    \ == ':') {\n                last_close_bracket = Some(next_bracket);\n      \
    \          last_open_bracket = Some(next_bracket);\n            } else {\n   \
    \             return false;\n            }\n        }\n    }\n\n    last_close_bracket.map(|c|\
    \ close_brackets.push(c)).unwrap_or(close_brackets)\n        .into_iter()\n  \
    \      .all(|b\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpjwt6fcyt.rs:75:13\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |         .all(|b\n   |             ^ unclosed delimiter\n76 |\
    \ }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `:`, `@`, or\
    \ `|`, found `)`\n  --> /tmp/tmpjwt6fcyt.rs:76:1\n   |\n75 |         .all(|b\n\
    \   |                - expected one of `:`, `@`, or `|`\n76 | }\n   | ^ unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwt6fcyt.rs:12:67\n \
    \  |\n12 |     let mut it = brackets.char_indices().filter_map(|(_, b)| b != 0).collect::<Vec<_>>();\n\
    \   |                                                                   ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwt6fcyt.rs:12:62\n\
    \   |\n12 |     let mut it = brackets.char_indices().filter_map(|(_, b)| b !=\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \                ^^^^^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n12 |     let mut it = brackets.char_indices().filter_map(|(_,\
    \ b)| Some(b != 0)).collect::<Vec<_>>();\n   |                               \
    \                               +++++      +\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<(_, _)>` in the current scope\n  --> /tmp/tmpjwt6fcyt.rs:30:40\n\
    \   |\n30 |     while let Some(next_bracket) = it2.next() {\n   |            \
    \                            ^^^^ method not found in `Vec<(_, _)>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut found = false;\n    let mut open_brackets = [String::new()];\n\
    \    let mut closing_brackets = [String::new()];\n\n    brackets.split_whitespace().into_iter().for_each(|c|{\n\
    \        if c == \">\" || c == \"<\" {\n            open_brackets.push(c.to_string());\n\
    \        } else {\n            closing_brackets.push(c.to_string());\n       \
    \ }\n    });\n\n    for (i, c) in brackets.char_indices().rev() {\n        if\
    \ open_brackets.contains(&closing_brackets[..i]) {\n            open_brackets.remove(i);\n\
    \            closing_brackets.remove(i);\n            found = true;\n        \
    \    break;\n        }\n    }\n\n    found\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for array `[String; 1]` in the\
    \ current scope\n  --> /tmp/tmp2lr62nf4.rs:18:27\n   |\n18 |             open_brackets.push(c.to_string());\n\
    \   |                           ^^^^ method not found in `[String; 1]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmp2lr62nf4.rs:20:30\n   |\n20 |             closing_brackets.push(c.to_string());\n\
    \   |                              ^^^^ method not found in `[String; 1]`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2lr62nf4.rs:25:35\n   |\n25 |  \
    \       if open_brackets.contains(&closing_brackets[..i]) {\n   |            \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ slice\n   |\n   = note: expected reference `&String`\n              found reference\
    \ `&[String]`\n\nerror[E0599]: no method named `remove` found for array `[String;\
    \ 1]` in the current scope\n  --> /tmp/tmp2lr62nf4.rs:26:27\n   |\n26 |      \
    \       open_brackets.remove(i);\n   |                           ^^^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `remove` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp2lr62nf4.rs:27:30\n\
    \   |\n27 |             closing_brackets.remove(i);\n   |                    \
    \          ^^^^^^ method not found in `[String; 1]`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() == 0 {\n        return true;\n    }\n\
    \n    let mut current_open_bracket = Some(0);\n\n    for ch in brackets {\n  \
    \      let open_count = if ch == '<' {\n            current_open_bracket.map(|c|\
    \ c - 1).unwrap_or(0)\n        } else {\n            0\n        };\n\n       \
    \ if open_count > 0 {\n            if ch == '>' {\n                current_open_bracket\
    \ = Some(open_count + 1);\n            }\n        } else {\n            if ch\
    \ == '>' {\n                current_open_bracket = None;\n            }\n    \
    \    }\n    }\n\n    current_open_bracket.is_some()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpu5cmafna.rs:18:15\n\
    \   |\n18 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut index = 0;\n    while index < brackets.len()\
    \ {\n        if brackets[index] == '<' {\n            let mut found = false;\n\
    \            while index < brackets.len() {\n                if brackets[index]\
    \ == '>' {\n                    found = true;\n                    break;\n  \
    \              }\n                index += 1;\n            }\n            if !found\
    \ {\n                return false;\n            }\n        }\n        index +=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwywe7pl0.rs:14:12\n\
    \   |\n14 |         if brackets[index] == '<' {\n   |            ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwywe7pl0.rs:17:20\n   |\n17 |                 if brackets[index]\
    \ == '>' {\n   |                    ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets;\n    while brackets.len()\
    \ > 1 {\n        brackets = &brackets[..brackets.len() - 1];\n        if brackets.chars().any(|c|\
    \ !(c == '<' || c == '>')) break;\n    }\n    brackets == brackets.to_string()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `break`\n  --> /tmp/tmpfdg47oz5.rs:15:62\n\
    \   |\n15 |         if brackets.chars().any(|c| !(c == '<' || c == '>')) break;\n\
    \   |         --                                                   ^^^^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n   |\nhelp: try placing this code inside a block\n   |\n15 |     \
    \    if brackets.chars().any(|c| !(c == '<' || c == '>')) { break };\n   |   \
    \                                                           +       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfdg47oz5.rs:14:20\n   |\n12 |     let mut brackets\
    \ = brackets;\n   |                        -------- expected due to this value\n\
    13 |     while brackets.len() > 1 {\n14 |         brackets = &brackets[..brackets.len()\
    \ - 1];\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n14\
    \ |         brackets = (&brackets[..brackets.len() - 1]).to_string();\n   |  \
    \                  +                               +++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets.chars().count());\n\
    \    while !stack.is_empty() {\n        let mut i = 0;\n        while i < stack.len()\
    \ {\n            let opening = stack.remove(i);\n            let closing = stack.remove(i);\n\
    \            if opening != closing {\n                return false;\n        \
    \    }\n            i += 1;\n        }\n        stack.push(0);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'removal index (is 0) should be < len (is 0)',\
    \ /tmp/tmp3a7jtabl.rs:18:33\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while !brackets.is_empty()\
    \ {\n        brackets = brackets.replace(&mut \"\", \"<>\");\n    }\n    brackets.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `str`\n   --> /tmp/tmpam70hhix.rs:14:37\n\
    \    |\n14  |         brackets = brackets.replace(&mut \"\", \"<>\");\n    | \
    \                            ------- ^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `str`\n    |                             |\n    |                    \
    \         required by a bound introduced by this call\n    |\n    = help: the\
    \ trait `Fn<(char,)>` is not implemented for `str`\n    = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&'static str`\n  \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&mut &'static str`\nnote: required by a bound in `str::<impl str>::replace`\n\
    help: consider dereferencing here\n    |\n14  |         brackets = brackets.replace(*&mut\
    \ \"\", \"<>\");\n    |                                     +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last_open = String::new();\n    let mut last_close\
    \ = String::new();\n    let mut first_open = false;\n    for (i, char) in brackets.chars().enumerate()\
    \ {\n        if char == '<' {\n            if first_open {\n                last_open\
    \ = char.to_string();\n            } else {\n                first_open = true;\n\
    \                last_open = char.to_string();\n            }\n        } else\
    \ if char == '>' {\n            if !first_open {\n                return false;\n\
    \            }\n            first_open = false;\n            last_close = char.to_string();\n\
    \        } else {\n            return false;\n        }\n    }\n    last_open.reverse();\n\
    \    last_close.reverse();\n    let mut opened_brackets = String::new();\n   \
    \ for (i, char) in brackets.chars().enumerate() {\n        if char == '<' {\n\
    \            opened_brackets.push_str(&last_open[i]);\n        } else if char\
    \ == '>' {\n            opened_brackets.push_str(&last_close[i]);\n        }\n\
    \    }\n    opened_brackets.reverse();\n    opened_brackets == &brackets\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl6pcp5be.rs:33:15\n   |\n33 |     last_open.reverse();\n\
    \   |               ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpl6pcp5be.rs:34:16\n   |\n34 | \
    \    last_close.reverse();\n   |                ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpl6pcp5be.rs:38:39\n   |\n38 |         \
    \    opened_brackets.push_str(&last_open[i]);\n   |                          \
    \             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl6pcp5be.rs:40:39\n   |\n40 |             opened_brackets.push_str(&last_close[i]);\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  -->"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.split('>').rev().all(|x| x.starts_with('<'))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3qdacyzi.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![\"<\"];\n    for ch in brackets\
    \ {\n        if ch == '<' {\n            stack.pop_back();\n        }\n      \
    \  if ch == '>' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop_back();\n            stack.unshift(ch);\n\
    \        }\n        stack.push(ch);\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmptrgyzwlk.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<&str>` in the current scope\n\
    \  --> /tmp/tmptrgyzwlk.rs:15:19\n   |\n15 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<&str>` in the current scope\n\
    \  --> /tmp/tmptrgyzwlk.rs:21:19\n   |\n21 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<&str>`\n\nerror[E0599]:\
    \ no method named `unshift` found for struct `Vec<&str>` in the current scope\n\
    \  --> /tmp/tmptrgyzwlk.rs:22:19\n   |\n22 |             stack.unshift(ch);\n\
    \   |                   ^^^^^^^ method not found in `Vec<&str>`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmptrgyzwlk.rs:14:15\n   |\n14\
    \ |         if ch == '<' {\n   |               ^^ no implementation for `&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmptrgyzwlk.rs:17:15\n   |\n17 |         if ch\
    \ == '>' {\n   |               ^^ no implementation for `&str == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help:\
    \ the following other types implement trait `Partial"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"<\") && !brackets.contains(\">\"\
    )\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq5i4m_wn.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == \">\") && brackets.chars().all(|c|\
    \ c == \"<\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpikls79dw.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == \">\") && brackets.chars().all(|c| c ==\
    \ \"<\")\n   |                                   ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    12 |     brackets.chars().all(|c| c == '>') && brackets.chars().all(|c| c == \"\
    <\")\n   |                                   ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpikls79dw.rs:12:73\n   |\n12 |     brackets.chars().all(|c| c ==\
    \ \">\") && brackets.chars().all(|c| c == \"<\")\n   |                       \
    \                                                  ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n12 |     brackets.chars().all(|c| c == \">\") && brackets.chars().all(|c|\
    \ c == '<')\n   |                                                            \
    \             ~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Find a left opening bracket.\n    let left_bracket\
    \ = brackets.find('<').unwrap();\n    // Find the first right opening bracket.\n\
    \    let right_bracket = brackets.rfind('<').unwrap();\n    // Check if the opening\
    \ brackets are in the correct place.\n    left_bracket < right_bracket && left_bracket\
    \ != 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp99fhiaqq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            stack.push(c);\n        } else if c ==\
    \ '>' {\n            if stack.len() > 0 {\n                if stack.last().unwrap()\
    \ != c {\n                    return false;\n                }\n             \
    \   stack.pop();\n            } else {\n                return false;\n      \
    \      }\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0j0yoxe7.rs:18:42\n\
    \   |\n18 |                 if stack.last().unwrap() != c {\n   |            \
    \                              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets;\n    brackets.replace(\"\
    <\", \"<<\").replace(\"<=\", \"<\").replace(\">\", \">>\").replace(\">=\", \"\
    >\").to_string();\n    let mut first = true;\n    while brackets.len() > 0 {\n\
    \        let mut open_brackets: Vec<_> = brackets.split_whitespace().collect();\n\
    \        if open_brackets.len() > 2 {\n            // only need 2 opening brackets\n\
    \            break;\n        }\n\n        let mut closing_brackets: Vec<_> = brackets.split_whitespace().collect();\n\
    \        if closing_brackets.len() > 2 {\n            // only need 2 closing brackets\n\
    \            break;\n        }\n\n        if opening == closing\n            ||\
    \ opening.is_empty()\n            || closing.is_empty()\n        {\n         \
    \   // if we're not at two opening brackets or two closing brackets,\n       \
    \     // we've found an opening bracket\n            if opening != \"\" {\n  \
    \              // found an opening bracket\n                let mut last = opening.len();\n\
    \                let mut last2 = closing.len();\n                while last2 <\
    \ last {\n                    // if we have two closing brackets and we've found\
    \ an\n                    // opening bracket, we'll still have two closing\n \
    \                   // brackets, and the correct closing bracket will go\n   \
    \                 // after that opening bracket\n                    if closing_brackets.len()\
    \ > 0 && closing.is_empty() {\n                        break;\n              \
    \      }\n                    last += 1;\n                    last2 += 1;\n  \
    \                  if last > closing_brackets.len() || last2 > closing.len() {\n\
    \                        // we've found a closing bracket that doesn't match\n\
    \                        // an opening bracket (no opening bracket) or a\n   \
    \                     // closing bracket that doesn't match the closing\n    \
    \                    // bracket (a closing bracket after a matching\n        \
    \                // opening bracket). we'll move the other closing\n         \
    \               // bracket to the beginning of the string\n                  \
    \      break;\n                    }\n                    let c = closing_brackets.remove(0).unwrap();\n\
    \                    closing.insert(last2, c);\n                }\n          \
    \  }\n            // we've found a closing bracket\n            let mut last:\
    \ usize = closing.len();\n            while last > 0 {\n                // if\
    \ we have two opening brackets and we've found a\n                // closing bracket,\
    \ we'll still have two opening\n                // brackets, and the correct opening\
    \ bracket will go\n                // after that closing bracket\n           \
    \     if opening.is_empty() {\n                    break;\n                }\n\
    \                last -= 1;\n                // if we have two closing brackets\
    \ and we've found a\n                // closing bracket, we'll still have two\
    \ closing\n                // brackets, and the correct closing bracket will go\n\
    \                // after that opening bracket\n\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpysuzg9gx.rs:93:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n31 |         {\n   |         - unclosed delimiter\n...\n63 |            \
    \ while last > 0 {\n   |                            - this delimiter might not\
    \ be properly closed...\n...\n77 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n93 | }\n   |   ^\n\nerror[E0425]: cannot find value\
    \ `opening` in this scope\n  --> /tmp/tmpysuzg9gx.rs:28:12\n   |\n28 |       \
    \  if opening == closing\n   |            ^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `closing` in this scope\n  --> /tmp/tmpysuzg9gx.rs:28:23\n\
    \   |\n28 |         if opening == closing\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `opening` in this\
    \ scope\n  --> /tmp/tmpysuzg9gx.rs:29:16\n   |\n29 |             || opening.is_empty()\n\
    \   |                ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `closing` in this scope\n  --> /tmp/tmpysuzg9gx.rs:30:16\n   |\n30 | \
    \            || closing.is_empty()\n   |                ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `opening` in this scope\n  --> /tmp/tmpysuzg9gx.rs:34:16\n\
    \   |\n34 |             if opening != \"\" {\n   |                ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `opening` in this scope\n\
    \  --> /tmp/tmpysuzg9gx.rs:36:32\n   |\n36 |                 let mut last = opening.len();\n\
    \   |                                ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `closing` in this scope\n  --> /tmp/tmpysuzg9gx.rs:37:33\n\
    \   |\n37 |                 let mut last2 = closing.len();\n   |             \
    \                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `closing` in this scope\n  --> /tmp/tmpysuzg9gx.rs:43:54\n   |\n43 | \
    \                    if closing_"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains('<') && brackets.contains('>')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvaz7mw43.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter_map(|c| match c {\n        '<'\
    \ => {\n            Some('>')\n        }\n        '>' => {\n            Some('<')\n\
    \        }\n        _ => None,\n    }).all(|c| {\n        let mut found = false;\n\
    \        for (_, c) in brackets.chars().skip(1) {\n            if c == c {\n \
    \               found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        found\n    })\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpel2v15fr.rs:22:13\n   |\n\
    22 |         for (_, c) in brackets.chars().skip(1) {\n   |             ^^^^^^\
    \    ------------------------ this expression has type `Option<char>`\n   |  \
    \           |\n   |             expected `char`, found tuple\n   |\n   = note:\
    \ expected type `char`\n             found tuple `(_, _)`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut chars = brackets.chars();\n    let mut open_brackets\
    \ = HashSet::new();\n    let mut close_brackets = HashSet::new();\n    let mut\
    \ open = HashSet::new();\n    let mut close = HashSet::new();\n\n    while chars.next()\
    \ {\n        let c = chars.next().unwrap();\n        if let Some(open) = open.find(&c)\
    \ { open_brackets.insert(open); }\n        else if let Some(close) = close.find(&c)\
    \ { close_brackets.insert(close); }\n        else {\n            open.insert(c);\n\
    \            if c == \">\" {\n                close.insert(\"</>\");\n       \
    \     }\n            close.insert(c);\n        }\n    }\n\n    close_brackets.is_superset(open_brackets)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpwdxmvolc.rs:13:29\n   |\n13 |     let mut open_brackets = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpwdxmvolc.rs:14:30\n   |\n14 |     let mut close_brackets = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpwdxmvolc.rs:15:20\n   |\n15 |     let mut open = HashSet::new();\n\
    \   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpwdxmvolc.rs:16:21\n\
    \   |\n16 |     let mut close = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwdxmvolc.rs:18:11\n   |\n18 |     while chars.next() {\n   |  \
    \         ^^^^^^^^^^^^ expected `bool`, found enum `Option`\n   |\n   = note:\
    \ expected type `bool`\n              found enum `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwdxmvolc.rs:24:21\n   |\n24 |             if\
    \ c == \">\" {\n   |                     ^^^ expected `char`, found `&str`\n \
    \  |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    24 |             if c == '>' {\n   |                     ~~~\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [brackets.to_string()];\n    while let\
    \ Some(b) = stack.pop() {\n        match b {\n            \"<\" => {\n       \
    \         if stack.len() < 1 {\n                    return false;\n          \
    \      }\n                let mut has_right_open_bracket = false;\n          \
    \      for x in &stack[stack.len() - 1] {\n                    if x == \"<\" {\n\
    \                        has_right_open_bracket = true;\n                    \
    \    break;\n                    }\n                }\n                if has_right_open_bracket\
    \ {\n                    stack.pop();\n                } else {\n            \
    \        stack.push(b);\n                }\n            }\n            _ => stack.push(b),\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop` found for array `[String; 1]` in the\
    \ current scope\n  --> /tmp/tmpe5j3yw8u.rs:13:31\n   |\n13 |     while let Some(b)\
    \ = stack.pop() {\n   |                               ^^^ method not found in\
    \ `[String; 1]`\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpe5j3yw8u.rs:20:26\n\
    \   |\n20 |                 for x in &stack[stack.len() - 1] {\n   |         \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^ `&String` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current\
    \ scope\n  --> /tmp/tmpe5j3yw8u.rs:27:27\n   |\n27 |                     stack.pop();\n\
    \   |                           ^^^ method not found in `[String; 1]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmpe5j3yw8u.rs:29:27\n   |\n29 |                     stack.push(b);\n\
    \   |                           ^^^^ method not found in `[String; 1]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmpe5j3yw8u.rs:32:24\n   |\n32 |             _ => stack.push(b),\n\
    \   |                        ^^^^ method not found in `[String; 1]`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() < 2 { false }\n    else if brackets.chars().any(|x|\
    \ !x.is_ascii_digit()) { false }\n    else if brackets.len() > 2 { true }\n  \
    \  else if brackets.chars().any(|x| x < '<' || x > '>') { false }\n    else {\
    \ correct_bracketing(brackets[1..brackets.len() - 1]) }\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv92r9u49.rs:16:31\n   |\n\
    16 |     else { correct_bracketing(brackets[1..brackets.len() - 1]) }\n   |  \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                               |\n\
    \   |                               expected struct `String`, found `str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [String::new(); 0];\n    let mut bracket\
    \ = String::new();\n    stack.push(\"\");\n\n    for c in brackets {\n       \
    \ match c {\n            '<' => {\n                if stack.len() >= stack.last().unwrap().len()\
    \ {\n                    return false;\n                } else {\n           \
    \         stack = stack.pop().unwrap().push(\"<\");\n                }\n     \
    \       }\n            '>' => {\n                if stack.len() >= stack.last().unwrap().len()\
    \ {\n                    return false;\n                } else {\n           \
    \         stack = stack.pop().unwrap().push(\">\");\n                }\n     \
    \       }\n            '[' => {\n                if stack.len() >= stack.last().unwrap().len()\
    \ {\n                    return false;\n                } else {\n           \
    \         stack = stack.pop().unwrap().push(\"[\");\n                }\n     \
    \       }\n            ']' => {\n                if stack.len() >= stack.last().unwrap().len()\
    \ {\n                    return false;\n                } else {\n           \
    \         stack = stack.pop().unwrap().push(\"]\");\n                }\n     \
    \       }\n            c => {\n                bracket = c;\n            }\n \
    \       }\n    }\n    for (_, s) in stack.iter().enumerate() {\n        if s !=\
    \ \"\" {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for array `[String; 0]` in the\
    \ current scope\n  --> /tmp/tmprcp24hcg.rs:14:11\n   |\n14 |     stack.push(\"\
    \");\n   |           ^^^^ method not found in `[String; 0]`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmprcp24hcg.rs:16:14\n   |\n16 |     for c in\
    \ brackets {\n   |              ^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0599]: no method named `pop` found for\
    \ array `[String; 0]` in the current scope\n  --> /tmp/tmprcp24hcg.rs:22:35\n\
    \   |\n22 |                     stack = stack.pop().unwrap().push(\"<\");\n  \
    \ |                                   ^^^ method not found in `[String; 0]`\n\n\
    error[E0599]: no method named `pop` found for array `[String; 0]` in the current\
    \ scope\n  --> /tmp/tmprcp24hcg.rs:29:35\n   |\n29 |                     stack\
    \ = stack.pop().unwrap().push(\">\");\n   |                                  \
    \ ^^^ method not found in `[String; 0]`\n\nerror[E0599]: no method named `pop`\
    \ found for array `[String; 0]` in the current scope\n  --> /tmp/tmprcp24hcg.rs:36:35\n\
    \   |\n36 |                     stack = stack.pop().unwrap().push(\"[\");\n  \
    \ |                                   ^^^ method not found in `[String; 0]`\n\n\
    error[E0599]: no method named `pop` found for array `[String; 0]` in the current\
    \ scope\n  --> /tmp/tmprcp24hcg.rs:43:35\n   |\n43 |                     stack\
    \ = stack.pop().unwrap().push(\"]\");\n   |                                  \
    \ ^^^ method not found in `[String; 0]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprcp24hcg.rs:47:27\n   |\n13 |     let mut bracket = String::new();\n\
    \   |                       ------------- expected due to this value\n...\n47\
    \ |                 bracket = c;\n   |                           ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                           |\n\
    \   |                           expected struct `String`, found `char`\n\nerror: "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        c != '>' &&\n   \
    \     c != '<' &&\n        c != '[' &&\n        c != ']'\n    })\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxg9ka7tr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut found = false;\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            if found {\n                return false;\n\
    \            }\n            found = true;\n        } else {\n            found\
    \ = false;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqpngcdmc.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        return false;\n   \
    \ }\n\n    let mut s = brackets;\n    let mut stack = Vec::new();\n\n    for c\
    \ in s.chars() {\n        if c == '<' {\n            stack.push(c);\n        }\
    \ else if c == '>' {\n            while stack.poll().unwrap() == '<' {\n     \
    \           stack.push(c);\n            }\n        } else {\n            return\
    \ false;\n        }\n    }\n\n    if stack.is_empty() {\n        return true;\n\
    \    }\n\n    // if the stack is not empty, there is a missing closing bracket\n\
    \    // so return false\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `poll` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpir86dnr_.rs:23:25\n   |\n23 |             while\
    \ stack.poll().unwrap() == '<' {\n   |                         ^^^^ method not\
    \ found in `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left = String::new();\n    let mut right = String::new();\n\
    \    let mut depth = 0;\n\n    for ch in &brackets {\n        if ch == '<' {\n\
    \            depth += 1;\n            left += &ch;\n        } else if ch == '>'\
    \ {\n            depth -= 1;\n            right += &ch;\n        } else if depth\
    \ == 0 {\n            left += &ch;\n        } else {\n            right += &ch;\n\
    \        }\n    }\n\n    left == right\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpntun8ji6.rs:16:15\n\
    \   |\n16 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpntun8ji6.rs:16:9\n   |\n\
    16 |     for ch in &brackets {\n   |         ^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpntun8ji6.rs:16:15\n\
    \    |\n16  |     for ch in &brackets {\n    |               ^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpntun8ji6.rs:16:5\n    |\n16  | /     for ch in &brackets {\n17  | |\
    \         if ch == '<' {\n18  | |             depth += 1;\n19  | |           \
    \  left += &ch;\n...   |\n27  | |         }\n28  | |     }\n    | |_____^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `None`\n\nerror[E0277]:\
    \ can't compare `str` with `char`\n  --> /tmp/tmpntun8ji6.rs:17:15\n   |\n17 |\
    \         if ch == '<' {\n   |               ^^ no implementation for `str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a,"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets {\n       \
    \ if c == '<' {\n            count += 1;\n        } else {\n            count\
    \ -= 1;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpada_y3mw.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(brackets);\n\
    \    while !stack.is_empty() {\n        let current = &stack.pop();\n        if\
    \ current.len() == 1 {\n            if current.chars().all(|c| !c.is_alphanumeric()\
    \ && !c.is_punctuation()) {\n                return true;\n            }\n   \
    \     }\n        for c in current.chars() {\n            if !c.is_alphanumeric()\
    \ && c.is_punctuation() && stack.len() > 0 {\n                stack.push(c);\n\
    \            }\n            if !c.is_alphanumeric() && !c.is_punctuation() &&\
    \ stack.len() == 1 {\n                stack.push(c);\n            }\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&Option<String>`\
    \ in the current scope\n  --> /tmp/tmpdwfau506.rs:16:20\n   |\n16 |         if\
    \ current.len() == 1 {\n   |                    ^^^ method not found in `&Option<String>`\n\
    \nerror[E0599]: no method named `chars` found for reference `&Option<String>`\
    \ in the current scope\n  --> /tmp/tmpdwfau506.rs:17:24\n   |\n17 |          \
    \   if current.chars().all(|c| !c.is_alphanumeric() && !c.is_punctuation()) {\n\
    \   |                        ^^^^^ method not found in `&Option<String>`\n\nerror[E0599]:\
    \ no method named `chars` found for reference `&Option<String>` in the current\
    \ scope\n  --> /tmp/tmpdwfau506.rs:21:26\n   |\n21 |         for c in current.chars()\
    \ {\n   |                          ^^^^^ method not found in `&Option<String>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut buffer = String::new();\n    buffer.push_str(brackets);\n\
    \    buffer.push('\\0');\n\n    // Keep track of how many opening brackets have\
    \ been seen.\n    let mut num_brackets: usize = 0;\n    for c in buffer.chars()\
    \ {\n        if c == '<' {\n            num_brackets += 1;\n        }\n      \
    \  if c == '>' {\n            num_brackets -= 1;\n        }\n    }\n    num_brackets\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5dzop5vq.rs:13:21\n   |\n\
    13 |     buffer.push_str(brackets);\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&brackets`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for c in brackets {\n        if c != '<' {\n         \
    \   open_brackets.push(c);\n        } else {\n            open_brackets.push(c);\n\
    \            if open_brackets.is_empty() {\n                return false;\n  \
    \          }\n            let mut last_c = None;\n            for i in 0..open_brackets.len()\
    \ - 1 {\n                if open_brackets[i] == '>' {\n                    closed_brackets.push(i);\n\
    \                    last_c = i;\n                    break;\n               \
    \ }\n            }\n            if last_c.is_none() {\n                return\
    \ false;\n            }\n            open_brackets.push_str(&open_brackets[last_c.unwrap()..]);\n\
    \        }\n    }\n    let open = open_brackets.chars().filter(|c| c == '<').count();\n\
    \    let closed = closed_brackets.chars().filter(|c| c == '>').count();\n    open\
    \ >= closed\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpauppv2xc.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpauppv2xc.rs:24:20\n\
    \   |\n24 |                 if open_brackets[i] == '>' {\n   |               \
    \     ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauppv2xc.rs:25:42\n\
    \   |\n25 |                     closed_brackets.push(i);\n   |               \
    \                           ^ expected `char`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpauppv2xc.rs:26:30\n   |\n22 |             let\
    \ mut last_c = None;\n   |                              ---- expected due to this\
    \ value\n...\n26 |                     last_c = i;\n   |                     \
    \         ^ expected enum `Option`, found `usize`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found type `usize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n26 |                     last_c = Some(i);\n   |          \
    \                    +++++ +\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpauppv2xc.rs:36:51\n   |\n36 |     let open = open_brackets.chars().filter(|c|\
    \ c == '<').count();\n   |                                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `Partial"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.count('<') == brackets.count('>')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmppu00e1pb.rs:12:14\n\
    \    |\n12  |       brackets.count('<') == brackets.count('>')\n    |        \
    \        ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmppu00e1pb.rs:12:37\n\
    \    |\n12  |       brackets.count('<') == brackets.count('>')\n    |        \
    \                               ^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .as_bytes()\n        .iter()\n    \
    \    .zip(\n            brackets.chars().take_while(|c| c != '<').filter(|c| c\
    \ != '>'),\n        )\n        .all(|(_, bracket)| bracket == '<')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8su09ss6.rs:16:47\n\
    \   |\n16 |             brackets.chars().take_while(|c| c != '<').filter(|c| c\
    \ != '>'),\n   |                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8su09ss6.rs:16:68\n\
    \   |\n16 |             brackets.chars().take_while(|c| c != '<').filter(|c| c\
    \ != '>'),\n   |                                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Loop through every character in the string.\n    for\
    \ (i, c) in brackets.chars().enumerate() {\n        // Skip non-\"<\"s.\n    \
    \    if !c.is_ascii() || c == '<' {\n            continue;\n        }\n\n    \
    \    // Iterate through the rest of the string and check if the current character\
    \ is an \">\".\n        let j = i + 1;\n        let last = brackets.chars().last_unwrap();\n\
    \        if j < last && !last.is_ascii() || last == '>' {\n            // It isn't,\
    \ so we have a problem.\n            return false;\n        }\n    }\n    // If\
    \ we made it here, then every opening bracket has a corresponding closing bracket.\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `last_unwrap` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp9nb_gvej.rs:21:37\n   |\n21 |         let last\
    \ = brackets.chars().last_unwrap();\n   |                                    \
    \ ^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `is_ascii` found for type `usize` in the current scope\n  --> /tmp/tmp9nb_gvej.rs:22:30\n\
    \   |\n22 |         if j < last && !last.is_ascii() || last == '>' {\n   |   \
    \                           ^^^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nb_gvej.rs:22:52\n   |\n22 |         if j <\
    \ last && !last.is_ascii() || last == '>' {\n   |                            \
    \                        ^^^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [0i32; 256];\n    let mut chars = brackets.chars().enumerate().collect::<Vec<_>>();\n\
    \n    while chars.len() > 0 {\n        let (idx, char) = chars.pop();\n\n    \
    \    if char == '>' {\n            if stack[idx + 1] < 0 {\n                return\
    \ false;\n            }\n        } else {\n            if stack[idx + 1] >= 0\
    \ {\n                return false;\n            }\n        }\n\n        stack[idx\
    \ + 1] += char as i32;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdd1d8ffg.rs:16:13\n   |\n\
    16 |         let (idx, char) = chars.pop();\n   |             ^^^^^^^^^^^   -----------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected enum `Option`, found tuple\n   |\n   = note: expected enum\
    \ `Option<(usize, char)>`\n             found tuple `(_, _)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = Vec::new();\n    let mut close = Vec::new();\n\
    \    brackets.split_whitespace().for_each(|c| match c {\n        '<' => open.push(1),\n\
    \        '>' => close.push(1),\n        _ => panic!(\"{}\", c)\n    });\n    !close.iter().all(|c|\
    \ !open.contains(c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyf6pnmji.rs:15:9\n   |\n\
    14 |     brackets.split_whitespace().for_each(|c| match c {\n   |            \
    \                                        - this expression has type `&str`\n15\
    \ |         '<' => open.push(1),\n   |         ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyf6pnmji.rs:16:9\n   |\n14 | \
    \    brackets.split_whitespace().for_each(|c| match c {\n   |                \
    \                                    - this expression has type `&str`\n15 | \
    \        '<' => open.push(1),\n16 |         '>' => close.push(1),\n   |      \
    \   ^^^ expected `str`, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets == brackets\n        .as_str()\n        .into_iter()\n\
    \        .map(|b| if b == \">\" {\n            \">\"\n        } else {\n     \
    \       b\n        })\n        .all(|b| b == \">\")\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: the method `into_iter` exists for reference `&str`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp8wqa_2ek.rs:14:10\n   |\n14 |\
    \         .into_iter()\n   |          ^^^^^^^^^ method cannot be called on `&str`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `&str: Iterator`\n           which is required\
    \ by `&str: IntoIterator`\n           `&&str: Iterator`\n           which is required\
    \ by `&&str: IntoIterator`\n           `&mut &str: Iterator`\n           which\
    \ is required by `&mut &str: IntoIterator`\n           `str: Sized`\n        \
    \   which is required by `str: IntoIterator`\n           `str: Iterator`\n   \
    \        which is required by `str: IntoIterator`\n           `&mut str: Iterator`\n\
    \           which is required by `&mut str: IntoIterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets;\n    let mut opening_brackets\
    \ = String::new();\n    let mut closing_brackets = String::new();\n    let mut\
    \ last = 0;\n    while brackets.len() > 0 {\n        let mut i = 0;\n        while\
    \ i < brackets.len() && brackets[i] != '<' {\n            i += 1;\n        }\n\
    \        let mut j = i;\n        while j < brackets.len() && brackets[j] != '>'\
    \ {\n            j += 1;\n        }\n        if i == j {\n            continue;\n\
    \        }\n        let mut new_str = String::new();\n        new_str.push_str(&brackets[last..i]);\n\
    \        new_str.push_str(\"<<\");\n        new_str.push_str(&brackets[j..]);\n\
    \        new_str.push_str(\">>\");\n        if opening_brackets == new_str {\n\
    \            opening_brackets.push_str(\"<<\");\n            closing_brackets.push_str(\"\
    <<\");\n        } else {\n            opening_brackets = new_str;\n          \
    \  closing_brackets = new_str;\n        }\n        last = j;\n    }\n    let mut\
    \ i1 = 0;\n    let mut i2 = opening_brackets.len();\n    while i1 < opening_brackets.len()\
    \ {\n        let mut j1 = 0;\n        let mut j2 = closing_brackets.len();\n \
    \       while j1 < j2 {\n            let mut char_count = 0;\n            let\
    \ mut pos = 0;\n            while pos < j1 && char_count < 3 {\n             \
    \   pos = j1 + 1;\n                let mut i = 0;\n                while i < i2\
    \ && opening_brackets[i] != closing_brackets[pos] {\n                    i +=\
    \ 1;\n                }\n                if i == i2 {\n                    char_count\
    \ += 1;\n                    j1 = j1 + 1;\n                } else {\n        \
    \            j1 = pos + 1;\n                }\n            }\n            if char_count\
    \ == 3 {\n                i2 = i2 + 1;\n            } else {\n               \
    \ j1 = j1 + 1;\n            }\n        }\n        i1 = i1 + 1;\n    }\n    i1\
    \ == opening_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdsat3v7d.rs:18:37\n\
    \   |\n18 |         while i < brackets.len() && brackets[i] != '<' {\n   |   \
    \                                  ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdsat3v7d.rs:22:37\n   |\n22 |         while j < brackets.len()\
    \ && brackets[j] != '>' {\n   |                                     ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdsat3v7d.rs:53:33\n   |\n53 |                 while i < i2 && opening_brackets[i]\
    \ != closing_brackets[pos] {\n   |                                 ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<Rang"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == '<')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy76nw0dn.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '<')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c < '>')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4oph_70g.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left_depth = 0;\n    let mut right_depth = 0;\n\
    \    for c in brackets.chars() {\n        match c {\n            '>' => right_depth\
    \ = right_depth - 1,\n            '<' => left_depth = left_depth + 1,\n      \
    \      _ => (),\n        }\n        if left_depth == 0 && right_depth == 0 {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx23gjjan.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if !brackets.is_empty() && brackets[0] == '>' {\n   \
    \     let mut found_open_bracket = false;\n        for bracketed_char in brackets.chars().skip_while(|c|\
    \ !found_open_bracket && c == '<') {\n            if found_open_bracket {\n  \
    \              return false;\n            }\n            found_open_bracket =\
    \ bracketed_char == '>';\n        }\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppjpb_6fp.rs:12:32\n   |\n12 |     if !brackets.is_empty() && brackets[0]\
    \ == '>' {\n   |                                ^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppjpb_6fp.rs:14:88\n\
    \   |\n14 |         for bracketed_char in brackets.chars().skip_while(|c| !found_open_bracket\
    \ && c == '<') {\n   |                                                       \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut is_correct = true;\n    brackets.chars().filter_map(|c|\
    \ match c {\n        '<' => Some(true),\n        _ => Some(false),\n    }).for_each(|b|\
    \ {\n        is_correct = is_correct && b;\n    });\n    is_correct\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe6lr_rns.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        match c {\n     \
    \       '<' => {\n                c.to_string().chars().all(|c| c != '>')\n  \
    \          }\n            '>' => {\n                c.to_string().chars().all(|c|\
    \ c != '<')\n            }\n            _ => false,\n        }\n    })\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcp00ht4y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty() || brackets.chars().any(|c| c ==\
    \ '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd16ct_68.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets: Vec<_> = brackets\n        .chars()\n\
    \        .filter(|c| *c != '<')\n        .collect();\n    open_brackets.push(0);\n\
    \    open_brackets.sort_unstable();\n    let mut close_brackets: Vec<_> = brackets\n\
    \        .chars()\n        .filter(|c| *c != '>')\n        .collect();\n    close_brackets.push(0);\n\
    \    close_brackets.sort_unstable();\n    let mut open = open_brackets.next();\n\
    \    let mut close = close_brackets.next();\n    while let Some(open) = open {\n\
    \        while let Some(close) = close {\n            if *open == *close {\n \
    \               match open {\n                    None => return false,\n    \
    \                Some(open) => open = open_brackets.next(),\n                }\n\
    \                match close {\n                    None => return false,\n  \
    \                  Some(close) => close = close_brackets.next(),\n           \
    \     }\n            } else {\n                return false;\n            }\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbpnyhqi4.rs:16:24\n   |\n\
    16 |     open_brackets.push(0);\n   |                        ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbpnyhqi4.rs:22:25\n\
    \   |\n22 |     close_brackets.push(0);\n   |                         ^ expected\
    \ `char`, found `u8`\n\nerror[E0599]: no method named `next` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmpbpnyhqi4.rs:24:34\n   |\n24\
    \ |     let mut open = open_brackets.next();\n   |                           \
    \       ^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpbpnyhqi4.rs:25:36\n\
    \   |\n25 |     let mut close = close_brackets.next();\n   |                 \
    \                   ^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpbpnyhqi4.rs:31:56\n\
    \   |\n31 |                     Some(open) => open = open_brackets.next(),\n \
    \  |                                                        ^^^^ method not found\
    \ in `Vec<char>`\n\nerror[E0599]: no method named `next` found for struct `Vec<char>`\
    \ in the current scope\n  --> /tmp/tmpbpnyhqi4.rs:35:59\n   |\n35 |          \
    \           Some(close) => close = close_brackets.next(),\n   |              \
    \                                             ^^^^ method not found in `Vec<char>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c.is_ascii() && c != '>')\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphdjzcjxo.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter(|c| c == '<').count() == brackets.chars().filter(|c|\
    \ c == '>').count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu98exav3.rs:12:35\n\
    \   |\n12 |     brackets.chars().filter(|c| c == '<').count() == brackets.chars().filter(|c|\
    \ c == '>').count()\n   |                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu98exav3.rs:12:84\n\
    \   |\n12 |     brackets.chars().filter(|c| c == '<').count() == brackets.chars().filter(|c|\
    \ c == '>').count()\n   |                                                    \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // We need to do this by hand, because brackets.rfind()\
    \ doesn't do what we want.\n    let mut last = None;\n    for c in &brackets {\n\
    \        if c == '<' {\n            last = Some(c.to_string());\n        } else\
    \ {\n            if last == Some(\"<\") {\n                last = Some(c.to_string());\n\
    \            } else {\n                last = None;\n            }\n        }\n\
    \    }\n    last.is_none()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp32hlaivw.rs:14:14\n\
    \   |\n14 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.chars();\n\n    let mut previous_closing_bracket\
    \ = None;\n    loop {\n        let c = iter.next().unwrap();\n        if previous_closing_bracket\
    \ != Some(c as char) {\n            previous_closing_bracket = Some(c as char);\n\
    \            assert!(iter.next().is_none());\n        } else {\n            assert!(iter.next().is_none());\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: iter.next().is_none()', /tmp/tmpg1rf19o7.rs:19:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for ch in brackets {\n    \
    \    if *ch != '>' && *ch != '<' && *ch != ' ' {\n            return false;\n\
    \        }\n        counter += 1;\n    }\n\n    if counter == 0 {\n        return\
    \ true;\n    }\n    counter == brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpar25di8i.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last = 0;\n    let mut lastclosed = -1;\n   \
    \ for (i, c) in brackets.chars().enumerate() {\n        last = i;\n        if\
    \ c == \">\" || c == \"<\" {\n            lastclosed = i;\n        }\n    }\n\
    \    lastclosed != -1 && lastclosed < last\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t161e66.rs:16:17\n   |\n\
    16 |         if c == \">\" || c == \"<\" {\n   |                 ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n16 |         if c == '>' || c == \"<\" {\n   |        \
    \         ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1t161e66.rs:16:29\n\
    \   |\n16 |         if c == \">\" || c == \"<\" {\n   |                      \
    \       ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a\
    \ `char` literal, use single quotes\n   |\n16 |         if c == \">\" || c ==\
    \ '<' {\n   |                             ~~~\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp1t161e66.rs:13:26\n   |\n13 | \
    \    let mut lastclosed = -1;\n   |                          ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp1t161e66.rs:20:19\n   |\n20 |  \
    \   lastclosed != -1 && lastclosed < last\n   |                   ^^\n   |   \
    \                |\n   |                   cannot apply unary operator `-`\n \
    \  |                   help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![False; BRACKETS.len()];\n    stack[BRACKETS.len()-1]\
    \ = true;\n    for (i, c) in BRACKETS.chars().enumerate() {\n        if c == c\
    \ {\n            stack[i] = true;\n        } else {\n            if stack[i -\
    \ 2] {\n                return false;\n            }\n            if stack[i -\
    \ 1] {\n                return false;\n            }\n            stack[i] = true;\n\
    \        }\n    }\n    stack[BRACKETS.len()-1] == true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `False` in this scope\n  --> /tmp/tmp4r6v2by3.rs:12:26\n\
    \   |\n12 |     let mut stack = vec![False; BRACKETS.len()];\n   |           \
    \               ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `BRACKETS` in this scope\n  --> /tmp/tmp4r6v2by3.rs:12:33\n   |\n12 |     let\
    \ mut stack = vec![False; BRACKETS.len()];\n   |                             \
    \    ^^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\n\
    error[E0425]: cannot find value `BRACKETS` in this scope\n  --> /tmp/tmp4r6v2by3.rs:13:11\n\
    \   |\n13 |     stack[BRACKETS.len()-1] = true;\n   |           ^^^^^^^^ help:\
    \ a local variable with a similar name exists: `brackets`\n\nerror[E0425]: cannot\
    \ find value `BRACKETS` in this scope\n  --> /tmp/tmp4r6v2by3.rs:14:19\n   |\n\
    14 |     for (i, c) in BRACKETS.chars().enumerate() {\n   |                  \
    \ ^^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\nerror[E0425]:\
    \ cannot find value `BRACKETS` in this scope\n  --> /tmp/tmp4r6v2by3.rs:27:11\n\
    \   |\n27 |     stack[BRACKETS.len()-1] == true\n   |           ^^^^^^^^ help:\
    \ a local variable with a similar name exists: `brackets`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut pos = 0;\n    while pos < brackets.len() {\n\
    \        let next_pos = pos + 1;\n        if next_pos >= brackets.len() {\n  \
    \          break;\n        }\n        if brackets[pos] == '<' && brackets[next_pos]\
    \ == '>' {\n            pos += 1;\n            next_pos;\n        } else {\n \
    \           pos += 1;\n        }\n    }\n    pos == brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo01qpp5g.rs:18:12\n\
    \   |\n18 |         if brackets[pos] == '<' && brackets[next_pos] == '>' {\n \
    \  |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo01qpp5g.rs:18:36\n\
    \   |\n18 |         if brackets[pos] == '<' && brackets[next_pos] == '>' {\n \
    \  |                                    ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<_> = vec![];\n    stack.push(brackets.chars().nth(0).unwrap());\n\
    \    for c in brackets.chars().nth(1) {\n        if stack.len() == 0 || stack.last().unwrap()\
    \ != c {\n            return false;\n        }\n        stack.pop();\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpf81le05r.rs:15:54\n\
    \   |\n15 |         if stack.len() == 0 || stack.last().unwrap() != c {\n   |\
    \                                                      ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut i = 0;\n    while i < brackets.len() {\n    \
    \    if brackets[i] == '<' {\n            if i + 1 < brackets.len() && brackets[i\
    \ + 1] == '>' {\n                i += 2;\n            }\n            else {\n\
    \                return false;\n            }\n        }\n        else if (brackets[i]\
    \ == '>') {\n            if i + 1 < brackets.len() && brackets[i + 1] == '<' {\n\
    \                i += 2;\n            }\n            else {\n                return\
    \ false;\n            }\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfvshu_nn.rs:22:17\n\
    \   |\n22 |         else if (brackets[i] == '>') {\n   |                 ^   \
    \               ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n22 -         else if (brackets[i] == '>') {\n\
    22 +         else if brackets[i] == '>' {\n   | \n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfvshu_nn.rs:14:12\n   |\n14 |  \
    \       if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfvshu_nn.rs:15:42\n   |\n15 |             if i + 1 < brackets.len()\
    \ && brackets[i + 1] == '>' {\n   |                                          ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfvshu_nn.rs:22:18\n   |\n22 |         else if (brackets[i] == '>')\
    \ {\n   |                  ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not impl"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| {\n        let mut i = 1;\n\
    \        loop {\n            i += 1;\n            if i < brackets.len() && brackets[i\
    \ - 1].chars().any(|c| c == c) {\n                return true;\n            }\n\
    \            if i >= brackets.len() || brackets[i + 1].chars().any(|c| c == c)\
    \ {\n                return false;\n            }\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptita4rue.rs:16:38\n\
    \   |\n16 |             if i < brackets.len() && brackets[i - 1].chars().any(|c|\
    \ c == c) {\n   |                                      ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptita4rue.rs:19:39\n   |\n19 |             if i >= brackets.len()\
    \ || brackets[i + 1].chars().any(|c| c == c) {\n   |                         \
    \              ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // We know the first opening bracket must be the last\
    \ closing bracket in the string.\n    let mut stack: Vec<_> = brackets.chars().cloned().collect();\n\
    \    let mut current_is_opening: bool = false;\n    let mut current: char = '\\\
    0';\n    // Iterate through each character in the string.\n    for i in 0..stack.len()\
    \ {\n        // If we're at the end of a string with no more opening brackets,\
    \ we're done.\n        if i == stack.len() - 1 {\n            return true;\n \
    \       }\n\n        // If we've found a new opening bracket, set our state and\
    \ start our search for the next closing one.\n        if stack[i] == '<' {\n \
    \           if stack[i + 1] == '>' {\n                current_is_opening = true;\n\
    \                i += 2;\n            } else {\n                current_is_opening\
    \ = false;\n            }\n        } else {\n            // If we found a closing\
    \ bracket, save it and remove it.\n            if stack[i] == '>' {\n        \
    \        let opening = stack.split_off(i);\n                let closing = opening.next().unwrap();\n\
    \                current = closing.to_string();\n            } else {\n      \
    \          // If we found a opening bracket, push it back onto the stack.\n  \
    \              stack = stack.push(brackets[i]).collect();\n            }\n   \
    \     }\n\n        // If we're currently opening a bracket, we've found an error.\n\
    \        if current_is_opening {\n            return false;\n        }\n    }\n\
    \    // If we got this far, something has gone wrong.\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpm6qzsgyo.rs:13:46\n     |\n13   |     let mut stack: Vec<_>\
    \ = brackets.chars().cloned().collect();\n     |                             \
    \                 ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpm6qzsgyo.rs:13:55\n\
    \   |\n13 |       let mut stack: Vec<_> = brackets.chars().cloned().collect();\n\
    \   |                                                         ^^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0599]: no method named `next`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpm6qzsgyo.rs:35:39\n\
    \   |\n35 |                 let closing = opening.next().unwrap();\n   |     \
    \                                  ^^^^ method not found in `Vec<_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm6qzsgyo.rs:39:36\n\
    \   |\n39 |                 stack = stack.push(brackets[i]).collect();\n   | \
    \                                   ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror["
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvd21oljf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if !brackets.is_empty() {\n        if brackets[0..0]\
    \ != \"<\" || brackets[0..0] != \">\" {\n            return false;\n        }\n\
    \    }\n\n    !brackets.is_empty() && brackets[0..0] == \"<\" && brackets[1..1]\
    \ == \">\"\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp_0gtua3j.rs:13:27\n\
    \   |\n13 |         if brackets[0..0] != \"<\" || brackets[0..0] != \">\" {\n\
    \   |                           ^^ no implementation for `str == &str`\n   |\n\
    \   = help: the trait `PartialEq<&str>` is not implemented for `str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmp_0gtua3j.rs:13:52\n   |\n13 |         if brackets[0..0]\
    \ != \"<\" || brackets[0..0] != \">\" {\n   |                                \
    \                    ^^ no implementation for `str == &str`\n   |\n   = help:\
    \ the trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `str` with `&str`\n  -->\
    \ /tmp/tmp_0gtua3j.rs:18:44\n   |\n18 |     !brackets.is_empty() && brackets[0..0]\
    \ == \"<\" && brackets[1..1] == \">\"\n   |                                  \
    \          ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp926k25jw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opens = Vec::new();\n    let mut closes = Vec::new();\n\
    \    for i in 0..brackets.len() {\n        match brackets.chars().nth(i) {\n \
    \           '<' => opens.push(1),\n            '>' => closes.push(1),\n      \
    \      _ => continue,\n        }\n    }\n    for open in opens {\n        if closes.iter().any(|&c|\
    \ c != open) {\n            return false;\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw21jwkbt.rs:16:13\n   |\n\
    15 |         match brackets.chars().nth(i) {\n   |               -----------------------\
    \ this expression has type `Option<char>`\n16 |             '<' => opens.push(1),\n\
    \   |             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n16 |             Some('<') => opens.push(1),\n   |\
    \             +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw21jwkbt.rs:17:13\n\
    \   |\n15 |         match brackets.chars().nth(i) {\n   |               -----------------------\
    \ this expression has type `Option<char>`\n16 |             '<' => opens.push(1),\n\
    17 |             '>' => closes.push(1),\n   |             ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n17 |          \
    \   Some('>') => closes.push(1),\n   |             +++++   +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == brackets.chars().filter(|x| x == '<').count()\
    \ &&\n    brackets.len() == brackets.chars().filter(|x| x == '>').count()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwpbf8gbl.rs:12:53\n\
    \   |\n12 |     brackets.len() == brackets.chars().filter(|x| x == '<').count()\
    \ &&\n   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwpbf8gbl.rs:13:53\n\
    \   |\n13 |     brackets.len() == brackets.chars().filter(|x| x == '>').count()\n\
    \   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last_open_paren = 0;\n    let mut has_matching_bracket\
    \ = false;\n    let mut is_left_bracket = false;\n    let mut is_right_bracket\
    \ = false;\n\n    let mut chars = String::new();\n\n    for c in &brackets {\n\
    \        if c == '<' {\n            is_left_bracket = true;\n        } else {\n\
    \            is_left_bracket = false;\n        }\n\n        if c == '>' {\n  \
    \          is_right_bracket = true;\n        } else {\n            is_right_bracket\
    \ = false;\n        }\n\n        if is_left_bracket {\n            if c == '('\
    \ {\n                has_matching_bracket = true;\n            } else {\n    \
    \            has_matching_bracket = false;\n            }\n        } else {\n\
    \            if c == ')' {\n                has_matching_bracket = true;\n   \
    \         } else {\n                has_matching_bracket = false;\n          \
    \  }\n        }\n\n        chars.push_str(&c.to_string());\n    }\n\n    if !is_right_bracket\
    \ {\n        return false;\n    }\n\n    if !has_matching_bracket {\n        return\
    \ false;\n    }\n\n    if chars.chars().count() == 0 {\n        return false;\n\
    \    }\n\n    if last_open_paren != chars.chars().count() - 1 {\n        return\
    \ false;\n    }\n\n    if last_open_paren == 0 {\n        return true;\n    }\n\
    \n    chars.chars().last().unwrap().cmp(&'(') == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp5qao0k89.rs:19:14\n\
    \   |\n19 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qao0k89.rs:69:48\n\
    \   |\n69 |     chars.chars().last().unwrap().cmp(&'(') == 0\n   |           \
    \                                     ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets == correct_bracket(brackets)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `correct_bracket` in this scope\n  -->\
    \ /tmp/tmpspfz5k68.rs:12:17\n   |\n12 |     brackets == correct_bracket(brackets)\n\
    \   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = 0;\n    let mut opening_brackets =\
    \ [String::new(); MAX_OPENING_BRACKET];\n    \n    while current < brackets.len()\
    \ {\n        let opening_bracket = brackets[current..current];\n        let closing_bracket\
    \ = brackets[current + 1..current + 2];\n\n        opening_brackets[opening_bracket.trim().parse().unwrap()]\
    \ += 1;\n        \n        current += 2;\n    }\n\n    !opening_brackets.iter().any(|&count|\
    \ !count.is_empty())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_OPENING_BRACKET` in this scope\n \
    \ --> /tmp/tmppuhrsmq9.rs:13:48\n   |\n13 |     let mut opening_brackets = [String::new();\
    \ MAX_OPENING_BRACKET];\n   |                                                ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `String: Copy` is not\
    \ satisfied\n  --> /tmp/tmppuhrsmq9.rs:13:33\n   |\n13 |     let mut opening_brackets\
    \ = [String::new(); MAX_OPENING_BRACKET];\n   |                              \
    \   ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n   |\n   =\
    \ note: the `Copy` trait is required because this value will be copied for each\
    \ element of the array\n   = help: consider creating a new `const` item and initializing\
    \ it with the result of the function call to be used in the repeat position, like\
    \ `const VAL: Type = const_fn();` and `let x = [VAL; 42];`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmppuhrsmq9.rs:16:13\n\
    \   |\n16 |         let opening_bracket = brackets[current..current];\n   |  \
    \           ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n16 |         let\
    \ opening_bracket = &brackets[current..current];\n   |                       \
    \        +\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmppuhrsmq9.rs:17:13\n   |\n17 |         let\
    \ closing_bracket = brackets[current + 1..current + 2];\n   |             ^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n17 |         let closing_bracket = &brackets[current\
    \ + 1..current + 2];\n   |                               +\n\nerror"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_open_bracket = false;\n    let mut last_open_bracket\
    \ = String::new();\n\n    for c in brackets {\n        match c {\n           \
    \ '<' => {\n                has_open_bracket = true;\n                last_open_bracket\
    \ = String::new();\n            }\n            '>' => {\n                last_open_bracket.push(c);\n\
    \                has_open_bracket = has_open_bracket && !last_open_bracket.is_empty();\n\
    \            }\n            _ => {}\n        }\n    }\n\n    !has_open_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnt740a2e.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = String::new();\n    let mut close = String::new();\n\
    \n    for c in brackets.chars() {\n        if let Ok((_, str)) = Bracket::from_string(c)\
    \ {\n            open.push_str(str);\n        } else {\n            close.push_str(&c.to_string());\n\
    \        }\n    }\n\n    open == close\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Bracket`\n  -->\
    \ /tmp/tmp2j5y_m3a.rs:16:31\n   |\n16 |         if let Ok((_, str)) = Bracket::from_string(c)\
    \ {\n   |                               ^^^^^^^ use of undeclared type `Bracket`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_lowercase();\n    let\
    \ mut last_opening = false; // Tracks the last opening bracket that had a corresponding\
    \ closing bracket.\n    while let Some(mut opening) = brackets.split_first_char().next()\
    \ {\n        if !last_opening && opening != '>' {\n            return false;\n\
    \        }\n        last_opening = opening == '>';\n        if opening == '<'\
    \ {\n            brackets = brackets.split_last_char().next().unwrap().to_string();\n\
    \        } else {\n            brackets = brackets.split_first_char().unwrap().to_string();\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_char` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmph0b6cooq.rs:14:44\n   |\n14 |     while\
    \ let Some(mut opening) = brackets.split_first_char().next() {\n   |         \
    \                                   ^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0599]: no method named `split_last_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmph0b6cooq.rs:20:33\n\
    \   |\n20 |             brackets = brackets.split_last_char().next().unwrap().to_string();\n\
    \   |                                 ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0599]: no method named `split_first_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmph0b6cooq.rs:22:33\n\
    \   |\n22 |             brackets = brackets.split_first_char().unwrap().to_string();\n\
    \   |                                 ^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .chars()\n        .filter(|c| match\
    \ c {\n            c if c == '>' => true,\n            _ => false,\n        })\n\
    \        .count() >= 2\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4ft4ohb0.rs:15:20\n\
    \   |\n15 |             c if c == '>' => true,\n   |                    ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_count = 0;\n    let mut closing_brackets\
    \ = 0;\n    for c in brackets {\n        if c == '<' {\n            opening_count\
    \ += 1;\n        } else if c == '>' {\n            closing_brackets += 1;\n  \
    \      }\n    }\n\n    opening_count == closing_brackets\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpp92u6j9w.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .chars()\n        .filter(|c| c.is_ascii_letter())\n\
    \        .all(|c| {\n            if let Some(pos) = find_bracketing(c) {\n   \
    \             *pos == c\n            } else {\n                false\n       \
    \     }\n        })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_bracketing` in this scope\n  -->\
    \ /tmp/tmpqd45wo2c.rs:16:32\n   |\n16 |             if let Some(pos) = find_bracketing(c)\
    \ {\n   |                                ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpqd45wo2c.rs:14:23\n   |\n14 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '<' || c == '>')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8egh6sde.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO: Optimize this, perhaps using a stack to find\
    \ matching closing brackets?\n\n    // Check if string has more than one character\n\
    \    let mut first_char_ok = false;\n    for c in brackets.chars() {\n       \
    \ first_char_ok = if c.is_digit(10) {\n            // We found a digit, check\
    \ if there is another digit\n            first_char_ok = if let Some(other_c)\
    \ = brackets.chars().next() {\n                other_c.is_digit(10)\n        \
    \    } else {\n                false\n            };\n        } else {\n     \
    \       first_char_ok = true;\n            break;\n        }\n    }\n    !first_char_ok\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwf0k2abn.rs:17:43\n   |\n\
    17 |           first_char_ok = if c.is_digit(10) {\n   |  ___________________________________________^\n\
    18 | |             // We found a digit, check if there is another digit\n19 |\
    \ |             first_char_ok = if let Some(other_c) = brackets.chars().next()\
    \ {\n20 | |                 other_c.is_digit(10)\n...  |\n23 | |             };\n\
    24 | |         } else {\n   | |_________^ expected `bool`, found `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().take_while(b => b == '<')\n        .all(|b|\
    \ b == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpiq7g78a7.rs:12:35\n   |\n12 |     brackets.chars().take_while(b\
    \ => b == '<')\n   |                                   ^^ expected one of 8 possible\
    \ tokens\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets: Vec<String> = brackets.split_whitespace().collect();\n\
    \    let mut closed_brackets: Vec<String> = Vec::new();\n\n    for open in open_brackets.iter()\
    \ {\n        if !open.is_empty() {\n            closed_brackets.push(\"<\");\n\
    \        }\n    }\n    closed_brackets.push(\">\");\n    closed_brackets.sort_by_key(|s|\
    \ s.to_string());\n    open_brackets.sort_by_key(|s| s.to_string());\n\n    open_brackets.iter().all(|open|\
    \ {\n        closed_brackets.iter().all(|closed| {\n            open == closed;\n\
    \        })\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp2mt8j8wo.rs:12:70\n     |\n12\
    \   |     let mut open_brackets: Vec<String> = brackets.split_whitespace().collect();\n\
    \     |                                                                      ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mt8j8wo.rs:17:34\n\
    \   |\n17 |             closed_brackets.push(\"<\");\n   |                   \
    \               ^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                  |\n   |                                  expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mt8j8wo.rs:20:26\n\
    \   |\n20 |     closed_brackets.push(\">\");\n   |                          ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2mt8j8wo.rs:25:45\n   |\n25 |\
    \           closed_brackets.iter().all(|closed| {\n   |  _____________________________________________^\n\
    26 | |             open == closed;\n   | |                           - help: remove\
    \ this semicolon\n27 | |         })\n   | |_________^ expected `bool`, found `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    let mut is_correct = true;\n\
    \    for ch in brackets.chars() {\n        if depth == 0 {\n            depth\
    \ = 1;\n        } else if ch == \">\" {\n            depth -= 1;\n        } else\
    \ if ch == \"<\" {\n            depth += 1;\n        } else {\n            is_correct\
    \ = false;\n            break;\n        }\n    }\n    is_correct\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbu5edhka.rs:17:25\n   |\n\
    17 |         } else if ch == \">\" {\n   |                         ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n17 |         } else if ch == '>' {\n   |              \
    \           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbu5edhka.rs:19:25\n\
    \   |\n19 |         } else if ch == \"<\" {\n   |                         ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n19 |         } else if ch == '<' {\n   |          \
    \               ~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for ch in brackets {\n    \
    \    if ch == '<' {\n            counter += 1;\n        } else {\n           \
    \ counter -= 1;\n        }\n        if counter == 0 {\n            return false;\n\
    \        }\n    }\n    counter == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnt5ll0pu.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnt5ll0pu.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n23 |     counter == 0;\n   |          \
    \       - help: remove this semicolon\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_bracket = String::new();\n    let mut\
    \ closing_bracket = String::new();\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        if c == '<' {\n            if opening_bracket.is_empty() {\n    \
    \            opening_bracket = String::from(\"{{{{\");\n            }\n      \
    \      opening_bracket.push_str(\"{{\");\n        } else if c == '>' {\n     \
    \       if closing_bracket.is_empty() {\n                closing_bracket = String::from(\"\
    }}}}\");\n            }\n            closing_bracket.push_str(\"}}\");\n     \
    \   } else {\n            if opening_bracket.is_empty() || closing_bracket.is_empty()\
    \ {\n                return false;\n            }\n            opening_bracket.push_str(&c.to_string());\n\
    \            closing_bracket.push_str(&c.to_string());\n        }\n    }\n   \
    \ opening_bracket.len() == closing_bracket.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpalwennxq.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    <\")\n/// False\n/// >>> correct_bracketing(\"<>\")\n/// True\n/// >>> correct_bracketing(\"\
    <<><>>\")\n/// True\n/// >>> correct_bracketing(\"><<>\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last_open_bracket: Option<usize> = None;\n\n\
    \    for (i, c) in brackets.chars().enumerate() {\n        if c == '<' {\n   \
    \         if !last_open_bracket.is_some() {\n                last_open_bracket\
    \ = Some(i);\n            }\n        } else {\n            if last_open_bracket.is_some()\
    \ && c == ']' {\n                last_open_bracket = None;\n            }\n  \
    \      }\n    }\n\n    last_open_bracket.is_none()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyk8qx10d.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
