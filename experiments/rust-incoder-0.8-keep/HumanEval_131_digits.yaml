name: HumanEval_131_digits
language: rust
prompt: "/// Given a positive integer n, return the product of the odd digits.\n///\
  \ Return 0 if all digits are even.\n/// For example:\n/// digits(1)  == 1\n/// digits(4)\
  \  == 0\n/// digits(235) == 15\nfn digits(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5),\
  \ 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n \
  \   assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n  \
  \  assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n\
  }\n"
completions: ["    let mut prod = 1;\n    while n > 0 {\n        prod *= n % 10;\n\
    \        n /= 10;\n    }\n    prod", "    debug_assert_eq!(n % 2 == 0, \"\");\n\
    \    (n as i32).pow(2.0).floor() as isize", "    // Slightly more efficient implementation\
    \ than n % 10 * 9 + n / 10.\n    let mut result = 1;\n    while n > 0 {\n    \
    \    result *= n % 10;\n        n /= 10;\n    }\n    result", "    debug_assert!(n\
    \ % 2 == 0);\n    n / 2", "    let mut result = 1;\n    for &d in n.to_string().chars().skip(1)\
    \ {\n        if d % 2 == 0 {\n            result *= d;\n        } else {\n   \
    \         break;\n        }\n    }\n    result", "    if n == 0 {\n        return\
    \ 0;\n    }\n\n    let mut n = n as usize;\n    let mut product = 1;\n    while\
    \ n > 0 {\n        product *= n % 10;\n        n /= 10;\n    }\n    product",
  "    let mut result = 1;\n    for _ in 0..(n % 2) {\n        result *= n % 10;\n\
    \        n /= 10;\n    }\n    result", "    n.checked_mul(2).map(|x| {\n     \
    \   // x & 1 is the digit, and x>>1 is the second digit.\n        // x>>1 is the\
    \ second digit, but x & 1 is not the second digit.\n        let y = x >> 1;\n\
    \        (x & 1) == y\n    }).unwrap_or(0)", "    let mut prod = 1;\n    while\
    \ n > 0 {\n        if n % 2 == 0 {\n            prod *= 2;\n            n /= 2;\n\
    \        } else {\n            prod *= n;\n            n -= 1;\n        }\n  \
    \  }\n    prod", "    if n < 10 {\n        return n;\n    }\n    let mut sum =\
    \ 0;\n    for &d in n.to_string().rev() {\n        if d % 2 == 1 {\n         \
    \   sum += 1;\n        }\n    }\n    sum", "    let mut result = 1;\n    for (i,\
    \ d) in n.digits().enumerate() {\n        if i % 2 == 0 {\n            result\
    \ *= d;\n        }\n    }\n    result", '    (n % 10) as isize', '    (n as isize).checked_mul(2
    as isize)', "    assert!(n > 0, \"n should be positive\");\n    if n < 10 {\n\
    \        return n;\n    }\n    let mut res = 1;\n    for i in 1..(n/2).ceil()\
    \ {\n        res *= i;\n        res += n % i;\n    }\n    res", "    while n >\
    \ 0 {\n        n = (n % 10).wrapping_mul(2).wrapping_add(1).unwrap();\n    }\n\
    \    n", '    n.checked_mul(2).unwrap()', "    let mut ans: isize = 1;\n    while\
    \ n > 0 {\n        ans *= n % 10;\n        n /= 10;\n    }\n    ans", "    if\
    \ n % 2 == 1 {\n        return n * digits(n - 1);\n    } else {\n        return\
    \ digits(n / 2) * digits(n / 2);\n    }", "    if n < 10 {\n        return n;\n\
    \    }\n    let mut product = 1;\n    let mut digits = n as usize;\n    for _\
    \ in 0..digits {\n        if digits % 2 == 1 {\n            product *= 10;\n \
    \       }\n        product *= digits % 10;\n        digits /= 10;\n    }\n   \
    \ product", "    assert!(n > 0);\n    // A trick taken from Knuth's Art of Computer\
    \ Programming, Vol 2.\n    if n % 2 == 0 {\n        return n;\n    }\n    return\
    \ 1 + digits(n / 2);", "    if n <= 0 {\n        return 0;\n    }\n\n    let mut\
    \ i = 1;\n    let mut product = 1;\n    for d in n.digits() {\n        if d %\
    \ 2 == 1 {\n            product *= i;\n        }\n        i += 1;\n    }\n   \
    \ product", "    let mut digits = 1;\n    while n > 0 {\n        if n % 10 ==\
    \ 0 {\n            digits *= 2;\n            n /= 10;\n        } else {\n    \
    \        digits *= 2;\n        }\n    }\n    digits", "    let mut ret: isize\
    \ = 0;\n    while n > 0 {\n        if n & 1 == 1 {\n            ret += 1;\n  \
    \          n >>= 1;\n        }\n        n >>= 1;\n    }\n    ret", "    let mut\
    \ num: isize = 1;\n    for d in n / 10 {\n        num <<= 1;\n        num |= d\
    \ % 10;\n    }\n    let rest = n % 10;\n    if rest % 2 == 0 {\n        0\n  \
    \  } else {\n        num * digits(rest)\n    }", "    let mut product = 1;\n \
    \   for i in 0..n / 2 {\n        product *= i % 2;\n    }\n    if n % 2 != 0 {\n\
    \        product *= 1;\n    }\n    product", "    fn helper(digits: &[isize],\
    \ remainder: &[bool]) {\n        for &n in digits {\n            if !*remainder[n]\
    \ {\n                *remainder[n] = true;\n                *remainder = remainder.iter().cloned().rev();\n\
    \                return;\n            }\n        }\n    }\n    let mut digits\
    \ = [0; 10];\n    let mut remainder = [false; 10];\n    for i in (0..n).rev()\
    \ {\n        helper(&digits, &remainder);\n    }\n    *remainder.last().unwrap()",
  "    let mut ret = 1;\n    while n > 0 {\n        // n is even, so multiply by 2\
    \ and add 1\n        ret *= 2;\n        ret += 1;\n        n -= 1;\n    }\n  \
    \  ret", "    if n % 2 == 0 {\n        n\n    } else {\n        let mut result\
    \ = 1;\n        for d in n.checked_mul(2).unwrap().digits().take(digits(n as usize)\
    \ + 1) {\n            *d += result as isize;\n            result <<= 1;\n    \
    \    }\n        result\n    }", "    let mut ret: isize = 1;\n    while n / 2\
    \ != 0 {\n        if n % 2 == 1 {\n            ret = ret * n;\n        }\n   \
    \     n = n / 2;\n    }\n    if n == 0 {\n        ret = 0;\n    }\n    ret", " \
    \   fn odd(i: isize) -> bool {\n        (i % 2) == 1 && i != 0\n    }\n    n as\
    \ usize * odd((n as usize) - 1).into()", "    if n % 2 == 0 {\n        0\n   \
    \ } else {\n        ((n % 10) as isize * digits((n / 10) as isize)) + 1\n    }",
  "    debug_assert!(n % 2 == 0);\n    (n.digits() as isize)", "    // We want to\
    \ sum up all the powers of 2 less than the number.\n    // So we calculate the\
    \ powers from the largest possible power of 2 that\n    // can hold the number.\n\
    \    let mut power_of_2 = 1;\n    while n > 0 {\n        power_of_2 *= 2;\n  \
    \      n -= 1;\n    }\n    // Now that we have our powers of 2, we know how many\
    \ digits there are\n    // and can easily calculate how many times we must multiply\
    \ the power of 2\n    // by 10 (i.e. by 10)\n    let num_digits = n / power_of_2;\n\
    \    // Then we multiply the number by this many times the power of 2\n    let\
    \ mut result = 1;\n    for _ in 0..num_digits {\n        result *= power_of_2;\n\
    \    }\n    result", "    let mut result = 1;\n    while n >= 2 {\n        result\
    \ *= n % 2;\n        n /= 2;\n    }\n    result", '    n % 10', "    debug_assert!(n\
    \ % 2 == 0);\n    debug_assert!(n >= 0);\n\n    // first convert n to a number\
    \ with 0 as least significant digit\n    let mut result = n;\n\n    // remove\
    \ least significant odd digit\n    if result % 2 == 1 {\n        result /= 2;\n\
    \    }\n\n    if result <= 1 {\n        result = 0;\n    }\n\n    result", " \
    \   n.checked_mul(10).expect(\"n must be positive\")\n        .checked_add(1,\
    \ |n| n % 2).expect(\"n must be odd\")\n        .checked_mul(2).expect(\"n must\
    \ be even\")\n        .unwrap_or(0)", "    let mut product = 1;\n    for digit\
    \ in n.to_string().chars().nth(1).rev() {\n        if digit % 2 == 0 {\n     \
    \       product *= digit;\n        }\n    }\n    product", "    let mut prod:\
    \ isize = 1;\n    for &d in n.to_digits() {\n        d %= 10;\n        if d %\
    \ 2 == 1 {\n            prod *= 10;\n            prod += d;\n        } else {\n\
    \            prod *= d;\n        }\n    }\n    prod", "    // The multiplication\
    \ of odd digits is just their quotient. \n    let mut product = n / 2;\n\n   \
    \ while n > 0 {\n        if n % 2 == 1 {\n            product *= 2;\n        }\n\
    \n        n /= 2;\n    }\n\n    product", '    n.checked_mul(2).map(|n| n.checked_mul_2()).unwrap_or(0)',
  "    if n < 0 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut\
    \ max_digit = if n % 2 == 0 {\n        n\n    } else {\n        n - 1\n    };\n\
    \    for i in 0..max_digit {\n        if n % 2 == 1 {\n            result *= 2;\n\
    \        }\n        if i > 0 {\n            result *= 10;\n        }\n       \
    \ n /= 10;\n    }\n    result", "    if n % 2 == 0 {\n        0\n    } else {\n\
    \        n\n    }", '    n / 10 as isize * (n % 10 as isize) + digits(n / 10)
    as isize', "    if n < 2 { return 0; }\n    let mut prod = 0;\n    let mut i =\
    \ 1;\n    while i <= n {\n        if n % i == 0 {\n            prod *= i; n /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    prod", "  \
    \  if n % 2 == 0 {\n        0\n    } else {\n        (n as f64).log10().floor()\
    \ as isize\n    }", "    let mut prod = 1;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            prod *= 10;\n        }\n        n /= 10;\n    }\n    prod",
  '    (n % 10 + n / 10) % 10', "    if n % 2 == 0 {\n        0\n    } else {\n  \
    \      n / 2\n    }", "    if n % 2 == 0 {\n        n\n    } else {\n        n\
    \ / 2 * 3\n    }", "    if n <= 0 {\n        return 0;\n    }\n    let mut result\
    \ = 1;\n    for _ in 0..n {\n        result *= 2;\n        if result % 2 == 0\
    \ {\n            return result;\n        }\n        result /= 2;\n    }\n    return\
    \ 0; // This should never happen", "    // the trick here is to compute the integer\
    \ part of the sum of the last digit\n    // and the current digit and then use\
    \ that as the current digit (using mod 10).\n    // we compute that sum using\
    \ a recursive function with the current digit and\n    // the original number,\
    \ then use that as the new number.\n    // we only need to compute the last digit\
    \ (since we don't need to check for\n    // the case where n is odd), so we use\
    \ n/10 to get the integer part.\n    // the base case for n is already handled\
    \ above, so that means we don't need\n    // to special case for n/10 and can\
    \ just use n to compute the sum.\n    let digits = n as isize;\n    if digits\
    \ % 2 == 0 {\n        return 0;\n    }\n    let mut s = digits / 10;\n    for\
    \ d in n / 10 {\n        s = s * 10 + d;\n    }\n    s", "    if n % 2 == 0 {\n\
    \        n * digits(n / 2)\n    } else {\n        0\n    }", "    if n <= 0 {\n\
    \        return 0;\n    }\n\n    let mut result = 1i32;\n    for d in n / 10 {\n\
    \        result = result * 10 + d as i32;\n    }\n\n    if n % 2 == 0 {\n    \
    \    return result as isize;\n    }\n\n    0 as isize", "    let mut product =\
    \ 1;\n    let mut n1 = n;\n    while n1 % 2 != 0 {\n        n1 /= 2;\n       \
    \ product *= 1;\n    }\n    n1 /= 2;\n    while n1 != 0 {\n        product *=\
    \ n1;\n        n1 /= 2;\n    }\n    product", '    (n as isize) * (n as isize)
    as isize', "    loop {\n        let d = n % 10;\n        n /= 10;\n        if\
    \ d % 2 == 1 {\n            return d * 2;\n        }\n    }", "    // We can't\
    \ use `n.to_string()`, since it drops trailing zeroes, but we can do better.\n\
    \    let mut d = 0;\n    let mut sum = 1;\n    while n > 0 {\n        d = n %\
    \ 10;\n        sum += d * d;\n        n /= 10;\n    }\n    if d % 2 != 0 {\n \
    \       0\n    } else {\n        sum\n    }", "    fn odd(x: isize) -> bool {\n\
    \        x.is_odd()\n    }\n\n    if n <= 0 {\n        0\n    } else if odd(n)\
    \ {\n        digits(n - 1)\n    } else {\n        digits(n / 2)\n    }", '    (n
    % 10).take_while(|&x| x.is_odd()).fold(1, |x, y| x * 2 + y)', "    let mut result\
    \ = 1isize;\n\n    while n > 0 {\n        result *= n % 10;\n        n /= 10;\n\
    \    }\n\n    result", "    if n == 0 {\n        return 0;\n    }\n    let mut\
    \ result: isize = 1;\n    for d in n % 10..=0 {\n        result *= 10;\n     \
    \   result += d;\n    }\n    result", "    let mut product: isize = 0;\n    let\
    \ mut remainder: isize = n;\n    while remainder > 0 {\n        remainder = (remainder\
    \ % 10) as isize + 1;\n        product = product * remainder as isize;\n    }\n\
    \    product", "    if n % 2 == 0 {\n        0\n    } else {\n        n / 2 *\
    \ 3\n    }", "    let mut product = 1;\n    for digit in n.to_string().chars().filter_map(|c|\
    \ c > '9') { product *= 10 }\n    product", "    (n as isize)\n        .check()\n\
    \        .filter_map(|n| {\n            if n % 2 != 0 {\n                0\n \
    \           } else {\n                n as isize\n            }\n        })\n\
    \        .sum()", "    debug_assert!((n % 10) == 0);\n\n    let mut result = 1;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            result *= 10;\n     \
    \   }\n        result *= n % 10;\n        n /= 10;\n    }\n    result", "    let\
    \ mut product = n;\n    let mut rem_product = 1;\n\n    // The loop will stop\
    \ at the next multiple of 3, because 3 * 3 = 9\n    for i in 0..(n / 3) {\n  \
    \      if n % i == 0 {\n            rem_product *= i;\n        }\n\n        product\
    \ *= i;\n    }\n\n    product *= rem_product;\n\n    // If all digits are even,\
    \ then the product will be a multiple of 3\n    if product % 3 == 0 {\n      \
    \  product += 3;\n    }\n\n    product", "    if n >= 10 {\n        n * digits(n\
    \ % 10)\n    } else {\n        if n % 2 == 1 {\n            0\n        } else\
    \ {\n            n * digits(n % 10) + 1\n        }\n    }", "    if n % 2 == 0\
    \ {\n        n as isize * 3\n    } else {\n        n as isize\n    }", "    let\
    \ mut total = 1;\n    while n > 0 {\n        total *= n % 10;\n        n /= 10;\n\
    \    }\n    total", "    if n % 2 == 0 {\n        n\n    } else {\n        (n\
    \ - 1) * (n + 1) >> 1\n    }", "    let mut d = 0;\n    for c in n.to_string().chars()\
    \ {\n        if c != '0' && (c & 1) == 0 {\n            d *= 2;\n        }\n \
    \       d += c as isize;\n    }\n    d", "    if n <= 0 {\n        return 0\n\
    \    }\n\n    let mut product = 1;\n    let mut rem = n;\n\n    while rem > 0\
    \ {\n        product *= rem % 10;\n        product %= 10;\n        rem /= 10;\n\
    \    }\n\n    product", '    (1..n / 2).filter(|&d| d % 2 == 1).product()', " \
    \   let mut product = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     product *= n % 10;\n        }\n        n /= 10;\n    }\n    product", " \
    \   if n % 2 == 0 {\n        n\n    } else {\n        n * digits(n / 2)\n    }",
  '    (n % 10 + 1) * digits(n / 10)', "    if n % 2 == 0 {\n        n\n    } else\
    \ {\n        digits(n / 2)\n    }", "    let mut res = 1;\n    let mut i = 1;\n\
    \    while i <= n {\n        if n % i == 0 {\n            res *= (i as isize);\n\
    \        }\n        i += 2;\n    }\n    res", "    // We know that n >= 0, and\
    \ n % 2 will only be 0 if the number is even,\n    // so we only need to test\
    \ n.\n    while n > 0 {\n        n -= 2;\n    }\n    n", "    fn digits_helper(x:\
    \ isize) -> isize {\n        if x % 2 != 0 {\n            x\n        } else {\n\
    \            digits_helper(x / 2)\n        }\n    }\n\n    digits_helper(n)",
  "    let mut product = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n        \
    \    product *= 2;\n        }\n        n /= 2;\n    }\n    product", "    let\
    \ mut product = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            product\
    \ *= n;\n        }\n        n /= 2;\n    }\n    product", "    let mut product\
    \ = 1;\n    let mut digits = n.to_string().chars();\n    if digits.len() == 0\
    \ {\n        return 0;\n    }\n    let mut has_even = false;\n    let mut num_chars\
    \ = digits.len();\n    while num_chars > 0 && num_chars < 10 {\n        has_even\
    \ = !has_even && num_chars.is_even();\n        product *= num_chars;\n       \
    \ num_chars /= 10;\n    }\n    product *= has_even ? 1 : 0", "    let mut res\
    \ = 0;\n    while n > 0 {\n        res *= 10;\n        res += n % 10;\n      \
    \  n /= 10;\n    }\n    res", "    let mut digits = Vec::new();\n    for d in\
    \ n / 10..0 {\n        let mut digit = d * 10;\n        digits.push(digit % 10);\n\
    \        digit /= 10;\n    }\n    digits\n        .iter()\n        .filter(|&d|\
    \ d % 2 == 1)\n        .sum()", "    if n % 2 == 0 {\n        n / 2\n    } else\
    \ {\n        n * 3 + 1\n    }", "    match n {\n        0 | 1 => 1,\n        _\
    \ => n * digits(n - 1)\n    }", "    if n > 10 || n < 1 {\n        return 0;\n\
    \    }\n\n    let mut res = 0;\n    let mut tmp = 0;\n\n    // Loop through the\
    \ whole number\n    for i in 0 .. n {\n        // Get the current digit\n    \
    \    let digit = n % 10;\n\n        // If the number is odd, multiply it by 2\
    \ and add it to the result\n        if digit % 2 == 1 {\n            res *= 2;\n\
    \            res += digit;\n        }\n\n        // If the number is even, add\
    \ it to the result and divide it by 2\n        else {\n            tmp *= 10;\n\
    \            tmp += digit;\n            res *= 2;\n            res += tmp;\n \
    \       }\n\n        // Remove the current digit from the number\n        n /=\
    \ 10;\n    }\n\n    // Return the final result\n    res", "    if n % 2 == 0 {\n\
    \        return n * digits(n / 2)\n    } else {\n        return 0\n    }", " \
    \   // find first odd digit, starting with 1\n    // the odd-digit (starting with\
    \ 1) will be in the range of 1..7\n    let mut i = 7;\n    while i && n / i !=\
    \ 0 {\n        i /= 2;\n    }\n    i * n", "    fn digit(n: isize) -> isize {\n\
    \        if n % 2 == 0 {\n            n / 2\n        } else {\n            0\n\
    \        }\n    }\n    digit(n as i32) * digit(n - 1 as i32)", "    // return\
    \ 0 when all digits are even\n    let num_digits = n.to_string().chars().count();\n\
    \    if num_digits % 2 == 1 {\n        return 0\n    }\n    // find first odd\
    \ (digit) index\n    let mut first_odd_index = num_digits / 2;\n    first_odd_index\
    \ += 1;\n    // loop through each odd digit\n    for i in first_odd_index..num_digits\
    \ {\n        // multiply by 2\n        if n % 2 == 1 {\n            n = n * 2;\n\
    \        } else {\n            break;\n        }\n    }\n    n", '    n % 10',
  "    if n % 2 == 0 {\n        return 0;\n    }\n    n / 2", '    n.to_digits(0).product()',
  '    n / 10', "    n % 10 % 2 != 0\n        ? 0\n        : n % 10 as isize * 2 +\
    \ digits(n / 10 as isize)", "    while n >= 2 {\n        if n % 2 == 1 {\n   \
    \         n /= 2;\n        } else {\n            return n\n        }\n    }\n\
    \    n", "    let mut product = 1;\n    while n > 0 {\n        product *= n %\
    \ 10;\n        n /= 10;\n    }\n    product", "    fn is_odd(n: isize) -> bool\
    \ {\n        n % 2 == 1\n    }\n    let mut product: isize = 1;\n    let mut last_digit\
    \ = n % 10;\n    while is_odd(last_digit) {\n        product *= last_digit;\n\
    \        last_digit /= 10;\n    }\n    product", "    // the number is not too\
    \ big, so no division is necessary\n    if n < 9 {\n        return n;\n    }\n\
    \    // n is too big for a u64 so we need to calculate it in steps\n    let mut\
    \ d = 0u64;\n    for _ in 0..n {\n        d *= 10;\n        d += n % 10;\n   \
    \     n /= 10;\n    }\n    if n % 2 == 0 {\n        return d * 3;\n    } else\
    \ {\n        return d * 2;\n    }", "    if n < 2 {\n        return 1;\n    }\n\
    \    let mut prod = 1;\n    for i in 1..=n/2 {\n        if n % i == 0 {\n    \
    \        prod *= i;\n        }\n    }\n    if prod < n {\n        prod *= n /\
    \ 2;\n    }\n    prod", '    (n as u64).rem() * (n as u64).rem()', '    n % 10
    as isize', "    let mut product = 0;\n    while n > 0 {\n        if n % 2 == 1\
    \ {\n            product *= 10;\n            product += n / 2;\n        }\n  \
    \      n /= 2;\n    }\n    product", "    if n % 2 == 0 {\n        n / 2\n   \
    \ } else {\n        n * 3\n    }", "    match n.checked_mul(2) {\n        Some(n)\
    \ => n,\n        None => 0,\n    }", "    if n == 0 {\n        return 0\n    }\n\
    \    \n    let mut product = 1;\n    for i in 1..=n/2 {\n        if n % 2 == 0\
    \ {\n            product *= i;\n        }\n        else {\n            product\
    \ *= -1;\n        }\n        n -= 1;\n    }\n    if n != 0 {\n        product\
    \ *= -1;\n    }\n    product", "    let mut n2 = n / 2;\n    let mut n1 = n %\
    \ 2;\n    while n1 < n2 {\n        n2 *= 2;\n        n1 += 1;\n    }\n    n2",
  "    let mut product = 1;\n    for i in 0..(n as usize) {\n        if n & (1 <<\
    \ i) != 0 {\n            product *= i;\n        }\n    }\n    product", "    if\
    \ n >= 2 {\n        digits(n / 2)\n    } else {\n        0\n    }", "    // Return\
    \ early if n is 0.\n    if n < 2 {\n        return n;\n    }\n\n    // Get the\
    \ first two digits.\n    let mut first = (n % 1000) / 100;\n    first = digits(first);\n\
    \    let mut second = (n % 100) % 10;\n    second = digits(second);\n\n    //\
    \ Compute and return the product of the digits.\n    first * second + n", "  \
    \  assert!(n % 2 == 0, \"n is even\");\n\n    let mut product = 1;\n    for d\
    \ in &[n..=32] {\n        product *= d;\n        if product > n {\n          \
    \  return 0;\n        }\n    }\n    product", "    fn digit(digits: &mut [isize],\
    \ digit: isize) {\n        if digit % 2 == 0 {\n            *digits += digit;\n\
    \        }\n    }\n    if n < 10 {\n        return n;\n    }\n    let mut product\
    \ = n as isize;\n    let mut digits = &mut [0isize];\n    for digit in &mut digits\
    \ {\n        digit(digits, *digit);\n    }\n    product = digits.iter().fold(1,\
    \ |product, digit| product * digit);\n    if product % 2 == 0 {\n        product\n\
    \    } else {\n        0\n    }", "    let mut res = n;\n    let mut t = 1;\n\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            res = res * t;\n    \
    \    }\n\n        res /= 2;\n        t *= 2;\n    }\n\n    res % 2 == 0", "  \
    \  if n < 10 { 1 }\n    else if n % 10 == 0 { 0 }\n    else { n / 10 }", "   \
    \ let mut product = 1;\n    while n > 0 {\n        product *= n % 10;\n      \
    \  n /= 10;\n    }\n    if n > 0 {\n        product\n    } else {\n        0\n\
    \    }", "    let mut product = 1;\n    while n > 0 {\n        let d = n % 10;\n\
    \        if d % 2 == 1 {\n            product *= d;\n        }\n        n /= 10;\n\
    \    }\n    product", "    if n % 2 == 1 {\n        0\n    } else {\n        let\
    \ mut total = 1;\n        for i in 0 .. n / 2 {\n            total *= i % 10;\n\
    \        }\n        total\n    }", "    let mut prod = 1;\n    for (i, &digit)\
    \ in n.to_digits().chars().enumerate() {\n        if i % 2 == 0 {\n          \
    \  prod *= digit;\n        } else {\n            return 0;\n        }\n    }\n\
    \    prod", '    n.trailing_digits().product()', "    let mut result = 1isize;\n\
    \    for digit in n.iter().cloned().collect::<Vec<_>>() {\n        if digit %\
    \ 2 == 1 {\n            result *= digit;\n        }\n    }\n    result", "   \
    \ let mut sum = 0;\n    let mut rem = 0;\n    while n != 0 {\n        if n % 2\
    \ == 1 {\n            sum += rem;\n        }\n        rem = n % 10;\n        n\
    \ /= 10;\n    }\n    sum", "    let mut product = 1;\n    for i in 0..n {\n  \
    \      if i & 1 != 0 {\n            product *= 10;\n        }\n        product\
    \ *= i;\n    }\n    product", "    let mut prod: isize = 0;\n    let mut q: isize\
    \ = 0;\n    while n > 0 {\n        q = n % 10;\n        n = n / 10;\n        prod\
    \ *= q;\n    }\n    prod", "    let mut product = n;\n    while product > 0 {\n\
    \        product /= 10;\n        product %= 10;\n    }\n    product", "    let\
    \ mut res = 0;\n    while n > 0 {\n        res *= n % 10;\n        n /= 10;\n\
    \    }\n    if n < 0 {\n        res = -res;\n    }\n    res", '    (n - 1) / 2
    * n % 2', "    if n % 2 == 1 {\n        n * digits(n / 2)\n    } else {\n    \
    \    0\n    }", "    let mut product = 1;\n    let mut digits = 0;\n    for d\
    \ in n.iter().rev() {\n        if d > 0 {\n            product *= d;\n       \
    \     digits += 1;\n        }\n    }\n    if digits % 2 == 1 {\n        product\n\
    \    } else {\n        0\n    }", "    if n % 2 == 0 {\n        n * 3\n    } else\
    \ {\n        n * 3 + 1\n    }", "    match n {\n        0 => 1,\n        _ =>\
    \ 0,\n    }", "    let mut product = 1;\n    let mut current_digit = 1;\n    while\
    \ n > 0 {\n        product *= current_digit;\n        if n % current_digit !=\
    \ 0 {\n            product /= current_digit;\n            break;\n        }\n\
    \        current_digit *= 2;\n        n /= current_digit;\n    }\n    product",
  "    n.checked_mul(2)\n        .expect(\"n must be positive\")\n        .floor()\n\
    \        .expect(\"n must be positive\")", "    if n >= 0 && n % 2 == 0 {\n  \
    \      n\n    } else {\n        digits(n - 1) * (n % 10) as isize\n    }", " \
    \   let mut result = 1;\n    for d in n.digits().rev() {\n        result = result\
    \ * d;\n    }\n    result", "    assert!(n % 2 != 0);\n    let mut product = 1;\n\
    \    for i in 1..n / 2 {\n        product *= i % 2;\n    }\n    product", '    n
    / 10', '    (n % 10).map(|d| d * 2).unwrap_or(0)', "    fn get_digit(i: isize)\
    \ -> isize {\n        i / 10\n    }\n\n    let mut product_of_odd = 0;\n    for\
    \ &i in n.to_string().chars().nth(1).unwrap().to_digits().iter() {\n        product_of_odd\
    \ *= get_digit(i);\n    }\n    product_of_odd", '    n.leading_zeros() as isize',
  '    (0..n).filter(|&x| x % 2).fold(1, |x, y| x * y)', "    let mut product = n.to_digits();\n\
    \n    while product & 1 != 0 {\n        product >>= 1;\n    }\n\n    if product\
    \ == 0 {\n        0\n    } else {\n        product\n    }", "    assert!(n % 2\
    \ == 0, \"only odd number allowed\");\n    let mut result = 1i32;\n    for d in\
    \ &[2..=n as usize] {\n        result = result*10 + d % 2;\n    }\n    result",
  '    (n as usize) % (2 as isize)', "    fn aux(n: isize) -> isize {\n        if\
    \ n % 2 == 0 {\n            n\n        } else {\n            n * n % 10 + aux(n\
    \ / 10)\n        }\n    }\n\n    aux(n)", "    let mut sum = 0;\n    let mut tmp\
    \ = 0;\n    let mut last_digit = 0;\n    for i in 1..n {\n        tmp = i * 10;\n\
    \        if i % 2 == 0 {\n            sum += tmp;\n        }\n        last_digit\
    \ = i;\n    }\n    sum % 10", "    let mut prod = 1;\n    for d in n.digits()\
    \ {\n        prod *= d;\n        if prod > 100 {\n            return 0\n     \
    \   }\n    }\n    prod", "    fn digits_aux(n: isize) -> isize {\n        match\
    \ n % 10 {\n            0 => 1,\n            1 => n,\n            _ => n % 10\
    \ * digits_aux(n / 10),\n        }\n    }\n    digits_aux(n)", "    fn product(a:\
    \ isize, i: isize) -> isize {\n        let mut result = 1;\n        while i >\
    \ 0 {\n            result *= a;\n            result %= 10;\n            i -= 1;\n\
    \        }\n        result\n    }\n\n    if n <= 0 {\n        return 0\n    }\n\
    \    let mut result = n;\n    let mut n = n as isize;\n    while n > 0 {\n   \
    \     result = product(result, n % 10 as isize);\n        n /= 10;\n    }\n  \
    \  result", "    let mut ret: isize = 1;\n    while n > 0 {\n        ret *= n\
    \ % 10;\n        n /= 10;\n    }\n    ret", '    n / (10 * 2)', '    n.checked_mul(2).expect("n
    == 0").unwrap()', "    let mut result: isize = 0;\n    while n > 0 {\n       \
    \ result = (result * 10) + (n % 10);\n        n /= 10;\n    }\n    result", " \
    \   if n < 10 {\n        return n as isize;\n    }\n    let mut product = 1;\n\
    \    let mut digit_pow = 0;\n    for digit in n.to_string().chars().filter(|c|\
    \ c != '0') {\n        if digit != '0' {\n            *digit_pow = digit;\n  \
    \          product *= digit as isize;\n        }\n        digit_pow++;\n    }\n\
    \    product", "    (n as i32).checked_mul(10).ok()\n        .and_then(|mut n|\
    \ n.checked_mul(10).ok())\n        .and_then(|mut n| n.checked_mul(10).ok())\n\
    \        .and_then(|mut n| n.checked_mul(10).ok())\n        .unwrap_or(0)", '    (n
    + 1) >> 1', '    (n as i32).checked_mul(10).unwrap() as isize', "    let mut result\
    \ = 1;\n    for d in n.digits() {\n        if d % 2 == 1 {\n            result\
    \ *= d;\n        }\n    }\n    result", "    let mut ret = 1;\n    for &d in n.digits()\
    \ {\n        if d.is_even() {\n            ret *= -1;\n        }\n        ret\
    \ *= d;\n    }\n    ret", '    n / 2 + n % 2', "    if n % 2 == 0 {\n        0\n\
    \    } else {\n        1 << (n - 1).leading_digits(2)\n    }", '    n / 2 * 3
    + n % 2', "    let mut result = 1;\n    while n > 0 {\n        if n % 2 == 0 {\n\
    \            result *= 2;\n            n /= 2;\n        } else {\n           \
    \ result *= n % 2;\n            n = (n - result) / 2;\n        }\n    }\n    result",
  "    let mut product_odd = 0;\n    for d in n.checked_digits(2) {\n        if d\
    \ % 2 == 1 {\n            product_odd += 1;\n        }\n    }\n    if product_odd\
    \ != 0 {\n        product_odd *= 2;\n    }\n    product_odd", "    let mut result\
    \ = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            result *= n;\n\
    \        }\n        n /= 2;\n    }\n    result", "    if n <= 0 {\n        return\
    \ 0;\n    }\n    let mut result = 0;\n    let mut m = n % 10;\n    for _ in 0..n\
    \ / 10 {\n        result = result * 10 + m;\n        m = m / 10;\n    }\n    result",
  "    let mut product = 1;\n    while n > 0 {\n        product *= n % 10;\n     \
    \   n /= 10;\n    }\n    if n % 2 == 0 {\n        product *= 2\n    }\n    product",
  "    if n % 2 == 0 {\n        n / 2\n    } else {\n        0\n    }", "    let mut\
    \ product = 1;\n    for (i, &d) in n.digits().enumerate() {\n        if i & 1\
    \ == 1 {\n            product *= d;\n        }\n    }\n    product", "    match\
    \ n % 10 {\n        0 => 0,\n        n => (n - 10) % 7,\n    }", "    let mut\
    \ sum = 0;\n    for i in n.checked_mul(2).rev() {\n        sum += i;\n    }\n\
    \    if sum % 2 == 1 {\n        0\n    } else {\n        sum\n    }", "    match\
    \ n % 10 {\n        0 => 1,\n        1 => 1,\n        2 => n,\n        3 | 4 =>\
    \ n * 2,\n        5 => n * 3,\n        6 => n * 4,\n        _ => n * 5,\n    }",
  "    if n % 2 == 0 {\n        n\n    } else {\n        0\n    }", "    let mut product\
    \ = 1;\n    for &d in &n {\n        if d % 2 == 1 {\n            product *= 2;\n\
    \        } else {\n            product *= 3;\n        }\n    }\n    product",
  '    (1..n as usize).product()', "    if n % 2 == 0 {\n        n\n    } else {\n\
    \        0\n    }", "    if n % 2 == 0 {\n        n / 2\n    } else {\n      \
    \  n * 3\n    }", "    let mut product = 1;\n    let mut counter = 1;\n    while\
    \ counter < n {\n        if n % counter == 0 {\n            product *= counter;\n\
    \        } else {\n            counter *= 2;\n        }\n    }\n    if product\
    \ == 0 {\n        product = 1;\n    }\n    product", "    if n % 2 == 0 {\n  \
    \      n\n    } else {\n        0\n    }", "    if n % 2 == 1 {\n        return\
    \ 0\n    }\n    let mut product = n - 1;\n    let mut rest = n;\n    while rest\
    \ % 2 == 0 {\n        rest /= 2;\n        product *= 2;\n    }\n    return product",
  '    (n as usize).checked_mul(2 as usize).ok()', "    let mut n = 0;\n    while\
    \ n != 0 {\n        n += n % 2;\n        n /= 2;\n    }\n    n", "    let mut\
    \ product = 1;\n    for i in n..=0 {\n        if i % 2 == 1 {\n            product\
    \ *= i;\n        }\n    }\n    product", "    let mut result = 1;\n    for digit\
    \ in n.checked_divide(10).unwrap().iter_digits() {\n        if digit.0 % 2 !=\
    \ 0 {\n            *result *= digit.0;\n        }\n    }\n    result", '    (1..(n
    as usize)).filter(|x| *x % 2).collect::<Vec<_>>().product()', "    if n % 2 ==\
    \ 0 {\n        n * digits(n + 1)\n    } else {\n        0\n    }", "    // The\
    \ digits are multiplied in reverse order.\n    (1..n).rs().fold(0, |acc, &x| acc\
    \ * x as isize)", "    assert!(n > 0);\n    loop {\n        let digit = n % 10;\n\
    \        if digit % 2 == 0 {\n            return digit;\n        }\n        n\
    \ /= 10;\n    }", "    let mut product = 1;\n    for &d in n.to_digits() {\n \
    \       product *= d;\n    }\n    if product % 2 == 0 {\n        product\n   \
    \ } else {\n        0\n    }", "    let mut product = 1;\n    while n > 0 {\n\
    \        product *= n % 10;\n        n /= 10;\n    }\n    if n == 0 {\n      \
    \  product\n    } else {\n        0\n    }", '    (n as usize).digits().filter(|&c|
    c & 1).product()', "    if n > 0 {\n        n / 2 * 3 % 2\n    } else {\n    \
    \    0\n    }", "    if n <= 0 {\n        return 0\n    }\n    let mut res = 0;\n\
    \    let mut factor = 1;\n    for d in n.digits() {\n        if d % 2 == 0 {\n\
    \            res += factor;\n        }\n        factor *= 10;\n    }\n    res",
  "    // Calculate the product\n    // by multiplying by 2 until we reach a whole\
    \ number\n    while n % 2 == 0 {\n        n /= 2;\n    }\n    n * 2", "    let\
    \ mut product: isize = 1;\n    for digit in &n.to_string()[..] {\n        if digit\
    \ % 2 == 1 {\n            product *= digit as isize;\n        }\n    }\n    product",
  "    debug_assert!(n > 0);\n    debug_assert!(n % 2 == 0);\n\n    let mut product\
    \ = 1;\n    for (i, _) in n.iter().enumerate() {\n        let digit = i % 10;\n\
    \        product *= digit;\n    }\n    product", "    while n != 0 {\n       \
    \ n /= 10;\n    }\n    n as isize"]
stop_tokens:
- "\n}"
