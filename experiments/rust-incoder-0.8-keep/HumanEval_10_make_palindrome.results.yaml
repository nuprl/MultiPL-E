name: HumanEval_10_make_palindrome
language: rust
results:
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut postfix\
    \ = string;\n    let mut reverse_string: String = string;\n    let mut palindrome\
    \ = string;\n    while !postfix.is_empty() {\n        let mut suffix_len = 0;\n\
    \        let mut prefix_len = 0;\n        while !postfix.is_empty() {\n      \
    \      suffix_len += 1;\n            prefix_len += 1;\n            let mut pos\
    \ = 0;\n            let mut suffix = 0;\n            while !postfix.is_empty()\
    \ {\n                pos = postfix.find(suffix, pos, String::npos);\n        \
    \        suffix += 1;\n            }\n            postfix = postfix.remove(suffix,\
    \ String::npos);\n            if suffix_len < 1 {\n                suffix_len\
    \ = 0;\n            }\n        }\n        if !postfix.is_empty() {\n         \
    \   let mut pos = 0;\n            let mut suffix = 0;\n            while !postfix.is_empty()\
    \ {\n                pos = postfix.find(suffix, pos, String::npos);\n        \
    \        suffix += 1;\n            }\n            postfix = postfix.remove(suffix,\
    \ String::npos);\n            let suffix_len =\n                suffix.len_utf8()\
    \ - (postfix.len() - pos) as u8;\n            let prefix_len =\n             \
    \   (postfix.len() - pos) as u8 + (suffix_len - suffix.len_utf8());\n        \
    \    if !suffix_len.is_multiple_of(2) {\n                palindrome = postfix.clone();\n\
    \            } else {\n                palindrome = postfix.append(reverse_string);\n\
    \            }\n            palindrome = palindrome.prepend(&reverse_string[prefix_len..prefix_len\
    \ + suffix_len]);\n        }\n        reverse_string = reverse_string.rev();\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp8kfd5bz1.rs:24:57\n   |\n24 | \
    \                pos = postfix.find(suffix, pos, String::npos);\n   |        \
    \                                                 ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0061]: this function takes 1 argument but\
    \ 3 arguments were supplied\n    --> /tmp/tmp8kfd5bz1.rs:24:31\n     |\n24   |\
    \                 pos = postfix.find(suffix, pos, String::npos);\n     |     \
    \                          ^^^^ ------  ---  ------------ supplied 3 arguments\n\
    \     |                               |\n     |                              \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8kfd5bz1.rs:24:23\n   |\n21 |             let\
    \ mut pos = 0;\n   |                           - expected due to this value\n\
    ...\n24 |                 pos = postfix.find(suffix, pos, String::npos);\n   |\
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmp8kfd5bz1.rs:27:54\n\
    \   |\n27 |             postfix = postfix.remove(suffix, String::npos);\n   |\
    \                                                      ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0061]: this function takes 1 argument but\
    \ 2 arguments were supplied\n    --> /tmp/tmp8kfd5bz1.rs:27:31\n     |\n27   |\
    \             postfix = postfix.remove(suffix, String::npos);\n     |        \
    \                       ^^^^^^ ------  ------------ supplied 2 arguments\n   \
    \  |                               |\n     |                               expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8kfd5bz1.rs:27:23\n   |\n12 |     let mut postfix\
    \ = string;\n   |                       ------ expected d"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = \"*\";\n    let mut palindrome = \"\";\n    let mut len = 0;\n    for ch in\
    \ string.chars() {\n        if len == 0 {\n            palindrome += ch;\n   \
    \     } else {\n            palindrome += ch;\n            let mut i = 0;\n  \
    \          while i < len {\n                if palindrome[i] == ch  {\n      \
    \              i += 1;\n                } else {\n                    break;\n\
    \                }\n            }\n            len = len - i;\n        }\n   \
    \ }\n    suffix += palindrome.chars().collect::<String>().reverse();\n    return\
    \ string[0..string.len() - 1].to_string() + suffix;\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpknnun7z9.rs:17:13\n   |\n17 |             palindrome +=\
    \ ch;\n   |             ----------^^^^^^\n   |             |\n   |           \
    \  cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpknnun7z9.rs:19:13\n   |\n\
    19 |             palindrome += ch;\n   |             ----------^^^^^^\n   |  \
    \           |\n   |             cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpknnun7z9.rs:22:20\n\
    \   |\n22 |                 if palindrome[i] == ch  {\n   |                  \
    \  ^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you can use\
    \ `.chars().nth()` or `.bytes().nth()`\n           for more information, see chapter\
    \ 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpknnun7z9.rs:31:54\n   |\n31 |     suffix += palindrome.chars().collect::<String>().reverse();\n\
    \   |                                                      ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string;\n    let mut start = 0;\n    while result.len() > 0 {\n        if\
    \ start%2 == 0 {\n            result += 'a';\n        } else {\n            result\
    \ += 'b';\n        }\n        start += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw69othrh.rs:16:23\n   |\n\
    16 |             result += 'a';\n   |                       ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n16 |             result += \"a\";\n   |                      \
    \ ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw69othrh.rs:18:23\n   |\n\
    18 |             result += 'b';\n   |                       ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n18 |             result += \"b\";\n   |                      \
    \ ~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = \"\";\n    let max_postfix_len = string.len();\n    let mut postfix_pos =\
    \ 0;\n    while postfix_pos < max_postfix_len {\n        let letter = string[postfix_pos];\n\
    \        if letter == reverse letter[0 .. 1] {\n            reversed_string +=\
    \ letter;\n            postfix_pos += 1;\n        } else {\n            postfix_pos\
    \ += 1;\n        }\n    }\n    reversed_string += string[max_postfix_len..];\n\
    \    reversed_string.to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `letter`\n  --> /tmp/tmpwua5l9ta.rs:17:30\n\
    \   |\n17 |         if letter == reverse letter[0 .. 1] {\n   |         --   \
    \                ^^^^^^ expected `{`\n   |         |\n   |         this `if` expression\
    \ has a condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n17 |         if letter == reverse { letter[0 .. 1] } {\n   |          \
    \                    +                +\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpwua5l9ta.rs:16:22\n   |\n16 |         let\
    \ letter = string[postfix_pos];\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpwua5l9ta.rs:24:5\n   |\n24 |     reversed_string\
    \ += string[max_postfix_len..];\n   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.chars().collect::<Vec<char>>();\n    let mut reverse_string = \"\"\
    .to_string();\n    let mut longest = 0;\n    while !string.is_empty() {\n    \
    \    let mut i = 0;\n        for &c in string.iter() {\n            i += 1;\n\
    \            if i >= longest {\n                longest = i;\n            }\n\
    \            if i == longest {\n                reverse_string += c.to_string();\n\
    \            }\n        }\n        if longest > 0 {\n            string += &string[longest\
    \ - longest as usize..];\n        }\n    }\n    string += &reverse_string[longest\
    \ as usize..];\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpogc99l1c.rs:23:35\n   |\n\
    23 |                 reverse_string += c.to_string();\n   |                  \
    \                 ^^^^^^^^^^^^^\n   |                                   |\n  \
    \ |                                   expected `&str`, found struct `String`\n\
    \   |                                   help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<char>`\n\
    \  --> /tmp/tmpogc99l1c.rs:27:13\n   |\n27 |             string += &string[longest\
    \ - longest as usize..];\n   |             ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<char>`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<char>`\n\
    \  --> /tmp/tmpogc99l1c.rs:30:5\n   |\n30 |     string += &reverse_string[longest\
    \ as usize..];\n   |     ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   | \
    \    |\n   |     cannot use `+=` on type `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpogc99l1c.rs:31:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n31 |     string\n   |     ^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (suffix,\
    \ prefix) = string.split_prefix();\n    let suffix_reverse = suffix.chars()\n\
    \        .map(|c| if c != c.to_ascii_lowercase() + 'c' { c } else { c }).collect();\n\
    \    prefix.append(&suffix_reverse);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvlppe6k3.rs:12:35\n   |\n12 |     let (suffix,\
    \ prefix) = string.split_prefix();\n   |                                   ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `strip_prefix`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // First find\
    \ largest prefix that is a palindrome\n    let mut palindrome = string;\n    let\
    \ mut index = palindrome.char_indices().filter_map(|p| p.is_palendrome()).min().unwrap();\n\
    \    palindrome = &palindrome[index..];\n\n    // Now prepend that prefix to the\
    \ palindrome suffix\n    let mut prefix = string;\n    let mut suffix = &palindrome[..index];\n\
    \    let mut reversed_suffix = suffix;\n\n    let mut reversed_prefix = suffix;\n\
    \    for _ in 0..index {\n        reversed_prefix = reversed_prefix.chars().cloned().rev().collect::<String>();\n\
    \        suffix += &reversed_prefix;\n    }\n    prefix += &reversed_suffix;\n\
    \n    // Return what we got\n    prefix\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_palendrome` found for tuple `(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpi2e4pzm7.rs:14:64\n   |\n14 |   \
    \  let mut index = palindrome.char_indices().filter_map(|p| p.is_palendrome()).min().unwrap();\n\
    \   |                                                                ^^^^^^^^^^^^^\
    \ method not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi2e4pzm7.rs:15:18\n   |\n13 |     let mut palindrome = string;\n   |\
    \                          ------ expected due to this value\n14 |     let mut\
    \ index = palindrome.char_indices().filter_map(|p| p.is_palendrome()).min().unwrap();\n\
    15 |     palindrome = &palindrome[index..];\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n15 |     palindrome = (&palindrome[index..]).to_string();\n   |       \
    \           +                    +++++++++++++\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpi2e4pzm7.rs:24:51\n\
    \     |\n24   |         reversed_prefix = reversed_prefix.chars().cloned().rev().collect::<String>();\n\
    \     |                                                   ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `rev` exists for struct `Cloned<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpi2e4pzm7.rs:24:60\n   |\n24 |           reversed_prefix\
    \ = reversed_prefix.chars().cloned().rev().collect::<String>();\n   |        \
    \                                                      ^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0368]: binary assignment o"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result:\
    \ String = \"\";\n\n    for s in string.chars() {\n        let suffix_len = string.len()\
    \ - string.chars().position(|x| x == s).unwrap();\n        result = &result[..suffix_len]\
    \ + &s[..];\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6nhnqc9r.rs:12:30\n   |\n\
    12 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmp6nhnqc9r.rs:16:43\n   |\n16\
    \ |         result = &result[..suffix_len] + &s[..];\n   |                   \
    \                        ^^^^^\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string\n    \
    \    .chars()\n        .enumerate()\n        .find_map(|(_, index)| {\n      \
    \      let string = string.clone();\n            let mut index = index as usize;\n\
    \            let mut suffix;\n            loop {\n                let i = index\
    \ % string.len();\n                if i == 0 {\n                    suffix = &string[i..];\n\
    \                    break;\n                }\n                index = index\
    \ / 2;\n            }\n            let string = &string[..];\n            (\n\
    \                string,\n                suffix,\n                suffix.chars().enumerate().find_map(|(_,\
    \ j)| {\n                    let j = j as usize;\n                    let mut\
    \ string = string;\n                    let mut i = i;\n                    loop\
    \ {\n                        let j = i as usize;\n                        if j\
    \ >= string.len() {\n                            break;\n                    \
    \    }\n                        let ch = &string[j];\n                       \
    \ if ch != string[j] {\n                            break;\n                 \
    \       }\n                        string = &string[i..j];\n                 \
    \       i = j;\n                    }\n                    let ch = &string[i];\n\
    \                    if ch != string[i] {\n                        return false;\n\
    \                    }\n                    true\n                }),\n      \
    \      )\n        })\n        .unwrap_or_else(|| panic!(\"no palindrome found\
    \ for {:?}\", string))\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpzpd72kr_.rs:34:33\n\
    \   |\n34 |                     let mut i = i;\n   |                         \
    \        ^ help: a local variable with a similar name exists: `j`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpzpd72kr_.rs:40:35\n\
    \   |\n40 |                         let ch = &string[j];\n   |               \
    \                    ^^^^^^^^^ string indices are ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpzpd72kr_.rs:41:34\n\
    \   |\n41 |                         if ch != string[j] {\n   |               \
    \                   ^^^^^^^^^ string indices are ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpzpd72kr_.rs:47:31\n\
    \   |\n47 |                     let ch = &string[i];\n   |                   \
    \            ^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmpzpd72kr_.rs:48:30\n \
    \  |\n48 |                     if ch != string[i] {\n   |                    \
    \          ^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut result = \"\";\n    let mut\
    \ string_iter = string.chars();\n    let mut max_ending_here = 0;\n    let mut\
    \ max_start = 0;\n\n    // find the longest postfix that is a palindrome\n   \
    \ while let Some(char) = {\n        let start = string_iter.next().unwrap().position();\n\
    \        let end = string_iter.last().unwrap().position();\n        let current_char\
    \ = getter_at(&string, start, end);\n        if char == current_char {\n     \
    \       result += &string[..start - max_ending_here];\n            result += &string[start\
    \ - max_start - 1].to_lowercase();\n            result += &string[end - max_ending_here\
    \ - 1].to_lowercase();\n            max_ending_here = end;\n            max_start\
    \ = start;\n        }\n    }\n    // if longest palindrome ends with an interior\
    \ char, add it\n    if let Some(last_char) = {\n        let start = string_iter.next().unwrap().position();\n\
    \        let end = string_iter.last().unwrap().position();\n        if last_char\
    \ != getter_at(&string, start, end) {\n            result += &string[..start -\
    \ max_ending_here];\n            result += &string[start - max_start - 1].to_lowercase();\n\
    \            result += &string[end - max_ending_here - 1].to_lowercase();\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `if`\n  --> /tmp/tmp__l8fhio.rs:35:5\n\
    \   |\n22 |       while let Some(char) = {\n   |  _____-----_-\n   | |     |\n\
    \   | |     while parsing the body of this `while` expression\n23 | |        \
    \ let start = string_iter.next().unwrap().position();\n24 | |         let end\
    \ = string_iter.last().unwrap().position();\n25 | |         let current_char =\
    \ getter_at(&string, start, end);\n...  |\n32 | |         }\n33 | |     }\n  \
    \ | |_____- this `while` condition successfully parsed\n34 |       // if longest\
    \ palindrome ends with an interior char, add it\n35 |       if let Some(last_char)\
    \ = {\n   |       ^^ expected `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Initialize\
    \ longest prefix that is a palindrome.\n    let mut longest_prefix = string\n\
    \        .split_first_character()\n        .collect::<Vec<&str>>()\n        .reverse();\n\
    \    // Loop while longest prefix continues to be a palindrome.\n    while longest_prefix.is_sorted()\
    \ {\n        let new_string = string\n            .split_first_character()\n \
    \           .collect::<Vec<&str>>()\n            .join(\"_\");\n        let new_longest_prefix\
    \ = longest_prefix\n            .iter()\n            .filter_map(|&x| x.to_lowercase())\n\
    \            .join(\"_\");\n        if new_string == new_longest_prefix {\n  \
    \          return new_string;\n        }\n        longest_prefix.push(&new_longest_prefix);\n\
    \    }\n    longest_prefix.reverse().collect::<Vec<&str>>().join(\"_\")\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_character` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpmvs4jrlh.rs:14:10\n   |\n14 | \
    \        .split_first_character()\n   |          ^^^^^^^^^^^^^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `split_first_character`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpmvs4jrlh.rs:20:14\n\
    \   |\n20 |             .split_first_character()\n   |              ^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string.split_first_match_iter()\n\
    \        .map(|c| if let Some(c) = (c as u8, c as usize)\n        { String::from_utf8_unchecked(c.to_le_bytes()).rev()\
    \ } else { c })\n        .find(|c| c.starts_with(string))\n        .ok()\n   \
    \     .or_else(|| panic!(\"No palindrome could be found\"))\n        .and_then(|c|\
    \ c + 'a')\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_match_iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpeaudl1zt.rs:12:12\n   |\n12 | \
    \    string.split_first_match_iter()\n   |            ^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `split_at_mut`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeaudl1zt.rs:13:25\n   |\n13 |         .map(|c|\
    \ if let Some(c) = (c as u8, c as usize)\n   |                         ^^^^^^^\
    \   --------------------- this expression has type `(u8, usize)`\n   |       \
    \                  |\n   |                         expected tuple, found enum\
    \ `Option`\n   |\n   = note: expected tuple `(u8, usize)`\n               found\
    \ enum `Option<_>`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpeaudl1zt.rs:14:56\n\
    \    |\n14  |           { String::from_utf8_unchecked(c.to_le_bytes()).rev() }\
    \ else { c })\n    |                                                         \
    \ ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut prefix = string;\n    for i in string.len() {\n     \
    \   if string[i] != string[string.len() - 1 - i] {\n            reverse = &string[..i];\n\
    \            prefix = &string[i - 1..];\n            break;\n        }\n    }\n\
    \    reverse += &prefix[..];\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmpfdkmf61y.rs:14:14\n\
    \   |\n14 |     for i in string.len() {\n   |              ^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpfdkmf61y.rs:15:12\n   |\n15 |         if string[i]\
    \ != string[string.len() - 1 - i] {\n   |            ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfdkmf61y.rs:15:25\n   |\n15 |         if string[i] != string[string.len()\
    \ - 1 - i] {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfdkmf61y.rs:16:23\n\
    \   |\n12 |     let mut reverse = string;\n   |                       -----"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return \"\";\n    }\n\n    let mut s = string;\n    let mut reverse\
    \ = &s[..s.len()].chars().collect::<String>();\n\n    let mut longest = 0;\n \
    \   let mut longest = 0;\n\n    while reverse != s[..longest] {\n        longest\
    \ = s.rfind('c', longest);\n\n        let mut reverse = &s[..longest].chars().collect::<String>();\n\
    \        reverse.extend(&reverse[..longest].reverse());\n        s = s.insert(longest,\
    \ reverse);\n    }\n\n    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtz2ee7e.rs:13:16\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if string.is_empty() {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0277]: can't\
    \ compare `&String` with `str`\n  --> /tmp/tmpvtz2ee7e.rs:22:19\n   |\n22 |  \
    \   while reverse != s[..longest] {\n   |                   ^^ no implementation\
    \ for `&String == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpvtz2ee7e.rs:23:21\n\
    \     |\n23   |         longest = s.rfind('c', longest);\n     |             \
    \        ^^^^^ ---  ------- supplied 2 arguments\n     |                     |\n\
    \     |                     expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvtz2ee7e.rs:23:19\n\
    \   |\n20 |     let mut longest = 0;\n   |                       - expected due\
    \ to this value\n...\n23 |         longest = s.rfind('c', longest);\n   |    \
    \               ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpvtz2ee7e.rs:26:44\n   |\n26 |         reverse.extend(&reverse[..longest].reverse());\n\
    \   | "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse_string\
    \ = \"\".to_string();\n    for i in string.chars() {\n        reverse_string +=\
    \ &format!(\"{}{}\", i, &reverse_string.chars().skip(i).collect::<String>().reverse().collect::<String>());\n\
    \    }\n    reverse_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00tja6_0.rs:14:76\n   |\n\
    14 |         reverse_string += &format!(\"{}{}\", i, &reverse_string.chars().skip(i).collect::<String>().reverse().collect::<String>());\n\
    \   |                                                                        \
    \    ^ expected `usize`, found `char`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp00tja6_0.rs:14:99\n\
    \   |\n14 |         reverse_string += &format!(\"{}{}\", i, &reverse_string.chars().skip(i).collect::<String>().reverse().collect::<String>());\n\
    \   |                                                                        \
    \                           ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Finding the\
    \ longest postfix of supplied string.\n    let len = string.len();\n    let mut\
    \ postfix = &string[..];\n    let mut palindrome = &string[len..];\n    // Iterate\
    \ through each character and check for palindrome\n    for i in 0..len {\n   \
    \     if i != len - 1 {\n            if string[i] == string[len - i - 1] {\n \
    \               postfix[i] = string[i];\n                palindrome[i] = string[len\
    \ - i - 1];\n            }\n        }\n    }\n    // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    palindrome.extend_from_slice(&postfix);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcj_73yev.rs:19:16\n\
    \   |\n19 |             if string[i] == string[len - i - 1] {\n   |          \
    \      ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcj_73yev.rs:19:29\n   |\n19 |             if string[i] == string[len\
    \ - i - 1] {\n   |                             ^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpcj_73yev.rs:20:17\n   |\n20 |                 postfix[i] = string[i];\n\
    \   |                 ^^^^^^^^^^ string indices are ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcj_73yev.rs:20:30\n\
    \   |\n20 |                 postfix[i] = string[i];\n   |                    \
    \          ^^^^^^^^^ `String"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (prefix_postfix,\
    \ suffix_suffix) = string.split_last_mut(|c| c.is_alphanumeric());\n    let reversed_string\
    \ = suffix_suffix.reverse().join(\"\");\n    prefix_postfix.append(&reversed_string);\n\
    \    prefix_postfix.to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpnwj__di8.rs:12:50\n   |\n12 |     let (prefix_postfix,\
    \ suffix_suffix) = string.split_last_mut(|c| c.is_alphanumeric());\n   |     \
    \                                             ^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `split_at`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed\
    \ = string;\n    let mut longest = 0;\n    let mut longestpalindrome = string;\n\
    \    while reverse > reverse {\n        reversed.pop();\n        if reverse >\
    \ reverse {\n            break;\n        }\n        reversed.pop();\n    }\n\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        if reversed[i] ==\
    \ reversed[i] {\n            i += 1;\n        } else {\n            longest =\
    \ 0;\n            longestpalindrome = string;\n            i += 1;\n        }\n\
    \    }\n\n    if longest > longestpalindrome.len() {\n        return longestpalindrome;\n\
    \    }\n\n    while reversed.len() > 0 {\n        reversed.pop();\n        if\
    \ reversed.len() > 0 {\n            reversed.pop();\n        }\n    }\n\n    if\
    \ reverse == reverse {\n        return longestpalindrome;\n    }\n    reverse\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `reverse` in this scope\n  --> /tmp/tmpg07_yeva.rs:15:11\n\
    \   |\n15 |     while reverse > reverse {\n   |           ^^^^^^^ help: a local\
    \ variable with a similar name exists: `reversed`\n\nerror[E0425]: cannot find\
    \ value `reverse` in this scope\n  --> /tmp/tmpg07_yeva.rs:15:21\n   |\n15 | \
    \    while reverse > reverse {\n   |                     ^^^^^^^ help: a local\
    \ variable with a similar name exists: `reversed`\n\nerror[E0425]: cannot find\
    \ value `reverse` in this scope\n  --> /tmp/tmpg07_yeva.rs:17:12\n   |\n17 | \
    \        if reverse > reverse {\n   |            ^^^^^^^ help: a local variable\
    \ with a similar name exists: `reversed`\n\nerror[E0425]: cannot find value `reverse`\
    \ in this scope\n  --> /tmp/tmpg07_yeva.rs:17:22\n   |\n17 |         if reverse\
    \ > reverse {\n   |                      ^^^^^^^ help: a local variable with a\
    \ similar name exists: `reversed`\n\nerror[E0425]: cannot find value `reverse`\
    \ in this scope\n  --> /tmp/tmpg07_yeva.rs:45:8\n   |\n45 |     if reverse ==\
    \ reverse {\n   |        ^^^^^^^ help: a local variable with a similar name exists:\
    \ `reversed`\n\nerror[E0425]: cannot find value `reverse` in this scope\n  -->\
    \ /tmp/tmpg07_yeva.rs:45:19\n   |\n45 |     if reverse == reverse {\n   |    \
    \               ^^^^^^^ help: a local variable with a similar name exists: `reversed`\n\
    \nerror[E0425]: cannot find value `reverse` in this scope\n  --> /tmp/tmpg07_yeva.rs:48:5\n\
    \   |\n48 |     reverse\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `reversed`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpg07_yeva.rs:25:12\n   |\n25 |         if reversed[i]\
    \ == reversed[i] {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut length\
    \ = string.len();\n    let mut prefix: Vec<String> = vec![];\n\n    let mut suffix:\
    \ String = string.to_string();\n\n    loop {\n        match suffix.chars().find(|c|\
    \ *c == 'A') {\n            Some(0) => break,\n            _ => break,\n     \
    \   };\n\n        prefix.push(suffix.chars().collect::<String>());\n        suffix\
    \ =\n            suffix\n                .chars()\n                .filter_map(|c|\
    \ if c == 'A' { 'A'.repeat(length) } else { c })\n                .collect();\n\
    \        length -= 1;\n    }\n\n    prefix.reverse().join(\"\") + suffix\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77cbpgar.rs:19:18\n   |\n\
    18 |         match suffix.chars().find(|c| *c == 'A') {\n   |               ----------------------------------\
    \ this expression has type `Option<char>`\n19 |             Some(0) => break,\n\
    \   |                  ^ expected `char`, found integer\n\nwarning: unreachable\
    \ statement\n  --> /tmp/tmp77cbpgar.rs:23:9\n   |\n18 | /         match suffix.chars().find(|c|\
    \ *c == 'A') {\n19 | |             Some(0) => break,\n20 | |             _ =>\
    \ break,\n21 | |         };\n   | |_________- any code following this `match`\
    \ expression is unreachable, as all arms diverge\n22 | \n23 |           prefix.push(suffix.chars().collect::<String>());\n\
    \   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0599]: no\
    \ method named `repeat` found for type `char` in the current scope\n  --> /tmp/tmp77cbpgar.rs:27:51\n\
    \   |\n27 |                 .filter_map(|c| if c == 'A' { 'A'.repeat(length) }\
    \ else { c })\n   |                                                   ^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77cbpgar.rs:27:75\n\
    \   |\n27 |                 .filter_map(|c| if c == 'A' { 'A'.repeat(length) }\
    \ else { c })\n   |                                                          \
    \                 ^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `char`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n27 |                 .filter_map(|c| if c == 'A' { 'A'.repeat(length)\
    \ } else { Some(c) })\n   |                                                  \
    \                         +++++ +\n\nerror[E0599]: no method named `join` found\
    \ for unit type `()` in the current scope\n  --> /tmp/tmp77cbpgar.rs:32:22\n \
    \  |\n32 |     prefix.reverse().join(\"\") + suffix\n   |                    \
    \  ^^^^ method not found in `()`\n\nerror: aborting due to 4 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more informat"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ prefix that is palindrome\n    let mut longest_prefix = string[0..0];\n    let\
    \ mut longest_postfix = LongestPalindrome::new(string);\n    let mut i = 1;\n\
    \    while longest_postfix.len() > i && longest_prefix.is_palindrome() {\n   \
    \     longest_prefix.push_str(&string[i..]);\n        longest_postfix.remove(i);\n\
    \        i += 1;\n    }\n    // Append the longest postfix of the longest prefix\
    \ to the beginning of the string\n    longest_prefix.push_str(&longest_postfix.reverse());\n\
    \    longest_prefix.to_owned()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `LongestPalindrome`\n\
    \  --> /tmp/tmp087546s5.rs:14:31\n   |\n14 |     let mut longest_postfix = LongestPalindrome::new(string);\n\
    \   |                               ^^^^^^^^^^^^^^^^^ use of undeclared type `LongestPalindrome`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp087546s5.rs:13:9\n   |\n13 |     let mut longest_prefix\
    \ = string[0..0];\n   |         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n13 |     let mut longest_prefix = &string[0..0];\n   |                \
    \              +\n\nerror[E0599]: no method named `is_palindrome` found for type\
    \ `str` in the current scope\n  --> /tmp/tmp087546s5.rs:16:55\n   |\n16 |    \
    \ while longest_postfix.len() > i && longest_prefix.is_palindrome() {\n   |  \
    \                                                     ^^^^^^^^^^^^^ method not\
    \ found in `str`\n\nerror[E0599]: no method named `push_str` found for type `str`\
    \ in the current scope\n  --> /tmp/tmp087546s5.rs:17:24\n   |\n17 |         longest_prefix.push_str(&string[i..]);\n\
    \   |                        ^^^^^^^^ method not found in `str`\n\nerror[E0599]:\
    \ no method named `push_str` found for type `str` in the current scope\n  -->\
    \ /tmp/tmp087546s5.rs:22:20\n   |\n22 |     longest_prefix.push_str(&longest_postfix.reverse());\n\
    \   |                    ^^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix_start_pos\
    \ = 0;\n    let mut prefix_end_pos = 0;\n    let mut suffix = string;\n    let\
    \ mut prefix = string;\n    while suffix_start_pos < suffix.len() {\n        let\
    \ mut palindrome = &suffix[suffix_start_pos..prefix_end_pos];\n        if palindrome\
    \ == &prefix.front() {\n            palindrome = &prefix.reverse();\n        }\n\
    \        suffix_start_pos = prefix_end_pos;\n        prefix_end_pos += palindrome.len();\n\
    \        prefix = prefix.pop();\n    }\n    prefix + &suffix[suffix_start_pos..]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplfw78il5.rs:18:34\n   |\n18 |         if palindrome\
    \ == &prefix.front() {\n   |                                  ^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmplfw78il5.rs:19:34\n   |\n19 | \
    \            palindrome = &prefix.reverse();\n   |                           \
    \       ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplfw78il5.rs:23:18\n   |\n15 |\
    \     let mut prefix = string;\n   |                      ------ expected due\
    \ to this value\n...\n23 |         prefix = prefix.pop();\n   |              \
    \    ^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<char>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string.chars()\n\
    \        .zip(string.chars().skip(1))\n        .map(|(a, b)| {\n            let\
    \ (prefix, suffix) = (a, b);\n            (prefix, suffix)\n        })\n     \
    \   .find_map(|(_, prefix)| {\n            let suffix = (&string[..]).rev();\n\
    \            (prefix, suffix)\n        })\n        .take_while(|(_, suffix)| suffix.is_palindrome())\n\
    \        .map(|(_, suffix)| suffix)\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&str` is not an iterator\n  --> /tmp/tmp1q1yv9ql.rs:19:40\n\
    \   |\n19 |             let suffix = (&string[..]).rev();\n   |              \
    \                          ^^^ `&str` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&str: Iterator`\n           which is required by `&mut &str: Iterator`\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1q1yv9ql.rs:20:13\n   |\n20 |\
    \             (prefix, suffix)\n   |             ^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found tuple\n   |\n   = note: expected enum `Option<_>`\n        \
    \     found tuple `(char, _)`\nhelp: try wrapping the expression in `Some`\n \
    \  |\n20 |             Some((prefix, suffix))\n   |             +++++        \
    \        +\n\nerror[E0599]: `Option<_>` is not an iterator\n   --> /tmp/tmp1q1yv9ql.rs:22:10\n\
    \    |\n22  |           .take_while(|(_, suffix)| suffix.is_palindrome())\n  \
    \  |            ^^^^^^^^^^ `Option<_>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<_>: Iterator`\n\
    \            which is required by `&mut Option<_>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut index = palindrome.len();\n    let mut reverse = String::new();\n\
    \    let mut reverse_index = 0;\n\n    while index > 0 {\n        reverse.push(palindrome[reverse_index..index].to_ascii_lowercase());\n\
    \        index = palindrome.rfind('a', reverse_index);\n        reverse_index\
    \ += 1;\n    }\n\n    if palindrome.len() < 2 {\n        palindrome += &reverse;\n\
    \    } else {\n        palindrome += &reverse.reverse();\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dmu9n9d.rs:18:22\n   |\n\
    18 |         reverse.push(palindrome[reverse_index..index].to_ascii_lowercase());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmp1dmu9n9d.rs:19:28\n\
    \     |\n19   |         index = palindrome.rfind('a', reverse_index);\n     |\
    \                            ^^^^^ ---  ------------- supplied 2 arguments\n \
    \    |                            |\n     |                            expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1dmu9n9d.rs:19:17\n   |\n13 |     let mut index\
    \ = palindrome.len();\n   |                     ---------------- expected due\
    \ to this value\n...\n19 |         index = palindrome.rfind('a', reverse_index);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp1dmu9n9d.rs:26:32\n   |\n26 | \
    \        palindrome += &reverse.reverse();\n   |                             \
    \   ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string[..].chars().take_while(|&c| !c.is_whitespace()).collect();\n    let\
    \ mut suffix = string[..].chars().skip_while(|&c| !c.is_whitespace()).collect();\n\
    \    let rev = prefix.reverse();\n    let rev_suffix = suffix.reverse();\n   \
    \ string\n        .replace_suffix(rev.len(), rev.join(\"\").to_string())\n   \
    \     .replace_suffix(rev_suffix.len(), rev_suffix.join(\"\").to_string())\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpytrw270b.rs:14:15\n\
    \   |\n12 |     let mut prefix = string[..].chars().take_while(|&c| !c.is_whitespace()).collect();\n\
    \   |         ---------- consider giving `prefix` a type\n13 |     let mut suffix\
    \ = string[..].chars().skip_while(|&c| !c.is_whitespace()).collect();\n14 |  \
    \   let rev = prefix.reverse();\n   |               ^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0599]: no method\
    \ named `replace_suffix` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpytrw270b.rs:17:10\n   |\n17 |         .replace_suffix(rev.len(), rev.join(\"\
    \").to_string())\n   |          ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `replace`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut len =\
    \ string.len();\n    let mut prefix = string.clone();\n    let mut suffix: String\
    \ = \"\";\n\n    for _ in 0..len {\n        if suffix == \"\" {\n            if\
    \ string.starts_with(prefix.reverse()) {\n                suffix = string.as_str().reverse();\n\
    \            }\n        } else {\n            if string.ends_with(suffix) && string.starts_with(prefix.reverse())\
    \ {\n                prefix = prefix.as_str().reverse();\n                suffix\
    \ = string.as_str().reverse();\n                break;\n            }\n      \
    \  }\n    }\n\n    prefix.to_owned() + suffix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpubfhzu00.rs:14:30\n   |\n\
    14 |     let mut suffix: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpubfhzu00.rs:18:42\n\
    \   |\n18 |             if string.starts_with(prefix.reverse()) {\n   |      \
    \                                    ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror[E0599]: no method named `reverse` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpubfhzu00.rs:19:42\n\
    \   |\n19 |                 suffix = string.as_str().reverse();\n   |        \
    \                                  ^^^^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmpubfhzu00.rs:22:33\n\
    \   |\n22 |             if string.ends_with(suffix) && string.starts_with(prefix.reverse())\
    \ {\n   |                       --------- ^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n   |                       |\n   |                       required\
    \ by a bound introduced by this call\n   |\n   = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nhelp: consider borrowing here\n \
    \  |\n22 |             if string.ends_with(&suffix) && string.starts_with(prefix.reverse())\
    \ {\n   |                                 +\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpubfhzu00.rs:22:70\n\
    \   |\n22 |             if string.ends_with(suffix) && string.starts_with(prefix.reverse())\
    \ {\n   |                                                                    \
    \  ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `reverse` found for referen"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = \"a\".to_string();\n    let mut result = string;\n\n    while result.len()\
    \ > 1 {\n        let mut i = 1;\n        let mut j = 1;\n        let mut k = i;\n\
    \        while k < result.len() {\n            if result[k] != result[k + i] {\n\
    \                break;\n            }\n            i += 1;\n            k +=\
    \ 1;\n        }\n        j -= i;\n        result = &result[..k];\n        suffix\
    \ += &result[..j];\n    }\n\n    return result + suffix;\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpegxmtjqz.rs:20:16\n\
    \   |\n20 |             if result[k] != result[k + i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpegxmtjqz.rs:20:29\n   |\n20 |             if result[k] != result[k\
    \ + i] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegxmtjqz.rs:27:18\n\
    \   |\n13 |     let mut result = string;\n   |                      ------ expected\
    \ due to this value\n...\n27 |         result = &result[..k];\n   |          \
    \        ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n27 |         result = (&result[..k]).to_string();\n\
    \   |                  +            +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpegxmtjqz.rs:31:21\n   |\n31 |     return result + suffix;\n\
    \   |                     ^^^^^^\n   |                     |\n   |           \
    \          expected `&str`, found struct `String`\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest_palindrome\
    \ = string;\n    longest_palindrome.push_front('');\n    let mut longest = 0;\n\
    \    for pos in longest_palindrome.chars().rev().skip(1) {\n        if longest_palindrome[longest]\
    \ != string[pos] {\n            longest = pos;\n        }\n    }\n    if longest_palindrome[longest\
    \ - 1] == ' ' {\n        longest += 1;\n    }\n    longest_palindrome.append(&string[longest\
    \ - 1]);\n    longest_palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpdogv8gj4.rs:13:36\n   |\n\
    13 |     longest_palindrome.push_front('');\n   |                            \
    \        ^ empty character literal\n\nerror[E0599]: no method named `push_front`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdogv8gj4.rs:13:24\n\
    \   |\n13 |     longest_palindrome.push_front('');\n   |                     \
    \   ^^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpdogv8gj4.rs:16:12\n   |\n16\
    \ |         if longest_palindrome[longest] != string[pos] {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n \
    \ --> /tmp/tmpdogv8gj4.rs:16:43\n   |\n16 |         if longest_palindrome[longest]\
    \ != string[pos] {\n   |                                           ^^^^^^^^^^^\
    \ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdogv8gj4.rs:17:23\n\
    \   |\n14 |     let mut longest = 0;\n   |                       - expected due\
    \ to this value\n...\n17 |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string ==\
    \ \"\" {\n        return \"\";\n    }\n\n    // Find longest prefix that is a\
    \ palindrome.\n    let mut longest = 0;\n    let mut suffix_start = string.len();\n\
    \    let mut suffix_end = string.len();\n\n    let mut prefix_start = string.len();\n\
    \    while suffix_start >= 0 {\n        let mut suffix = &string[suffix_start..];\n\
    \        let mut index = suffix.iter().rev().find(|c| *c != string[suffix_start\
    \ - 1]);\n        if index == None {\n            suffix = &string[suffix_start..];\n\
    \        } else {\n            suffix = suffix.split_to(index);\n        }\n\n\
    \        // Check if this suffix is a palindrome prefix.\n        let mut suffix_slice\
    \ = suffix.as_slice();\n        let mut suffix_reversed = suffix_slice.iter().rev();\n\
    \        if suffix_slice[..suffix_reversed.next()].iter() == suffix_reversed {\n\
    \            longest = suffix_start + 1;\n            suffix_start -= 1;\n   \
    \     } else {\n            suffix_start -= 1;\n        }\n\n        if suffix_start\
    \ >= 0 {\n            suffix_start -= 1;\n        }\n    }\n\n    // Append to\
    \ the beginning of the string reverse of the string prefix that comes before it.\n\
    \    let mut prefix = &string[prefix_start..prefix_start];\n    let mut prefix_reversed\
    \ = prefix.iter().rev();\n    prefix_reversed.next_back();\n    let mut prefix_slice\
    \ = prefix.as_slice();\n    prefix_slice.insert(prefix_reversed.next(), &string[prefix_start..]);\n\
    \n    // Return string joined by empty string.\n    \"\".to_string().join(&prefix_slice)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59m7znoy.rs:13:16\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if string == \"\" {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0599]: no method\
    \ named `iter` found for reference `&str` in the current scope\n  --> /tmp/tmp59m7znoy.rs:24:32\n\
    \   |\n24 |         let mut index = suffix.iter().rev().find(|c| *c != string[suffix_start\
    \ - 1]);\n   |                                ^^^^ method not found in `&str`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n24 |         let mut index\
    \ = suffix.chars().rev().find(|c| *c != string[suffix_start - 1]);\n   |     \
    \                           ~~~~~\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp59m7znoy.rs:24:60\n   |\n24 |         let\
    \ mut index = suffix.iter().rev().find(|c| *c != string[suffix_start - 1]);\n\
    \   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_to` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp59m7znoy.rs:28:29\n   |\n28 |          \
    \   suffix = suffix.split_to(index);\n   |                             ^^^^^^^^\
    \ help: there is an associated function with a similar name: `split`"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    let mut palindrome: Vec<String> = vec![string];\n\n    while i !=\
    \ j {\n        if string[i] == string[j] {\n            palindrome.pop_back();\n\
    \            j -= 1;\n        } else {\n            i += 1;\n            j -=\
    \ 1;\n            palindrome.push((string[..i] + string[j..]).clone());\n    \
    \    }\n    }\n\n    String::from(palindrome.iter().collect())\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplcz9900h.rs:21:12\n\
    \   |\n21 |         if string[i] == string[j] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplcz9900h.rs:21:25\n   |\n21 |         if string[i] == string[j]\
    \ {\n   |                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `pop_back` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmplcz9900h.rs:22:24\n   |\n22 |          \
    \   palindrome.pop_back();\n   |                        ^^^^^^^^ method not found\
    \ in `Vec<String>`\n\nerror[E0369]: cannot add `str` to `str`\n  --> /tmp/tmplcz9900h.rs:27:42\n\
    \   |\n27 |             palindrome.push((string[..i] + string[j..]).clone());\n\
    \   |                              ----------- ^ ----------- str\n   |       \
    \                       |\n   |                              str\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0369,\
    \ E0599.\nFor more information about an error, try `rustc"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest_postfix_palindrome\
    \ = String::new();\n    for c in string.chars() {\n        longest_postfix_palindrome.append(c.to_string());\n\
    \    }\n\n    longest_postfix_palindrome\n        .append_str(&longest_postfix_palindrome)\n\
    \        .reverse()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3utum4dm.rs:14:36\n   |\n14 |         longest_postfix_palindrome.append(c.to_string());\n\
    \   |                                    ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append_str` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3utum4dm.rs:18:10\n   |\n18 |         .append_str(&longest_postfix_palindrome)\n\
    \   |          ^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `as_str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string\n        .chars()\n        .map(|c| match c {\n            'a' | 'e'\
    \ | ... | 'z' | 'A' | ... | 'Z' => c as char,\n            _ => c,\n        })\n\
    \        .collect::<Vec<char>>()\n        .rev()\n        .join(\"\");\n    let\
    \ prefix = reversed_string[..string.len()];\n    String::from(prefix) + &reversed_string[string.len()..]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: unexpected `...`\n  --> /tmp/tmp187r5zto.rs:15:25\n   |\n15 |  \
    \           'a' | 'e' | ... | 'z' | 'A' | ... | 'Z' => c as char,\n   |      \
    \                   ^^^\n   |                         |\n   |                \
    \         not a valid pattern\n   |                         help: for a rest pattern,\
    \ use `..` instead of `...`\n\nerror: unexpected `...`\n  --> /tmp/tmp187r5zto.rs:15:43\n\
    \   |\n15 |             'a' | 'e' | ... | 'z' | 'A' | ... | 'Z' => c as char,\n\
    \   |                                           ^^^\n   |                    \
    \                       |\n   |                                           not\
    \ a valid pattern\n   |                                           help: for a\
    \ rest pattern, use `..` instead of `...`\n\nerror: `..` patterns are not allowed\
    \ here\n  --> /tmp/tmp187r5zto.rs:15:25\n   |\n15 |             'a' | 'e' | ...\
    \ | 'z' | 'A' | ... | 'Z' => c as char,\n   |                         ^^^\n  \
    \ |\n   = note: only allowed in tuple, tuple struct, and slice patterns\n\nerror:\
    \ `..` patterns are not allowed here\n  --> /tmp/tmp187r5zto.rs:15:43\n   |\n\
    15 |             'a' | 'e' | ... | 'z' | 'A' | ... | 'Z' => c as char,\n   | \
    \                                          ^^^\n   |\n   = note: only allowed\
    \ in tuple, tuple struct, and slice patterns\n\nerror[E0599]: `Vec<char>` is not\
    \ an iterator\n   --> /tmp/tmp187r5zto.rs:19:10\n    |\n19  |           .rev()\n\
    \    |            ^^^ `Vec<char>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<char>: Iterator`\n      \
    \      which is required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n\
    \            which is required by `&mut [char]: Iterator`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string;\n\
    \    let mut palindrome = string;\n    let mut last_index = -1;\n    while !s.is_empty()\
    \ {\n        let index = s.rfind('a');\n        if index == s.len() - 1 {\n  \
    \          palindrome += 'a';\n            last_index = -1;\n        } else {\n\
    \            palindrome += &s[..index + 1];\n            last_index = index;\n\
    \        }\n        s = &s[index..];\n    }\n    palindrome.push_str(&string[..last_index]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6pnxq1p9.rs:17:21\n   |\n\
    17 |         if index == s.len() - 1 {\n   |                     ^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         if index == Some(s.len() - 1) {\n   |                    \
    \ +++++           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6pnxq1p9.rs:18:27\n\
    \   |\n18 |             palindrome += 'a';\n   |                           ^^^\
    \ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n18 |             palindrome += \"a\";\n   |       \
    \                    ~~~\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp6pnxq1p9.rs:21:38\n   |\n21 |             palindrome += &s[..index\
    \ + 1];\n   |                                ----- ^ - {integer}\n   |       \
    \                         |\n   |                                Option<usize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6pnxq1p9.rs:22:26\n   |\n14 |\
    \     let mut last_index = -1;\n   |                          -- expected due\
    \ to this value\n...\n22 |             last_index = index;\n   |             \
    \             ^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected\
    \ type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp6pnxq1p9.rs:24:14\n\
    \   |\n24 |         s = &s[index..];\n   |              ^^^^^^^^^^ `String` cannot\
    \ be indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<us"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let max_len =\
    \ find_longest_palindrome(&string).0;\n    string\n        .chars()\n        .filter_map(|c|\
    \ if c == c.to_ascii_lowercase().to_lowercase() || c == c.to_ascii_uppercase().to_uppercase()\
    \ {\n            Some(c.to_ascii_lowercase().to_lowercase())\n        } else {\n\
    \            None\n        })\n        .filter(|c| c.is_ascii_lowercase())\n \
    \       .collect::<String>()\n        .join(\"\")\n        .append(&string[max_len..])\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \  --> /tmp/tmpgz_8di9l.rs:12:19\n   |\n12 |     let max_len = find_longest_palindrome(&string).0;\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgz_8di9l.rs:15:33\n   |\n15 |         .filter_map(|c|\
    \ if c == c.to_ascii_lowercase().to_lowercase() || c == c.to_ascii_uppercase().to_uppercase()\
    \ {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgz_8di9l.rs:15:79\n   |\n15 |         .filter_map(|c| if c == c.to_ascii_lowercase().to_lowercase()\
    \ || c == c.to_ascii_uppercase().to_uppercase() {\n   |                      \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToUppercase`\n\nerror[E0599]: no method named\
    \ `is_ascii_lowercase` found for reference `&ToLowercase` in the current scope\n\
    \  --> /tmp/tmpgz_8di9l.rs:20:23\n   |\n20 |         .filter(|c| c.is_ascii_lowercase())\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ method not found in `&ToLowercase`\n\
    \nerror[E0277]: a value of type `String` cannot be built from an iterator over\
    \ elements of type `ToLowercase`\n    --> /tmp/tmpgz_8di9l.rs:21:10\n     |\n\
    21   |         .collect::<String>()\n     |          ^^^^^^^ value of type `String`\
    \ cannot be built from `std::iter::Iterator<Item=ToLowercase>`\n     |\n     =\
    \ help: the trait `FromIterator<ToLowercase>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0599]: no method named `join` found for struct `String` in th"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut last_char\
    \ = string[string.len() - 1];\n    let mut index = 0;\n    while last_char !=\
    \ string[index] {\n        last_char = string[string.len() - index];\n       \
    \ index += 1\n    }\n    let mut string_reverse = string[string.len() - index..string.len()\
    \ - 1];\n    let mut palindrome = string;\n    palindrome += &string_reverse;\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9tyfwp3n.rs:12:25\n\
    \   |\n12 |     let mut last_char = string[string.len() - 1];\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp9tyfwp3n.rs:14:24\n   |\n14 |     while last_char != string[index]\
    \ {\n   |                        ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9tyfwp3n.rs:15:21\n   |\n15 |         last_char = string[string.len()\
    \ - index];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclu"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string;\n\n    while new_string.len() > 1 {\n        new_string = new_string.chars()\n\
    \            .rev()\n            .collect::<String>() + new_string.chars().next().unwrap();\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8whs9z8g.rs:17:36\n   |\n\
    17 |             .collect::<String>() + new_string.chars().next().unwrap();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev_string\
    \ = string\n        .chars()\n        .enumerate()\n        .flat_map(|(i, char)|\
    \ {\n            if i >= string.len() {\n                vec![(i, char)];\n  \
    \          } else {\n                vec![\n                    (i, char),\n \
    \                   ((i + 1) % string.len(), char),\n                ]\n     \
    \       }\n        })\n        .collect::<Vec<(usize, char)>>();\n\n    let prefix_length_string\
    \ = string.chars().enumerate().take(string.len() - 1).collect::<Vec<_>>();\n \
    \   let prefix_length = prefix_length_string\n        .iter()\n        .map(|(_,\
    \ c)| c.len() as usize)\n        .sum();\n\n    let suffix = string\n        .chars()\n\
    \        .enumerate()\n        .take(string.len() - 2)\n        .collect::<Vec<_>>();\n\
    \    let suffix_length_string = suffix\n        .iter()\n        .map(|(_, c)|\
    \ c.len() as usize)\n        .sum();\n\n    let prefix_length = prefix_length\
    \ + suffix_length;\n\n    let mut reversed_string = String::new();\n\n    for\
    \ i in rev_string.iter() {\n        reversed_string.push_str(&string[i as usize\
    \ - prefix_length]);\n    }\n\n    debug!(\"Rev string for {}: {}\", string, reversed_string);\n\
    \n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmpa02a5egi.rs:51:5\n\
    \   |\n51 |     debug!(\"Rev string for {}: {}\", string, reversed_string);\n\
    \   |     ^^^^^\n\nerror[E0425]: cannot find value `suffix_length` in this scope\n\
    \  --> /tmp/tmpa02a5egi.rs:43:41\n   |\n43 |     let prefix_length = prefix_length\
    \ + suffix_length;\n   |                                         ^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prefix_length`\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmpa02a5egi.rs:19:17\n \
    \  |\n16 |  /             if i >= string.len() {\n17 |  |                 vec![(i,\
    \ char)];\n   |  |                 ---------------- help: consider removing this\
    \ semicolon\n   |  |                 |\n   |  |                 expected because\
    \ of this\n18 |  |             } else {\n19 |  |                 vec![\n   | \
    \ |_________________^\n20 | ||                     (i, char),\n21 | ||       \
    \              ((i + 1) % string.len(), char),\n22 | ||                 ]\n  \
    \ | ||_________________^ expected `()`, found struct `Vec`\n23 |  |          \
    \   }\n   |  |_____________- `if` and `else` have incompatible types\n   |\n \
    \  = note: expected unit type `()`\n                 found struct `Vec<(usize,\
    \ char)>`\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `len` found for reference `&char` in the current scope\n  --> /tmp/tmpa02a5egi.rs:30:25\n\
    \   |\n30 |         .map(|(_, c)| c.len() as usize)\n   |                    \
    \     ^^^ method not found in `&char`\n\nerror[E0599]: no method named `len` found\
    \ for reference `&char` in the current scope\n  --> /tmp/tmpa02a5egi.rs:40:25\n\
    \   |\n40 |         .map(|(_, c)| c.len() as usize)\n   |                    \
    \     ^^^ method not found in `&char`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest\
    \ = String::new();\n    let mut rest = String::new();\n    let mut prefix;\n \
    \   let mut suffix;\n    let mut rest = string;\n\n    while rest.len() > 0 {\n\
    \        longest = longest + &rest[rest.len() - 1];\n        if rest.len() <=\
    \ 1 {\n            break;\n        }\n        rest = &rest[0..(rest.len() - 1)];\n\
    \    }\n\n    longest = longest.trim();\n    let mut suffix = &longest;\n\n  \
    \  while suffix.is_prefix(&longest[..]) {\n        suffix = &suffix[..(suffix.len()\
    \ - 1)];\n    }\n\n    suffix += &longest[..];\n    longest = &suffix;\n\n   \
    \ while !suffix\n        .iter()\n        .all(|&c| c == 'z' || c == 'Z')\n  \
    \  {\n        if suffix\n            .iter()\n            .any(|&c| c == 'z' ||\
    \ c == 'Z')\n        {\n            break;\n        }\n\n        suffix = &suffix[..suffix.len()\
    \ - 1];\n    }\n\n    while suffix\n        .iter()\n        .any(|&c| c == 'z'\
    \ || c == 'Z')\n    {\n        if suffix\n            .iter()\n            .all(|&c|\
    \ c == 'z' || c == 'Z')\n        {\n            break;\n        }\n\n        suffix\
    \ = &suffix[..suffix.len() - 1];\n    }\n\n    longest = &longest[..];\n\n   \
    \ let mut rev_suffix;\n    let mut rev_longest = String::new();\n\n    let mut\
    \ i = suffix.len() - 1;\n\n    while i != 0 {\n        if suffix.len() > 0 {\n\
    \            rev_suffix = suffix.reverse();\n            if suffix[..suffix.len()\
    \ - 1] == rev_suffix {\n                suffix += &rev_suffix[..(rev_suffix.len()\
    \ - 1)];\n                rev_longest = &rev_suffix[..(rev_suffix.len() - 1)];\n\
    \            } else {\n                suffix += &rev_suffix[..(rev_suffix.len()\
    \ - 1)];\n            }\n        } else {\n            break;\n        }\n   \
    \     i--;\n    }\n\n    longest = longest.trim();\n\n    rev_suffix += &longest[..];\n\
    \    longest = &rev_suffix;\n\n    while !longest\n        .iter()\n        .all(|&c|\
    \ c == 'z' || c == 'Z')\n    {\n        if longest\n            .iter()\n    \
    \        .any(|&c| c == 'z' || c == 'Z')\n        {\n            break;\n    \
    \    }\n\n        longest = &longest[..];\n    }\n\n    rev_suffix += &longest[..\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmp8ufpks2o.rs:105:27\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - closing delimiter possibly meant for this\n\
    ...\n105 |     rev_suffix += &longest[..\n    |                           ^ unclosed\
    \ delimiter\n106 | }\n    | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8ufpks2o.rs:19:30\n\
    \   |\n19 |         longest = longest + &rest[rest.len() - 1];\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ufpks2o.rs:23:16\n\
    \   |\n16 |     let mut rest = string;\n   |                    ------ expected\
    \ due to this value\n...\n23 |         rest = &rest[0..(rest.len() - 1)];\n  \
    \ |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |         rest =\
    \ (&rest[0..(rest.len() - 1)]).to_string();\n   |                +           \
    \               +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ufpks2o.rs:26:15\n\
    \   |\n12 |     let mut longest = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n26 |     longest = longest.trim();\n   |  \
    \             ^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |               |\n   |               expected struct `String`, found `&str`\n\
    \nerror[E0599]: no method named `is_prefix` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmp8"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut index = palindrome.len() - 1;\n    loop {\n        if\
    \ index == -1 {\n            palindrome = palindrome.to_string();\n          \
    \  break;\n        }\n        let mut char: u32 = palindrome[&index]; // TODO:\
    \ optimize char\n        let mut reverse: u32 = char;\n        loop {\n      \
    \      let c = palindrome[&(index + 1)..];\n            reverse = c;\n       \
    \     reverse = reverse << 1;\n            reverse = reverse | (c >> 1);\n   \
    \         index -= 1;\n            if index == -1 {\n                break;\n\
    \            }\n        }\n        palindrome = palindrome.to_string();\n    \
    \    palindrome += String::from_u32(&reverse).to_string();\n        index += 1;\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp_cbrnqmn.rs:15:21\n\
    \   |\n15 |         if index == -1 {\n   |                     ^^\n   |      \
    \               |\n   |                     cannot apply unary operator `-`\n\
    \   |                     help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `&usize`\n  --> /tmp/tmp_cbrnqmn.rs:19:29\n\
    \   |\n19 |         let mut char: u32 = palindrome[&index]; // TODO: optimize\
    \ char\n   |                             ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `&usize`\n   |\n   = help: the trait `Index<&usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<&usize>`\n\
    \  --> /tmp/tmp_cbrnqmn.rs:22:21\n   |\n22 |             let c = palindrome[&(index\
    \ + 1)..];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `RangeFrom<&usize>`\n   |\n   = help: the trait `Index<RangeFrom<&usize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmp_cbrnqmn.rs:27:25\n   |\n27 |             if index == -1 {\n  \
    \ |                         ^^\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    shortest_palindrome(string)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shortest_palindrome` in this scope\n\
    \  --> /tmp/tmpelqzt7mf.rs:12:5\n   |\n12 |     shortest_palindrome(string)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut postfix = string.chars().take_while(|&c| !c.is_alphanumeric()).collect::<Vec<_>>();\n\
    \n    // Find longest postfix that is palindrome\n    let mut max_prefix_len =\
    \ 0;\n    let mut prefix_len = string.len();\n    for suffix in postfix.iter().rev()\
    \ {\n        let suffix_len = string.len() - suffix.len();\n        if suffix_len\
    \ > max_prefix_len {\n            max_prefix_len = suffix_len;\n            prefix_len\
    \ = suffix_len;\n        }\n    }\n\n    palindrome.push_str(&string[prefix_len..]);\n\
    \n    // Append the reverse of the prefix\n    let mut reversed_prefix = \"\"\
    ;\n    for suffix in postfix.iter().rev() {\n        reversed_prefix.push_str(&string[suffix]);\n\
    \    }\n\n    palindrome.push_str(&reversed_prefix);\n\n    palindrome\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpnhktioh6.rs:19:48\n   |\n19 |         let suffix_len\
    \ = string.len() - suffix.len();\n   |                                       \
    \         ^^^ method not found in `&char`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpnhktioh6.rs:31:25\n\
    \   |\n31 |         reversed_prefix.push_str(&string[suffix]);\n   |         \
    \                ^^^^^^^^ method not found in `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `&char`\n  --> /tmp/tmpnhktioh6.rs:31:35\n   |\n\
    31 |         reversed_prefix.push_str(&string[suffix]);\n   |                \
    \                   ^^^^^^^^^^^^^^ `String` cannot be indexed by `&char`\n   |\n\
    \   = help: the trait `Index<&char>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (prefix_len,\
    \ suffix_len) = string.len().find_prefix_or_suffix();\n\n    let prefix = &string[..prefix_len];\n\
    \    let suffix = &string[prefix_len..];\n    let suffix = suffix.reverse();\n\
    \n    &string[..prefix_len] + suffix + &string[prefix_len..]\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_prefix_or_suffix` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp7h65_u4r.rs:12:49\n   |\n12 |     let (prefix_len,\
    \ suffix_len) = string.len().find_prefix_or_suffix();\n   |                  \
    \                               ^^^^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `reverse` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp7h65_u4r.rs:16:25\n   |\n16 |     let suffix = suffix.reverse();\n\
    \   |                         ^^^^^^^ method not found in `&str`\n\nerror[E0369]:\
    \ cannot add `_` to `&str`\n  --> /tmp/tmp7h65_u4r.rs:18:27\n   |\n18 |     &string[..prefix_len]\
    \ + suffix + &string[prefix_len..]\n   |     --------------------- ^ ------ _\n\
    \   |     |\n   |     &str\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0369, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut pos =\
    \ 0;\n    let mut new_string = \"\";\n    while pos < string.len() {\n       \
    \ let mut pos = 0;\n        let mut i = 0;\n        while i < string.len() {\n\
    \            let c = &string[i];\n            if c == '_' {\n                i\
    \ = i + 1;\n                continue;\n            }\n            if c != string[pos\
    \ as usize] {\n                break;\n            }\n            i = i + 1;\n\
    \            pos = pos + 1;\n        }\n        if i == string.len() {\n     \
    \       new_string = new_string.to_owned() + &string[pos as usize..];\n      \
    \  }\n    }\n    new_string.to_owned()\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvcv503su.rs:18:22\n\
    \   |\n18 |             let c = &string[i];\n   |                      ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpvcv503su.rs:19:18\n\
    \   |\n19 |             if c == '_' {\n   |                  ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpvcv503su.rs:23:21\n   |\n23 |             if c != string[pos as\
    \ usize] {\n   |                     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcv503su.rs:30:26\n\
    \   |\n13 |     let mut new_string = \"\";\n   |                          -- expected\
    \ due to this value\n...\n30 |             new_string = new_string.to_owned()\
    \ + &string[pos as usize..];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struc"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = string;\n    let mut suffix_length = 1;\n\
    \n    while let Some(prefix) = get_prefix_of_postfix_of_string(&mut palindrome)\
    \ {\n        if palindrome.starts_with(prefix) {\n            palindrome = palindrome[prefix.is_ok()..]\n\
    \                .chars()\n                .fold(\"\".to_string(), |mut x, y|\
    \ {\n                    let x = x.to_string() + y.to_string();\n            \
    \        assert!(x == y);\n                    x;\n                });\n     \
    \       suffix_length += prefix.is_ok();\n        }\n    }\n    string.push_str(&reverse(&palindrome));\n\
    \    string.push_str(&*[0; suffix_length]);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpoms2jxi8.rs:29:27\n   |\n14 |     let mut suffix_length = 1;\n   | \
    \    --------------------- help: consider using `const` instead of `let`: `const\
    \ suffix_length`\n...\n29 |     string.push_str(&*[0; suffix_length]);\n   | \
    \                          ^^^^^^^^^^^^^ non-constant value\n\nerror[E0425]: cannot\
    \ find function `get_prefix_of_postfix_of_string` in this scope\n  --> /tmp/tmpoms2jxi8.rs:16:30\n\
    \   |\n16 |     while let Some(prefix) = get_prefix_of_postfix_of_string(&mut\
    \ palindrome) {\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `reverse` in this\
    \ scope\n  --> /tmp/tmpoms2jxi8.rs:28:22\n   |\n28 |     string.push_str(&reverse(&palindrome));\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoms2jxi8.rs:21:45\n   |\n21 |                     let x\
    \ = x.to_string() + y.to_string();\n   |                                     \
    \        ^^^^^^^^^^^^^\n   |                                             |\n \
    \  |                                             expected `&str`, found struct\
    \ `String`\n   |                                             help: consider borrowing\
    \ here: `&y.to_string()`\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmpoms2jxi8.rs:22:31\n   |\n22 |                     assert!(x ==\
    \ y);\n   |                               ^^ no implementation for `String ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n    let mut reversed = string[..];\n    reversed.reverse();\n\
    \    format!(\"{}{}\", string, &reversed)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmppi_ziua4.rs:16:14\n   |\n16 |     reversed.reverse();\n\
    \   |              ^^^^^^^ method not found in `str`\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmppi_ziua4.rs:15:9\n\
    \   |\n15 |     let mut reversed = string[..];\n   |         ^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n15 |     let mut reversed = &string[..];\n  \
    \ |                        +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut longest = string;\n\n    for i in 0..string.len() {\n\
    \        longest = longest\n            .chars()\n            .enumerate()\n \
    \           .filter(|(_, ichars)| ichars[0] != i)\n            .map(|(_, chars)|\
    \ chars)\n            .collect::<Vec<_>>()\n            .join(\"\");\n       \
    \ reverse = reverse.chars()\n            .enumerate()\n            .filter(|(_,\
    \ ichars)| ichars[0] != i)\n            .map(|(_, chars)| chars)\n           \
    \ .collect::<Vec<_>>()\n            .join(\"\");\n    }\n    reverse += longest;\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `&char`\n  --> /tmp/tmprmaddnj9.rs:19:35\n\
    \   |\n19 |             .filter(|(_, ichars)| ichars[0] != i)\n   |          \
    \                         ^^^^^^^^^\n\nerror[E0599]: the method `join` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmprmaddnj9.rs:22:14\n\
    \   |\n22 |             .join(\"\");\n   |              ^^^^ method cannot be\
    \ called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error[E0608]: cannot index into a value of type `&char`\n  --> /tmp/tmprmaddnj9.rs:25:35\n\
    \   |\n25 |             .filter(|(_, ichars)| ichars[0] != i)\n   |          \
    \                         ^^^^^^^^^\n\nerror[E0599]: the method `join` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmprmaddnj9.rs:28:14\n\
    \   |\n28 |             .join(\"\");\n   |              ^^^^ method cannot be\
    \ called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprmaddnj9.rs:30:16\n   |\n30 |  \
    \   reverse += longest;\n   |                ^^^^^^^\n   |                |\n\
    \   |                expected `&str`, found struct `String`\n   |            \
    \    help: consider borrowing here: `&longest`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let max_len =\
    \ string.len();\n    let mut reverse_string = string;\n    loop {\n        if\
    \ max_len == 0 || max_len == 1 {\n            return reverse_string;\n       \
    \ }\n        let mut i = 0;\n        let mut j = max_len - 1;\n        while i\
    \ < j {\n            if string[i] != string[j] {\n                break;\n   \
    \         }\n            i += 1;\n            j -= 1;\n        }\n        let\
    \ mut string_to_prepend = reverse_string[..j + 1];\n        reverse_string = reverse_string[j..i].to_string();\n\
    \        string_to_prepend = string_to_prepend.reverse().to_string();\n      \
    \  reverse_string = string_to_prepend.concat(reverse_string);\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx2vukibw.rs:21:16\n\
    \   |\n21 |             if string[i] != string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx2vukibw.rs:21:29\n   |\n21 |             if string[i] != string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpx2vukibw.rs:27:13\n   |\n27 |         let\
    \ mut string_to_prepend = reverse_string[..j + 1];\n   |             ^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n27 |         let mut string_to_prepend = &reverse_string[..j\
    \ + 1];\n   |                                     +\n\nerror[E0599]: no method\
    \ named `reverse` found for type `str` i"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let max_len = string.chars().max_by_key(|c| c).unwrap().len_utf8();\n\
    \    let mut suffix = string;\n    suffix.set_len(max_len);\n\n    let mut reverse_suffix;\n\
    \    let mut last_char = None;\n    let mut i = 0;\n    while i < suffix.len()\
    \ {\n        let c = suffix.get_u8(i);\n        if c != last_char {\n        \
    \    reverse_suffix = suffix.clone();\n            last_char = c;\n        }\n\
    \        reverse_suffix.put_char(c, i);\n        i += 1;\n    }\n    suffix.extend_from_slice(&reverse_suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `set_len` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjh9i5c2k.rs:15:12\n   |\n15 |     suffix.set_len(max_len);\n\
    \   |            ^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `get_u8` found for struct `String` in the current scope\n  --> /tmp/tmpjh9i5c2k.rs:21:24\n\
    \   |\n21 |         let c = suffix.get_u8(i);\n   |                        ^^^^^^\
    \ help: there is an associated function with a similar name: `get`\n\nerror[E0599]:\
    \ no method named `put_char` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpjh9i5c2k.rs:26:24\n   |\n26 |         reverse_suffix.put_char(c,\
    \ i);\n   |                        ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `extend_from_slice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjh9i5c2k.rs:29:12\n   |\n29 |     suffix.extend_from_slice(&reverse_suffix);\n\
    \   |            ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    if len == 0 {\n        return string;\n    }\n\n    let mut suffix = \"_\"\
    ;\n    let mut prefix = \"\";\n    let mut i = 0;\n\n    // Find longest prefix\
    \ that is a palindrome\n    while i < len {\n        let current = &string[i];\n\
    \        let next = &string[i + len];\n\n        let prefix_next = prefix + (*current\
    \ as char).to_string();\n        let suffix = prefix_next.chars().rev().collect::<String>();\n\
    \        suffix\n            .insert((*next as char).to_string(), 1)\n       \
    \     .insert(0, *current as char);\n        i += 1;\n        prefix = suffix;\n\
    \    }\n    prefix + suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzwabbq88.rs:23:24\n\
    \   |\n23 |         let current = &string[i];\n   |                        ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzwabbq88.rs:24:21\n   |\n24 |         let next = &string[i + len];\n\
    \   |                     ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `String` to `&str`\n  --> /tmp/tmpzwabbq88.rs:26:34\n\
    \   |\n26 |         let prefix_next = prefix + (*current as char).to_string();\n\
    \   |                           ------ ^ ------------------------------ String\n\
    \   |                           |      |\n   |                           |   \
    \   `+` cannot be used to concatenate a `&str` with a `String`\n   |         \
    \                  &str\n   |\nhelp: create an owned `String` on the left and\
    \ add a borrow on the right\n   |\n26 |         let prefix_next = prefix.to_owned()\
    \ + &(*current as char).to_string();\n   |                                 +++++++++++\
    \   +\n\nerror[E0369]: cannot add `&str` to `&str`"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed_string:\
    \ String = string.rev();\n    let length_of_string: usize = string.len() - 1;\n\
    \    let prefix_length: usize = (reversed_string\n        .chars()\n        .take_while(|&c|\
    \ c != 'a')\n        .count()\n    ) / 2;\n    let suffix_length: usize = (reversed_string\n\
    \        .chars()\n        .take_while(|&c| c != 'a')\n        .count()\n    )\
    \ / 2;\n    if length_of_string < prefix_length + suffix_length {\n        panic!(\"\
    The length of the supplied string is less than the length of a palindrome.\");\n\
    \    }\n    let new_string = &string[prefix_length..] + &reversed_string[..suffix_length];\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp7uy175gm.rs:12:42\n\
    \    |\n12  |       let reversed_string: String = string.rev();\n    |       \
    \                                     ^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror[E0369]: cannot add `&str` to `&str`\n\
    \  --> /tmp/tmp7uy175gm.rs:27:47\n   |\n27 |     let new_string = &string[prefix_length..]\
    \ + &reversed_string[..suffix_length];\n   |                      ------------------------\
    \ ^ --------------------------------- &str\n   |                      |      \
    \                  |\n   |                      |                        `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                      &str\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n27 -     let new_string\
    \ = &string[prefix_length..] + &reversed_string[..suffix_length];\n27 +     let\
    \ new_string = string[prefix_length..] + &reversed_string[..suffix_length];\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Longest palindromic\
    \ suffix is just the reverse of the string that ends before the suffix\n    let\
    \ rev_suffix = &string[..string.len() - 1];\n    let mut suffix = [0u8; rev_suffix.len()];\n\
    \    rev_suffix.encode_utf8(&mut suffix);\n\n    // Find longest palindromic substring\
    \ that begins with suffix\n    let suffix_len = suffix.len();\n    let mut sub\
    \ = suffix.clone();\n    let mut len = 0;\n\n    // The longest palindromic substrings\
    \ that start with the suffix\n    let mut best_palindromic_substrings = Vec::new();\n\
    \n    // The longest palindromic suffix that ends with the suffix\n    let mut\
    \ best_palindromic_suffix = String::new();\n\n    // Keep going until we have\
    \ a palindromic suffix\n    while *sub == *suffix[..suffix_len] {\n        //\
    \ Find the longest palindromic substring that ends with the suffix\n        while\
    \ !suffix_len.is_zero() {\n            // Find the longest palindromic substring\
    \ that begins with the suffix\n            while !suffix.is_zero() {\n       \
    \         // Copy the substring up to and including suffix\n                let\
    \ palindromic_substring = &sub[..suffix[..suffix_len]];\n                best_palindromic_substrings.push(palindromic_substring);\n\
    \n                // Copy the substring from suffix up to suffix\n           \
    \     let palindromic_suffix = &suffix[..suffix_len];\n                best_palindromic_suffix\
    \ = best_palindromic_suffix.append(palindromic_suffix);\n\n                //\
    \ Skip the part of the prefix that precedes the suffix\n                sub =\
    \ &sub[..suffix[..suffix_len]];\n                suffix_len = suffix.len();\n\n\
    \                // If we are at the end of the string, return it\n          \
    \      if *suffix == 0 {\n                    return best_palindromic_suffix;\n\
    \                }\n            }\n\n            // Copy the longest palindromic\
    \ suffix that ends with the suffix\n            let palindromic_suffix = &suffix[..suffix_len];\n\
    \            best_palindromic_suffix = best_palindromic_suffix.append(palindromic_suffix);\n\
    \n            // Increment the suffix length and continue\n            suffix_len\
    \ += 1;\n        }\n    }\n\n    \"\"\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp3tczya6e.rs:14:28\n   |\n13 |     let rev_suffix = &string[..string.len()\
    \ - 1];\n   |     -------------- help: consider using `const` instead of `let`:\
    \ `const rev_suffix`\n14 |     let mut suffix = [0u8; rev_suffix.len()];\n   |\
    \                            ^^^^^^^^^^ non-constant value\n\nerror[E0599]: no\
    \ method named `encode_utf8` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp3tczya6e.rs:15:16\n   |\n15 |     rev_suffix.encode_utf8(&mut suffix);\n\
    \   |                ^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `encode_utf16`\n\nerror[E0599]: no method named `is_zero` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmp3tczya6e.rs:31:27\n   |\n\
    31 |         while !suffix_len.is_zero() {\n   |                           ^^^^^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3tczya6e.rs:40:67\n\
    \   |\n40 |                 best_palindromic_suffix = best_palindromic_suffix.append(palindromic_suffix);\n\
    \   |                                                                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3tczya6e.rs:54:63\n\
    \   |\n54 |             best_palindromic_suffix = best_palindromic_suffix.append(palindromic_suffix);\n\
    \   |                                                               ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3tczya6e.rs:61:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    61 |     \"\"\n   |     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0435,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // TODO: This\
    \ is O(n*log(n)) algorithm.\n    // It could be done in O(n) by precomputing and\
    \ sorting all the possible palindromes.\n    let mut s = string;\n    let mut\
    \ is_palindrome = true;\n\n    while !s.is_empty() {\n        let suffix = s.to_lowercase().chars().skip(s.len()\
    \ - 1).collect::<String>();\n        let mut prefix_suffix = 0;\n        for c\
    \ in suffix.chars() {\n            if !s.starts_with(&c.to_string()) {\n     \
    \           prefix_suffix += 1;\n            }\n        }\n\n        s = s.chars().skip(s.len()\
    \ - prefix_suffix.to_string().chars().count()).collect::<String>();\n        if\
    \ s.len() != prefix_suffix.to_string().chars().count() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n\n    if is_palindrome {\n \
    \       return s\n    }\n    else {\n        match s.to_lowercase().rposition(|c|\
    \ c.is_lowercase()) {\n            Some(index) => {\n                let mut suffix\
    \ = 'a';\n                for (i, &c) in s.chars().enumerate() {\n           \
    \         if i < (index - 1) {\n                        suffix += c.to_string().to_lowercase()\n\
    \                    }\n                }\n                return s.chars().skip(index).collect::<String>().append(&suffix);\n\
    \            }\n            None => return s,\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpbzwdtmz4.rs:37:32\n   |\n37 |         match\
    \ s.to_lowercase().rposition(|c| c.is_lowercase()) {\n   |                   \
    \             ^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbzwdtmz4.rs:40:25\n   |\n40 |                 for (i, &c)\
    \ in s.chars().enumerate() {\n   |                         ^^     ---------------------\
    \ this expression has type `Option<(usize, char)>`\n   |                     \
    \    |\n   |                         expected `char`, found reference\n   |  \
    \                       help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbzwdtmz4.rs:45:66\n   |\n45 |                 return s.chars().skip(index).collect::<String>().append(&suffix);\n\
    \   |                                                                  ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string.split_at_iter(|c|\
    \ c.is_uppercase())\n        .map(|c| c.to_ascii_lowercase())\n        .unwrap_or(string)\n\
    \        .chars()\n        .chain(string.chars())\n        .enumerate()\n    \
    \    .flat_map(|(_, start)| {\n            let last = start;\n            loop\
    \ {\n                let i = start % 2 + 1;\n                let next = start\
    \ + i;\n                if next < string.len() {\n                    if string[next]\
    \ != string[last] {\n                        last = next;\n                  \
    \  } else {\n                        break;\n                    }\n         \
    \       }\n                start = next;\n            }\n            (&string[..last],\
    \ start)\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_at_iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpn85mjvh0.rs:12:12\n   |\n12 |     string.split_at_iter(|c|\
    \ c.is_uppercase())\n   |            ^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpn85mjvh0.rs:24:40\n   |\n24 |  \
    \                   if string[next] != string[last] {\n   |                  \
    \                      ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn85mjvh0.rs:24:24\n   |\n24 |                     if string[next]\
    \ != string[last] {\n   |                        ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.len()\
    \ <= 1 {\n        return string;\n    }\n    let mut suffix_start = 0;\n    let\
    \ mut suffix_end = string.len() - 1;\n    while suffix_end > suffix_start {\n\
    \        if suffix(&string[suffix_start .. suffix_end] == &string[suffix_end ..\
    \ suffix_start]) {\n            suffix_end -= 1;\n        } else {\n         \
    \   suffix_start += 1;\n            suffix_end -= 1;\n        }\n    }\n    let\
    \ mut prefix_start = suffix_start - 1;\n    while prefix_start >= 0 && prefix_end\
    \ < string.len() && string[prefix_start] == string[prefix_end] {\n        prefix_start\
    \ -= 1;\n        prefix_end += 1;\n    }\n    prefix_start = prefix_start == -1\
    \ ? 0 : prefix_start + 1;\n    let mut result_string = string;\n    result_string.push_front(&string[prefix_start\
    \ .. suffix_end]);\n    result_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `0`\n\
    \  --> /tmp/tmpvei2q3pn.rs:30:41\n   |\n30 |     prefix_start = prefix_start ==\
    \ -1 ? 0 : prefix_start + 1;\n   |                                         ^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]: cannot find function\
    \ `suffix` in this scope\n  --> /tmp/tmpvei2q3pn.rs:18:12\n   |\n18 |        \
    \ if suffix(&string[suffix_start .. suffix_end] == &string[suffix_end .. suffix_start])\
    \ {\n   |            ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `prefix_end` in this scope\n  --> /tmp/tmpvei2q3pn.rs:26:32\n   |\n26\
    \ |     while prefix_start >= 0 && prefix_end < string.len() && string[prefix_start]\
    \ == string[prefix_end] {\n   |                                ^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `suffix_end`\n\nerror[E0425]: cannot\
    \ find value `prefix_end` in this scope\n  --> /tmp/tmpvei2q3pn.rs:26:92\n   |\n\
    26 |     while prefix_start >= 0 && prefix_end < string.len() && string[prefix_start]\
    \ == string[prefix_end] {\n   |                                              \
    \                                              ^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `suffix_end`\n\nerror[E0425]: cannot find value\
    \ `prefix_end` in this scope\n  --> /tmp/tmpvei2q3pn.rs:28:9\n   |\n28 |     \
    \    prefix_end += 1;\n   |         ^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `suffix_end`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpvei2q3pn.rs:26:61\n   |\n26 |     while prefix_start\
    \ >= 0 && prefix_end < string.len() && string[prefix_start] == string[prefix_end]\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = string;\n    let mut prefix = string;\n    let mut reverse = string;\n\n \
    \   // reverse the suffix while keeping the prefix\n    while !suffix.is_empty()\
    \ {\n        reverse.push(*suffix);\n        suffix = suffix.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).collect();\n    }\n\n    // reverse the prefix while\
    \ keeping the suffix\n    while !prefix.is_empty() {\n        reverse.push(*prefix);\n\
    \        prefix = prefix.chars().skip_while(|c| !c.is_ascii_lowercase()).collect();\n\
    \    }\n\n    reverse.push(reverse.chars().collect::<String>().reverse().collect());\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpws23i9dd.rs:18:22\n   |\n\
    18 |         reverse.push(*suffix);\n   |                      ^^^^^^^ expected\
    \ `char`, found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpws23i9dd.rs:24:22\n\
    \   |\n24 |         reverse.push(*prefix);\n   |                      ^^^^^^^\
    \ expected `char`, found `str`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpws23i9dd.rs:28:54\n\
    \   |\n28 |     reverse.push(reverse.chars().collect::<String>().reverse().collect());\n\
    \   |                                                      ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut palindrome_len = string.length();\n    if palindrome_len\
    \ % 2 == 1 { // odd length\n        palindrome += \"/\";\n        palindrome_len\
    \ += 1;\n    }\n    let mut palindrome_len_half = palindrome_len / 2;\n    for\
    \ _ in 0..palindrome_len_half {\n        let first_character = palindrome.chars().nth(0).unwrap();\n\
    \        let last_character = palindrome.chars().nth(palindrome_len - 1u).unwrap();\n\
    \        palindrome = palindrome.chars()\n            .chain(first_character.rev())\n\
    \            .chain(last_character.rev())\n            .collect();\n    }\n  \
    \  palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpn622mzsp.rs:21:70\n\
    \   |\n21 |         let last_character = palindrome.chars().nth(palindrome_len\
    \ - 1u).unwrap();\n   |                                                      \
    \                ^^ invalid suffix `u`\n   |\n   = help: the suffix must be one\
    \ of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpn622mzsp.rs:13:37\n\
    \   |\n13 |     let mut palindrome_len = string.length();\n   |              \
    \                       ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0599]: `char` is not an iterator\n  --> /tmp/tmpn622mzsp.rs:23:36\n\
    \   |\n23 |             .chain(first_character.rev())\n   |                  \
    \                  ^^^ `char` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `char: Iterator`\n           which\
    \ is required by `&mut char: Iterator`\n\nerror[E0599]: `char` is not an iterator\n\
    \  --> /tmp/tmpn622mzsp.rs:24:35\n   |\n24 |             .chain(last_character.rev())\n\
    \   |                                   ^^^ `char` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string_to_check\
    \ = string;\n    let mut suffix_to_reverse = \"\";\n\n    while string_to_check.is_palindrom()\
    \ {\n        let index = string_to_check.rfind('a');\n        suffix_to_reverse\
    \ += string_to_check.chars().skip(index).collect::<String>();\n\n        string_to_check\
    \ = string_to_check.to_owned() + suffix_to_reverse.to_owned();\n    }\n\n    string_to_check\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_palindrom` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcputet5p.rs:15:27\n   |\n15 |     while\
    \ string_to_check.is_palindrom() {\n   |                           ^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcputet5p.rs:17:59\n\
    \   |\n17 |         suffix_to_reverse += string_to_check.chars().skip(index).collect::<String>();\n\
    \   |                                                           ^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpcputet5p.rs:17:9\n   |\n\
    17 |         suffix_to_reverse += string_to_check.chars().skip(index).collect::<String>();\n\
    \   |         -----------------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |                 |\n   |         |                 `+` cannot be\
    \ used to concatenate a `&str` with a `String`\n   |         cannot use `+=` on\
    \ type `&str`\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcputet5p.rs:19:56\n\
    \   |\n19 |         string_to_check = string_to_check.to_owned() + suffix_to_reverse.to_owned();\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                        |\n   |         \
    \                                               expected `&str`, found struct\
    \ `String`\n   |                                                        help:\
    \ consider borrowing here: `&suffix_to_reverse.to_owned()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut last_seen = String::new();\n    let mut last_index =\
    \ 0;\n    while last_seen != palindrome {\n        last_seen = palindrome[last_index..].to_string();\n\
    \        last_index = last_seen.rfind('a').unwrap() + 1;\n    }\n    palindrome[last_index..].to_owned()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpd4n9bmub.rs:17:43\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut start\
    \ = String::from(\"\");\n    let mut prefix = String::from(\"\");\n    let mut\
    \ suffix = String::from(\"\");\n    for c in string.chars() {\n        start.push_str(&start[start.len()..]);\n\
    \        prefix.push_str(&prefix[start.len()..]);\n        if c == 'a' {\n   \
    \         prefix.push_str(&prefix[start.len()..]);\n            start.push_str(&start[start.len()..]);\n\
    \        }\n        if c != ' ' {\n            suffix.push_str(&suffix[prefix.len()..]);\n\
    \            suffix.push_str(&suffix[prefix.len()..]);\n        } else {\n   \
    \         suffix.push_str(&suffix[start.len()..]);\n            suffix.push_str(&suffix[start.len()..]);\n\
    \        }\n    }\n    if start.is_empty() {\n        return String::from(\"\"\
    );\n    }\n    let mut start = start[start.len()..].chars();\n    let mut prefix\
    \ = prefix[prefix.len()..].chars();\n    let mut suffix = suffix[suffix.len()..].chars();\n\
    \    while !start.is_empty() && prefix.is_empty() && suffix.is_empty() {\n   \
    \     if start.len() == 1 {\n            prefix.push(start.pop());\n         \
    \   prefix.push(suffix.pop());\n        } else {\n            if start.len() <=\
    \ prefix.len() {\n                prefix.push(start.pop());\n            } else\
    \ {\n                prefix.push(suffix.pop());\n            }\n        }\n  \
    \  }\n    suffix.reverse();\n    suffix.push_str(&prefix[start.len()..]);\n  \
    \  start.reverse();\n    start.push_str(&suffix[prefix.len()..]);\n    start.push_str(&prefix[start.len()..]);\n\
    \    start\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpu99d6cvd.rs:36:18\n   |\n36 |     while !start.is_empty()\
    \ && prefix.is_empty() && suffix.is_empty() {\n   |                  ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `is_empty`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpu99d6cvd.rs:36:39\n\
    \   |\n36 |     while !start.is_empty() && prefix.is_empty() && suffix.is_empty()\
    \ {\n   |                                       ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `is_empty` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpu99d6cvd.rs:36:60\n   |\n36 |     while !start.is_empty()\
    \ && prefix.is_empty() && suffix.is_empty() {\n   |                          \
    \                                  ^^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0599]: no method named `len` found for struct `Chars` in the current scope\n\
    \  --> /tmp/tmpu99d6cvd.rs:37:18\n   |\n37 |         if start.len() == 1 {\n \
    \  |                  ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `push` found for struct `Chars` in the current scope\n  --> /tmp/tmpu99d6cvd.rs:38:20\n\
    \   |\n38 |             prefix.push(start.pop());\n   |                    ^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `pop` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpu99d6cvd.rs:38:31\n \
    \  |\n38 |             prefix.push(start.pop());\n   |                       \
    \        ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `push` found for struct `Chars` in the current scope\n  --> /tmp/tmpu99d6cvd.rs:39:20\n\
    \   |\n39 |             prefix.push(suffix.pop());\n   |                    ^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `pop` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpu99d6cvd.rs:39:32\n \
    \  |\n39 |             prefix.push(suffix.pop());\n   |                      \
    \          ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Ch"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse_substring\
    \ = String::from(string);\n    reverse_substring.reverse();\n    let prefix_substring\
    \ = &string[..reverse_substring.len()];\n    let prefix_reversed = &reverse_substring[..prefix_substring.len()];\n\
    \    reverse_substring.append(prefix_reversed);\n    reverse_substring.append(&string[prefix_substring.len()..]);\n\
    \    reverse_substring\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdhu2z9x1.rs:13:23\n   |\n13 |     reverse_substring.reverse();\n\
    \   |                       ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpdhu2z9x1.rs:16:23\n   |\n\
    16 |     reverse_substring.append(prefix_reversed);\n   |                    \
    \   ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdhu2z9x1.rs:17:23\n\
    \   |\n17 |     reverse_substring.append(&string[prefix_substring.len()..]);\n\
    \   |                       ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut max_length\
    \ = 0;\n    let mut suffix = 0;\n    let mut start = string.len();\n    while\
    \ start > 0 {\n        max_length = max_length\n            .max(max_length)\n\
    \            .max(string[start - 1]);\n        start -= 1;\n    }\n    while max_length\
    \ > 0 {\n        start += 1;\n        suffix = 0;\n        while start < string.len()\
    \ {\n            let current = string[start];\n            suffix = suffix\n \
    \               .max(suffix)\n                .max(current);\n            start\
    \ += 1;\n        }\n        string = &string[..suffix];\n        max_length -=\
    \ 1;\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_iaw4zao.rs:18:18\n\
    \   |\n18 |             .max(string[start - 1]);\n   |                  ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_iaw4zao.rs:25:27\n   |\n25 |             let current = string[start];\n\
    \   |                           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_iaw4zao.rs:31:18\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \               ------ expected due to this parameter type\n...\n31 |        \
    \ string = &string[..suffix];\n   |                  ^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n31 |         string = (&string[..suffix]).to_string();\n   |           \
    \       +                 +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    let mut max_len = string\n\
    \        .chars()\n        .filter_map(|c| c.to_ascii_lowercase())\n        .filter(|c|\
    \ c.is_alphanumeric())\n        .max();\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    while\
    \ max_len >= 0 {\n        let suffix = string.chars().take(max_len).collect::<String>();\n\
    \        let reversed_suffix = suffix.chars().collect::<String>().reverse();\n\
    \        let palindromic = &suffix[..];\n        if palindromic != &reversed_suffix\
    \ {\n            max_len -= 1;\n        } else {\n            string.insert(0,\
    \ palindromic);\n            break;\n        }\n    }\n    return string;\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_n9khtn6.rs:15:25\n   |\n\
    15 |         .filter_map(|c| c.to_ascii_lowercase())\n   |                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<_>`\n              found type `char`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n15 |         .filter_map(|c| Some(c.to_ascii_lowercase()))\n\
    \   |                         +++++                      +\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp_n9khtn6.rs:21:66\n   |\n21 |         let reversed_suffix = suffix.chars().collect::<String>().reverse();\n\
    \   |                                                                  ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_n9khtn6.rs:26:30\n   |\n26 |             string.insert(0,\
    \ palindromic);\n   |                              ^^^^^^^^^^^ expected `char`,\
    \ found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find longest\
    \ postfix that is a palindrome\n    let mut longest = 0;\n    let mut longest_suffix\
    \ = 0;\n    let mut longest_prefix_length = 0;\n    let mut current_suffix = 0;\n\
    \    let mut current_string: String = string;\n    while current_string.len()\
    \ > 0 {\n        let current = current_string.len() - 1;\n        let suffix =\
    \ &current_string[current ..].to_lowercase();\n        if suffix.len() > 0 {\n\
    \            if longest < suffix {\n                longest = suffix.len();\n\
    \            }\n            if longest_suffix < suffix {\n                longest_suffix\
    \ = suffix.len();\n            }\n            if longest_prefix_length < longest\
    \ {\n                longest_prefix_length = longest;\n            }\n       \
    \     current_suffix = suffix;\n            current_string = &current_string[0\
    \ .. (longest - 1)].to_lowercase();\n        }\n    }\n\n    // If longest suffix\
    \ is a palindrome\n    if longest_suffix == longest {\n        // Reverse the\
    \ longest prefix that comes before longest suffix.\n        let mut reversed_prefix:\
    \ String = current_string;\n        while reversed_prefix.len() > 0 {\n      \
    \      let current = reversed_prefix.len() - 1;\n            let prefix = &reversed_prefix[current\
    \ ..].to_lowercase();\n            if longest_prefix_length < prefix {\n     \
    \           longest_prefix_length = prefix;\n            }\n            reversed_prefix\
    \ = &reversed_prefix[0 .. (longest_prefix_length - 1)].to_lowercase();\n     \
    \   }\n        // Append longest suffix to beginning of the reversed prefix.\n\
    \        let mut result = current_string;\n        result = &result[0..(longest\
    \ - 1)].to_lowercase() + &longest_suffix;\n        if longest_prefix_length ==\
    \ longest {\n            // No need for append if longest prefix is longest\n\
    \            result = current_string;\n        }\n        return result;\n   \
    \ }\n    return string;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `{integer}` with `&String`\n  --> /tmp/tmprbfsgyjp.rs:22:24\n\
    \   |\n22 |             if longest < suffix {\n   |                        ^ no\
    \ implementation for `{integer} < &String` and `{integer} > &String`\n   |\n \
    \  = help: the trait `PartialOrd<&String>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0277]: can't compare `{integer}` with `&String`\n  -->\
    \ /tmp/tmprbfsgyjp.rs:25:31\n   |\n25 |             if longest_suffix < suffix\
    \ {\n   |                               ^ no implementation for `{integer} < &String`\
    \ and `{integer} > &String`\n   |\n   = help: the trait `PartialOrd<&String>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprbfsgyjp.rs:31:30\n   |\n16 |     let mut current_suffix = 0;\n   |\
    \                              - expected due to this value\n...\n31 |       \
    \      current_suffix = suffix;\n   |                              ^^^^^^ expected\
    \ integer, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbfsgyjp.rs:32:30\n\
    \   |\n17 |     let mut current_string: String = string;\n   |               \
    \              ------ expected due to this type\n...\n32 |             current_string\
    \ = &current_string[0 .. (longest - 1)].to_lowercase();\n   |                \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n\
    32 -             current_string = &current_string[0 .. (longest - 1)].to_lowercase();\n\
    32 +             current_string = current_string[0 .. (longest - 1)].to_lowercase();\n\
    \   | \n\nerror[E0308]: mismatch"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string;\n    let mut suffix;\n    let mut rev = 0;\n\n    while !prefix.is_empty()\
    \ {\n        suffix = prefix.rev();\n        if suffix > rev {\n            rev\
    \ = suffix;\n            prefix = prefix.chars().next().unwrap().to_string();\n\
    \        }\n    }\n\n    format!(\"{}{}\", string, rev).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp7_lyun9l.rs:17:25\n\
    \    |\n17  |           suffix = prefix.rev();\n    |                        \
    \   ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  \
    \  |\n    = note: the following trait bounds were not satisfied:\n           \
    \ `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string;\n    let mut suffix = string;\n    let mut suffix_size = prefix.len();\n\
    \    let mut i = 0;\n    while i < suffix_size {\n        let c = suffix[i];\n\
    \        let index = i;\n        while i + 1 < suffix_size && suffix[i + 1] ==\
    \ c {\n            i += 1;\n        }\n        if index == i {\n            break;\n\
    \        }\n        suffix = suffix.replace(index.., index - i..);\n        i\
    \ += 1;\n    }\n    prefix = prefix.reverse();\n    prefix.push((&suffix[..suffix_size]).join(\"\
    \"));\n    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf797atdb.rs:17:17\n\
    \   |\n17 |         let c = suffix[i];\n   |                 ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf797atdb.rs:19:38\n   |\n19 |         while i + 1 < suffix_size\
    \ && suffix[i + 1] == c {\n   |                                      ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `RangeFrom<usize>`\n\
    \   --> /tmp/tmpf797atdb.rs:25:25\n    |\n25  |         suffix = suffix.replace(index..,\
    \ index - i..);\n    |                         ^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `RangeFrom<usize>`\n    |\n    = help: the trait `FnMut<(char,)>`\
    \ is not implemented for `RangeFrom<usize>`\n    = help: the following other types\
    \ implement trait `Pattern<'a>`:\n              &'b String\n              &'b\
    \ [char; N]\n              &'b [char]\n              &'b str\n              &'c\
    \ &'b str\n              [char; N]\n              char\n              pattern::MultiCharEqPattern<"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev = string.rev();\n\
    \    let mid = string.len() / 2;\n    string.append(&rev[..mid]);\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp290wgp3j.rs:12:22\n\
    \    |\n12  |       let rev = string.rev();\n    |                        ^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp290wgp3j.rs:14:12\n   |\n14 |     string.append(&rev[..mid]);\n\
    \   |            ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut length\
    \ = 0;\n    let mut index = 0;\n    let mut string_to_prepend = string;\n\n  \
    \  // Check if we still need to search the string.\n    while !string_to_prepend.starts_with(string_to_prepend.chars().skip_while(|c|\
    \ *c != 'a')) {\n        length += 1;\n        index += 1;\n        if length\
    \ == string_to_prepend.len() {\n            break;\n        }\n        string_to_prepend\
    \ = string_to_prepend.chars().skip_while(|c| *c != 'a').collect();\n    }\n\n\
    \    // Search for the longest postfix palindrome in the string.\n    let mut\
    \ prefix_length = 0;\n    let mut prefix_index = 0;\n    while prefix_index <\
    \ string_to_prepend.len() {\n        let suffix_length = string_to_prepend[prefix_index..].chars().count();\n\
    \        let suffix_index = string_to_prepend.len() - suffix_length - 1;\n   \
    \     let suffix_to_prepend = string_to_prepend[prefix_index..suffix_index];\n\
    \        prefix_length += suffix_length;\n        prefix_index += suffix_index;\n\
    \        if prefix_length == string_to_prepend.len() {\n            break;\n \
    \       }\n        string_to_prepend = suffix_to_prepend.chars().skip_while(|c|\
    \ *c != 'a').collect();\n    }\n\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_index = 0;\n    while suffix_index < string_to_prepend.len() {\n    \
    \    let prefix_length = string_to_prepend[suffix_index..].chars().count();\n\
    \        let prefix_index = string_to_prepend.len() - prefix_length - 1;\n   \
    \     let prefix_to_prepend = string_to_prepend[suffix_index..prefix_index];\n\
    \        suffix_length += prefix_length;\n        suffix_index += prefix_index;\n\
    \        if suffix_length == string_to_prepend.len() {\n            break;\n \
    \       }\n        string_to_prepend = prefix_to_prepend.chars().skip_while(|c|\
    \ *c != 'a').collect();\n    }\n\n    // Prepend reverse of the prefix to the\
    \ suffix.\n    String::from(string_to_prepend[suffix_index..suffix_index].chars()\n\
    \        .skip_while(|c| *c != 'a')\n        .collect::<String>().reverse().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpdsn4imqu.rs:17:79: 17:92]>`\n    --> /tmp/tmpdsn4imqu.rs:17:42\n\
    \     |\n17   |     while !string_to_prepend.starts_with(string_to_prepend.chars().skip_while(|c|\
    \ *c != 'a')) {\n     |                              ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `SkipWhile<Chars<'_>, [closure@/tmp/tmpdsn4imqu.rs:17:79:\
    \ 17:92]>`\n     |                              |\n     |                    \
    \          required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `FnMut<(char,)>` is not implemented for `SkipWhile<Chars<'_>, [closure@/tmp/tmpdsn4imqu.rs:17:79:\
    \ 17:92]>`\n     = help: the following other types implement trait `Pattern<'a>`:\n\
    \               &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpdsn4imqu.rs:17:79: 17:92]>`\nnote: required by a bound in `core::str::<impl\
    \ str>::starts_with`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpdsn4imqu.rs:32:13\n   |\n32 |  \
    \       let suffix_to_prepend = string_to_prepend[prefix_index..suffix_index];\n\
    \   |             ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n32 |\
    \         let suffix_to_prepend = &string_to_prepend[prefix_index..suffix_index];\n\
    \   |                                 +\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmpdsn4imqu.rs:46:13\n\
    \   |\n46 |         let prefix_to_prepend = string_to_prepend["
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // TODO: Find\
    \ a way to implement this function without using recursion\n    // TODO: Avoid\
    \ copying the string\n    string.chars().filter(|c| !c.is_whitespace()).collect::<String>().reverse()\
    \ + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp2_avxbjt.rs:14:71\n   |\n14 |     string.chars().filter(|c|\
    \ !c.is_whitespace()).collect::<String>().reverse() + &string\n   |          \
    \                                                             ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find longest\
    \ postfix of supplied string that is a palindrome\n    let mut postfix = string;\n\
    \    let mut length = 0;\n\n    while postfix.len() > 0 {\n        if !postfix.starts_with(&postfix[length..])\
    \ {\n            length = 0;\n            break;\n        }\n        length +=\
    \ 1;\n        postfix = &postfix[..];\n    }\n\n    // Add reverse of the postfix\
    \ to the end of supplied string.\n    // If this palindrome begins with a string\
    \ - append it to it.\n    string[..length].reverse()\n        + &string[length..].iter()\n\
    \            .chain(vec![&postfix[length..].reverse()].iter())\n            .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp92reu6os.rs:22:19\n   |\n\
    13 |     let mut postfix = string;\n   |                       ------ expected\
    \ due to this value\n...\n22 |         postfix = &postfix[..];\n   |         \
    \          ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n22 |         postfix = (&postfix[..]).to_string();\n\
    \   |                   +            +++++++++++++\n\nerror[E0599]: no method\
    \ named `reverse` found for type `str` in the current scope\n  --> /tmp/tmp92reu6os.rs:27:22\n\
    \   |\n27 |     string[..length].reverse()\n   |                      ^^^^^^^\
    \ method not found in `str`\n\nerror[E0599]: no method named `iter` found for\
    \ type `str` in the current scope\n  --> /tmp/tmp92reu6os.rs:28:29\n   |\n28 |\
    \         + &string[length..].iter()\n   |                             ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `reverse` found for type\
    \ `str` in the current scope\n  --> /tmp/tmp92reu6os.rs:29:44\n   |\n29 |    \
    \         .chain(vec![&postfix[length..].reverse()].iter())\n   |            \
    \                                ^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut len =\
    \ string.len();\n    let mut palindrome = string;\n    let mut suffix_index =\
    \ 0;\n\n    while suffix_index < len {\n        let mut prefix_index = 0;\n  \
    \      let mut suffix_str = \"\";\n\n        while prefix_index < len {\n    \
    \        suffix_str += &string[suffix_index..][prefix_index..][prefix_index..];\n\
    \            prefix_index += 1;\n        }\n\n        let mut palindrome_slice\
    \ = palindrome.chars().take(suffix_str.len());\n        palindrome_slice = palindrome_slice.rev();\n\
    \n        if palindrome_slice == palindrome_slice {\n            palindrome +=\
    \ &string[suffix_index..][prefix_index..];\n            suffix_index += 1;\n \
    \       }\n\n        len -= 1;\n    }\n\n    palindrome\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpvjisdocx.rs:21:13\n   |\n21 |             suffix_str +=\
    \ &string[suffix_index..][prefix_index..][prefix_index..];\n   |             ----------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpvjisdocx.rs:26:45\n\
    \     |\n26   |         palindrome_slice = palindrome_slice.rev();\n     |   \
    \                                          ^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n     |\n     = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n               &mut I\n              \
    \ Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n        \
    \       ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n    \
    \           Box<I, A>\n               Chunks<'_, T>\n             and 109 others\n\
    \     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `std::iter::Take<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvjisdocx.rs:26:28\n   |\n25 |         let mut\
    \ palindrome_slice = palindrome.chars().take(suffix_str.len());\n   |        \
    \                            ----------------------------------------- expected\
    \ due to this value\n26 |         palindrome_slice = palindrome_slice.rev();\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::iter::Take`,\
    \ found struct `Rev`\n   |\n   = note: expected struct `std::iter::Take<Chars<'_>>`\n\
    \              found struct `Rev<std::iter::Take<Chars<'_>>>`\n\nerror[E0369]:\
    \ binary operation `==` cannot be applied to type `std::iter::Take<Chars<'_>>`\n\
    \  --> /tmp/tmpvjisdocx.rs:28:29\n   |\n28 |         if palindrome_slice == palindrome_slice\
    \ {\n   |            ---------------- ^^ ---------------- std::iter::Take<Chars<'_>>\n\
    \   |            |\n   |            std::iter::Take<Chars<'_>>\n\nerror: aborting\
    \ du"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // find the longest\
    \ postfix of a palindrome that begins with the supplied string.\n    let mut postfix\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    let mut longest = 0;\n\
    \    while i < postfix.len() && j < string.length {\n        if postfix.starts_with(&string[j])\
    \ {\n            i += longest;\n            longest = 1;\n            i += 1;\n\
    \        } else {\n            longest = 0;\n        }\n        i += 1;\n    \
    \    j += 1;\n    }\n    // if longest is not zero, append reverse of a string\
    \ prefix that comes before it\n    longest == 0\n        ? string\n        : string\
    \ + &string[&postfix.len() - longest - 1]\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `string`\n\
    \  --> /tmp/tmpg2lk1cuv.rs:30:11\n   |\n30 |         ? string\n   |          \
    \ ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0609]: no\
    \ field `length` on type `String`\n  --> /tmp/tmpg2lk1cuv.rs:17:43\n   |\n17 |\
    \     while i < postfix.len() && j < string.length {\n   |                   \
    \                        ^^^^^^ unknown field\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpg2lk1cuv.rs:18:33\n   |\n18\
    \ |         if postfix.starts_with(&string[j]) {\n   |                       \
    \          ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // O(n) time\
    \ O(n) space\n    let mut longest = string.len();\n    let mut reverse = String::new();\n\
    \n    for ch in string.chars() {\n        if !ch\n            .chars()\n     \
    \       .enumerate()\n            .any(|(_, pos)| pos == 0 || pos == string.len())\n\
    \        {\n            break;\n        }\n\n        if ch != string[pos - 1]\
    \ {\n            break;\n        }\n\n        longest -= 1;\n        reverse +=\
    \ string[pos];\n    }\n\n    longest += 1;\n    reverse.reverse();\n\n    let\
    \ mut reversed = String::new();\n    reversed.push_str(&reverse);\n\n    longest\n\
    \        .to_string()\n        .push_str(&reversed)\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `pos` in this scope\n  --> /tmp/tmp5f9ann3n.rs:25:25\n\
    \   |\n25 |         if ch != string[pos - 1] {\n   |                         ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `pos` in this scope\n\
    \  --> /tmp/tmp5f9ann3n.rs:30:27\n   |\n30 |         reverse += string[pos];\n\
    \   |                           ^^^ not found in this scope\n\nerror[E0599]: no\
    \ method named `chars` found for type `char` in the current scope\n  --> /tmp/tmp5f9ann3n.rs:18:14\n\
    \   |\n18 |             .chars()\n   |              ^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5f9ann3n.rs:34:13\n   |\n34 |     reverse.reverse();\n\
    \   |             ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f9ann3n.rs:39:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n39 | /     longest\n40 | |         .to_string()\n41 | |         .push_str(&reversed)\n\
    \   | |____________________________^ expected struct `String`, found `()`\n  \
    \ |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmp5f9ann3n.rs:41:10\n\
    \   |\n39 | /     longest\n40 | |         .to_string()\n   | |____________________-\
    \ you probably want to use this value after calling the method...\n41 |      \
    \     .push_str(&reversed)\n   |            ^^^^^^^^ this call modifies its receiver\
    \ in-place\n   = note: ...instead of the `()` output of method `push_str`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return \"\";\n    }\n\n    // Find the longest postfix that is a\
    \ palindrome.\n    let mut postfix = string;\n    let mut reverse = 0;\n    while\
    \ !postfix.starts_with('a'.rev()) {\n        reverse += 1;\n        postfix =\
    \ postfix.chars().take(2).collect::<String>().to_string();\n    }\n\n    if postfix.len()\
    \ <= reverse {\n        return string;\n    }\n\n    string += &string[..(string.len()\
    \ - reverse)];\n    let mut result = 0;\n    let mut current = 1;\n    while current\
    \ <= reverse {\n        let current = current * 2;\n        result = result *\
    \ 10 + current;\n    }\n    result *= 10;\n    result += reverse;\n    string\
    \ += &string[..(string.length() - reverse)];\n    result.to_string()\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7sp4ay5k.rs:13:16\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if string.is_empty() {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0599]: `char`\
    \ is not an iterator\n  --> /tmp/tmp7sp4ay5k.rs:19:36\n   |\n19 |     while !postfix.starts_with('a'.rev())\
    \ {\n   |                                    ^^^ `char` is not an iterator\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp7sp4ay5k.rs:37:33\n   |\n37 |     string += &string[..(string.length()\
    \ - reverse)];\n   |                                 ^^^^^^ help: there is an\
    \ associated function with a similar name: `len`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = String::new();\n    let mut prefix_length = 0;\n\n    for (index, char) in\
    \ string.chars().enumerate() {\n        if char == char.to_ascii_lowercase() {\n\
    \            palindrome.push((char.to_ascii_lowercase()));\n            prefix_length\
    \ += 1;\n        } else {\n            palindrome.push((char.to_ascii_lowercase()));\n\
    \        }\n    }\n\n    if prefix_length > 1 {\n        let mut last_char = palindrome[palindrome.len()\
    \ - 1];\n        for _ in 0..palindrome.len() - prefix_length {\n            palindrome.push((&last_char));\n\
    \            last_char = palindrome[palindrome.len() - 1];\n        }\n    }\n\
    \    palindrome.push((&char.to_ascii_lowercase()));\n\n    palindrome\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmpsubtb3ap.rs:31:23\n\
    \   |\n31 |     palindrome.push((&char.to_ascii_lowercase()));\n   |         \
    \              ^^^^ not a value\n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmpsubtb3ap.rs:17:29\n   |\n17 |             palindrome.push((char.to_ascii_lowercase()));\n\
    \   |                             ^                         ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    17 -             palindrome.push((char.to_ascii_lowercase()));\n17 +         \
    \    palindrome.push(char.to_ascii_lowercase());\n   | \n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpsubtb3ap.rs:20:29\n   |\n\
    20 |             palindrome.push((char.to_ascii_lowercase()));\n   |         \
    \                    ^                         ^\n   |\nhelp: remove these parentheses\n\
    \   |\n20 -             palindrome.push((char.to_ascii_lowercase()));\n20 +  \
    \           palindrome.push(char.to_ascii_lowercase());\n   | \n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpsubtb3ap.rs:27:29\n   |\n\
    27 |             palindrome.push((&last_char));\n   |                        \
    \     ^          ^\n   |\nhelp: remove these parentheses\n   |\n27 -         \
    \    palindrome.push((&last_char));\n27 +             palindrome.push(&last_char);\n\
    \   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpsubtb3ap.rs:31:21\n\
    \   |\n31 |     palindrome.push((&char.to_ascii_lowercase()));\n   |         \
    \            ^                          ^\n   |\nhelp: remove these parentheses\n\
    \   |\n31 -     palindrome.push((&char.to_ascii_lowercase()));\n31 +     palindrome.push(&char.to_ascii_lowercase());\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpsubtb3ap.rs:25:29\n   |\n25 |         let mut last_char = palindrome[palindrome.len()\
    \ - 1];\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `St"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut reverse: String = String::new();\n\
    \    let mut longest = String::new();\n    let mut pos = 0;\n\n    for c in string.chars()\
    \ {\n        if pos == 0 {\n            longest = String::new();\n        }\n\
    \        if c != longest.chars().next().unwrap() {\n            longest = longest.push_str(c);\n\
    \        } else {\n            longest = longest.push_str(&*reverse);\n      \
    \  }\n        pos = longest.chars().last().unwrap();\n    }\n    longest = longest.push_str(&*reverse);\n\
    \    return longest\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpncj047az.rs:25:40\n   |\n\
    25 |             longest = longest.push_str(c);\n   |                        \
    \                ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpncj047az.rs:25:23\n   |\n17 |     let mut longest = String::new();\n\
    \   |                       ------------- expected due to this value\n...\n25\
    \ |             longest = longest.push_str(c);\n   |                       ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpncj047az.rs:25:31\n   |\n25 |         \
    \    longest = longest.push_str(c);\n   |                       ------- ^^^^^^^^\
    \ this call modifies `longest` in-place\n   |                       |\n   |  \
    \                     you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpncj047az.rs:27:23\n   |\n17 |     let mut longest\
    \ = String::new();\n   |                       ------------- expected due to this\
    \ value\n...\n27 |             longest = longest.push_str(&*reverse);\n   |  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpncj047az.rs:27:31\n\
    \   |\n27 |             longest = longest.push_str(&*reverse);\n   |         \
    \              ------- ^^^^^^^^ this call modifies `longest` in-place\n   |  \
    \                     |\n   |                       you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpncj047az.rs:29:15\n\
    \   |\n18 |     let mut pos = 0;\n   |                   - expected due to this\
    \ value\n...\n29 |         pos = longest.chars().last().unwrap();\n   |      \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpncj047az.rs:31:15\n   |\n17 |     let mut longest\
    \ = Str"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut rev: Vec<&str> = Vec::new();\n    loop {\n        let\
    \ mut suffix = string;\n        rev.push(suffix);\n        for suffix in rev.iter().rev()\
    \ {\n            if let Ok(s) = suffix.chars().nth(0) {\n                return\
    \ s.to_string();\n            }\n        }\n        if let Some(s) = suffix.chars().nth(0)\
    \ {\n            string = s.to_string() + string;\n        } else {\n        \
    \    break;\n        }\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpazp6wo6b.rs:16:18\n   |\n\
    16 |         rev.push(suffix);\n   |                  ^^^^^^\n   |           \
    \       |\n   |                  expected `&str`, found struct `String`\n   |\
    \                  help: consider borrowing here: `&suffix`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpazp6wo6b.rs:18:20\n   |\n18 |             if let Ok(s)\
    \ = suffix.chars().nth(0) {\n   |                    ^^^^^   ---------------------\
    \ this expression has type `Option<char>`\n   |                    |\n   |   \
    \                 expected enum `Option`, found enum `Result`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpazp6wo6b.rs:23:38\n   |\n23 |             string\
    \ = s.to_string() + string;\n   |                                      ^^^^^^\n\
    \   |                                      |\n   |                           \
    \           expected `&str`, found struct `String`\n   |                     \
    \                 help: consider borrowing here: `&string`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let length =\
    \ string.length();\n    let mut longest = 0;\n    let mut palindrome = String::new();\n\
    \    for pos in 1..length {\n        if pos <= 1 {\n            palindrome.push('_');\n\
    \            palindrome.push(string[pos - 1..]);\n        }\n        palindrome.push('_');\n\
    \        let index = string.rfind(string[pos - 1..], pos);\n        if index >=\
    \ 0 {\n            palindrome.push(string[pos - 1..index]);\n            let prefix\
    \ = string[..index].chars();\n            let suffix = string[index..].chars();\n\
    \            palindrome.push(rev::reverse(prefix.collect()));\n            palindrome.push(rev::reverse(suffix.collect()));\n\
    \            longest = if longest < index {\n                index\n         \
    \   } else {\n                longest\n            };\n        }\n    }\n    palindrome.push('_');\n\
    \    palindrome.push(rev::reverse(string[longest..].chars().collect()));\n   \
    \ palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rev`\n\
    \  --> /tmp/tmpre71vheg.rs:26:29\n   |\n26 |             palindrome.push(rev::reverse(prefix.collect()));\n\
    \   |                             ^^^ use of undeclared crate or module `rev`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rev`\n \
    \ --> /tmp/tmpre71vheg.rs:27:29\n   |\n27 |             palindrome.push(rev::reverse(suffix.collect()));\n\
    \   |                             ^^^ use of undeclared crate or module `rev`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rev`\n \
    \ --> /tmp/tmpre71vheg.rs:36:21\n   |\n36 |     palindrome.push(rev::reverse(string[longest..].chars().collect()));\n\
    \   |                     ^^^ use of undeclared crate or module `rev`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpre71vheg.rs:12:25\n   |\n12 |     let length = string.length();\n  \
    \ |                         ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpre71vheg.rs:18:29\n\
    \   |\n18 |             palindrome.push(string[pos - 1..]);\n   |            \
    \                 ^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpre71vheg.rs:21:28\n\
    \     |\n21   |         let index = string.rfind(string[pos - 1..], pos);\n  \
    \   |                            ^^^^^ -----------------  --- supplied 2 arguments\n\
    \     |                            |\n     |                            expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpre71vheg.rs:22:21\n   |\n22 |         if index\
    \ >= 0 {\n   |                     ^ expected enum `Option`, found integer\n \
    \  |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n22 |         if index >= Some(0)\
    \ {\n   |                     +++++ +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpre71vhe"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string\n    \
    \    .chars()\n        .filter_map(|p| p.to_string())\n        .enumerate()\n\
    \        .filter(|&(i, s)| s.chars().all_bytes().to_vec() == s.chars().r_bytes().to_vec())\n\
    \        .map(|(i, s)| s.chars().rev().collect())\n        .map(|s| string[..i]\
    \ + s + string[i + s.len()..].to_string())\n        .max()\n        .unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp0scrgjvd.rs:18:27\n\
    \   |\n18 |         .map(|s| string[..i] + s + string[i + s.len()..].to_string())\n\
    \   |                           ^ help: a local variable with a similar name exists:\
    \ `s`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp0scrgjvd.rs:18:43\n\
    \   |\n18 |         .map(|s| string[..i] + s + string[i + s.len()..].to_string())\n\
    \   |                                           ^ help: a local variable with\
    \ a similar name exists: `s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0scrgjvd.rs:14:25\n\
    \   |\n14 |         .filter_map(|p| p.to_string())\n   |                     \
    \    ^^^^^^^^^^^^^ expected enum `Option`, found struct `String`\n   |\n   = note:\
    \ expected enum `Option<_>`\n            found struct `String`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n14 |         .filter_map(|p| Some(p.to_string()))\n\
    \   |                         +++++             +\n\nerror[E0369]: cannot add\
    \ `_` to `str`\n  --> /tmp/tmp0scrgjvd.rs:18:30\n   |\n18 |         .map(|s| string[..i]\
    \ + s + string[i + s.len()..].to_string())\n   |                  -----------\
    \ ^ - _\n   |                  |\n   |                  str\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string.clone();\n    let mut prefix_to_longest = string.clone();\n    let\
    \ mut prefix_to_longest = string.clone();\n    let mut prefix_to_longest = string.clone();\n\
    \    let mut prefix_to_longest = string.clone();\n\n    let mut longest_postfix\
    \ = 0;\n\n    while longest_postfix < string.len() {\n        longest_postfix\
    \ += 1;\n        let postfix = &string[longest_postfix ..].to_lowercase();\n\n\
    \        let mut reversed_postfix = postfix.clone();\n        reversed_postfix\
    \ = reversed_postfix.chars().collect::<String>().reverse();\n\n        if reversed_postfix.starts_with(&reversed_string)\
    \ {\n            reversed_string.push_str(&reversed_postfix);\n            return\
    \ reversed_string;\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpd69_b2s7.rs:25:73\n   |\n25 |         reversed_postfix\
    \ = reversed_postfix.chars().collect::<String>().reverse();\n   |            \
    \                                                             ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut buffer\
    \ = String::new();\n    buffer.push_str(&string);\n    buffer.push_front(&string[..]);\n\
    \n    while buffer.ends_with(&buffer[..]) {\n        let mut s = buffer.clone();\n\
    \        buffer.push_front(&buffer[..]);\n        buffer.reverse();\n        buffer.push_str(&s);\n\
    \    }\n\n    buffer\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_front` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmprw42ccwg.rs:14:12\n   |\n14 |     buffer.push_front(&string[..]);\n\
    \   |            ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `push_front` found for struct `String` in the current scope\n  --> /tmp/tmprw42ccwg.rs:18:16\n\
    \   |\n18 |         buffer.push_front(&buffer[..]);\n   |                ^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmprw42ccwg.rs:19:16\n\
    \   |\n19 |         buffer.reverse();\n   |                ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed:\
    \ Vec<u8> = vec![];\n\n    for &ch in string.chars() {\n        reversed.push(*ch\
    \ as u8);\n    }\n\n    let mut end = string.len();\n\n    while let Some(suffix)\
    \ = string.split_last_mut() {\n        if suffix == &reversed[0..reversed.len()].iter().rev().collect::<String>()\
    \ {\n            end = suffix.len();\n        } else {\n            break;\n \
    \       }\n    }\n\n    string[end..].concat(reversed.reverse())\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppw1onxdy.rs:14:9\n   |\n\
    14 |     for &ch in string.chars() {\n   |         ^^^    -------------- this\
    \ expression has type `Option<char>`\n   |         |\n   |         expected `char`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `ch`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror[E0599]: no method named `split_last_mut` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmppw1onxdy.rs:20:37\n   |\n20 |     while let\
    \ Some(suffix) = string.split_last_mut() {\n   |                             \
    \        ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `split_at`\n\nerror[E0277]: a value of type `String` cannot be built from an\
    \ iterator over elements of type `&u8`\n    --> /tmp/tmppw1onxdy.rs:21:64\n  \
    \   |\n21   |         if suffix == &reversed[0..reversed.len()].iter().rev().collect::<String>()\
    \ {\n     |                                                                ^^^^^^^\
    \ value of type `String` cannot be built from `std::iter::Iterator<Item=&u8>`\n\
    \     |\n     = help: the trait `FromIterator<&u8>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0599]: no method named `concat` found for type `str` in the current scope\n\
    \  --> /tmp/tmppw1onxdy.rs:28:19\n   |\n28 |     string[end..].concat(reversed.reverse())\n\
    \   |                   ^^^^^^ method not found in `str`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let (lower, upper) = string.char_indices();\n    if lower.is_none()\
    \ {\n        return string;\n    }\n    // longest postfix of string\n    let\
    \ max_len = lower.last().unwrap() - 1;\n    loop {\n        // find the longest\
    \ postfix of string\n        let mut found = false;\n        let mut postfix =\
    \ string;\n        let mut i = 0;\n        while !found && i < max_len && !postfix.is_empty()\
    \ {\n            let c = postfix.as_str()[i];\n            if c != string[upper.unwrap()..].as_str().len()\
    \ {\n                // found the longest postfix\n                found = true;\n\
    \            }\n            postfix.push(c);\n            i += 1;\n        }\n\
    \        // if found the palindrome postfix then append the reverse of the suffix\n\
    \        if found {\n            postfix.reverse();\n            return postfix.clone();\n\
    \        }\n        // if not found the postfix then decrement max length\n  \
    \      max_len -= 1;\n        // if max length reached then break the loop\n \
    \       if max_len == 0 {\n            break;\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4tdwcz68.rs:13:9\n   |\n\
    13 |     let (lower, upper) = string.char_indices();\n   |         ^^^^^^^^^^^^^^\
    \   --------------------- this expression has type `CharIndices<'_>`\n   |   \
    \      |\n   |         expected struct `CharIndices`, found tuple\n   |\n   =\
    \ note: expected struct `CharIndices<'_>`\n               found tuple `(_, _)`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp4tdwcz68.rs:25:21\n\
    \   |\n25 |             let c = postfix.as_str()[i];\n   |                   \
    \  ^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n           for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0599]: no method named `as_str` found for type `str` in the current scope\n\
    \  --> /tmp/tmp4tdwcz68.rs:26:46\n   |\n26 |             if c != string[upper.unwrap()..].as_str().len()\
    \ {\n   |                                             -^^^^^^-- help: remove this\
    \ method call\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4tdwcz68.rs:35:21\n   |\n35 |          \
    \   postfix.reverse();\n   |                     ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut prefix;\n    let\
    \ mut suffix;\n    let mut revstring;\n    let mut index = 0;\n    while longest_postfix.len()\
    \ > 0 {\n        index = longest_postfix.rfind('a', index);\n        if index\
    \ == String::npos {\n            break;\n        }\n        longest_postfix.remove(index,\
    \ 1);\n        let len = longest_postfix.len();\n        let revlen = len - 1;\n\
    \        revstring = &string[revlen..];\n        prefix = &string[0..len];\n \
    \       suffix = &string[len..];\n        if longest_postfix.eq(prefix) && longest_postfix.eq(suffix)\
    \ {\n            break;\n        }\n        longest_postfix = &revstring[revlen..];\n\
    \    }\n    longest_postfix.extend(&string[..]);\n    return longest_postfix;\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpjmo43o4l.rs:19:33\n     |\n19   |         index = longest_postfix.rfind('a',\
    \ index);\n     |                                 ^^^^^ ---  ----- supplied 2\
    \ arguments\n     |                                 |\n     |                \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmo43o4l.rs:19:17\n  \
    \ |\n17 |     let mut index = 0;\n   |                     - expected due to this\
    \ value\n18 |     while longest_postfix.len() > 0 {\n19 |         index = longest_postfix.rfind('a',\
    \ index);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpjmo43o4l.rs:20:29\n\
    \   |\n20 |         if index == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpjmo43o4l.rs:23:25\n\
    \     |\n23   |         longest_postfix.remove(index, 1);\n     |            \
    \             ^^^^^^ -----  - supplied 2 arguments\n     |                   \
    \      |\n     |                         expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmo43o4l.rs:32:27\n\
    \   |\n13 |     let mut longest_postfix = string;\n   |                      \
    \         ------ expected due to this value\n...\n32 |         longest_postfix\
    \ = &revstring[revlen..];\n   |                           ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n32 |         longest_postfix = (&revstring[revlen..]).to_string();\n  \
    \ |                           +                    +++++++++++++\n\nerror[E0277]:\
    \ `&str` is not an iterator\n   --> /tmp/tmpjmo43o4l.rs:34:28\n    |\n34"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut len = string.len();\n    let mut index = len - 1;\n \
    \   let mut palindrome = String::new();\n\n    // Start with the longest postfix\
    \ that is a palindrome\n    while index >= 0 {\n        if string[index] != string[len]\
    \ {\n            break;\n        }\n\n        palindrome.push((&string[index]).to_string());\n\
    \        index -= 1;\n    }\n\n    // Append reverse of the prefix before the\
    \ palindromic suffix\n    index += 1;\n    while index < len {\n        palindrome.push((&string[index]).to_string());\n\
    \        index += 1;\n    }\n\n    palindrome\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmo6u95i0.rs:19:12\n\
    \   |\n19 |         if string[index] != string[len] {\n   |            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmo6u95i0.rs:19:29\n   |\n19 |         if string[index] != string[len]\
    \ {\n   |                             ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmo6u95i0.rs:23:27\n   |\n23 |         palindrome.push((&string[index]).to_string());\n\
    \   |                           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Inde"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest_palindrome\
    \ = string;\n    let mut i = string.len();\n    while i >= 0 {\n        let mut\
    \ j = i;\n        while j >= 0 {\n            let x = string[j];\n           \
    \ longest_palindrome.append(&x);\n            j -= 1;\n        }\n        i =\
    \ longest_palindrome.len();\n    }\n    longest_palindrome.rev_iter().clone().unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbkikp5u9.rs:17:21\n\
    \   |\n17 |             let x = string[j];\n   |                     ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbkikp5u9.rs:18:32\n   |\n18 |          \
    \   longest_palindrome.append(&x);\n   |                                ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `rev_iter` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpbkikp5u9.rs:23:24\n\
    \   |\n23 |     longest_palindrome.rev_iter().clone().unwrap().to_string()\n \
    \  |                        ^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string_palindrome\
    \ = string\n        .chars()\n        .enumerate()\n        .filter_map(|(i, c)|\
    \ {\n            if i == 0 {\n                return Some(String::new());\n  \
    \          }\n            match c.to_ascii_lowercase() {\n                'a'\
    \ => Some(String::new()),\n                'e' => Some(String::new()),\n     \
    \           'i' => Some(String::new()),\n                'o' => Some(String::new()),\n\
    \                'u' => Some(String::new()),\n                _ => None,\n   \
    \         }\n        })\n        .filter_map(|s| s.take(s.len() - 1))\n      \
    \  .filter_map(|s| s.reverse())\n        .next()\n        .unwrap_or(String::new());\n\
    \n    string_palindrome\n        .rev()\n        .into_iter()\n        .map(|&c|\
    \ String::from(c))\n        .collect::<Vec<String>>()\n        .join(\"\")\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp002b682r.rs:28:27\n\
    \    |\n28  |           .filter_map(|s| s.take(s.len() - 1))\n    |          \
    \                   ^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string;\n\
    \    let mut is_palindrome = true;\n    while !s.is_empty() && is_palindrome {\n\
    \        let last_char = s.chars().last_unwrap();\n        s = s.chars().skip(1).collect::<String>();\n\
    \        let mut s_rev: String = s.chars().collect::<String>().rev().collect();\n\
    \        s = s_rev.into_owned();\n        is_palindrome = s.starts_with(last_char);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `last_unwrap` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpc_rihs0m.rs:15:35\n   |\n15 |         let last_char\
    \ = s.chars().last_unwrap();\n   |                                   ^^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmpc_rihs0m.rs:17:63\n    |\n17  |           let mut s_rev: String\
    \ = s.chars().collect::<String>().rev().collect();\n    |                    \
    \                                             ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpc_rihs0m.rs:18:19\n\
    \   |\n18 |         s = s_rev.into_owned();\n   |                   ^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if let Some(pos)\
    \ = string.rfind('a')\n    {\n        let mut reverse_string = String::with_capacity(string.len());\n\
    \        for c in string.rfind('a', pos)\n        {\n            reverse_string.push(c);\n\
    \        }\n        reverse_string.push(string[..pos]);\n        reverse_string.rev();\n\
    \        let mut reversed = reverse_string.rev();\n        let mut pos = 0;\n\
    \        let mut palindrome = String::with_capacity(string.len() + 1);\n     \
    \   while pos < reversed.len() {\n            palindrome.push(reversed[pos]);\n\
    \            pos += 1;\n        }\n        palindrome.push('a');\n        return\
    \ palindrome;\n    } else {\n        return string;\n    }\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpf790bafc.rs:15:25\n     |\n15   |         for c in string.rfind('a',\
    \ pos)\n     |                         ^^^^^ ---  --- supplied 2 arguments\n \
    \    |                         |\n     |                         expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf790bafc.rs:17:33\n   |\n17 |             reverse_string.push(c);\n\
    \   |                                 ^ expected `char`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf790bafc.rs:19:29\n   |\n19 |         reverse_string.push(string[..pos]);\n\
    \   |                             ^^^^^^^^^^^^^ expected `char`, found `str`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpf790bafc.rs:20:24\n\
    \    |\n20  |           reverse_string.rev();\n    |                         \
    \ ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpf790bafc.rs:21:43\n\
    \    |\n21  |           let mut reversed = reverse_string.rev();\n    |      \
    \                                       ^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = string;\n    let mut pre = string;\n    let mut start = Vec::new();\n\n  \
    \  while !suffix.is_empty() {\n        let mut last_char = &suffix[suffix.len()\
    \ - 1];\n        if last_char != pre.chars().nth(0) {\n            start.push(last_char);\n\
    \            pre = &suffix[..suffix.len() - 1];\n        } else {\n          \
    \  break;\n        }\n    }\n\n    if !pre.is_empty() {\n        start.push(pre.chars().nth(0));\n\
    \    }\n\n    let start = start.collect::<String>();\n    let rev_start = start.rev().collect::<String>();\n\
    \n    &rev_start + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjdjmfb4a.rs:17:30\n\
    \   |\n17 |         let mut last_char = &suffix[suffix.len() - 1];\n   |     \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `Option<char>`\n  --> /tmp/tmpjdjmfb4a.rs:18:22\n\
    \   |\n18 |         if last_char != pre.chars().nth(0) {\n   |               \
    \       ^^ no implementation for `&_ == Option<char>`\n   |\n   = help: the trait\
    \ `PartialEq<Option<char>>` is not implemented for `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjdjmfb4a.rs:20:19\n   |\n13 |     let mut pre = string;\n\
    \   |                   ------ expected due to this value\n...\n20 |         \
    \    pre = &suffix[..suffix.len() - 1];\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n20 |             pre = (&suffix[..suffix.len() - 1]).to_string();\n   |\
    \                   +                           +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjdjmfb4a.rs:27:20\n   |\n27 |         start.push(pre.chars().nth(0));\n\
    \   |                    ^^^^^^^^^^^^^^^^^^\n   |                    |\n   | \
    \                   expected reference, found enum `Option`\n   |            \
    \        help: consider borrowing here: `&pre.chars().nth(0)`\n   |\n   = note:\
    \ expected reference `&_`\n                   found enum `Option<char>`\n\nerror[E0599]:\
    \ `Vec<&_>` is not an iterator\n   --> /tmp/tmpjdjmfb4a.rs:30:23\n    |\n30  |\
    \       let start = start.collect::<String>();\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reverse_string = string;\n    let mut start = 0;\n  \
    \  while start < string.len() {\n        let end = string.len();\n        let\
    \ middle = (end - start) / 2;\n        let suffix = &string[middle..];\n     \
    \   if suffix == &string[..middle] {\n            if suffix == &string[middle..]\
    \ {\n                reverse_string = &string[..middle];\n                break;\n\
    \            }\n            let start = middle;\n        } else {\n          \
    \  start = middle;\n        }\n    }\n    &string[..reverse_string.len()] + reverse_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpna8_giik.rs:21:34\n   |\n\
    13 |     let mut reverse_string = string;\n   |                              ------\
    \ expected due to this value\n...\n21 |                 reverse_string = &string[..middle];\n\
    \   |                                  ^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n21 |        \
    \         reverse_string = (&string[..middle]).to_string();\n   |            \
    \                      +                 +++++++++++++\n\nerror[E0369]: cannot\
    \ add `String` to `&str`\n  --> /tmp/tmpna8_giik.rs:29:37\n   |\n29 |     &string[..reverse_string.len()]\
    \ + reverse_string\n   |     ------------------------------- ^ --------------\
    \ String\n   |     |                               |\n   |     |             \
    \                  `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |     &str\n   |\nhelp: remove the borrow on the left and add one on the right\n\
    \   |\n29 -     &string[..reverse_string.len()] + reverse_string\n29 +     string[..reverse_string.len()]\
    \ + &reverse_string\n   | \n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n\n  \
    \  while suffix_end < string.len() {\n        let mut suffix_len = string.len()\
    \ - suffix_end;\n        let mut suffix_lens = suffix_len.to_string();\n\n   \
    \     while suffix_lens.len() > 1 {\n            suffix_lens = suffix_lens.split_whitespace()[0];\n\
    \        }\n\n        suffix_end += suffix_lens.len() - 1;\n        suffix_lens\
    \ = suffix_len.to_string();\n        suffix_start = suffix_end - suffix_lens.len()\
    \ + 1;\n\n        let mut suffix_end = suffix_end;\n        let mut suffix_start\
    \ = suffix_start;\n\n        let mut reverse = suffix_lens.reverse();\n      \
    \  reverse.reserve(suffix_len.len() - suffix_lens.len());\n        suffix_end\
    \ = suffix_end + reverse.len();\n\n        let mut reverse = reverse.to_string();\n\
    \        let mut suffix_end = suffix_end;\n\n        while suffix_end < string.len()\
    \ {\n            suffix_end = suffix_end + 1;\n            let mut reverse = suffix_end.to_string()\
    \ + reverse.to_string();\n        }\n\n        palindrome.insert(suffix_end, &reverse);\n\
    \n        let mut suffix_end = suffix_end;\n        let mut suffix_start = suffix_start;\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp3uoew31l.rs:21:27\n   |\n21 |             suffix_lens = suffix_lens.split_whitespace()[0];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp3uoew31l.rs:31:39\n   |\n31 |         let mut reverse = suffix_lens.reverse();\n\
    \   |                                       ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0599]: no method named `len`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp3uoew31l.rs:32:36\n\
    \   |\n32 |         reverse.reserve(suffix_len.len() - suffix_lens.len());\n \
    \  |                                    ^^^ method not found in `usize`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // 1. Find the\
    \ longest palindrome\n    let max_len = find_longest_palindrome_prefix(&string);\n\
    \    let mut str = string;\n\n    // 2. Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    str.push_str(&str[..max_len]);\n\
    \n    // 3. Add an extra letter at the beginning.\n    str.push_str(&string[0]);\n\
    \n    str\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_prefix` in\
    \ this scope\n  --> /tmp/tmpp45eai5_.rs:13:19\n   |\n13 |     let max_len = find_longest_palindrome_prefix(&string);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpp45eai5_.rs:20:19\n\
    \   |\n20 |     str.push_str(&string[0]);\n   |                   ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (max_len,\
    \ pref_max_len) = (\n        string.len(),\n        string.rsplit(|x| x, 1).unwrap().len(),\n\
    \    );\n    let mut string = \"\";\n    let mut palindromic_suffix = string;\n\
    \    let mut prefix_len = 0;\n    for _ in 0..max_len - pref_max_len + 1 {\n \
    \       let new_string = string.clone();\n        let is_palindromic = match palindromic_suffix.rsplit(|x|\
    \ x, 1).unwrap() {\n            x if x == *x => true,\n            _ => false,\n\
    \        };\n        if is_palindromic {\n            palindromic_suffix = palindromic_suffix.clone();\n\
    \            string += *x;\n        } else {\n            string += *x;\n    \
    \        prefix_len += 1;\n        }\n    }\n    string\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpssmb2gcf.rs:27:24\n\
    \   |\n27 |             string += *x;\n   |                        ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpssmb2gcf.rs:29:24\n\
    \   |\n29 |             string += *x;\n   |                        ^ not found\
    \ in this scope\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmpssmb2gcf.rs:14:16\n     |\n14   |         string.rsplit(|x|\
    \ x, 1).unwrap().len(),\n     |                ^^^^^^ -----  - supplied 2 arguments\n\
    \     |                |\n     |                expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `std::str::RSplit` in the current scope\n  --> /tmp/tmpssmb2gcf.rs:14:33\n\
    \   |\n14 |         string.rsplit(|x| x, 1).unwrap().len(),\n   |            \
    \                     ^^^^^^ method not found in `std::str::RSplit<'_, _>`\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmpssmb2gcf.rs:21:55\n     |\n21   |         let is_palindromic =\
    \ match palindromic_suffix.rsplit(|x| x, 1).unwrap() {\n     |               \
    \                                        ^^^^^^ -----  - supplied 2 arguments\n\
    \     |                                                       |\n     |      \
    \                                                 expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `std::str::RSplit` in the current scope\n  --> /tmp/tmpssmb2gcf.rs:21:72\n\
    \   |\n21 |         let is_palindromic = match palindromic_suffix.rsplit(|x| x,\
    \ 1).unwrap() {\n   |                                                        \
    \                ^^^^^^ method not found in `std::str::RSplit<'_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpssmb2gcf.rs:33:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n33 |     string\n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.len()\
    \ < 2 {\n        return string;\n    }\n\n    let max_len = longest_palindrome(&string).len();\n\
    \    let mut result = String::from(&string[0..max_len]);\n    result.push(&string[max_len..]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome` in this scope\n\
    \  --> /tmp/tmpw3k_6lyh.rs:16:19\n   |\n16 |     let max_len = longest_palindrome(&string).len();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw3k_6lyh.rs:18:17\n   |\n18 |     result.push(&string[max_len..]);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut reverse_suffix = [0u8; string.len()];\n    let mut reverse_prefix\
    \ = [0];\n\n    while !palindrome.is_empty() {\n        let len = palindrome.len();\n\
    \n        for j in reverse_prefix.iter_mut() {\n            if *j >= len {\n \
    \               *j = len;\n            }\n        }\n\n        for j in reverse_suffix.iter_mut()\
    \ {\n            if *j < 0 {\n                *j = 0;\n            }\n       \
    \ }\n\n        for i in reverse_suffix.iter() {\n            debug_assert!(i >=\
    \ 0);\n            debug_assert!(reverse_prefix[i] <= 0);\n            debug_assert!(i\
    \ < len);\n            debug_assert!(reverse_prefix[i] >= 0);\n            debug_assert!(reverse_suffix[i]\
    \ <= len);\n            debug_assert!(i >= reverse_suffix[i]);\n\n           \
    \ if palindrome[i] == string[reverse_prefix[i] .. reverse_suffix[i]] {\n     \
    \           reverse_prefix[i] = 0;\n                reverse_suffix[i] = len -\
    \ 1;\n            }\n        }\n\n        if reverse_suffix.iter().filter(|x|\
    \ *x == 0).next().is_some() {\n            palindrome.append(&string[..reverse_suffix.iter().filter(|x|\
    \ *x == 0).next().unwrap()]);\n        }\n    }\n\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpz8_wqvpt.rs:13:36\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                    ------ this would need to be a `const`\n12\
    \ |     let mut palindrome = string;\n13 |     let mut reverse_suffix = [0u8;\
    \ string.len()];\n   |                                    ^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz8_wqvpt.rs:32:32\n   |\n32 |             debug_assert!(i\
    \ >= 0);\n   |                                ^\n   |                        \
    \        |\n   |                                expected `&u8`, found integer\n\
    \   |                                help: consider borrowing here: `&0`\n\nerror[E0277]:\
    \ the type `[usize]` cannot be indexed by `&u8`\n  --> /tmp/tmpz8_wqvpt.rs:33:27\n\
    \   |\n33 |             debug_assert!(reverse_prefix[i] <= 0);\n   |         \
    \                  ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>` is not implemented\
    \ for `&u8`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&u8>` for\
    \ `[usize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz8_wqvpt.rs:34:31\n\
    \   |\n34 |             debug_assert!(i < len);\n   |                        \
    \       ^^^ expected `&u8`, found `usize`\n\nerror[E0277]: the type `[usize]`\
    \ cannot be indexed by `&u8`\n  --> /tmp/tmpz8_wqvpt.rs:35:27\n   |\n35 |    \
    \         debug_assert!(reverse_prefix[i] >= 0);\n   |                       \
    \    ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[usize]>` is not implemented for `&u8`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&u8>` for `[usize]`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `&u8`\n  --> /tmp/tmpz8_wqvpt.rs:39:16\n\
    \   |\n39 |             if palindrome[i] == string[reverse_prefix[i] .. reverse_suffix[i]]\
    \ {\n   |                ^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string;\n\
    \    if s.len() > 2 {\n        let mut maxlen = 0;\n        for &c in s.chars()\
    \ {\n            if maxlen < c.len() {\n                maxlen = c.len();\n  \
    \          }\n        }\n        let mut start = String::new();\n        let mut\
    \ middle = String::new();\n        let mut end = String::new();\n        for (i,\
    \ &c) in s.chars().enumerate() {\n            if i < maxlen {\n              \
    \  if i == maxlen - 1 {\n                    start.push(c);\n                }\n\
    \                middle.push(c);\n            } else {\n                if i ==\
    \ 0 {\n                    end.push(c);\n                }\n                end.push(c);\n\
    \                middle.push(c);\n            }\n        }\n        s = start\
    \ + middle.reverse() + end;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm6mlf9dy.rs:15:13\n   |\n\
    15 |         for &c in s.chars() {\n   |             ^^    --------- this expression\
    \ has type `Option<char>`\n   |             |\n   |             expected `char`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm6mlf9dy.rs:23:17\n  \
    \ |\n23 |         for (i, &c) in s.chars().enumerate() {\n   |               \
    \  ^^     --------------------- this expression has type `Option<(usize, char)>`\n\
    \   |                 |\n   |                 expected `char`, found reference\n\
    \   |                 help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpm6mlf9dy.rs:37:28\n   |\n37 |         s = start + middle.reverse()\
    \ + end;\n   |                            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm6mlf9dy.rs:37:40\n   |\n37 |         s = start + middle.reverse()\
    \ + end;\n   |                                        ^^^\n   |              \
    \                          |\n   |                                        expected\
    \ `&str`, found struct `String`\n   |                                        help:\
    \ consider borrowing here: `&end`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = String::new();\n    let mut suffix = String::new();\n\n    for c in string.chars()\
    \ {\n        if let Some(next) = suffix[suffix.len() - 1] {\n            if next\
    \ != c {\n                suffix.push(c);\n            }\n        } else {\n \
    \           if suffix != c {\n                reverse.push(c);\n             \
    \   suffix.push(c);\n            }\n        }\n    }\n\n    &reverse + &suffix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp43rt3lm.rs:16:29\n\
    \   |\n16 |         if let Some(next) = suffix[suffix.len() - 1] {\n   |     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpp43rt3lm.rs:21:23\n\
    \   |\n21 |             if suffix != c {\n   |                       ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0369]: cannot add\
    \ `&String` to `&String`\n  --> /tmp/tmpp43rt3lm.rs:28:14\n   |\n28 |     &reverse\
    \ + &suffix\n   |     -------- ^ ------- &String\n   |     |        |\n   |  \
    \   |        `+` cannot be used to concatenate two `&str` strings\n   |     &String\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n28 -     &reverse +\
    \ &suffix\n28 +     reverse + &suffix\n   | \n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explai"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_iter = string.rchars();\n    let mut prefix\
    \ = string.clone();\n    let mut prefix_iter = prefix.chars();\n    let mut min_len\
    \ = 0;\n    let mut index = 0;\n    loop {\n        assert!(suffix_iter.peek()\
    \ != Some(&'z'));\n        let chars = prefix_iter.peek()?;\n        if suffix_iter.peek()\
    \ == Some(&'z') {\n            // We found a palindrome with suffix of length\
    \ z.\n            let mut suffix_str = suffix_iter.next(); // move to next character\
    \ in suffix.\n            suffix_str = suffix_str.to_ascii_lowercase(); // convert\
    \ character in suffix to lower case.\n            suffix_str = suffix_str[..suffix_len];\
    \ // remove character in suffix from suffix string.\n            suffix_len -=\
    \ suffix_str.length(); // decrement suffix length.\n            // Convert reverse\
    \ suffix_str from upper case to lower case.\n            suffix_str = suffix_str\n\
    \                .split_ascii_lowercase()\n                .concat();\n      \
    \      // Concatenate reverse suffix_str to prefix.\n            prefix.append(suffix_str);\n\
    \            suffix_iter = suffix_iter.copied(); // move to next character in\
    \ suffix.\n            suffix_iter = suffix_iter.tail(); // move to next tail\
    \ in suffix.\n            suffix_len -= suffix_iter\n                .next()\n\
    \                .map(|x| x.to_ascii_lowercase().len_utf8())\n               \
    \ .sum();\n            if suffix_len < min_len {\n                min_len = suffix_len;\n\
    \                index = suffix_len;\n            }\n        } else {\n      \
    \      // Not a palindrome with suffix.\n            suffix_iter.next();\n   \
    \         suffix_iter.unwrap();\n            prefix.truncate(prefix_iter); //\
    \ remove prefix from prefix string.\n            suffix_len = prefix_iter.len();\
    \ // set suffix length to prefix length.\n        }\n    }\n    let mut palindrome\
    \ = string.clone();\n    palindrome.truncate(index); // remove prefix from palindrome.\n\
    \    palindrome = palindrome.concat(); // add prefix and suffix to palindrome.\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rchars` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5azu8ht1.rs:13:34\n   |\n13 |     let mut suffix_iter\
    \ = string.rchars();\n   |                                  ^^^^^^ help: there\
    \ is an associated function with a similar name: `chars`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Chars` in the current scope\n  --> /tmp/tmp5azu8ht1.rs:20:33\n\
    \   |\n20 |         let chars = prefix_iter.peek()?;\n   |                   \
    \              ^^^^ method not found in `Chars<'_>`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmp5azu8ht1.rs:20:39\n   |\n\
    11 | / fn make_palindrome(string: String) -> String {\n12 | |     let mut suffix_len\
    \ = string.len();\n13 | |     let mut suffix_iter = string.rchars();\n14 | | \
    \    let mut prefix = string.clone();\n...  |\n20 | |         let chars = prefix_iter.peek()?;\n\
    \   | |                                       ^ cannot use the `?` operator in\
    \ a function that returns `String`\n...  |\n54 | |     palindrome\n55 | | }\n\
    \   | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<_>` is not implemented for `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp5azu8ht1.rs:32:20\n   |\n32 |             prefix.append(suffix_str);\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5azu8ht1.rs:47:29\n   |\n47 |             prefix.truncate(prefix_iter);\
    \ // remove prefix from prefix string.\n   |                             ^^^^^^^^^^^\
    \ expected `usize`, found struct `Chars`\n\nerror[E0599]: no method named `len`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmp5azu8ht1.rs:48:38\n\
    \   |\n48 |             suffix_len = prefix_iter.len(); // set suffix length to\
    \ prefix length.\n   |                                      ^^^ method not found\
    \ in `Chars<'_>`\n\nwarning: unreachable statement\n  --> /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.replace(' ', '').to_owned();\n    while string.len() > 1 && string[string.len()\
    \ - 1] == string[0] {\n        string = string.split_last_mut().rev().collect();\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmp93z0ehzb.rs:12:43\n   |\n\
    12 |     let mut string = string.replace(' ', '').to_owned();\n   |          \
    \                                 ^ empty character literal\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp93z0ehzb.rs:13:31\n\
    \   |\n13 |     while string.len() > 1 && string[string.len() - 1] == string[0]\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp93z0ehzb.rs:13:59\n   |\n13 |     while string.len() > 1 && string[string.len()\
    \ - 1] == string[0] {\n   |                                                  \
    \         ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `split_last_mut` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp93z0ehzb.rs:14:25\n   |\n14 |         string = string.split_last_mut().rev().collect();\n\
    \   |                         ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror: aborting du"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    make_postfix_palindrome(string).rev()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `make_postfix_palindrome` in this scope\n\
    \  --> /tmp/tmpk4o_cvta.rs:12:5\n   |\n12 |     make_postfix_palindrome(string).rev()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    let mut palindrome = string;\n    while palindrome.len() > 0 {\n        let\
    \ index = palindrome.len() - 1;\n        let prefix = &palindrome[index..].chars().collect::<String>();\n\
    \        let mut suffix = &palindrome[0..index].chars().collect::<String>();\n\
    \        suffix.reverse();\n        palindrome = prefix + suffix;\n    }\n   \
    \ palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp5ykr9pgk.rs:18:16\n   |\n18 |         suffix.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmp5ykr9pgk.rs:19:29\n\
    \   |\n19 |         palindrome = prefix + suffix;\n   |                      ------\
    \ ^ ------ &String\n   |                      |      |\n   |                 \
    \     |      `+` cannot be used to concatenate two `&str` strings\n   |      \
    \                &String\n   |\n   = note: string concatenation requires an owned\
    \ `String` on the left\nhelp: create an owned `String` from a string reference\n\
    \   |\n19 |         palindrome = prefix.to_owned() + suffix;\n   |           \
    \                 +++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0369, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    debug_assert_eq!(string.len(),\
    \ 1, \"Incorrect length\");\n    let mut string_end = string;\n    let mut found\
    \ = false;\n\n    loop {\n        let mut string_start = string;\n        while\
    \ !found && string_start.len() > string_end.len() {\n            let mut char\
    \ = string_start[string_start.len() - 1];\n            let mut string_end = string;\n\
    \            for index in 1..string_start.len() {\n                if string_start[index]\
    \ != char {\n                    break;\n                }\n                string_end\
    \ += &string_start[index];\n            }\n            char = char.rjust(char.len()\
    \ / 2, '0');\n        }\n        if string_start.len() > string_end.len() {\n\
    \            found = true;\n        } else {\n            string_end += &string_start[string_start.len()\
    \ - string_end.len()];\n            string_start = string_start.replace(string_start.len()\
    \ - string_end.len(), 0, \"\");\n        }\n    }\n    found\n        ? string\n\
    \        : string.rjust(len(string) - string_end.len(), '0')\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `string`\n\
    \  --> /tmp/tmpq5jj5v_2.rs:37:11\n   |\n37 |         ? string\n   |          \
    \ ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq5jj5v_2.rs:19:28\n\
    \   |\n19 |             let mut char = string_start[string_start.len() - 1];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq5jj5v_2.rs:22:20\n   |\n22 |                 if string_start[index]\
    \ != char {\n   |                    ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq5jj5v_2.rs:25:32\n   |\n25 |                 string_end += &string_start[index];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_lowercase();\n\n    // Step 1 - Find the longest palindrome that\
    \ begins with a string.\n    let mut prefix: String = string;\n    let mut palindrome:\
    \ String;\n    let mut longest = 0;\n    while !prefix.is_empty() {\n        longest\
    \ = longest + 1;\n        let mut suffix;\n        if longest > string.len() /\
    \ 2 {\n            suffix = string[string.len() - longest as usize..].to_lowercase();\n\
    \        } else {\n            suffix = string[longest as usize..].to_lowercase();\n\
    \        }\n\n        // Step 2 - Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n        let mut suffix\
    \ = suffix.chars().copied().rev().collect::<String>();\n        let mut suffix\
    \ = suffix.to_string();\n        let mut suffix = suffix.chars().copied().rev().collect::<String>();\n\
    \        let mut suffix = suffix.to_string();\n        suffix = suffix.chars().copied().rev().collect::<String>();\n\
    \        suffix = suffix.to_string();\n        suffix = suffix.chars().copied().rev().collect::<String>();\n\
    \        suffix = suffix.to_string();\n\n        let mut suffix2 = suffix;\n \
    \       let mut suffix3 = suffix2;\n\n        while !suffix2.is_empty() {\n  \
    \          suffix2 = suffix2.chars().copied().rev().collect::<String>();\n   \
    \         suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev().collect::<String>();\n\
    \            suffix2 = suffix2.to_string();\n            suffix2 = suffix2.chars().copied().rev\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3vjo2b2y.rs:69:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n18 |     while !prefix.is_empty()\
    \ {\n   |                              - unclosed delimiter\n...\n40 |       \
    \  while !suffix2.is_empty() {\n   |                                   - this\
    \ delimiter might not be properly closed...\n...\n60 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n69 | }\n   |   ^\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp3vjo2b2y.rs:28:41\n\
    \     |\n28   |         let mut suffix = suffix.chars().copied().rev().collect::<String>();\n\
    \     |                                         ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `copied`\n\nerror[E0599]: the method\
    \ `rev` exists for struct `Copied<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp3vjo2b2y.rs:28:50\n   |\n28 |           let mut suffix = suffix.chars().copied().rev().collect::<String>();\n\
    \   |                                                    ^^^ method cannot be\
    \ called on `Copied<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Copied<Chars<'_>>: Iterator`\n     \
    \      `Copied<Chars<'_>>: Iterator`\n           which is required by `&mut Copied<Chars<'_>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vjo2b2y.rs:18:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n18 | /     while !prefix.is_empty() {\n19 | |         longest = longest +\
    \ 1;\n20 | |         let mut suffix;\n21 | |         if longest > string.len()\
    \ / 2 {\n...  |\n68 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\""
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').sort_by(|&a, &b| a.cmp(b)).collect()\n        .chain(string.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').sort_by(|&a, &b| a.cmp(b)).collect())\n        .fold(String::new(),\
    \ |mut builder, char| {\n            builder.push_str(&string[string.len() - string.len(char.len())..]);\n\
    \            builder.push_str(&string[0..string.len(char.len())]);\n         \
    \   builder\n        })\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9hi8rldx.rs:12:32\n\
    \   |\n12 |     string.chars().filter(|&c| *c >= 'A' && *c <= 'Z').sort_by(|&a,\
    \ &b| a.cmp(b)).collect()\n   |                                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp9hi8rldx.rs:12:45\n   |\n\
    12 |     string.chars().filter(|&c| *c >= 'A' && *c <= 'Z').sort_by(|&a, &b| a.cmp(b)).collect()\n\
    \   |                                             ^^\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Filter` in the current scope\n  --> /tmp/tmp9hi8rldx.rs:12:56\n\
    \   |\n12 |     string.chars().filter(|&c| *c >= 'A' && *c <= 'Z').sort_by(|&a,\
    \ &b| a.cmp(b)).collect()\n   |                                              \
    \          ^^^^^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmp9hi8rldx.rs:12:27:\
    \ 12:54]>`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9hi8rldx.rs:13:43\n\
    \   |\n13 |         .chain(string.chars().filter(|&c| *c >= 'a' && *c <= 'z').sort_by(|&a,\
    \ &b| a.cmp(b)).collect())\n   |                                           ^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9hi8rldx.rs:13:56\n\
    \   |\n13 |         .chain(string.chars().filter(|&c| *c >= 'a' && *c <= 'z').sort_by(|&a,\
    \ &b| a.cmp(b)).collect())\n   |                                             \
    \           ^^\n\nerror[E0599]: no method named `sort_by` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmp9hi8rldx.rs:13:67\n   |\n13 |         .chain(string.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').sort_by(|&a, &b| a.cmp(b)).collect())\n   |        \
    \                                                           ^^^^^^^ method not\
    \ found in `Filter<Chars<'_>, [closure@/tmp/tmp9hi8rldx.rs:13:38: 13:65]>`\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \  --> /tmp/tmp9hi8rldx.rs:15:60\n     |\n15   |             builder.push_str(&string[string.len()\
    \ - string.len(char.len())..]);\n     |                                      \
    \                      ^^^ ---------- supplied 1 argument\n     |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut found = false;\n    while !found {\n        let pos =\
    \ string.len();\n        let reverse_pos = string\n            .rposition(|ch|\
    \ ch != string[pos - 1]);\n        let new_string = String::from(&string[0..pos\
    \ - 1] + &string[reverse_pos..]);\n        found = new_string.is_palindrome();\n\
    \        string = new_string;\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpqye1ko5y.rs:17:14\n   |\n17 |             .rposition(|ch|\
    \ ch != string[pos - 1]);\n   |              ^^^^^^^^^ method not found in `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqye1ko5y.rs:17:35\n\
    \   |\n17 |             .rposition(|ch| ch != string[pos - 1]);\n   |        \
    \                           ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpqye1ko5y.rs:18:59\n\
    \   |\n18 |         let new_string = String::from(&string[0..pos - 1] + &string[reverse_pos..]);\n\
    \   |                                       ------------------- ^ ----------------------\
    \ &str\n   |                                       |                   |\n   |\
    \                                       |                   `+` cannot be used\
    \ to concatenate two `&str` strings\n   |                                    \
    \   &str\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\nhelp: remove the borrow to obtain an owned `String`\n   |\n18 -  \
    \       let new_string = String::from(&string[0..pos - 1] + &string[reverse_pos..]);\n\
    18 +         let new_string = String::from(string[0..pos - 1] + &string[reverse_pos..]);\n\
    \   | \n\nerror[E0599]: no method named `is_palindrome` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpqye1ko5y.rs:19:28\n   |\n19 |         found\
    \ = new_string.is_palindrome();\n   |                            ^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut result = string;\n    let mut i = string.len();\n\
    \    let mut j = string.len() - 1;\n    while i >= 0 || j >= 0 {\n        if i\
    \ < 0 {\n            j = 0;\n        } else {\n            i += 1;\n        }\n\
    \        if j == 0 {\n            j += 1;\n        }\n        if j > i {\n   \
    \         let mut tmp = &result[i..j];\n            tmp = tmp.reverse();\n   \
    \         result = &result[i..j] + &tmp;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpur2yf9ps.rs:27:23\n   |\n27 |             tmp =\
    \ tmp.reverse();\n   |                       ^^^^^^^ method not found in `&str`\n\
    \nerror[E0369]: cannot add `&&str` to `&str`\n  --> /tmp/tmpur2yf9ps.rs:28:36\n\
    \   |\n28 |             result = &result[i..j] + &tmp;\n   |                 \
    \     ------------- ^ ---- &&str\n   |                      |             |\n\
    \   |                      |             `+` cannot be used to concatenate two\
    \ `&str` strings\n   |                      &str\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: remove the borrow to obtain an\
    \ owned `String`\n   |\n28 -             result = &result[i..j] + &tmp;\n28 +\
    \             result = result[i..j] + &tmp;\n   | \n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string;\n    let mut reversed_result = string;\n\n    for i in 1..string.len()\
    \ {\n        let mut first_postfix = result[..i];\n        let mut last_postfix\
    \ = result[(i + 1)..];\n\n        while first_postfix == &reversed_result[..(i\
    \ + 1)] {\n            first_postfix += &reversed_result[i..];\n            last_postfix\
    \ += &reversed_result[(i + 1)..];\n        }\n\n        result = first_postfix\
    \ + &last_postfix;\n\n        reversed_result = reversed_result.chars().rev().collect();\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpblzd1fut.rs:16:13\n   |\n16 |         let mut first_postfix\
    \ = result[..i];\n   |             ^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n16 |         let mut first_postfix = &result[..i];\n   |              \
    \                   +\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpblzd1fut.rs:17:13\n   |\n17 |  \
    \       let mut last_postfix = result[(i + 1)..];\n   |             ^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n17 |         let mut last_postfix = &result[(i\
    \ + 1)..];\n   |                                +\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmpblzd1fut.rs:19:29\n   |\n19 |         while\
    \ first_postfix == &reversed_result[..(i + 1)] {\n   |                       \
    \      ^^ no implementation for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `str`\n  --> /tmp/tmpblzd1fut.rs:20:13\n   |\n20 |      \
    \       first_postfix += &reversed_result[i..];\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reverse = string;\n    let mut postfix =\
    \ string;\n    let mut length = 1;\n\n    // Start with longest possible suffix\n\
    \    while !is_palindrome(&mut postfix) {\n        postfix = &string[..];\n  \
    \      length += 1;\n    }\n\n    // Append reverse of string prefix that comes\
    \ before suffix\n    let mut suffix = &string[..];\n    while !is_palindrome(&mut\
    \ suffix) {\n        let index = prefix.find_last_index(suffix);\n        if index\
    \ >= 0 {\n            reverse.extend_from_slice(&prefix[..index]);\n         \
    \   reverse.push_str(&suffix[..(index + suffix.len())]);\n        } else {\n \
    \           break;\n        }\n        length += 1;\n        suffix = &string[..];\n\
    \    }\n\n    reverse.extend_from_slice(&prefix[..]);\n    reverse.push_str(&suffix);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp30p5i7tr.rs:18:12\n   |\n18 |     while !is_palindrome(&mut postfix)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmp30p5i7tr.rs:25:12\n\
    \   |\n25 |     while !is_palindrome(&mut suffix) {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `prefix` in this\
    \ scope\n  --> /tmp/tmp30p5i7tr.rs:26:21\n   |\n26 |         let index = prefix.find_last_index(suffix);\n\
    \   |                     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `prefix` in this scope\n  --> /tmp/tmp30p5i7tr.rs:28:40\n   |\n28\
    \ |             reverse.extend_from_slice(&prefix[..index]);\n   |           \
    \                             ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `prefix` in this scope\n  --> /tmp/tmp30p5i7tr.rs:37:32\n\
    \   |\n37 |     reverse.extend_from_slice(&prefix[..]);\n   |                \
    \                ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp30p5i7tr.rs:19:19\n   |\n14 |     let mut postfix = string;\n \
    \  |                       ------ expected due to this value\n...\n19 |      \
    \   postfix = &string[..];\n   |                   ^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n19\
    \ |         postfix = (&string[..]).to_string();\n   |                   +   \
    \        +++++++++++++\n\nerror[E0599]: no method named `extend_from_slice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp30p5i7tr.rs:28:21\n\
    \   |\n28 |             reverse.extend_from_slice(&prefix[..index]);\n   |   \
    \                  ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `extend_from_slice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp30p5i7tr.rs:37:13\n   |\n37 |     reverse.extend_from_slice(&prefix[..]);\n\
    \   |             ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 8 previous errors\n\nSome errors hav"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string;\n    for c in new_string.chars() {\n        if *c != *reverse {\n\
    \            break;\n        }\n        *new_string.push(*c)?;\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `reverse` in this scope\n  --> /tmp/tmpf77p3qh2.rs:14:19\n\
    \   |\n14 |         if *c != *reverse {\n   |                   ^^^^^^^ not found\
    \ in this scope\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpf77p3qh2.rs:14:12\n\
    \   |\n14 |         if *c != *reverse {\n   |            ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpf77p3qh2.rs:17:26\n   |\n17 | \
    \        *new_string.push(*c)?;\n   |                          ^^\n\nerror[E0277]:\
    \ the `?` operator can only be applied to values that implement `Try`\n  --> /tmp/tmpf77p3qh2.rs:17:10\n\
    \   |\n17 |         *new_string.push(*c)?;\n   |          ^^^^^^^^^^^^^^^^^^^^\
    \ the `?` operator cannot be applied to type `()`\n   |\n   = help: the trait\
    \ `Try` is not implemented for `()`\n\nerror[E0277]: the `?` operator can only\
    \ be used in a function that returns `Result` or `Option` (or another type that\
    \ implements `FromResidual`)\n  --> /tmp/tmpf77p3qh2.rs:17:29\n   |\n11 | / fn\
    \ make_palindrome(string: String) -> String {\n12 | |     let mut new_string =\
    \ string;\n13 | |     for c in new_string.chars() {\n14 | |         if *c != *reverse\
    \ {\n...  |\n17 | |         *new_string.push(*c)?;\n   | |                   \
    \          ^ cannot use the `?` operator in a function that returns `String`\n\
    18 | |     }\n19 | |     new_string\n20 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `String`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.length\
    \ <= 1 {\n        return string\n    }\n    let mut index = 0\n    let mut s =\
    \ \"\".to_string();\n    let mut rev = String::new();\n    while index < string.length\
    \ {\n        let mut cur = string[index..].chars();\n        while cur.next().map(|c|\
    \ *c).unwrap() == *string {\n            cur = cur.cloned()\n                .take_while(|c|\
    \ !c.is_whitespace())\n                .cloned()\n                .chain(cur)\n\
    \                .cloned()\n                .cloned()\n                .take_while(|c|\
    \ !c.is_whitespace())\n                .cloned()\n                .cloned()\n\
    \                .cloned();\n        }\n        let mut last: Option<char> = None;\n\
    \        for c in cur {\n            let is_last = (index == string.length);\n\
    \            let c = *c;\n            let mut revc = rev[..].chars();\n      \
    \      while revc.next().map(|c| *c).unwrap() == rev[..] {\n                revc\
    \ = revc.cloned()\n                    .take_while(|c| !c.is_whitespace())\n \
    \                   .cloned()\n                    .chain(revc)\n            \
    \        .cloned()\n                    .cloned()\n                    .take_while(|c|\
    \ !c.is_whitespace())\n                    .cloned()\n                    .cloned()\n\
    \                    .cloned();\n            }\n            let mut cur2 = rev[..].chars();\n\
    \            let mut rev2 = revc.cloned();\n            while cur2.next().map(|c|\
    \ *c).unwrap() == rev2 {\n                cur2 = cur2.cloned()\n             \
    \       .take_while(|c| !c.is_whitespace())\n                    .cloned()\n \
    \                   .chain(cur2)\n                    .cloned()\n            \
    \        .cloned()\n                    .take_while(|c| !c.is_whitespace())\n\
    \                    .cloned()\n                    .cloned()\n              \
    \      .cloned();\n            }\n            if *c == *cur2 && *c == *rev2 &&\
    \ *c != *last.unwrap() {\n                s += c;\n                last = Some(c);\n\
    \            } else {\n                s += *last.unwrap();\n                last\
    \ = None;\n            }\n            s += *c;\n        }\n        index += 1;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpulxmc4uk.rs:15:22\n\
    \   |\n15 |     let mut index = 0\n   |                      ^ help: add `;` here\n\
    16 |     let mut s = \"\".to_string();\n   |     --- unexpected token\n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmpulxmc4uk.rs:34:27\n\
    \   |\n34 |             let is_last = (index == string.length);\n   |        \
    \                   ^                      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n34 -             let is_last\
    \ = (index == string.length);\n34 +             let is_last = index == string.length;\n\
    \   | \n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpulxmc4uk.rs:12:15\n\
    \   |\n12 |     if string.length <= 1 {\n   |               ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpulxmc4uk.rs:18:26\n\
    \   |\n18 |     while index < string.length {\n   |                          ^^^^^^\
    \ unknown field\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpulxmc4uk.rs:20:34\n\
    \   |\n20 |         while cur.next().map(|c| *c).unwrap() == *string {\n   | \
    \                                 ^^\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpulxmc4uk.rs:21:23\n \
    \    |\n21   |             cur = cur.cloned()\n     |                       ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `take_while` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpulxmc4uk.rs:22:18\n \
    \  |\n22 |                   .take_while(|c| !c.is_whitespace())\n   |       \
    \             ^^^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n           which\
    \ is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterato"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string.to_lowercase()\n\
    \        .chars()\n        .filter_map(|c| if c.is_alphanumeric() || c == '.'\
    \ {Some(c)} else if c.is_whitespace() {None} else if c.is_punctuation() {None}\
    \ else if c.is_numeric() {None} else {Some(c)})\n        .cloned()\n        .collect::<String>()\n\
    \        .into_iter()\n        .map(|c| {\n            if let Some(first) = {\n\
    \                if let Some(remainder) = string.split_first_by(|&x| x == first).next()\
    \ {\n                    match &*remainder {\n                        &c[..] =>\
    \ {\n                            let mut result = c;\n                       \
    \     for c in remainder.chars().by_ref() {\n                                if\
    \ c != first[0] {\n                                    result = c.to_string()\
    \ + result;\n                                }\n                            }\n\
    \                            result\n                        }\n             \
    \           &_ => unreachable!(),\n                    }\n                } else\
    \ {\n                    c\n                }\n            } else {\n        \
    \        c\n            }\n        })\n        .collect::<String>()\n        .reverse()\n\
    \        .join(\"\") + \"a\"\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `[`\n  --> /tmp/tmpqhnf1zpi.rs:22:27\n\
    \   |\n22 |                         &c[..] => {\n   |                        \
    \   ^ expected one of `=>`, `@`, `if`, or `|`\n\nerror: missing condition for\
    \ `if` expression\n  --> /tmp/tmpqhnf1zpi.rs:19:15\n   |\n19 |             if\
    \ let Some(first) = {\n   |               ^ expected if condition here\n\nerror[E0425]:\
    \ cannot find value `first` in this scope\n  --> /tmp/tmpqhnf1zpi.rs:20:74\n \
    \  |\n20 |                 if let Some(remainder) = string.split_first_by(|&x|\
    \ x == first).next() {\n   |                                                 \
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_punctuation` found for type `char` in the current scope\n  --> /tmp/tmpqhnf1zpi.rs:14:113\n\
    \   |\n14 | ...) {None} else if c.is_punctuation() {None} else if c.is_numeric()\
    \ {None} else {Some(c)})\n   |                       ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0271]:\
    \ type mismatch resolving `<[closure@/tmp/tmpqhnf1zpi.rs:14:21: 14:181] as FnOnce<(char,)>>::Output\
    \ == Option<&_>`\n    --> /tmp/tmpqhnf1zpi.rs:15:10\n     |\n15   |         .cloned()\n\
    \     |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected enum `Option<&_>`\n                found enum `Option<char>`\n    \
    \ = note: required because of the requirements on the impl of `Iterator` for `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpqhnf1zpi.rs:14:21: 14:181]>`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpqhnf1zpi.rs:14:21: 14:181]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpqhnf1zpi.rs:16:10\n   |\n16 |            .collect::<String>()\n\
    \   |             ^^^^^^^ method cannot be called on `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpqhnf1zpi.rs:14:21: 14:181]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<FilterMap<Chars<'_"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ postfix of string that is a palindrome.\n    let max_len = find_max_postfix(string);\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    let mut reversed = String::new();\n    reversed.push_str(&string.chars().rev().take(max_len).collect());\n\
    \    reversed.push_str(&string[max_len..]);\n\n    reversed\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_max_postfix` in this scope\n \
    \ --> /tmp/tmpkf6vrrf5.rs:13:19\n   |\n13 |     let max_len = find_max_postfix(string);\n\
    \   |                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ a value of type `str` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpkf6vrrf5.rs:17:59\n     |\n17   |     reversed.push_str(&string.chars().rev().take(max_len).collect());\n\
    \     |                                                           ^^^^^^^ value\
    \ of type `str` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `str`\n  \
    \   = help: the following other types implement trait `FromIterator<A>`:\n   \
    \            <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = [string[0]];\n    let mut reversed_suffix = suffix;\n    loop {\n        let\
    \ mut last_char_index = suffix.len() - 1;\n        while last_char_index >= 0\
    \ && suffix[last_char_index] != string[last_char_index] {\n            last_char_index\
    \ -= 1;\n        }\n        if last_char_index >= 0 {\n            suffix.remove(last_char_index);\n\
    \            reversed_suffix.push(suffix[0]);\n        } else {\n            break;\n\
    \        }\n    }\n    string[suffix.len()..].to_owned() + reversed_suffix.to_owned()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7_acx3ds.rs:12:23\n   |\n12 |     let mut suffix = [string[0]];\n  \
    \ |                       ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7_acx3ds.rs:16:66\n   |\n16 |         while last_char_index >=\
    \ 0 && suffix[last_char_index] != string[last_char_index] {\n   |            \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `remove` found for array `[_; 1]`\
    \ in the current scope\n  --> /tmp/tmp7_acx3ds.rs:20:20\n   |\n20 |          \
    \   suffix.remove(last_char_index);\n   |                    ^^^^^^ method not\
    \ found in `[_; 1]`\n\nerror[E0599]: no method named `push` found for array `[_;\
    \ 1]` in the current scope\n  --> /tmp/tmp7_acx3ds.rs:21:29\n   |\n21 |      \
    \       reversed_suffix.push(suffix[0]);\n   |                             ^^^^\
    \ method not found in `[_; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_acx3ds.rs:26:41\n\
    \   |\n26 |     s"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut reversed: String = \"\";\n \
    \   for c in string.chars() {\n        if c == c.to_string(char::reverse) {\n\
    \            reversed.push(c);\n        } else {\n            reversed.push(c);\n\
    \        }\n    }\n    reversed.reverse();\n    reversed + &string[1..]\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0noskxu.rs:16:32\n   |\n\
    16 |     let mut reversed: String = \"\";\n   |                       ------ \
    \  ^^- help: try using a conversion method: `.to_string()`\n   |             \
    \          |        |\n   |                       |        expected struct `String`,\
    \ found `&str`\n   |                       expected due to this\n\nerror[E0599]:\
    \ no function or associated item named `reverse` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb0noskxu.rs:18:35\n   |\n18 |         if c == c.to_string(char::reverse)\
    \ {\n   |                                   ^^^^^^^ function or associated item\
    \ not found in `char`\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n    --> /tmp/tmpb0noskxu.rs:18:19\n     |\n18   |         if c\
    \ == c.to_string(char::reverse) {\n     |                   ^^^^^^^^^ -------------\
    \ supplied 1 argument\n     |                   |\n     |                   expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb0noskxu.rs:18:17\n   |\n18 |         if c ==\
    \ c.to_string(char::reverse) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpb0noskxu.rs:24:14\n\
    \   |\n24 |     reversed.reverse();\n   |              ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ postfix palindrome of supplied string.\n    let mut len = string.len();\n  \
    \  let mut longest = 0;\n    let mut i = 0;\n    for _ in 0..len {\n        if\
    \ let Some(middle) = string.find_last_index(&string[i], len - i) {\n         \
    \   longest = middle;\n            i += longest;\n        } else {\n         \
    \   return string.to_string();\n        }\n    }\n    let mut palindrome = string[i];\n\
    \    let mut rest = string[len - longest..];\n    while let Some(middle) = rest.find_last_index(&palindrome)\
    \ {\n        palindrome = &rest[..middle];\n        rest = &rest[middle..];\n\
    \    }\n    return palindrome + &rest;\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_last_index` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1xi0obrz.rs:17:38\n   |\n17 |         if\
    \ let Some(middle) = string.find_last_index(&string[i], len - i) {\n   |     \
    \                                 ^^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1xi0obrz.rs:17:55\n\
    \   |\n17 |         if let Some(middle) = string.find_last_index(&string[i], len\
    \ - i) {\n   |                                                       ^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1xi0obrz.rs:24:26\n   |\n24 |     let mut palindrome = string[i];\n\
    \   |                          ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `find_last_index` found for type\
    \ `str` in the current scope\n  --> /tmp/tmp1xi0obrz.rs:26:35\n   |\n26 |    \
    \ while let Some(middle) = rest.find_last_index(&palindrome) {\n   |         \
    \                          ^^^^^^^^^^^^^^^ method not found in `str`\n\nerr"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string;\n    let mut len: usize = string.len();\n    while len > 1 {\n   \
    \     reverse = string[len - 2];\n        len -= 1;\n    }\n    let mut new_string\
    \ = reverse;\n    for ch in string.chars().cloned() {\n        if *ch != *new_string\
    \ {\n            break;\n        }\n        new_string = ch.to_string();\n   \
    \ }\n    string.append(&new_string);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppqbs66mj.rs:15:19\n\
    \   |\n15 |         reverse = string[len - 2];\n   |                   ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmppqbs66mj.rs:19:30\n     |\n19   |     for ch in string.chars().cloned()\
    \ {\n     |                              ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmppqbs66mj.rs:19:15\n\
    \   |\n19 |     for ch in string.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmppqbs66mj.rs:19:15\n   |\n19 |     for ch in string.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    let mut suffix = string;\n\
    \    let mut prefix;\n    while let Some(prefix_char) = suffix.rfind(&suffix[..])\
    \ {\n        // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n        suffix = &suffix[..prefix_char.reverse().len()];\n\
    \        prefix = &prefix[..prefix_char.reverse().len()];\n    }\n    let mut\
    \ reversed_suffix;\n    if suffix.len() > 0 {\n        // If the longest postfix\
    \ is of length > 1, reverse it to build the palindrome.\n        reversed_suffix\
    \ = suffix\n            .chars()\n            .map(|char| char.to_string().to_lowercase())\n\
    \            .collect::<Vec<_>>()\n            .join();\n    }\n    let mut palindrome\
    \ = prefix.to_owned();\n    palindrome.push(&*reversed_suffix);\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpcyzi_t0f.rs:17:40\n   |\n17 |         suffix = &suffix[..prefix_char.reverse().len()];\n\
    \   |                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcyzi_t0f.rs:17:18\n   |\n13 |     let mut suffix = string;\n  \
    \ |                      ------ expected due to this value\n...\n17 |        \
    \ suffix = &suffix[..prefix_char.reverse().len()];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n17 |         suffix = (&suffix[..prefix_char.reverse().len()]).to_string();\n\
    \   |                  +                                      +++++++++++++\n\n\
    error[E0599]: no method named `reverse` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpcyzi_t0f.rs:18:40\n   |\n18 |         prefix = &prefix[..prefix_char.reverse().len()];\n\
    \   |                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpcyzi_t0f.rs:27:14\n\
    \    |\n27  |             .join();\n    |              ^^^^- supplied 0 arguments\n\
    \    |              |\n    |              expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    let mut index = 0..string.len() - 1;\n    while index < reversed_string.len()\
    \ {\n        let mut char = reversed_string[index];\n        if char != string[index]\
    \ {\n            reversed_string = reversed_string\n                .split_last_mut()\n\
    \                .expect(\"Could not split string\")\n                .unwrap()\n\
    \                .reverse()\n                .chain(String::from(\"a\"))\n   \
    \             .collect::<String>()\n                .join(\"a\");\n        }\n\
    \        index += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `<` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmpjlwf0t40.rs:14:17\n   |\n14 |     while index < reversed_string.len()\
    \ {\n   |           ----- ^ --------------------- usize\n   |           |\n  \
    \ |           std::ops::Range<usize>\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpjlwf0t40.rs:15:13\n\
    \   |\n15 |         let mut char = reversed_string[index];\n   |             ^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n15 |         let mut char = &reversed_string[index];\n\
    \   |                        +\n\nerror[E0599]: no method named `split_last_mut`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpjlwf0t40.rs:18:18\n\
    \   |\n18 |                 .split_last_mut()\n   |                  ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmpjlwf0t40.rs:26:9\n   |\n26 |         index += 1;\n   |        \
    \ -----^^^^^\n   |         |\n   |         cannot use `+=` on type `std::ops::Range<usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n    let mut palindrome = string;\n    let\
    \ mut suffix_length = 0;\n    for c in string.chars() {\n        if c.is_alphanumeric()\
    \ {\n            suffix_length = suffix_length + c.len_utf8();\n        }\n  \
    \  }\n    let mut prefix_length = string.len() - suffix_length;\n    let mut reversed_string\
    \ = String::new();\n    let mut previous_c = 0;\n    while prefix_length >= 0\
    \ {\n        if reversed_string.len() > 0 {\n            reversed_string.push(c);\n\
    \        }\n        if c.is_alphanumeric() {\n            reversed_string.push(c);\n\
    \        }\n        reversed_string.push(palindrome[prefix_length]);\n       \
    \ prefix_length -= 1;\n    }\n    palindrome = reversed_string;\n    return palindrome;\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptqw2ofl0.rs:27:34\n\
    \   |\n27 |             reversed_string.push(c);\n   |                       \
    \           ^ not found in this scope\n\nerror[E0425]: cannot find value `c` in\
    \ this scope\n  --> /tmp/tmptqw2ofl0.rs:29:12\n   |\n29 |         if c.is_alphanumeric()\
    \ {\n   |            ^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `c` in this scope\n  --> /tmp/tmptqw2ofl0.rs:30:34\n   |\n30 |             reversed_string.push(c);\n\
    \   |                                  ^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptqw2ofl0.rs:32:30\n\
    \   |\n32 |         reversed_string.push(palindrome[prefix_length]);\n   |   \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = string;\n    let mut prefix = string;\n    let mut palindrome = string;\n\n\
    \    // Find postfix of palindrome that starts with string.\n    let mut index\
    \ = prefix.rfind(&suffix).unwrap();\n    while index != Ok(0) {\n        palindrome\
    \ = palindrome[index..].to_string() + palindrome[..index].to_string() + suffix;\n\
    \        prefix = prefix[..index] + prefix[index..];\n        index = prefix.rfind(&suffix).unwrap();\n\
    \    }\n\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpegvxeiy_.rs:18:20\n   |\n\
    18 |     while index != Ok(0) {\n   |                    ^^^^^ expected `usize`,\
    \ found enum `Result`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Result<{integer}, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegvxeiy_.rs:19:56\n\
    \   |\n19 |         palindrome = palindrome[index..].to_string() + palindrome[..index].to_string()\
    \ + suffix;\n   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                        |\n   |         \
    \                                               expected `&str`, found struct\
    \ `String`\n   |                                                        help:\
    \ consider borrowing here: `&palindrome[..index].to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpegvxeiy_.rs:19:90\n   |\n19 |         palindrome\
    \ = palindrome[index..].to_string() + palindrome[..index].to_string() + suffix;\n\
    \   |                                                                        \
    \                  ^^^^^^\n   |                                              \
    \                                            |\n   |                         \
    \                                                                 expected `&str`,\
    \ found struct `String`\n   |                                                \
    \                                          help: consider borrowing here: `&suffix`\n\
    \nerror[E0369]: cannot add `str` to `str`\n  --> /tmp/tmpegvxeiy_.rs:20:34\n \
    \  |\n20 |         prefix = prefix[..index] + prefix[index..];\n   |         \
    \         --------------- ^ --------------- str\n   |                  |\n   |\
    \                  str\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string;\
    \ // Copy string into s\n    let mut longest_palindrome = String::new(); // Longest\
    \ palindromic suffix ends with this string\n\n    // Find the longest postfix\
    \ of string that is a palindrome.\n    // For example suppose string is abc\n\
    \    // Let longest palindromic suffix end with 'c' and longest postfix is b\n\
    \    let mut longest_postfix_index = String::new();\n\n    for index in 0..s.len()\
    \ - 1 {\n        longest_postfix_index.clear();\n        let mut longest_prefix_index\
    \ = 0;\n        while longest_prefix_index < longest_postfix_index.len() {\n \
    \           longest_prefix_index.clear();\n            longest_prefix_index =\
    \ longest_postfix_index.len();\n            for index2 in 0..longest_prefix_index.len()\
    \ {\n                if index2 == longest_prefix_index.len() - 1 && s[longest_prefix_index]\
    \ == '-' {\n                    longest_prefix_index += 1;\n                }\
    \ else if s[longest_prefix_index] == s[longest_prefix_index + index2] {\n    \
    \                longest_prefix_index += 1;\n                } else {\n      \
    \              break;\n                }\n            }\n            longest_postfix_index.clear();\n\
    \            for index3 in 0..longest_prefix_index.len() {\n                longest_postfix_index.push_back(s[longest_prefix_index\
    \ - index3]);\n            }\n        }\n        longest_palindrome = longest_palindrome.append(longest_postfix_index);\n\
    \    }\n    return longest_palindrome;\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `clear` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmph38y4vo8.rs:24:34\n   |\n24 |             longest_prefix_index.clear();\n\
    \   |                                  ^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmph38y4vo8.rs:26:51\n\
    \   |\n26 |             for index2 in 0..longest_prefix_index.len() {\n   |  \
    \                                                 ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmph38y4vo8.rs:27:51\n   |\n27 |                 if index2 == longest_prefix_index.len()\
    \ - 1 && s[longest_prefix_index] == '-' {\n   |                              \
    \                     ^^^ method not found in `usize`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmph38y4vo8.rs:27:64\n   |\n\
    27 |                 if index2 == longest_prefix_index.len() - 1 && s[longest_prefix_index]\
    \ == '-' {\n   |                                                             \
    \   ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph38y4vo8.rs:29:27\n\
    \   |\n29 |                 } else if s[longest_prefix_index] == s[longest_prefix_index\
    \ + index2] {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n       "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (longest_palindrome_prefix,\
    \ longest_palindrome_suffix) = get_longest_palindrome_prefix_suffix(string);\n\
    \    longest_palindrome_suffix.rev().to_owned() + longest_palindrome_prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_longest_palindrome_prefix_suffix`\
    \ in this scope\n  --> /tmp/tmpok0bap2b.rs:12:66\n   |\n12 |     let (longest_palindrome_prefix,\
    \ longest_palindrome_suffix) = get_longest_palindrome_prefix_suffix(string);\n\
    \   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.to_string();\n    let mut reversed_string = string;\n    loop {\n \
    \       string = reversed_string;\n        if let Some(ref mut palindrome) = string\n\
    \            .find_first_of(&string[..])\n            .map(|i| if *i == 0 { None\
    \ } else { Some(string.clone().rev().to_string().chars().nth(i).unwrap()) })\n\
    \        {\n            reversed_string += palindrome;\n        } else {\n   \
    \         break;\n        }\n    }\n    return string;\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `find_first_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmposmi7e0m.rs:17:14\n   |\n17 |          \
    \   .find_first_of(&string[..])\n   |              ^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmposmi7e0m.rs:18:69\n\
    \    |\n18  |               .map(|i| if *i == 0 { None } else { Some(string.clone().rev().to_string().chars().nth(i).unwrap())\
    \ })\n    |                                                                  \
    \     ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmposmi7e0m.rs:16:16\n    |\n16  |         if let Some(ref\
    \ mut palindrome) = string\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Some`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string.chars().collect::<Vec<u8>>();\n    let mut reverse: Vec<u8> = string.clone();\n\
    \    reverse.reverse();\n    reverse.insert(0, 0);\n    let mut start = string;\n\
    \    let mut end = string;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let start = index as usize;\n        let end = string.len();\n  \
    \      let mut index = start;\n        while index != end {\n            let c\
    \ = string[index];\n            let mut index2 = index;\n            while index2\
    \ != end && string[index2] == c {\n                index2 += 1;\n            }\n\
    \            let mut index3 = index;\n            while index3 != end && string[index3]\
    \ == c {\n                index3 += 1;\n            }\n            let mut index4\
    \ = index;\n            while index4 != end && string[index4] == c {\n       \
    \         index4 += 1;\n            }\n            let mut index5 = index;\n \
    \           while index5 != end && string[index5] == c {\n                index5\
    \ += 1;\n            }\n            let mut index6 = index;\n            while\
    \ index6 != end && string[index6] == c {\n                index6 += 1;\n     \
    \       }\n            let mut index7 = index;\n            while index7 != end\
    \ && string[index7] == c {\n                index7 += 1;\n            }\n    \
    \        let mut index8 = index;\n            while index8 != end && string[index8]\
    \ == c {\n                index8 += 1;\n            }\n            let mut index9\
    \ = index;\n            while index9 != end && string[index9] == c {\n       \
    \         index9 += 1;\n            }\n            let mut index10 = index;\n\
    \            while index10 != end && string[index10] == c {\n                index10\
    \ += 1;\n            }\n            let mut index11 = index;\n            while\
    \ index11 != end && string[index11] == c {\n                index11 += 1;\n  \
    \          }\n            let mut index12 = index;\n            while index12\
    \ != end && string[index12] == c {\n                index12 += 1;\n          \
    \  }\n            let mut index13 = index;\n            while index13 != end &&\
    \ string[index13] == c {\n                index13 += 1;\n            }\n     \
    \       let mut index14 = index;\n            while index14 != end && string[index14]\
    \ == c {\n                index14 += 1;\n            }\n            let mut index15\
    \ = index;\n            while index15 != end && string[index15] == c {\n     \
    \           index15 += 1;\n            }\n            let mut index16 = index;\n\
    \            while index16 != end && string[index16] == c {\n                \n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpv8euyo01.rs:93:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n19 |     while index\
    \ < string.len() {\n   |                                - unclosed delimiter\n\
    ...\n23 |         while index != end {\n   |                            - unclosed\
    \ delimiter\n...\n82 |             while index16 != end && string[index16] ==\
    \ c {\n   |                                                          - this delimiter\
    \ might not be properly closed...\n83 |                 \n84 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n93 | }\n   |   ^\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpv8euyo01.rs:12:37\n     |\n12   | \
    \    let mut string = string.chars().collect::<Vec<u8>>();\n     |           \
    \                          ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv8euyo01.rs:19:5\n   |\n11 |   fn make_palindrome(string:\
    \ String) -> String {\n   |                                         ------ expected\
    \ `String` because of return type\n...\n19 | /     while index < string.len()\
    \ {\n20 | |         let start = index as usize;\n21 | |         let end = string.len();\n\
    22 | |         let mut index = start;\n...  |\n92 | |     assert_eq!(candidate(String::from(\"\
    jerry\")), String::from(\"jerryrrej\"));\n93 | | }\n   | |__^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut index\
    \ = 0;\n    let mut reversed_string = string;\n    while index < string.len()\
    \ {\n        let index = reversed_string.rfind('i', index);\n        if index\
    \ == 0 {\n            break;\n        }\n        let substring = &reversed_string[index..];\n\
    \        let reversed_substring = reversed_string.slice(-index).reverse();\n \
    \       let full_substring = &reversed_substring[0..index];\n        if full_substring\
    \ == substring {\n            break;\n        }\n        reversed_string = &reversed_substring[..];\n\
    \        index += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpe_ud0pe4.rs:15:37\n     |\n15   |         let index = reversed_string.rfind('i',\
    \ index);\n     |                                     ^^^^^ ---  ----- supplied\
    \ 2 arguments\n     |                                     |\n     |          \
    \                           expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_ud0pe4.rs:16:21\n\
    \   |\n16 |         if index == 0 {\n   |                     ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         if index == Some(0) {\n   |                     +++++ +\n\n\
    error[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpe_ud0pe4.rs:19:26\n   |\n19 |         let substring = &reversed_string[index..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `slice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpe_ud0pe4.rs:20:50\n   |\n20 |         let\
    \ reversed_substring = reversed_string.slice(-index).reverse();\n   |        \
    \                                          ^^^^^ help: there is an associated\
    \ function with a similar name: `split_once`\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `Option<usize>`\n  --> /tmp/tmpe_ud0pe4.rs:20:56\n   |\n\
    20 |         let reversed_substring = reversed_stri"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut index\
    \ = string.len();\n    let mut rev_string = string;\n    while index > 0 {\n \
    \       rev_string = string[index..].chars().collect::<String>().reverse().join(\"\
    \");\n        if rev_string == string {\n            break;\n        }\n     \
    \   index -= 1;\n    }\n    rev_string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwu2v370l.rs:15:66\n   |\n15 |         rev_string\
    \ = string[index..].chars().collect::<String>().reverse().join(\"\");\n   |  \
    \                                                                ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = string;\n    let mut reverse = string;\n    while suffix.chars().any(|c| c\
    \ != reverse.chars().nth(suffix.len() - 1 - c.0)) {\n        if suffix.len() <\
    \ 2 {\n            return \"\";\n        }\n        let mut suffix_reverse = suffix;\n\
    \        let mut reverse = reverse;\n        for c in suffix_reverse {\n     \
    \       reverse = reverse.chars().nth(suffix_reverse.len() - 1 - c);\n       \
    \ }\n        suffix = \"{}{}\".format(suffix_reverse, reverse);\n    }\n    return\
    \ suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0610]: `char` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp255rdytt.rs:14:80\n   |\n14 |     while suffix.chars().any(|c|\
    \ c != reverse.chars().nth(suffix.len() - 1 - c.0)) {\n   |                  \
    \                                                              ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp255rdytt.rs:14:39\n   |\n14 |     while suffix.chars().any(|c|\
    \ c != reverse.chars().nth(suffix.len() - 1 - c.0)) {\n   |                  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp255rdytt.rs:16:20\n\
    \   |\n16 |             return \"\";\n   |                    ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                    |\n   |       \
    \             expected struct `String`, found `&str`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmp255rdytt.rs:20:18\n   |\n20 |         for\
    \ c in suffix_reverse {\n   |                  ^^^^^^^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp255rdytt.rs:21:23\n   |\n19 |         let mut reverse =\
    \ reverse;\n   |                           ------- expected due to this value\n\
    20 |         for c in suffix_reverse {\n21 |             reverse = reverse.chars().nth(suffix_reverse.len()\
    \ - 1 - c);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<char>`\n\nerror[E0599]: no method\
    \ named `format` found for reference `&'static str` in the current scope\n  -->\
    \ /tmp/tmp255rdytt.rs:23:25\n   |\n23 |         suffix = \"{}{}\".format(suffix_reverse,\
    \ reverse);\n   |                         ^^^^^^ method not found in `&'"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.len()\
    \ <= 2 {\n        return string;\n    }\n    let mut start = string;\n    let\
    \ mut end = string;\n    let mut min_len = 2;\n    let mut max_len = string.len();\n\
    \    let mut postfix_start = String::new();\n    let mut postfix_end = String::new();\n\
    \    while let Some(char) = get_longest_palindrome(start, end) {\n        let\
    \ mut start = string;\n        let mut end = string;\n        start.push_str(&char);\n\
    \        while let Some(char) = get_longest_palindrome(start, end) {\n       \
    \     let char = String::from(char);\n            if char == char {\n        \
    \        start = start + char;\n                end = end + char;\n          \
    \      continue;\n            }\n            postfix_start.push_str(&char);\n\
    \            if start != end {\n                postfix_end.push_str(&char);\n\
    \                start = end;\n            }\n            start = start + char;\n\
    \            end = end + char;\n        }\n        if min_len > max_len {\n  \
    \          min_len = max_len;\n        }\n        max_len = max_len + 1;\n   \
    \ }\n    if postfix_start != postfix_end {\n        postfix_end.push_str(&postfix_start);\n\
    \    }\n    start + &postfix_end\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_longest_palindrome` in this scope\n\
    \  --> /tmp/tmpysj2cbuc.rs:21:28\n   |\n21 |     while let Some(char) = get_longest_palindrome(start,\
    \ end) {\n   |                            ^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `get_longest_palindrome` in\
    \ this scope\n  --> /tmp/tmpysj2cbuc.rs:25:32\n   |\n25 |         while let Some(char)\
    \ = get_longest_palindrome(start, end) {\n   |                               \
    \ ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmpysj2cbuc.rs:21:20\n\
    \   |\n21 |     while let Some(char) = get_longest_palindrome(start, end) {\n\
    \   |                    ^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpysj2cbuc.rs:21:15\n    |\n21  |\
    \     while let Some(char) = get_longest_palindrome(start, end) {\n    |     \
    \          ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    =\
    \ help: the trait `Sized` is not implemented for `str`\nnote: required by a bound\
    \ in `Some`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpysj2cbuc.rs:28:33\n\
    \   |\n28 |                 start = start + char;\n   |                      \
    \           ^^^^\n   |                                 |\n   |               \
    \                  expected `&str`, found struct `String`\n   |              \
    \                   help: consider borrowing here: `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpysj2cbuc.rs:29:29\n   |\n29 |                 end = end\
    \ + char;\n   |                             ^^^^\n   |                       \
    \      |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&char`\n\nerror[E0308]:\
    \ mismatched types\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    let mut suffix = string.reverse();\n    let mut index\
    \ = 0;\n\n    while suffix[index] == reversed[index] {\n        reversed.swap(0,\
    \ index + 1);\n        index += 1;\n    }\n\n    reversed.swap(0, index + 1);\n\
    \n    reversed.append::<String>(reversed)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwqm8x380.rs:13:29\n   |\n13 |     let mut suffix\
    \ = string.reverse();\n   |                             ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwqm8x380.rs:16:28\n\
    \   |\n16 |     while suffix[index] == reversed[index] {\n   |               \
    \             ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwqm8x380.rs:17:18\n   |\n17 |         reversed.swap(0,\
    \ index + 1);\n   |                  ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpwqm8x380.rs:21:14\n   |\n21 |     reversed.swap(0, index + 1);\n   |\
    \              ^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmpwqm8x380.rs:23:14\n\
    \   |\n23 |     reversed.append::<String>(reversed)\n   |              ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    make_palindrome_impl(string,\
    \ \"\", string.chars().collect::<String>().reverse());\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `make_palindrome_impl` in this scope\n\
    \  --> /tmp/tmp99d2mhd_.rs:12:5\n   |\n12 |     make_palindrome_impl(string, \"\
    \", string.chars().collect::<String>().reverse());\n   |     ^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp99d2mhd_.rs:12:73\n   |\n\
    12 |     make_palindrome_impl(string, \"\", string.chars().collect::<String>().reverse());\n\
    \   |                                                                        \
    \ ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp99d2mhd_.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut strings\
    \ = vec![string];\n\n    for &s in &strings {\n        if s.chars().all(|c| !c.is_ascii_lowercase())\
    \ {\n            return s; // The string must be only lower case ascii characters\n\
    \        }\n    }\n\n    let mut max = 0;\n    let mut min_length = 1;\n    let\
    \ mut prefix = \"\";\n    let mut postfix = string;\n\n    for &s in &strings\
    \ {\n        if s.chars().all(|c| !c.is_ascii_lowercase()) {\n            return\
    \ s; // The string must be only lower case ascii characters\n        }\n\n   \
    \     let mut prefix_length = 0;\n        let mut postfix_length = 0;\n\n    \
    \    for &c in &s {\n            if !c.is_ascii_lowercase() {\n              \
    \  continue;\n            }\n\n            if c != c[0] {\n                break;\n\
    \            }\n\n            prefix_length += 1;\n        }\n\n        for &c\
    \ in &s {\n            if !c.is_ascii_lowercase() {\n                continue;\n\
    \            }\n\n            if c != c[-1] {\n                break;\n      \
    \      }\n\n            postfix_length += 1;\n        }\n\n        if prefix_length\
    \ > postfix_length {\n            continue;\n        }\n\n        if prefix_length\
    \ < min {\n            min = prefix_length;\n        }\n\n        if postfix_length\
    \ < min {\n            min = postfix_length;\n        }\n\n        if prefix_length\
    \ >= max {\n            max = prefix_length;\n        }\n\n        if postfix_length\
    \ >= max {\n            max = postfix_length;\n        }\n    }\n\n    if min\
    \ == max {\n        return string; // No palindrome could be found with this string\n\
    \    }\n\n    let mut reversed_prefix = String::new();\n    let mut reversed_postfix\
    \ = String::new();\n\n    for &s in &strings {\n        if s.chars().all(|c| !c.is_ascii_lowercase())\
    \ {\n            return s; // The string must be only lower case ascii characters\n\
    \        }\n\n        for &c in &s {\n            if !c.is_ascii_lowercase() {\n\
    \                continue;\n            }\n\n            if c != c[0] {\n    \
    \            break;\n            }\n\n            reversed_prefix.push(c);\n \
    \       }\n\n        for &c in &s {\n            if !c.is_ascii_lowercase() {\n\
    \                continue;\n            }\n\n            if c != c[-1] {\n   \
    \             break;\n            }\n\n            reversed_postfix.push(c);\n\
    \        }\n    }\n\n    let mut strings = vec![string];\n\n    for &s in &strings\
    \ {\n        if s.chars().all(|c| !c.is_ascii_lowercase()) {\n            return\
    \ s; // The string must be only lower case ascii characters\n        }\n\n   \
    \     for &c in &s {\n            if !c.is_ascii_lowercase() {\n             \
    \   continue;\n            }\n\n            if c \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj6ic9btr.rs:137:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n117 |     for\
    \ &s in &strings {\n    |                        - unclosed delimiter\n...\n122\
    \ |         for &c in &s {\n    |                      - this delimiter might\
    \ not be properly closed...\n...\n128 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpj6ic9btr.rs:128:1\n    |\n127 |             if c \n    |\
    \             -- this `if` expression has a condition, but no block\n128 | }\n\
    \    | ^ expected `{`\n\nerror[E0425]: cannot find value `min` in this scope\n\
    \  --> /tmp/tmpj6ic9btr.rs:61:28\n   |\n61 |         if prefix_length < min {\n\
    \   |                            ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find value `min` in this scope\n  --> /tmp/tmpj6ic9btr.rs:62:13\n   |\n\
    62 |             min = prefix_length;\n   |             ^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmpj6ic9btr.rs:65:29\n\
    \   |\n65 |         if postfix_length < min {\n   |                          \
    \   ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find value `min`\
    \ in this scope\n  --> /tmp/tmpj6ic9btr.rs:66:13\n   |\n66 |             min =\
    \ postfix_length;\n   |             ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find value `min` in this scope\n  --> /tmp/tmpj6ic9btr.rs:78:8\n   |\n\
    78 |     if min == max {\n   |        ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmpj6ic9btr.rs:33:19\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    palindrome.push('\\0');\n\n    for mut index = (string.length()\
    \ / 2) - 1; index >= 0; index-- {\n        let mut current = string[index];\n\n\
    \        for _ in 0..index {\n            palindrome[..index] += &current;\n \
    \           current += 1;\n        }\n    }\n\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpasbvkx1d.rs:15:18\n  \
    \ |\n15 |     for mut index = (string.length() / 2) - 1; index >= 0; index-- {\n\
    \   |                  ^ help: try adding `in` here\n\nerror: expected expression,\
    \ found `=`\n  --> /tmp/tmpasbvkx1d.rs:15:19\n   |\n15 |     for mut index = (string.length()\
    \ / 2) - 1; index >= 0; index-- {\n   |                   ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut i = 1;\n\
    \    let mut result = string;\n    let mut j = string.len() - 1;\n    while i\
    \ <= j {\n        let first_char = &string[i..].chars().next().unwrap();\n   \
    \     let second_char = &string[j..].chars().next().unwrap();\n        if first_char\
    \ == second_char {\n            i += 1;\n            j -= 1;\n            continue;\n\
    \        }\n        if first_char > second_char {\n            i += 1;\n     \
    \   } else {\n            j -= 1;\n        }\n        result = result.insert(0,\
    \ first_char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpibp8qsk_.rs:28:35\n   |\n\
    28 |         result = result.insert(0, first_char);\n   |                    \
    \               ^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |         result = result.insert(0, *first_char);\n\
    \   |                                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpibp8qsk_.rs:28:18\n   |\n13 |     let mut result = string;\n  \
    \ |                      ------ expected due to this value\n...\n28 |        \
    \ result = result.insert(0, first_char);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpibp8qsk_.rs:28:25\n   |\n28 |         result\
    \ = result.insert(0, first_char);\n   |                  ------ ^^^^^^ this call\
    \ modifies `result` in-place\n   |                  |\n   |                  you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `insert`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let len = string.len();\n    if len < 2 {\n        return palindrome;\n\
    \    }\n    let prefix_len = string.rfind('').unwrap();\n    let suffix_len =\
    \ len - prefix_len;\n    for i in 0..prefix_len {\n        palindrome.push(palindrome[prefix_len..].chars().collect::<String>().reverse().collect::<String>().to_lowercase());\n\
    \    }\n    for i in 0..suffix_len {\n        palindrome.push(palindrome[suffix_len..].chars().collect::<String>().collect::<String>().to_lowercase());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmp8zeuwj89.rs:17:36\n   |\n\
    17 |     let prefix_len = string.rfind('').unwrap();\n   |                   \
    \                 ^ empty character literal\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp8zeuwj89.rs:20:78\n\
    \   |\n20 |         palindrome.push(palindrome[prefix_len..].chars().collect::<String>().reverse().collect::<String>().to_lowercase());\n\
    \   |                                                                        \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmp8zeuwj89.rs:23:78\n\
    \    |\n23  |           palindrome.push(palindrome[suffix_len..].chars().collect::<String>().collect::<String>().to_lowercase());\n\
    \    |                                                                       \
    \         ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut max_len\
    \ = string.len() as i32;\n    let mut prefix_reverse = String::new();\n    for\
    \ (i, char) in string.chars().enumerate() {\n        let prefix_idx = i + 1;\n\
    \        let suffix = (&string[prefix_idx..prefix_idx..prefix_idx + 1]).collect::<String>().to_owned();\n\
    \        let palindrome_suffix = match palindrome(suffix) {\n            Some(p)\
    \ => p.to_string(),\n            None => suffix.to_string(),\n        };\n   \
    \     prefix_reverse += &char * &palindrome_suffix;\n    }\n    prefix_reverse\
    \ += &string[1..max_len.iter().cloned().rev().take()]\n        .collect::<String>()\n\
    \        .to_owned();\n    prefix_reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmp_vlwmog6.rs:16:53\n   |\n16 |         let suffix = (&string[prefix_idx..prefix_idx..prefix_idx\
    \ + 1]).collect::<String>().to_owned();\n   |                                \
    \                     ^^ expected one of 7 possible tokens\n\nerror[E0425]: cannot\
    \ find function `palindrome` in this scope\n  --> /tmp/tmp_vlwmog6.rs:17:39\n\
    \   |\n17 |         let palindrome_suffix = match palindrome(suffix) {\n   | \
    \                                      ^^^^^^^^^^ not found in this scope\n\n\
    error[E0369]: cannot multiply `&char` by `&_`\n  --> /tmp/tmp_vlwmog6.rs:21:33\n\
    \   |\n21 |         prefix_reverse += &char * &palindrome_suffix;\n   |      \
    \                     ----- ^ ------------------ &_\n   |                    \
    \       |\n   |                           &char\n\nerror[E0599]: no method named\
    \ `iter` found for type `i32` in the current scope\n  --> /tmp/tmp_vlwmog6.rs:23:42\n\
    \   |\n23 |     prefix_reverse += &string[1..max_len.iter().cloned().rev().take()]\n\
    \   |                                          ^^^^ method not found in `i32`\n\
    \nerror[E0599]: `str` is not an iterator\n  --> /tmp/tmp_vlwmog6.rs:24:10\n  \
    \ |\n24 |         .collect::<String>()\n   |          ^^^^^^^ `str` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut rev =\
    \ string;\n    rev.push(&mut rev.split_off(|c| !c.is_alphanumeric()).rev().collect::<Vec<_>>()[0]);\n\
    \    rev.rev();\n    let mut prefix: Vec<usize> = vec![];\n    let mut suffix\
    \ = string;\n    while suffix.starts_with(&mut prefix) {\n        prefix.push(suffix.starts_with(&mut\
    \ prefix).unwrap());\n        suffix.remove(0);\n    }\n    prefix.reverse();\n\
    \    rev.extend(prefix.clone());\n    rev.extend(suffix.clone());\n    rev\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpv0feqbrx.rs:13:34\n\
    \   |\n13 |     rev.push(&mut rev.split_off(|c| !c.is_alphanumeric()).rev().collect::<Vec<_>>()[0]);\n\
    \   |                                  ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpv0feqbrx.rs:13:59\n    |\n13  |       rev.push(&mut\
    \ rev.split_off(|c| !c.is_alphanumeric()).rev().collect::<Vec<_>>()[0]);\n   \
    \ |                                                             ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpv0feqbrx.rs:14:9\n    |\n14  |       rev.rev();\n\
    \    |           ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `Vec<usize>`\n    -->\
    \ /tmp/tmpv0feqbrx.rs:17:30\n     |\n17   |     while suffix.starts_with(&mut\
    \ prefix) {\n     |                  ----------- ^^^^^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `Vec<usize>`\n     |                  |\n     |             \
    \     required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `FnMut<(char,)>` is not implemented for `Vec<usize>`\n     = help: the following\
    \ other types implement trait `Pattern<'a>`:\n               &'b String\n    \
    \           &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    reversed_string = reversed_string.rev();\n    let mut last_index\
    \ = reversed_string.len();\n\n    for (index, char) in reversed_string.chars().enumerate()\
    \ {\n        if *char != *reversed_string[index] {\n            last_index = index;\n\
    \            break;\n        }\n    }\n    let result = &reversed_string[0..last_index];\n\
    \n    result.reverse()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp2ha6dpqu.rs:13:39\n\
    \    |\n13  |       reversed_string = reversed_string.rev();\n    |          \
    \                               ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp2ha6dpqu.rs:17:12\n\
    \   |\n17 |         if *char != *reversed_string[index] {\n   |            ^^^^^\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2ha6dpqu.rs:17:22\n\
    \   |\n17 |         if *char != *reversed_string[index] {\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp2ha6dpqu.rs:24:12\n   |\n24 |     result.reverse()\n   |      \
    \      ^^^^^^^ method not found in `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        \"\".to_string()\n    } else {\n        let mut longest_prefix_length\
    \ = 0;\n        let mut shortest_suffix_length = 0;\n        let mut reversed_suffix\
    \ = [0; string.len()];\n        let mut string_to_be_appended = string;\n    \
    \    while longest_prefix_length != string_to_be_appended.len() {\n          \
    \  let mut longest_prefix_length = longest_prefix_length\n                + longest_prefix_length(longest_prefix_length,\
    \ reversed_suffix);\n            let mut shortest_suffix_length = longest_prefix_length\n\
    \                + longest_prefix_length(longest_prefix_length, reversed_suffix)\n\
    \                - longest_prefix_length;\n            let mut reversed_suffix_copy\
    \ = reversed_suffix.clone();\n            let mut string_to_be_appended = &mut\
    \ string_to_be_appended.remove(shortest_suffix_length);\n            while longest_prefix_length\
    \ < string_to_be_appended.len() {\n                if string_to_be_appended.chars().next().unwrap()\
    \ != string_to_be_appended\n                    .chars()\n                   \
    \ .next()\n                    .unwrap()\n                    .clone()\n     \
    \               .iter()\n                    .rev()\n                    .find(|&x|\
    \ x == string_to_be_appended.chars().next().unwrap())\n                {\n   \
    \                 break;\n                }\n                longest_prefix_length\
    \ = longest_prefix_length\n                    + longest_prefix_length(longest_prefix_length,\
    \ reversed_suffix);\n                shortest_suffix_length = longest_prefix_length\n\
    \                    + longest_prefix_length(longest_prefix_length, reversed_suffix)\n\
    \                    - longest_prefix_length;\n                reversed_suffix_copy\
    \ = reversed_suffix.clone();\n                string_to_be_appended = &mut string_to_be_appended.remove(shortest_suffix_length);\n\
    \            }\n            reversed_suffix.copy_from_slice(reversed_suffix_copy);\n\
    \        }\n        string_to_be_appended\n    }\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp87idr2d0.rs:17:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                    ------ this would need to be a `const`\n...\n\
    17 |         let mut reversed_suffix = [0; string.len()];\n   |              \
    \                         ^^^^^^\n\nerror[E0618]: expected function, found `usize`\n\
    \  --> /tmp/tmp87idr2d0.rs:21:19\n   |\n15 |         let mut longest_prefix_length\
    \ = 0;\n   |             ------------------------- `longest_prefix_length` has\
    \ type `usize`\n...\n21 |                 + longest_prefix_length(longest_prefix_length,\
    \ reversed_suffix);\n   |                   ^^^^^^^^^^^^^^^^^^^^^----------------------------------------\n\
    \   |                   |\n   |                   call expression requires function\n\
    \nerror[E0618]: expected function, found `usize`\n  --> /tmp/tmp87idr2d0.rs:23:19\n\
    \   |\n20 |             let mut longest_prefix_length = longest_prefix_length\n\
    \   |                 ------------------------- `longest_prefix_length` has type\
    \ `usize`\n...\n23 |                 + longest_prefix_length(longest_prefix_length,\
    \ reversed_suffix)\n   |                   ^^^^^^^^^^^^^^^^^^^^^----------------------------------------\n\
    \   |                   |\n   |                   call expression requires function\n\
    \nerror[E0599]: the method `len` exists for mutable reference `&mut char`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp87idr2d0.rs:27:65\n   |\n\
    27 |             while longest_prefix_length < string_to_be_appended.len() {\n\
    \   |                                                                 ^^^ method\
    \ cannot be called on `&mut char` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `char: ExactSizeIterator`\n\
    \           which is required by `&mut char: ExactSizeIterator`\n\nerror[E0599]:\
    \ no method named `chars` found for mutable reference `&mut char` in the current\
    \ scope\n  --> /tmp/tmp87idr2d0.rs:28:42\n   |\n28 |                 if string_to_be_appended.chars().next().unwrap()\
    \ != s"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string ==\
    \ \"\" {\n        return \"\";\n    }\n    string.split_first_mut().reverse().join().into_owned()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5di3c614.rs:13:16\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n12 |    \
    \ if string == \"\" {\n13 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0599]: no method\
    \ named `split_first_mut` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp5di3c614.rs:15:12\n   |\n15 |     string.split_first_mut().reverse().join().into_owned()\n\
    \   |            ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `split_at_mut`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let prefix_len\
    \ = string\n        .split_whitespace()\n        .len() / 2\n        as usize;\n\
    \n    let suffix_len = string\n        .split_whitespace()\n        .len() / 2\n\
    \        as usize;\n\n    let postfix_len = string.len() - suffix_len;\n\n   \
    \ let mut suffix_prefix: Vec<_> = String::new();\n    suffix_prefix.append(string[prefix_len..].to_lowercase()).collect();\n\
    \    suffix_prefix.reverse();\n\n    String::from_utf8_lossy(&suffix_prefix).unwrap()\n\
    \        .chars()\n        .rev()\n        .join(\"\")\n        + &suffix_prefix[..postfix_len]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpv5sdl2p_.rs:14:10\n   |\n14 |         .len()\
    \ / 2\n   |          ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpv5sdl2p_.rs:19:10\n   |\n19 |         .len() / 2\n   |        \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv5sdl2p_.rs:24:37\n   |\n24 |     let mut suffix_prefix: Vec<_>\
    \ = String::new();\n   |                            ------   ^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `String`\n   |                            |\n   |\
    \                            expected due to this\n   |\n   = note: expected struct\
    \ `Vec<_>`\n              found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv5sdl2p_.rs:25:26\n   |\n25 |     suffix_prefix.append(string[prefix_len..].to_lowercase()).collect();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut\
    \ Vec<_>`, found struct `String`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                         found struct `String`\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmpv5sdl2p_.rs:25:63\n   |\n25 |     suffix_prefix.append(string[prefix_len..].to_lowercase()).collect();\n\
    \   |                                                               ^^^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `Cow<'_, str>` in the\
    \ current scope\n  --> /tmp/tmpv5sdl2p_.rs:28:45\n   |\n28 |     String::from_utf8_lossy(&suffix_prefix).unwrap()\n\
    \   |                                             ^^^^^^ method not found in `Cow<'_,\
    \ str>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // TODO: use\
    \ [String::reverse()][2] and [String::find_iter()][2] instead of manual string\
    \ manipulation\n    let mut string = string;\n    loop {\n        let mut reverse\
    \ = string;\n        reverse.reverse();\n        let mut i = string.find_iter(|c|\
    \ c != reverse);\n        if i == String::npos { break };\n        string = &string[i..];\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyaya48mm.rs:16:17\n   |\n16 |         reverse.reverse();\n\
    \   |                 ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `find_iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpyaya48mm.rs:17:28\n   |\n17 | \
    \        let mut i = string.find_iter(|c| c != reverse);\n   |               \
    \             ^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no function\
    \ or associated item named `npos` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpyaya48mm.rs:18:25\n   |\n18 |         if i == String::npos { break\
    \ };\n   |                         ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyaya48mm.rs:19:18\n\
    \   |\n13 |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n19 |         string = &string[i..];\n   |          \
    \        ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n19 |         string = (&string[i..]).to_string();\n\
    \   |                  +            +++++++++++++\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n    let mut start = string.chars().enumerate().find(|(_,\
    \ char)| char == 'a');\n    let mut end = string.chars().enumerate().rfind(|(_,\
    \ char)| char == 'a');\n    if end == None {\n        end = string.chars().enumerate().len()\
    \ - 1;\n    }\n    let mut suffix = &string[end.unwrap() + 1 .. ];\n    let mut\
    \ suffix = &suffix[..start.unwrap() - 1];\n    let mut prefix = &string[start.unwrap()\
    \ .. ];\n    let mut prefix = &prefix[..end.unwrap()];\n    let mut reversed =\
    \ prefix.clone();\n    reversed.reverse();\n    prefix.append(reversed);\n   \
    \ prefix.prepend(&string[0]);\n    prefix.reverse();\n    prefix.append(suffix);\n\
    \    return prefix.to_string();\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpps51gxp7.rs:15:70\n\
    \   |\n15 |     let mut start = string.chars().enumerate().find(|(_, char)| char\
    \ == 'a');\n   |                                                             \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: the method `rfind` exists for struct\
    \ `Enumerate<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpps51gxp7.rs:16:46\n\
    \   |\n16 |       let mut end = string.chars().enumerate().rfind(|(_, char)| char\
    \ == 'a');\n   |                                                ^^^^^ method cannot\
    \ be called on `Enumerate<Chars<'_>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `Chars<'_>:\
    \ ExactSizeIterator`\n           which is required by `Enumerate<Chars<'_>>: DoubleEndedIterator`\n\
    \nerror[E0599]: the method `len` exists for struct `Enumerate<Chars<'_>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpps51gxp7.rs:18:42\n   |\n\
    18 |           end = string.chars().enumerate().len() - 1;\n   |             \
    \                               ^^^ method cannot be called on `Enumerate<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n           which\
    \ is required by `Enumerate<Chars<'_>>: ExactSizeIterator`\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `(usize, char)`\n  --> /tmp/tmpps51gxp7.rs:21:47\n\
    \   |\n21 |     let mut suffix = &suffix[..start.unwrap() - 1];\n   |        \
    \                        -------------- ^ - {integer}\n   |                  \
    \              |\n   |                                (usize, char)\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<(usize, char)>`\n  --> /tmp/tmpps51gxp7.rs:22:23\n\
    \   |\n22 |     let mut prefix = &string[start.unwrap() .. ];\n   |          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` can"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut string_to_reverse = string;\n    let mut reverse_string_to_append\
    \ = string;\n\n    while palindrome.chars().count() > 0 {\n        let mut last_index\
    \ = palindrome.chars().rposition(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().last().unwrap()))).unwrap()).unwrap();\n\
    \        let mut first_index = palindrome.chars().rposition(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().first().unwrap()))).unwrap()).unwrap();\n\
    \n        while first_index > last_index {\n            let mut to_be_deleted\
    \ = palindrome.chars().position(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().last().unwrap()))).unwrap()).unwrap();\n\
    \            palindrome.remove(&to_be_deleted, 1);\n            last_index -=\
    \ 1;\n        }\n        palindrome = &palindrome[..last_index].to_string() +\
    \ &palindrome[last_index..];\n\n        reverse_string_to_append = &string_to_reverse[..first_index].to_string()\
    \ + &string_to_reverse[first_index..];\n\n        palindrome += reverse_string_to_append;\n\
    \n        string_to_reverse = &string_to_reverse[..last_index].to_string() + &string_to_reverse[last_index..];\n\
    \n        if string_to_reverse == &palindrome {\n            return palindrome;\n\
    \        }\n    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmptwu1obyx.rs:17:49\n     |\n17   | ...   let mut last_index =\
    \ palindrome.chars().rposition(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().last().unwr...\n\
    \     |                                               ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptwu1obyx.rs:17:60\n   |\n17 | ...   let mut last_index\
    \ = palindrome.chars().rposition(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().last().unwr...\n\
    \   |                                                          ^--\n   |     \
    \                                                     ||\n   |               \
    \                                           |expected due to this\n   |      \
    \                                                    expected `char`, found reference\n\
    \   |                                                          help: did you mean\
    \ `i`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwu1obyx.rs:17:99\n  \
    \ |\n17 | ...har::from_u32(char::from_u32(char::from(palindrome.chars().last().unwrap()))).unwrap()).unwrap();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `char`\n   |\nhelp: you can cast a `char` to a `u32`,\
    \ since a `char` always occupies 4 bytes\n   |\n17 |         let mut last_index\
    \ = palindrome.chars().rposition(|&i| i == char::from_u32(char::from_u32(char::from(palindrome.chars().last().unwrap())\
    \ as u32)).unwrap()).unwrap();\n   |                  "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find longest\
    \ prefix that is a palindrome\n    let (longest_prefix_suffix, longest_prefix_suffix_suffix)\
    \ = longest_palindrome_suffix(string);\n    // Reverse longest prefix to suffix\
    \ part of palindrome and add it to the end of the string\n    string + longest_prefix_suffix.reverse()\
    \ + longest_prefix_suffix_suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpwt02yb4u.rs:13:65\n   |\n13 |     let (longest_prefix_suffix,\
    \ longest_prefix_suffix_suffix) = longest_palindrome_suffix(string);\n   |   \
    \                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string;\n    reversed_string.chars()\n        .rev()\n        .filter(|c|\
    \ *c != ' ')\n        .fold(String::new(), |mut reversed_string, reversed_char|\
    \ {\n            *reversed_string += &reversed_char;\n            reversed_string\n\
    \        });\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `str`\n  --> /tmp/tmphr2_3qq3.rs:17:13\n   |\n17 |             *reversed_string\
    \ += &reversed_char;\n   |             ----------------^^^^^^^^^^^^^^^^^^\n  \
    \ |             |\n   |             cannot use `+=` on type `str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let reversed_suffix = (&string + &string).chars().enumerate().fold(\"\
    \".to_string(), |mut acc, (i, c)| {\n        let mut chars = (&mut acc.to_string()).chars();\n\
    \        chars.insert(i, c);\n        chars.to_owned()\n    });\n\n    let mut\
    \ last_i = -1; // last position of string to reverse\n    let mut last_i = &string.chars().nth(string.len()\
    \ - 1);\n    let mut last_c = '\\0';\n    while last_i != 0 {\n        let mut\
    \ i = 0;\n        let mut i = 0;\n        while i <= last_i {\n            let\
    \ mut c = string.chars().nth(i);\n            let mut j = i;\n            while\
    \ j <= last_i {\n                if *j != c {\n                    break;\n  \
    \              }\n                j = j + 1;\n            }\n            if j\
    \ > i {\n                break;\n            }\n            i = i + 1;\n     \
    \   }\n        if i == last_i {\n            let mut c = string.chars().nth(i);\n\
    \            let mut j = i;\n            while j <= last_i {\n               \
    \ if *j != c {\n                    break;\n                }\n              \
    \  j = j + 1;\n            }\n            if j == i {\n                last_i\
    \ = i;\n                last_c = c;\n            }\n        }\n        last_i\
    \ = last_i - 1;\n    }\n    if last_c.is_some() {\n        if let Some(mut c)\
    \ = last_c {\n            string = string.chars().skip_while(|&c| *c != *c).collect::<String>().to_owned();\n\
    \            string = &string[..(string.len() - 1 + c)];\n        }\n    }\n \
    \   string + &reversed_suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmpbv9oo0yt.rs:16:36\n\
    \   |\n16 |     let reversed_suffix = (&string + &string).chars().enumerate().fold(\"\
    \".to_string(), |mut acc, (i, c)| {\n   |                            ------- ^\
    \ ------- &String\n   |                            |       |\n   |           \
    \                 |       `+` cannot be used to concatenate two `&str` strings\n\
    \   |                            &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: remove the borrow to obtain an\
    \ owned `String`\n   |\n16 -     let reversed_suffix = (&string + &string).chars().enumerate().fold(\"\
    \".to_string(), |mut acc, (i, c)| {\n16 +     let reversed_suffix = (string +\
    \ &string).chars().enumerate().fold(\"\".to_string(), |mut acc, (i, c)| {\n  \
    \ | \n\nerror[E0277]: can't compare `&Option<char>` with `{integer}`\n  --> /tmp/tmpbv9oo0yt.rs:25:18\n\
    \   |\n25 |     while last_i != 0 {\n   |                  ^^ no implementation\
    \ for `&Option<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&Option<char>`\n   = help: the trait `PartialEq` is\
    \ implemented for `Option<T>`\n\nerror[E0277]: can't compare `{integer}` with\
    \ `&Option<char>`\n  --> /tmp/tmpbv9oo0yt.rs:28:17\n   |\n28 |         while i\
    \ <= last_i {\n   |                 ^^ no implementation for `{integer} < &Option<char>`\
    \ and `{integer} > &Option<char>`\n   |\n   = help: the trait `PartialOrd<&Option<char>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbv9oo0yt.rs:31:24\n   |\n31 |             while j <= last_i {\n   |\
    \                        ^^^^^^ expected `usize`, found `&Option<char>`\n   |\n\
    \   = note:   expected type `usize`\n           found reference `&Option<char>`\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpbv9oo0yt.r"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.to_string();\n    match result.chars().rposition(|c| c.is_lowercase())\
    \ {\n        Some(first) => result\n            .chars()\n            .split_last_mut(first)\n\
    \            .chain(string.chars().rsplit_first_mut(first))\n            .collect(),\n\
    \        None => result,\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp1qp9ty6d.rs:13:26\n     |\n13   |     match result.chars().rposition(|c|\
    \ c.is_lowercase()) {\n     |                          ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0599]: no method\
    \ named `split_last_mut` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmp1qp9ty6d.rs:16:14\n   |\n16 |             .split_last_mut(first)\n \
    \  |              ^^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `rsplit_first_mut` found for struct `Chars` in the current scope\n\
    \  --> /tmp/tmp1qp9ty6d.rs:17:35\n   |\n17 |             .chain(string.chars().rsplit_first_mut(first))\n\
    \   |                                   ^^^^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string.to_owned();\n    let mut length = 0;\n    let mut start = 0;\n    while\
    \ start < string.len() {\n        let end = length - 1;\n        let mut pos =\
    \ start;\n        while pos < end {\n            if string[pos] != string[pos\
    \ + 1] {\n                break;\n            }\n            pos += 1;\n     \
    \   }\n        if pos > start {\n            reverse = reverse.clone();\n    \
    \        reverse.insert(0, string[start..pos]);\n            start = pos;\n  \
    \          length += 1;\n        }\n    }\n    reverse\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6wnk5muw.rs:19:16\n\
    \   |\n19 |             if string[pos] != string[pos + 1] {\n   |            \
    \    ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6wnk5muw.rs:19:31\n   |\n19 |             if string[pos] != string[pos\
    \ + 1] {\n   |                               ^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6wnk5muw.rs:26:31\n\
    \   |\n26 |             reverse.insert(0, string[start..pos]);\n   |         \
    \                      ^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string;\n\n    let mut i = 1;\n    for let mut c in string.chars() {\n   \
    \     if i != 0 {\n            i += 1;\n            continue;\n        }\n\n \
    \       let is_palindromic = match c {\n            'a' .. 'z' => c <= 'z' ||\
    \ c == 'a' && i > 0,\n            'A' .. 'Z' => c >= 'a' && c <= 'z' || c == 'A'\
    \ && i > 0,\n            '0' .. '9' => c == 0 || i >= 1,\n            _ => return\
    \ result,\n        };\n\n        if is_palindromic {\n            i += 1;\n  \
    \          continue;\n        }\n\n        i += 1;\n        result = result.replace_range(i,\
    \ i, &c.to_string());\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmp44mhum84.rs:15:9\n\
    \   |\n15 |     for let mut c in string.chars() {\n   |         ^^^ expected identifier,\
    \ found keyword\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp44mhum84.rs:15:12\n\
    \   |\n15 |     for let mut c in string.chars() {\n   |            ^ help: try\
    \ adding `in` here\n\nerror: expected expression, found keyword `mut`\n  --> /tmp/tmp44mhum84.rs:15:13\n\
    \   |\n15 |     for let mut c in string.chars() {\n   |             ^^^ expected\
    \ expression\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = string;\n    let mut prefix = string;\n\n    // Find longest postfix of supplied\
    \ string\n    let mut longest_postfix = String::new();\n    for i in 0..string.len()\
    \ - 1 {\n        let mut j = i;\n        for j in i + 1..string.len() {\n    \
    \        if string[i] == string[j] {\n                break;\n            }\n\
    \        }\n        longest_postfix.push_str(&string[i..j]);\n    }\n\n    //\
    \ Append the reverse of the postfix to the string\n    longest_postfix.push_str(&suffix.iter().rev().collect::<String>());\n\
    \n    // Append the postfix to the string\n    prefix.push_str(&longest_postfix);\n\
    \n    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9ilw7ooi.rs:20:16\n\
    \   |\n20 |             if string[i] == string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9ilw7ooi.rs:20:29\n   |\n20 |             if string[i] == string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9ilw7ooi.rs:28:38\n   |\n28 |     longest_postfix.push_str(&suffix.iter().rev().collect::<String>());\n\
    \   |                                      ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n28 |     longest_postfix.push_str(&suffix.chars().rev().collect::<String>());\n\
    \   |                                      ~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut palindrome = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_prefix_length = longest_postfix.len();\n\n    while let Some(prefix_length)\
    \ = longest_postfix.rfind(' ') {\n        longest_postfix.push_str(&palindrome[..prefix_length]);\n\
    \        longest_prefix_length = prefix_length;\n    }\n\n    let mut suffix_length\
    \ = longest_prefix_length;\n    let mut reversed_suffix_length = 0;\n    while\
    \ let Some(suffix_length) = longest_postfix.find(' ', longest_prefix_length) {\n\
    \        reversed_suffix_length += suffix_length;\n        longest_postfix.push_str(&palindrome[longest_prefix_length..reversed_suffix_length]);\n\
    \    }\n\n    longest_postfix.push_str(&palindrome[reversed_suffix_length..]);\n\
    \n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpxw728bkn.rs:24:53\n     |\n24   |     while let Some(suffix_length)\
    \ = longest_postfix.find(' ', longest_prefix_length) {\n     |               \
    \                                      ^^^^ ---  --------------------- supplied\
    \ 2 arguments\n     |                                                     |\n\
    \     |                                                     expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if let len =\n\
    \        string.len()\n            + string\n            .chars()\n          \
    \  .rev()\n            .take(string.len())\n            .rev()\n            .take(string.len()\
    \ / 2)\n            .filter(|c| *c == *c)\n            .count() as usize\n   \
    \ {\n        let mut string: String = string;\n        for _ in 0..len {\n   \
    \         string.push(*string.last().unwrap().to_lowercase());\n        }\n  \
    \      string.push(string.reverse());\n        string\n    } else {\n        string\n\
    \    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpfbi7v6_r.rs:18:14\n     |\n18   |             .rev()\n     |\
    \              ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `ExactSizeIterator` for `Rev<Chars<'_>>`\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `std::iter::Take<Rev<Chars<'_>>>`\n\
    note: required by a bound in `rev`\n\nerror[E0599]: the method `take` exists for\
    \ struct `Rev<std::iter::Take<Rev<Chars<'_>>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpfbi7v6_r.rs:19:14\n   |\n19 |                .take(string.len()\
    \ / 2)\n   |                 ^^^^ method cannot be called on `Rev<std::iter::Take<Rev<Chars<'_>>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Rev<Chars<'_>>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n           which\
    \ is required by `&mut Rev<std::iter::Take<Rev<Chars<'_>>>>: Iterator`\n\nerror[E0599]:\
    \ `String` is not an iterator\n   --> /tmp/tmpfbi7v6_r.rs:25:33\n    |\n25  |\
    \               string.push(*string.last().unwrap().to_lowercase());\n    |  \
    \                                 ^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror[E059"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut palindrome: String = string;\n\
    \    let mut suffix = &string;\n\n    for _ in 0..string.len() - 1 {\n       \
    \ let mut char: char = String::new();\n\n        while suffix.is_empty() {\n \
    \           let index = suffix.find(\"-\");\n\n            if index == None {\n\
    \                char = suffix.chars().next().unwrap();\n            } else {\n\
    \                char = suffix.chars().next().unwrap();\n                suffix\
    \ = &suffix[index..];\n            }\n        }\n\n        let reversed_char =\
    \ char.chars().collect::<String>().reverse().collect::<String>();\n        let\
    \ reversed_suffix = (reversed_char + &char).into_owned();\n\n        let mut suffix_len\
    \ = suffix.len();\n\n        for _ in 0..char.len() - 1 {\n            let mut\
    \ char2 = String::new();\n\n            while suffix_len == 0 {\n            \
    \    suffix_len = suffix.len();\n\n                let index = suffix.find(\"\
    -\");\n\n                if index == None {\n                    char2 = suffix.chars().next().unwrap();\n\
    \                } else {\n                    char2 = suffix.chars().next().unwrap();\n\
    \                    suffix = &suffix[index..];\n                }\n         \
    \   }\n\n            palindrome += &char2;\n            palindrome += &reversed_suffix[..suffix_len];\n\
    \        }\n    }\n\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj6n_vshq.rs:20:30\n   |\n\
    20 |         let mut char: char = String::new();\n   |                       ----\
    \   ^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |               \
    \        |\n   |                       expected due to this\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpj6n_vshq.rs:29:27\n\
    \   |\n29 |                 suffix = &suffix[index..];\n   |                 \
    \          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpj6n_vshq.rs:33:34\n   |\n33 |         let reversed_char\
    \ = char.chars().collect::<String>().reverse().collect::<String>();\n   |    \
    \                              ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpj6n_vshq.rs:38:26\n\
    \   |\n38 |         for _ in 0..char.len() - 1 {\n   |                       \
    \   ^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6n_vshq.rs:47:29\n\
    \   |\n39 |             let mut char2 = String::new();\n   |                 \
    \            ------------- expected due to this value\n...\n47 |             \
    \        char2 = suffix.chars().next().unwrap();\n   |                       \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                             |\n   |                             expected\
    \ struct `String`, found `char`\n\nerror[E0308]"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix;\n\
    \    let mut prefix = string;\n    while let Some(suffix) = suffix_of_string(&mut\
    \ prefix) {\n        prefix = append_to_end(&mut prefix, &reverse(&suffix));\n\
    \    }\n    return prefix;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix_of_string` in this scope\n \
    \ --> /tmp/tmpbfzli3nc.rs:14:30\n   |\n14 |     while let Some(suffix) = suffix_of_string(&mut\
    \ prefix) {\n   |                              ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `append_to_end` in this scope\n\
    \  --> /tmp/tmpbfzli3nc.rs:15:18\n   |\n15 |         prefix = append_to_end(&mut\
    \ prefix, &reverse(&suffix));\n   |                  ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `reverse` in this scope\n \
    \ --> /tmp/tmpbfzli3nc.rs:15:46\n   |\n15 |         prefix = append_to_end(&mut\
    \ prefix, &reverse(&suffix));\n   |                                          \
    \    ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n\n    let mut suffix = 0;\n    while !palindrome.starts_with(string[suffix..])\
    \ {\n        suffix += 1;\n    }\n\n    let mut string_to_append = string[suffix..];\n\
    \    let mut postfix = suffix;\n    while !string_to_append.starts_with(string[postfix\
    \ - 1..postfix + 1]) {\n        postfix -= 1;\n    }\n\n    palindrome.push_str(string_to_append);\n\
    \    palindrome.push_str(&string[postfix - 1..]);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpoouha6yy.rs:15:35\n     |\n15   |     while !palindrome.starts_with(string[suffix..])\
    \ {\n     |                       ----------- ^^^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n     |                       |\n     |         \
    \              required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `core::str::<impl str>::starts_with`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `str`\n    --> /tmp/tmpoouha6yy.rs:15:35\n     |\n15   |    \
    \ while !palindrome.starts_with(string[suffix..]) {\n     |                  \
    \     ----------- ^^^^^^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                       |\n     |                       required by a bound\
    \ introduced by this call\n     |\n     = note: the trait bound `str: Pattern<'_>`\
    \ is not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n15   |     while !palindrome.starts_with(&string[suffix..])\
    \ {\n     |                                   +\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmpoouha6yy.rs:19:9\n\
    \   |\n19 |     let mut string_to_append = string[suffix..];\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n19 |     let mut string_to_append = &string[suffix..];\n\
    \   |                                +\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n    --> /tmp/tmpoouha6yy.rs:21:41\n\
    \     |\n21   |     while !string_to_append.starts_with(string[postfix - 1..postfix\
    \ + 1]) {\n     |"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    palindrome.push(palindrome[..].reverse());\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp45d9gk6n.rs:13:36\n   |\n13 |     palindrome.push(palindrome[..].reverse());\n\
    \   |                                    ^^^^^^^ method not found in `str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.len()\
    \ < 2 {\n        return string;\n    }\n\n    let mut suffix = string[1..].to_owned();\n\
    \    let mut prefix = string[..1].to_owned();\n\n    // find the longest postfix\
    \ that is a palindrome\n    let mut max = 0;\n    let mut index = prefix.len();\n\
    \    while index > 0 {\n        let mut suffix_index = 0;\n        while suffix_index\
    \ < suffix.len() && suffix[index] == suffix[suffix_index] {\n            suffix_index\
    \ += 1;\n        }\n        index -= suffix_index;\n        if suffix_index ==\
    \ suffix.len() {\n            max = index;\n        }\n    }\n    prefix.prepend(&suffix[..max].iter().cloned());\n\
    \    suffix[..max].to_owned()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplkstry6_.rs:24:46\n\
    \   |\n24 |         while suffix_index < suffix.len() && suffix[index] == suffix[suffix_index]\
    \ {\n   |                                              ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplkstry6_.rs:24:63\n   |\n24 |         while suffix_index < suffix.len()\
    \ && suffix[index] == suffix[suffix_index] {\n   |                           \
    \                                    ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `prepend` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmplkstry6_.rs:32:12\n   |\n32 |     prefix.prepend(&suffix[..max].iter().cloned());\n\
    \   |            ^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `iter` found for type `str` in the current scope\n  --> /tmp/tmplkstry6_.rs:32:35\n\
    \   |\n32 |     prefix.prepend(&suffix[..max].iter().cloned());\n   |        \
    \                           ^^^^ method not found in `str`\n\nerror: aborting"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffixes\
    \ = Vec::new();\n    let mut longest_suffix = 1;\n\n    for c in string.chars()\
    \ {\n        if c.is_digit() {\n            suffixes.push(&c.to_string());\n \
    \           longest_suffix++;\n        } else {\n            suffixes.push(&c.to_string()\
    \ + '0');\n            longest_suffix++;\n        }\n    }\n\n    let mut min_length\
    \ = longest_suffix;\n    let mut max_length = longest_suffix;\n\n    for s in\
    \ &suffixes[..] {\n        let mut reverse = 0;\n        let mut i = 0;\n    \
    \    for c in s.chars() {\n            reverse = reverse * 10 + c as u8;\n   \
    \         i += 1;\n        }\n\n        if reverse > min_length {\n          \
    \  min_length = reverse;\n        }\n\n        if reverse < max_length {\n   \
    \         max_length = reverse;\n        }\n    }\n\n    let mut palindrome =\
    \ String::new();\n    for s in &suffixes[..] {\n        let mut reverse = 0;\n\
    \        let mut i = 0;\n        for c in s.chars() {\n            reverse = reverse\
    \ * 10 + c as u8;\n            i += 1;\n        }\n\n        palindrome.push((i\
    \ as u32).to_string());\n    }\n\n    palindrome.push(palindrome.chars().filter(|c|\
    \ c.is_digit()).collect::<Vec<_>>().join());\n\n    palindrome = palindrome.reverse();\n\
    \    palindrome.push(palindrome);\n\n    palindrome = palindrome.pop();\n    palindrome.push(palindrome);\n\
    \n    palindrome = palindrome.reverse();\n    palindrome.push(palindrome);\n\n\
    \    palindrome = palindrome.pop();\n    palindrome.push(palindrome);\n\n    palindrome\
    \ = palindrome.reverse();\n    palindrome.push(palindrome);\n\n    palindrome\
    \ = palindrome.pop();\n    palindrome.push(palindrome);\n\n    palindrome = palindrome.reverse();\n\
    \    palindrome.push(palindrome);\n\n    palindrome = palindrome.pop();\n    palindrome.push(palindrome);\n\
    \n    palindrome = palindrome.reverse();\n    palindrome.push(palindrome);\n\n\
    \    palindrome = palindrome.pop();\n    palindrome.push(palindrome);\n\n    palindrome\
    \ = palindrome.reverse();\n    palindrome.push(palindrome);\n\n    palindrome\
    \ = palin\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpztulnuyh.rs:18:27\n\
    \   |\n18 |             longest_suffix++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       \
    \      { let tmp = longest_suffix; longest_suffix += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n18 -            \
    \ longest_suffix++;\n18 +             longest_suffix += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpztulnuyh.rs:21:27\n   |\n21\
    \ |             longest_suffix++;\n   |                           ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |             { let\
    \ tmp = longest_suffix; longest_suffix += 1; tmp };\n   |             +++++++++++\
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n21 -             longest_suffix++;\n\
    21 +             longest_suffix += 1;\n   | \n\nerror[E0425]: cannot find value\
    \ `palin` in this scope\n  --> /tmp/tmpztulnuyh.rs:92:18\n   |\n92 |     palindrome\
    \ = palin\n   |                  ^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpztulnuyh.rs:16:14\n\
    \    |\n16  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |              |\n    |              expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0369]: cannot add `char`\
    \ to `&String`\n  --> /tmp/tmpztulnuyh.rs:20:42\n   |\n20 |             suffixes.push(&c.to_string()\
    \ + '0');\n   |                           -------------- ^ --- char\n   |    \
    \                       |\n   |                           &String\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpztulnuyh.rs:54:25\n   |\n54 |         palindrome.push((i\
    \ as u32).to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmpztulnuyh.rs:57:53\n    |\n57 \
    \ |     palindrome.push(palindrome.chars().filter(|c| c.is_digit()).collect::<Vec<_>>().join());"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string;\n\
    \    let mut i = 0;\n    let mut longest_palindrome_length = 0;\n    while i <\
    \ s.len() {\n        let c = s[i];\n        let j = i + 1;\n        let palindrome\
    \ = String::new();\n        while j < s.len() && s[j] != c {\n            palindrome.push(c);\n\
    \            i += 1;\n            j += 1;\n        }\n        longest_palindrome_length\
    \ = std::cmp::max(longest_palindrome_length, palindrome.len());\n        i +=\
    \ 1;\n    }\n    let mut r = String::new();\n    for _ in 0..(longest_palindrome_length\
    \ - 1) {\n        r.push(c);\n    }\n    r.reverse();\n    r + s\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpc4fswu9v.rs:29:16\n\
    \   |\n29 |         r.push(c);\n   |                ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpc4fswu9v.rs:16:17\n   |\n16 |         let c = s[i];\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc4fswu9v.rs:19:30\n   |\n19 |         while j < s.len() && s[j]\
    \ != c {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpc4fswu9v.rs:31:7\n   |\n31 |     r.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc4fswu9v.rs:32:9\n\
    \   |\n32 |     r + s\n   |         ^\n   |         |\n   |         expected `&str`,\
    \ found struct `String`\n   |         help: consider borrowing here: `&s`\n\n\
    error: aborting due to 5 previous errors\n\nSome erro"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix:\
    \ String = string;\n    suffix.reverse();\n    let mut prefix: String = string;\n\
    \    let mut palindrome = string;\n    for c in string.chars() {\n        if !palindrome.starts_with(c.to_string())\
    \ {\n            palindrome = palindrome.append(&c);\n        }\n    }\n    if\
    \ palindrome.starts_with(&prefix.reverse()) {\n        palindrome = prefix.clone()\
    \ + &palindrome[prefix.len() - palindrome.len() - 1];\n    } else {\n        palindrome\
    \ = prefix.clone() + &palindrome[0];\n    }\n    palindrome.reverse();\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0lo50yp4.rs:13:12\n   |\n13 |     suffix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n    --> /tmp/tmp0lo50yp4.rs:17:36\n     |\n17   |         if !palindrome.starts_with(c.to_string())\
    \ {\n     |                        ----------- ^^^^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                        |\n     |            \
    \            required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n17   |         if !palindrome.starts_with(&c.to_string())\
    \ {\n     |                                    +\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmp0lo50yp4.rs:18:37\n\
    \   |\n18 |             palindrome = palindrome.append(&c);\n   |            \
    \                         ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp0lo50yp4.rs:21:39\n   |\n21 |     if palindrome.starts_with(&prefix.reverse())\
    \ {\n   |                                       ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp0lo50yp4.rs:22:40\n   |\n22 |         palindrome\
    \ = prefix.clone() + &palindrome[prefix.len() - palindrome.len() - 1];\n   | \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFr"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.reverse().to_string();\n    let palindrome = string\n        .split_at_rev()\n\
    \        .next()\n        .chain(\n            &string.split_at_rev()\n      \
    \          .next()\n                .chain(&reversed.split_at_rev().next().chain(string))\n\
    \        )\n        .collect();\n    palindrome.collect::<String>().join(\"\"\
    )\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpwxltq15g.rs:12:27\n   |\n12 |     let reversed\
    \ = string.reverse().to_string();\n   |                           ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `split_at_rev` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpwxltq15g.rs:14:10\n   |\n14 |         .split_at_rev()\n   |   \
    \       ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `split_at`\n\nerror[E0599]: no method named `split_at_rev` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpwxltq15g.rs:17:21\n   |\n17 | \
    \            &string.split_at_rev()\n   |                     ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `split_at`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (mut longest_postfix,\
    \ mut longest_suffix) =\n        string.chars().enumerate().map(|(_, c)| c).max_by_key(|c|\
    \ c.len());\n    longest_suffix += longest_postfix.clone();\n    longest_postfix\n\
    \        .to_ascii_lowercase()\n        .chars()\n        .enumerate()\n     \
    \   .map(|(_, c)| {\n            if c.0 != longest_postfix.len() || c.1 != longest_postfix.len()\
    \ - 1 {\n                panic!(\"Inconsistent string lengths\");\n          \
    \  }\n            c\n        })\n        .filter(|&(_, c)| c == longest_postfix.to_ascii_lowercase().to_ascii_lowercase())\n\
    \        .next()\n        .unwrap()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpy7q7yc8n.rs:13:69\n   |\n13 |         string.chars().enumerate().map(|(_,\
    \ c)| c).max_by_key(|c| c.len());\n   |                                      \
    \                               ^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy7q7yc8n.rs:12:9\n   |\n12 |     let (mut longest_postfix,\
    \ mut longest_suffix) =\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found tuple\n13 |         string.chars().enumerate().map(|(_,\
    \ c)| c).max_by_key(|c| c.len());\n   |         ------------------------------------------------------------------\
    \ this expression has type `Option<char>`\n   |\n   = note: expected enum `Option<char>`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut length\
    \ = string.len();\n    let mut index = 0;\n    let mut resulting_string = string;\n\
    \    let mut found_palindrome = false;\n    while !found_palindrome {\n      \
    \  // reverse first part of string\n        if index > 0 {\n            let current_substring\
    \ = &string[index..(length - 1)];\n            let current_substring_len = current_substring.len();\n\
    \            if current_substring.chars()\n                .rev()\n          \
    \      .chain(current_substring)\n                .eq(&current_substring[..current_substring_len])\n\
    \            {\n                index -= current_substring_len;\n            \
    \    continue;\n            }\n        }\n        // reverse second part of string\n\
    \        if index != 0 {\n            let current_substring = &string[(length\
    \ - 1)..index];\n            let current_substring_len = current_substring.len();\n\
    \            if current_substring.chars()\n                .rev()\n          \
    \      .chain(current_substring)\n                .eq(&current_substring[..current_substring_len])\n\
    \            {\n                index -= current_substring_len;\n            \
    \    continue;\n            }\n        }\n        // compare first and second\
    \ parts, if they are not equal then check if they are palindrome\n        let\
    \ current_substring = &string[index..length];\n        let current_substring_len\
    \ = current_substring.len();\n        if current_substring.chars()\n         \
    \   .rev()\n            .chain(current_substring)\n            .eq(&current_substring[..current_substring_len])\n\
    \        {\n            found_palindrome = true;\n        } else {\n         \
    \   length = length - 1;\n            index += 1;\n            resulting_string\
    \ = &string[index..length];\n        }\n    }\n    resulting_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpj6csffa8.rs:23:24\n\
    \   |\n23 |                 .chain(current_substring)\n   |                  -----\
    \ ^^^^^^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |                  |\n   |                  required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `&str`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror[E0599]: the method `eq` exists for struct `std::iter::Chain<Rev<Chars<'_>>,\
    \ &str>`, but its trait bounds were not satisfied\n  --> /tmp/tmpj6csffa8.rs:24:18\n\
    \   |\n24 |                   .eq(&current_substring[..current_substring_len])\n\
    \   |                    ^^ method cannot be called on `std::iter::Chain<Rev<Chars<'_>>,\
    \ &str>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<&str as Iterator>::Item = char`\n \
    \          which is required by `std::iter::Chain<Rev<Chars<'_>>, &str>: Iterator`\n\
    \           `&str: Iterator`\n           which is required by `std::iter::Chain<Rev<Chars<'_>>,\
    \ &str>: Iterator`\n           `std::iter::Chain<Rev<Chars<'_>>, &str>: Iterator`\n\
    \           which is required by `&mut std::iter::Chain<Rev<Chars<'_>>, &str>:\
    \ Iterator`\n\nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmpj6csffa8.rs:36:24\n\
    \   |\n36 |                 .chain(current_substring)\n   |                  -----\
    \ ^^^^^^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |                  |\n   |                  required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `&str`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror[E0599]: the method `eq` exists for struct `std::iter::Chain<Rev<Chars<'_>>,\
    \ &str>`, but its trait bounds were not satisfied\n  --> /tmp/tmpj6csffa8.rs:37:18\n\
    \   |\n37 |                   .eq(&current_substring[..current_substring_len])\n\
    \   |                    ^^ m"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut postfix\
    \ = string;\n    let mut prefix = string;\n    let mut palindrome = string;\n\
    \    if string.is_empty() {\n        return palindrome;\n    }\n    let mut suffix;\n\
    \    while !postfix.is_empty() {\n        suffix = postfix.clone();\n        suffix.reverse();\n\
    \        if suffix.eq_ignore_ascii_case(prefix) {\n            palindrome.push((&prefix[..]).to_ascii_lowercase());\n\
    \            palindrome.push((&suffix[..]).to_ascii_lowercase());\n          \
    \  prefix = \"\";\n            postfix = \"\";\n        } else {\n           \
    \ prefix.push(suffix);\n        }\n    }\n    if postfix.is_empty() {\n      \
    \  palindrome\n    } else {\n        palindrome.push((&prefix[..]).to_ascii_lowercase());\n\
    \        palindrome\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5519kdgp.rs:21:16\n   |\n21 |         suffix.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:22:40\n\
    \   |\n22 |         if suffix.eq_ignore_ascii_case(prefix) {\n   |           \
    \                             ^^^^^^\n   |                                   \
    \     |\n   |                                        expected `&str`, found struct\
    \ `String`\n   |                                        help: consider borrowing\
    \ here: `&prefix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:23:29\n\
    \   |\n23 |             palindrome.push((&prefix[..]).to_ascii_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:24:29\n\
    \   |\n24 |             palindrome.push((&suffix[..]).to_ascii_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:25:22\n\
    \   |\n13 |     let mut prefix = string;\n   |                      ------ expected\
    \ due to this value\n...\n25 |             prefix = \"\";\n   |              \
    \        ^^- help: try using a conversion method: `.to_string()`\n   |       \
    \               |\n   |                      expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:26:23\n   |\n12 |\
    \     let mut postfix = string;\n   |                       ------ expected due\
    \ to this value\n...\n26 |             postfix = \"\";\n   |                 \
    \      ^^- help: try using a conversion method: `.to_string()`\n   |         \
    \              |\n   |                       expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5519kdgp.rs:28:25\n   |\n28 |\
    \             prefix.push(suffix);\n   |                         ^^^^^^ expected\
    \ `char`, found "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // longest postfix\
    \ of string that is a palindrome\n    let lpost_len = string.chars().filter(|c|\
    \ c.is_alphanumeric()).count();\n\n    // postfix of string that comes before\
    \ longest postfix\n    let lpre_len = string\n        .chars()\n        .filter(|c|\
    \ c.is_alphanumeric())\n        .count();\n    let pre_len = (lpre_len as i32)\
    \ - (lpost_len as i32);\n\n    // reverse of string prefix that comes before longest\
    \ postfix\n    let rpre_len = string.chars().count();\n    let rpre_len = (rpre_len\
    \ as i32) - pre_len;\n\n    // reverse of string postfix that comes before longest\
    \ postfix\n    let rpost_len = string\n        .chars()\n        .filter(|c| c.is_alphanumeric())\n\
    \        .count();\n    let post_len = (rpost_len as i32) - (lpost_len as i32);\n\
    \n    let mut s = string;\n    if rpre_len > 0 {\n        s = String::from_utf8(s.bytes().take(rpre_len).rev());\n\
    \    }\n\n    if post_len > 0 {\n        s = String::from_utf8(s.bytes().take(post_len).rev());\n\
    \    }\n\n    if lpost_len > 0 {\n        s = String::from_utf8(s.bytes().take(lpost_len).rev());\n\
    \    }\n\n    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp89rjfqcs.rs:35:46\n   |\n\
    35 |         s = String::from_utf8(s.bytes().take(rpre_len).rev());\n   |    \
    \                                          ^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |         s = String::from_utf8(s.bytes().take(rpre_len.try_into().unwrap()).rev());\n\
    \   |                                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp89rjfqcs.rs:35:31\n   |\n35 |\
    \         s = String::from_utf8(s.bytes().take(rpre_len).rev());\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `Rev`\n   |\n   = note: expected struct `Vec<u8>`\n           \
    \   found struct `Rev<std::iter::Take<std::str::Bytes<'_>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp89rjfqcs.rs:35:13\n   |\n33 |     let mut s\
    \ = string;\n   |                 ------ expected due to this value\n34 |    \
    \ if rpre_len > 0 {\n35 |         s = String::from_utf8(s.bytes().take(rpre_len).rev());\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Result`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Result<String, FromUtf8Error>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp89rjfqcs.rs:39:46\n   |\n39 |         s = String::from_utf8(s.bytes().take(post_len).rev());\n\
    \   |                                              ^^^^^^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n39 |         s = String::from_utf8(s.bytes().take(post_len.try_into().unwrap()).rev());\n\
    \   |                                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp89rjfqcs.rs:39:31\n   |\n39 |\
    \         s = String::from_utf8(s.bytes().take(post_len).rev());\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `Rev`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut len =\
    \ string.len();\n    let mut postfix = string;\n\n    while len > 1 {\n      \
    \  if postfix[len - 2] != string[len - 1] {\n            break;\n        }\n\n\
    \        len -= 1;\n    }\n\n    postfix = &postfix[..(len - 2)];\n    postfix.append(&string[..(len\
    \ - 2)]);\n\n    postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm72enp38.rs:16:12\n\
    \   |\n16 |         if postfix[len - 2] != string[len - 1] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm72enp38.rs:16:32\n   |\n16 |         if postfix[len - 2] != string[len\
    \ - 1] {\n   |                                ^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm72enp38.rs:23:15\n\
    \   |\n13 |     let mut postfix = string;\n   |                       ------ expected\
    \ due to this value\n...\n23 |     postfix = &postfix[..(len - 2)];\n   |    \
    \           ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n23 |     postfix = (&postfix[..(len\
    \ - 2)]).to_string();\n   |               +                     +++++++++++++\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpm72enp38.rs:24:13\n   |\n24 |     postfix.append(&string[..(len\
    \ - 2)]);\n   |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut max_len\
    \ = string.len();\n    let mut suffix = 0;\n    let mut new_string = \"\";\n \
    \   while max_len > 0 {\n        let rev_string = string[..suffix].reversed();\n\
    \        let prefix_string = string.split_last_mut()[..suffix].collect::<Vec<_>>();\n\
    \        let mut prefix_len = prefix_string.len();\n        while prefix_len >\
    \ 0 && prefix_string[prefix_len - 1] == rev_string[prefix_len - 1] {\n       \
    \     prefix_len -= 1;\n        }\n        new_string += &rev_string[..prefix_len];\n\
    \        suffix = prefix_len + suffix;\n        max_len = len - suffix;\n    }\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `len` in this scope\n  --> /tmp/tmpu507wjbr.rs:24:19\n\
    \   |\n24 |         max_len = len - suffix;\n   |                   ^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `reversed` found for type `str`\
    \ in the current scope\n  --> /tmp/tmpu507wjbr.rs:16:43\n   |\n16 |         let\
    \ rev_string = string[..suffix].reversed();\n   |                            \
    \               ^^^^^^^^ method not found in `str`\n\nerror[E0599]: no method\
    \ named `split_last_mut` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu507wjbr.rs:17:36\n   |\n17 |         let prefix_string = string.split_last_mut()[..suffix].collect::<Vec<_>>();\n\
    \   |                                    ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu507wjbr.rs:26:5\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n26 |     new_string\n   |     ^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut start\
    \ = 0\n    let mut end = string.len() - 1;\n    let mut suffix;\n    while start\
    \ < end {\n        suffix = string[start..end].to_lowercase().reverse();\n   \
    \     if suffix == string[start..end].to_lowercase() {\n            return format!(\"\
    {}{}\", string.chars()[start..end].collect::<String>(), suffix);\n        }\n\
    \        start = end + 1;\n        end -= 1;\n    }\n    return string[start..].to_lowercase().reverse();\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmppt8aceqd.rs:12:22\n\
    \   |\n12 |     let mut start = 0\n   |                      ^ help: add `;` here\n\
    13 |     let mut end = string.len() - 1;\n   |     --- unexpected token\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmppt8aceqd.rs:16:52\n   |\n16 |         suffix = string[start..end].to_lowercase().reverse();\n\
    \   |                                                    ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmppt8aceqd.rs:18:36\n  \
    \ |\n18 |             return format!(\"{}{}\", string.chars()[start..end].collect::<String>(),\
    \ suffix);\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmppt8aceqd.rs:23:43\n   |\n23 |     return string[start..].to_lowercase().reverse();\n\
    \   |                                           ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix_len\
    \ = string.len();\n    let mut suffix_len = 0;\n    let mut prefix = &string[..prefix_len];\n\
    \    let mut suffix = &string[..suffix_len];\n    let mut suffix_reverse_prefix\
    \ = &prefix;\n\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    while suffix_len > prefix_len {\n        suffix_reverse_prefix += &suffix[..suffix_len];\n\
    \        suffix_len += 1;\n        prefix_len -= 1;\n        suffix = &string[..suffix_len];\n\
    \    }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    let mut suffix_reverse_prefix_len\
    \ = suffix_reverse_prefix.len();\n    suffix_reverse_prefix_len += 1;\n    let\
    \ mut suffix_reverse = &string[..suffix_reverse_prefix_len];\n    suffix_reverse_prefix\
    \ += &suffix_reverse[..suffix_reverse_len];\n\n    // Return prefix + suffix_reverse_prefix\
    \ + suffix.\n    prefix + suffix_reverse_prefix + suffix\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `suffix_reverse_len` in this scope\n  -->\
    \ /tmp/tmp5w2lz4yy.rs:30:48\n   |\n30 |     suffix_reverse_prefix += &suffix_reverse[..suffix_reverse_len];\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `suffix_reverse`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&&str`\n  --> /tmp/tmp5w2lz4yy.rs:20:9\n\
    \   |\n20 |         suffix_reverse_prefix += &suffix[..suffix_len];\n   |    \
    \     ---------------------^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |   \
    \      cannot use `+=` on type `&&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&&str`\n  --> /tmp/tmp5w2lz4yy.rs:30:5\n   |\n\
    30 |     suffix_reverse_prefix += &suffix_reverse[..suffix_reverse_len];\n   |\
    \     ---------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \  |\n   |     cannot use `+=` on type `&&str`\n\nerror[E0369]: cannot add `&&str`\
    \ to `&str`\n  --> /tmp/tmp5w2lz4yy.rs:33:12\n   |\n33 |     prefix + suffix_reverse_prefix\
    \ + suffix\n   |     ------ ^ --------------------- &&str\n   |     |      |\n\
    \   |     |      `+` cannot be used to concatenate two `&str` strings\n   |  \
    \   &str\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\nhelp: create an owned `String` from a string reference\n   |\n33 |\
    \     prefix.to_owned() + suffix_reverse_prefix + suffix\n   |           +++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0369, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string;\n    let mut suffix = string;\n    let mut reversed_suffix;\n    let\
    \ mut min_length = 0;\n    while min_length < prefix.len() {\n        let mut\
    \ i = 0;\n        while i < prefix.len() && i < suffix.len() {\n            if\
    \ prefix[i] == suffix[i] {\n                i += 1;\n                continue;\n\
    \            }\n            if prefix[i] > suffix[i] {\n                i += 1;\n\
    \                continue;\n            }\n            min_length = std::cmp::min(min_length,\
    \ i);\n            break;\n        }\n        prefix = &prefix[min_length..];\n\
    \        suffix = &suffix[min_length..];\n        reversed_suffix = &suffix[..min_length];\n\
    \    }\n    String::from_utf8_lossy(&prefix[..min_length] + &reversed_suffix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnnark6u9.rs:19:16\n\
    \   |\n19 |             if prefix[i] == suffix[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnnark6u9.rs:19:29\n   |\n19 |             if prefix[i] == suffix[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnnark6u9.rs:23:16\n   |\n23 |             if prefix[i] > suffix[i]\
    \ {\n   |                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find longest\
    \ postfix that is a palindrome\n    let mut longest_postfix = string.clone();\n\
    \    for i in 1..string.len() {\n        // Start reversing the longest postfix\
    \ if it is a palindrome\n        if longest_postfix == string\n            .chars()\n\
    \            .filter(|c| !c.is_ascii())\n            .collect::<Vec<char>>()\n\
    \            .reverse()\n            .as_slice()\n            .to_owned()\n  \
    \      {\n            longest_postfix.push_str(&string[..i]);\n        }\n   \
    \ }\n\n    // Append the reversed prefix to the end of the longest postfix\n \
    \   longest_postfix.push_str(&string[longest_postfix.len()..]);\n\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_slice` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpefriyuu2.rs:21:14\n   |\n21 |             .as_slice()\n\
    \   |              ^^^^^^^^ method not found in `()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    string.rotate_left_by(string.len() - 1);\n\n    let prefix_size\
    \ = string.len() - 1;\n    let mut suffix = &string[prefix_size..];\n    let mut\
    \ reversed_suffix;\n    let mut last_character;\n    while let Some(character)\
    \ = suffix.chars().last_mut() {\n        last_character = character;\n       \
    \ reversed_suffix = suffix\n            .chars()\n            .rev()\n       \
    \     .map(|c| c.to_ascii_lowercase().chars().last().unwrap())\n            .join();\n\
    \        if suffix\n            .chars()\n            .take_while(|&c| c != last_character)\n\
    \            .eq(&reversed_suffix)\n        {\n            break;\n        }\n\
    \        suffix = &string[prefix_size..];\n    }\n    string.append(&reversed_suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_left_by` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgq5fpmbu.rs:13:12\n   |\n13 |     string.rotate_left_by(string.len()\
    \ - 1);\n   |            ^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `last_mut` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmpgq5fpmbu.rs:19:48\n   |\n19 |     while let Some(character) = suffix.chars().last_mut()\
    \ {\n   |                                                ^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpgq5fpmbu.rs:24:45\n   |\n24 |          \
    \   .map(|c| c.to_ascii_lowercase().chars().last().unwrap())\n   |           \
    \                                  ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `join` found for struct `Map` in the current scope\n  --> /tmp/tmpgq5fpmbu.rs:25:14\n\
    \   |\n25 |             .join();\n   |              ^^^^ method not found in `Map<Rev<Chars<'_>>,\
    \ _>`\n\nerror[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgq5fpmbu.rs:35:12\n   |\n35 |     string.append(&reversed_suffix);\n\
    \   |            ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result:\
    \ String = string;\n    let mut suffix;\n    while !result.is_empty() {\n    \
    \    let (suffix, _) = string.split_last_mut();\n        if suffix.is_empty()\
    \ {\n            break;\n        }\n        result.insert(0, suffix);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0pw2e1n0.rs:15:34\n   |\n15 |         let\
    \ (suffix, _) = string.split_last_mut();\n   |                               \
    \   ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `split_at`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.to_owned();\n    let mut iter = string.char_indices();\n    loop {\n\
    \        let (i, _) = iter.next();\n        if i != 0 {\n            iter.rev().for_each(|_|\
    \ ());\n            let mut j = i - 1;\n            let mut k = i + 1;\n     \
    \       let mut mut k = j;\n            let mut suffix = &string[k..];\n     \
    \       let mut start = &string[0..i];\n            let mut reverse = suffix;\n\
    \            let mut reversed = revcomp(&reverse);\n            while (j >= 0\
    \ && k <= string::len() - 1) {\n                if reversed != &suffix[j..] {\n\
    \                    reverse = revcomp(&suffix[k..]);\n                    break;\n\
    \                }\n                j = j - 1;\n                k = k + 1;\n \
    \           }\n            suffix = &string[k..];\n            start = &string[0..i];\n\
    \            if j >= 0 {\n                let mut strings = vec![];\n        \
    \        let mut end = suffix;\n                let mut first = suffix[j..];\n\
    \                while *suffix[j] != reverse {\n                    suffix[j]\
    \ = first[0];\n                    suffix[j + 1] = first[1];\n               \
    \     first = suffix[j + 1..];\n                    j += 1;\n                \
    \    strings.push((start.clone(), end.clone()));\n                }\n        \
    \        strings.push((start.clone(), end.clone()));\n                start =\
    \ &strings[0][0];\n                end = &strings[0][1];\n                for\
    \ s in strings {\n                    let mut string = &strings[1][0];\n     \
    \               let mut suffix1 = &strings[1][1];\n                    let mut\
    \ first = suffix[j..];\n                    while *suffix[j] != reverse {\n  \
    \                      suffix[j] = first[0];\n                        suffix[j\
    \ + 1] = first[1];\n                        first = suffix[j + 1..];\n       \
    \                 suffix1 = &suffix1[j..];\n                        j += 1;\n\
    \                    }\n                    suffix1 = &suffix1[j..];\n       \
    \             strings.push((&string[0], suffix1));\n                }\n      \
    \          strings.sort();\n                string = &strings[0][0];\n       \
    \         suffix1 = &strings[0][1];\n                strings.sort_by_key(|&(start,\
    \ end)| {\n                    start.cmp(&end)\n                });\n        \
    \        suffix = &strings[1][1];\n            }\n            string = string.append(&suffix);\n\
    \            strings.sort_by_key(|&(start, end)| {\n                start.cmp(&end)\n\
    \            });\n            string = string.append(&suffix1);\n            strings.sort_by_key(|&(start,\
    \ end)| {\n                start.cmp(&end)\n            });\n            string\
    \ = string.append(&strings[1][1]);\n            strings.sort_by_key(|&(start,\
    \ end)| \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8l4wd2ep.rs:90:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n14 |     loop {\n\
    \   |          - unclosed delimiter\n15 |         let (i, _) = iter.next();\n\
    16 |         if i != 0 {\n   |                   - this delimiter might not be\
    \ properly closed...\n...\n81 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n90 | }\n   |   ^\n\nerror: `mut` on a binding may not be repeated\n\
    \  --> /tmp/tmp8l4wd2ep.rs:20:21\n   |\n20 |             let mut mut k = j;\n\
    \   |                     ^^^ help: remove the additional `mut`s\n\nerror: expected\
    \ expression, found `)`\n  --> /tmp/tmp8l4wd2ep.rs:81:1\n   |\n81 | }\n   | ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp8l4wd2ep.rs:80:32\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n80 |             strings.sort_by_key(|&(start, end)| \n   |             \
    \                   ^ unclosed delimiter\n81 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmp8l4wd2ep.rs:25:35\n   |\n25 |             while (j >= 0 && k <=\
    \ string::len() - 1) {\n   |                                   ^^^^^^ use of undeclared\
    \ crate or module `string`\n\nerror[E0425]: cannot find function `revcomp` in\
    \ this scope\n  --> /tmp/tmp8l4wd2ep.rs:24:32\n   |\n24 |             let mut\
    \ reversed = revcomp(&reverse);\n   |                                ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `revcomp` in this\
    \ scope\n  --> /tmp/tmp8l4wd2ep.rs:27:31\n   |\n27 |                     reverse\
    \ = revcomp(&suffix[k..]);\n   |                               ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `suffix1` in this scope\n \
    \ --> /tmp/tmp8l4wd2ep.rs:65:17\n   |\n65 |                 suffix1 = &strings[0][1];\n\
    \   |                 ^^^^^^^ help: "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    palindrome.push_str(&String::from(&palindrome.chars().rev().take(string.len()).collect::<String>()));\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpwnip9oug.rs:13:70\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut palindrome = string;\n   |    \
    \                      ------ value moved here\n13 |     palindrome.push_str(&String::from(&palindrome.chars().rev().take(string.len()).collect::<String>()));\n\
    \   |                                                                      ^^^^^^^^^^^^\
    \ value borrowed here after move\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let prefix_length = palindrome.chars().filter_map(|p| palindrome[p])\n\
    \        .count();\n    palindrome.push_str(&string[prefix_length..].chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp89ft180j.rs:13:59\n\
    \   |\n13 |     let prefix_length = palindrome.chars().filter_map(|p| palindrome[p])\n\
    \   |                                                           ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut rev:\
    \ string;\n    let mut max = 0;\n    let mut prefix = '';\n\n    for s in string.chars()\
    \ {\n        if max < s.len() {\n            max = s.len();\n            prefix\
    \ = &s[..max];\n        }\n    }\n\n    rev = &string[..max];\n\n    string\n\
    \        .split_last_mut()\n        .reverse()\n        .filter(|s| !s.is_empty())\n\
    \        .join() + rev + &string[..max]\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpozhbbz47.rs:14:23\n   |\n\
    14 |     let mut prefix = '';\n   |                       ^ empty character literal\n\
    \nerror[E0573]: expected type, found local variable `string`\n   --> /tmp/tmpozhbbz47.rs:12:18\n\
    \    |\n12  |       let mut rev: string;\n    |                    ^^^^^^ help:\
    \ a struct with a similar name exists (notice the capitalization): `String`\n\n\
    error[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpozhbbz47.rs:17:20\n   |\n17 |         if max < s.len() {\n   |\
    \                    ^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `len` found for type `char` in the current scope\n  --> /tmp/tmpozhbbz47.rs:18:21\n\
    \   |\n18 |             max = s.len();\n   |                     ^^^ method not\
    \ found in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n\
    \  --> /tmp/tmpozhbbz47.rs:19:23\n   |\n19 |             prefix = &s[..max];\n\
    \   |                       ^^^^^^^^\n\nerror[E0599]: no method named `split_last_mut`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpozhbbz47.rs:26:10\n\
    \   |\n26 |         .split_last_mut()\n   |          ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split_at`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0573, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0573`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string:\
    \ Vec<String> = Vec::new();\n    let mut longest_palindrome = string.to_string();\n\
    \n    for &character in &string {\n        let mut reversed_character: String\
    \ = character.to_string();\n        while !reversed_character.is_empty() {\n \
    \           reversed_character\n                .chars()\n                .map(|c|\
    \ c.to_digit(16).unwrap())\n                .collect::<Vec<_>>()\n           \
    \     .reverse()\n                .iter()\n                .cloned()\n       \
    \         .enumerate()\n                .find(|&(index, value)| value == c).unwrap()\n\
    \                .unwrap()\n                .next()\n                .unwrap()\n\
    \                .to_string()\n                .insert(0, reversed_character);\n\
    \        }\n\n        if longest_palindrome.chars().any(|c| c == character) {\n\
    \            longest_palindrome.append(reversed_character);\n        } else {\n\
    \            reversed_string.push(reversed_character);\n            longest_palindrome\
    \ = character.to_string();\n        }\n    }\n\n    reversed_string.push(reversed_string.pop().clone());\n\
    \    reversed_string.push(longest_palindrome);\n    reversed_string.join(\"\"\
    ).to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpifjm2ewp.rs:26:50\n\
    \   |\n26 |                 .find(|&(index, value)| value == c).unwrap()\n   |\
    \                                                  ^ not found in this scope\n\
    \nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpifjm2ewp.rs:15:23\n\
    \   |\n15 |     for &character in &string {\n   |                       ^^^^^^^\
    \ `&String` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0599]: no method named `iter` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmpifjm2ewp.rs:23:18\n   |\n\
    23 |                 .iter()\n   |                  ^^^^ method not found in `()`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpifjm2ewp.rs:35:32\n   |\n35 |             longest_palindrome.append(reversed_character);\n\
    \   |                                ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpifjm2ewp.rs:42:26\n   |\n42 |     reversed_string.push(reversed_string.pop().clone());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<String>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = String::from(string);\n    palindrome = find_longest_postfix_palindrome(palindrome);\n\
    \    let mut reversed_string = String::from(palindrome);\n    reversed_string\
    \ = reversed_string[..palindrome.len()].to_string();\n    palindrome = &palindrome[..reversed_string.len()];\n\
    \    reversed_string = &reversed_string[..palindrome.len()];\n    palindrome +\
    \ reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_postfix_palindrome` in\
    \ this scope\n  --> /tmp/tmp32az9g7g.rs:13:18\n   |\n13 |     palindrome = find_longest_postfix_palindrome(palindrome);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp32az9g7g.rs:16:18\n   |\n12 |\
    \     let mut palindrome = String::from(string);\n   |                       \
    \   -------------------- expected due to this value\n...\n16 |     palindrome\
    \ = &palindrome[..reversed_string.len()];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n16 |     palindrome = (&palindrome[..reversed_string.len()]).to_string();\n\
    \   |                  +                                    +++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp32az9g7g.rs:17:23\n   |\n14 |  \
    \   let mut reversed_string = String::from(palindrome);\n   |                \
    \               ------------------------ expected due to this value\n...\n17 |\
    \     reversed_string = &reversed_string[..palindrome.len()];\n   |          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n17 |     reversed_string\
    \ = (&reversed_string[..palindrome.len()]).to_string();\n   |                \
    \       +                                    +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp32az9g7g.rs:18:18\n   |\n18 |     palindrome + reversed_string\n\
    \   |                  ^^^^^^^^^^^^^^^\n   |                  |\n   |        \
    \          expected `&str`, found struct `String`\n   |                  help:\
    \ consider borrowing here: `&reversed_string`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result:\
    \ String = \"\";\n    for c in string.chars() {\n        if string.is_palindrome(c)\
    \ {\n            let palindrome_start = string.rfind(c).unwrap();\n          \
    \  let palindrome_end = palindrome_start - 1;\n            let palindrome = &string[palindrome_start\
    \ ..= palindrome_end];\n            result = result + &palindrome.reverse() +\
    \ &c;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbfzbs_f2.rs:12:30\n   |\n\
    12 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0599]: no method\
    \ named `is_palindrome` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpbfzbs_f2.rs:14:19\n   |\n14 |         if string.is_palindrome(c) {\n\
    \   |                   ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpbfzbs_f2.rs:18:43\n   |\n18 |             result = result + &palindrome.reverse()\
    \ + &c;\n   |                                           ^^^^^^^ method not found\
    \ in `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbfzbs_f2.rs:18:55\n\
    \   |\n18 |             result = result + &palindrome.reverse() + &c;\n   |  \
    \                                                     ^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix_start\
    \ = string.rfind('a');\n    let mut suffix_end = string.rfind('a');\n    let mut\
    \ suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != string[suffix_offset\
    \ + 2] {\n            suffix_end = suffix_offset + 1;\n            suffix_length\
    \ -= 2;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ suffix_start = suffix_end;\n    let mut suffix_end = suffix_start;\n    let\
    \ mut suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != string[suffix_offset\
    \ + 2] {\n            suffix_end = suffix_offset + 1;\n            suffix_length\
    \ -= 2;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ suffix_start = suffix_end;\n    let mut suffix_end = suffix_start;\n    let\
    \ mut suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != string[suffix_offset\
    \ + 2] {\n            suffix_end = suffix_offset + 1;\n            suffix_length\
    \ -= 2;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ suffix_start = suffix_end;\n    let mut suffix_end = suffix_start;\n    let\
    \ mut suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != string[suffix_offset\
    \ + 2] {\n            suffix_end = suffix_offset + 1;\n            suffix_length\
    \ -= 2;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ suffix_start = suffix_end;\n    let mut suffix_end = suffix_start;\n    let\
    \ mut suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != string[suffix_offset\
    \ + 2] {\n            suffix_end = suffix_offset + 1;\n            suffix_length\
    \ -= 2;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ suffix_start = suffix_end;\n    let mut suffix_end = suffix_start;\n    let\
    \ mut suffix_offset = suffix_end;\n    let mut suffix_length = suffix_end - suffix_start;\n\
    \    while suffix_length >= 2 {\n        if string[suffix_offset + 1] != \n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxj6yia0m.rs:92:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n81 |     while suffix_length\
    \ >= 2 {\n   |                              - this delimiter might not be properly\
    \ closed...\n82 |         if string[suffix_offset + 1] != \n83 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n92 | }\n   |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpxj6yia0m.rs:83:1\n   |\n\
    83 | }\n   | ^ expected expression\n\nerror[E0369]: cannot subtract `Option<usize>`\
    \ from `Option<usize>`\n  --> /tmp/tmpxj6yia0m.rs:15:40\n   |\n15 |     let mut\
    \ suffix_length = suffix_end - suffix_start;\n   |                           \
    \  ---------- ^ ------------ Option<usize>\n   |                             |\n\
    \   |                             Option<usize>\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpxj6yia0m.rs:17:33\n   |\n17 |         if string[suffix_offset\
    \ + 1] != string[suffix_offset + 2] {\n   |                   ------------- ^\
    \ - {integer}\n   |                   |\n   |                   Option<usize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpxj6yia0m.rs:17:62\n\
    \   |\n17 |         if string[suffix_offset + 1] != string[suffix_offset + 2]\
    \ {\n   |                                                ------------- ^ - {integer}\n\
    \   |                                                |\n   |                 \
    \                               Option<usize>\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpxj6yia0m.rs:18:40\n   |\n18 |            \
    \ suffix_end = suffix_offset + 1;\n   |                          -------------\
    \ ^ - {integer}\n   |                          |\n   |                       \
    \   Option<usize>\n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n\
    \  --> /tmp/tmpxj6yia0m.rs:28:40\n   |\n28 |     let mut suffix_length = suffix_end\
    \ - suffix_start;\n   |                             ---------- ^ ------------\
    \ Option"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    while let Some(i) = string.reverse().find(|c| !c.is_alphanumeric())\
    \ {\n        let rest = string.as_str().substring(i, string.len());\n        let\
    \ last = rest.chars().collect::<String>();\n        let last_reversed = last.reverse();\n\
    \        string = string + &last_reversed;\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp_4mi9u95.rs:13:32\n   |\n13 |     while let Some(i)\
    \ = string.reverse().find(|c| !c.is_alphanumeric()) {\n   |                  \
    \              ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0599]: no method named `substring` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp_4mi9u95.rs:14:36\n   |\n14 |         let\
    \ rest = string.as_str().substring(i, string.len());\n   |                   \
    \                 ^^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string\n        .chars()\n        .enumerate()\n        .filter(|(_, x)| x\
    \ != string.len())\n        .map(|(_, x)| x.to_string())\n        .collect::<Vec<_>>()\n\
    \        .join(\"\");\n    new_string = format!(\"{}{}\", &new_string, &string[new_string.len()\
    \ - string.len()..]);\n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3fw05nj.rs:15:31\n   |\n\
    15 |         .filter(|(_, x)| x != string.len())\n   |                       \
    \        ^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0277]: can't compare\
    \ `&char` with `usize`\n  --> /tmp/tmp_3fw05nj.rs:15:28\n   |\n15 |         .filter(|(_,\
    \ x)| x != string.len())\n   |                            ^^ no implementation\
    \ for `&char == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string;\n    let mut prefix = &string;\n    let mut suffix = &string;\n  \
    \  let mut reversed_suffix = &string;\n\n    // Find longest postfix of supplied\
    \ string.\n    while suffix.len() > 0 {\n        let mut reverse_suffix = suffix;\n\
    \        for c in reversed_suffix.chars() {\n            if c != c.to_lowercase().as_str()\
    \ {\n                reverse_suffix += &c.to_lowercase().as_str()[..];\n     \
    \           break;\n            }\n        }\n        let mut reverse_suffix_index\
    \ = reversed_suffix.len() - 1;\n        let mut suffix = &reversed_suffix[..];\n\
    \n        // Find the longest prefix that comes before the suffix that is a palindrome\n\
    \        while prefix.len() > 0 {\n            let mut reverse_prefix = prefix;\n\
    \            for c in suffix.chars() {\n                if c != c.to_lowercase().as_str()\
    \ {\n                    reverse_prefix += &c.to_lowercase().as_str()[..];\n \
    \                   break;\n                }\n            }\n            let\
    \ mut reverse_prefix_index = suffix.len() - 1;\n\n            // Check to see\
    \ if these two characters match\n            if reverse_suffix[..] == reverse_prefix[..]\
    \ {\n                // If they match then increment the index\n             \
    \   reverse_suffix_index += 1;\n                reverse_prefix_index -= 1;\n \
    \           }\n\n            // If the reverse prefix was longer than the suffix\
    \ then keep looking\n            if reverse_prefix_index >= 0 {\n            \
    \    prefix = &reverse_prefix[..reverse_prefix_index];\n            } else {\n\
    \                // If the reverse prefix was shorter than the suffix then we\
    \ found a palindrome\n                // and can exit this loop\n            \
    \    break;\n            }\n        }\n\n        // If we found a palindrome we\
    \ can update the reverse suffix with the prefix and exit the loop\n        if\
    \ reverse_suffix_index >= 0 {\n            reversed_suffix = &suffix[..reverse_suffix_index];\n\
    \        } else {\n            // We didn't find a palindrome, move on to the\
    \ next\n            break;\n        }\n    }\n\n    // Now we have the longest\
    \ postfix that is a palindrome, append it to the end of the supplied string\n\
    \    result += &reversed_suffix[..];\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpiynlzq5v.rs:21:38\n   |\n21 |             if\
    \ c != c.to_lowercase().as_str() {\n   |                                     \
    \ ^^^^^^ method not found in `ToLowercase`\n\nerror[E0599]: no method named `as_str`\
    \ found for struct `ToLowercase` in the current scope\n  --> /tmp/tmpiynlzq5v.rs:22:53\n\
    \   |\n22 |                 reverse_suffix += &c.to_lowercase().as_str()[..];\n\
    \   |                                                     ^^^^^^ method not found\
    \ in `ToLowercase`\n\nerror[E0599]: no method named `as_str` found for struct\
    \ `ToLowercase` in the current scope\n  --> /tmp/tmpiynlzq5v.rs:33:42\n   |\n\
    33 |                 if c != c.to_lowercase().as_str() {\n   |               \
    \                           ^^^^^^ method not found in `ToLowercase`\n\nerror[E0599]:\
    \ no method named `as_str` found for struct `ToLowercase` in the current scope\n\
    \  --> /tmp/tmpiynlzq5v.rs:34:57\n   |\n34 |                     reverse_prefix\
    \ += &c.to_lowercase().as_str()[..];\n   |                                   \
    \                      ^^^^^^ method not found in `ToLowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiynlzq5v.rs:49:26\n   |\n13 |     let mut prefix\
    \ = &string;\n   |                      ------- expected due to this value\n...\n\
    49 |                 prefix = &reverse_prefix[..reverse_prefix_index];\n   | \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `str`\n   |\n   = note: expected reference `&String`\n     \
    \         found reference `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiynlzq5v.rs:59:31\n\
    \   |\n15 |     let mut reversed_suffix = &string;\n   |                     \
    \          ------- expected due to this value\n...\n59 |             reversed_suffix\
    \ = &suffix[..reverse_suffix_index];\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror: aborting due to 6 previous "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse_suffix\
    \ = ''; // longest palindrome that ends with supplied string\n    let mut string_palindrome\
    \ = ''; // longest palindrome that starts with supplied string\n    let mut longest_postfix\
    \ = ''; // longest postfix of supplied string that is a palindrome\n    let mut\
    \ longest_prefix = ''; // longest prefix of supplied string that is a palindrome\n\
    \    longest_postfix = &string[..]; // longest postfix of supplied string that\
    \ is a palindrome\n    longest_prefix = &string[..]; // longest prefix of supplied\
    \ string that is a palindrome\n    for i in 1..string.len() {\n        if string[longest_postfix[-i].len()\
    \ > longest_prefix[-i].len() {\n            longest_postfix = &string[longest_postfix[-i].len()..];\n\
    \        } else {\n            longest_prefix = &string[longest_prefix[-i].len()..];\n\
    \        }\n    }\n    if longest_prefix == &string[..] {\n        return longest_prefix;\n\
    \    }\n    reverse_suffix = &string[..].rev();\n    longest_postfix = &string_palindrome[..];\n\
    \    for i in 1..reverse_suffix.len() {\n        if longest_postfix[-i] != reverse_suffix[-i]\
    \ {\n            string_palindrome = longest_postfix.clone(); // longest palindrome\
    \ that ends with supplied string\n            break;\n        }\n    }\n    string_palindrome\
    \ += longest_postfix;\n    return string_palindrome;\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpc9wpxv5n.rs:12:31\n   |\n\
    12 |     let mut reverse_suffix = ''; // longest palindrome that ends with supplied\
    \ string\n   |                               ^ empty character literal\n\nerror:\
    \ empty character literal\n  --> /tmp/tmpc9wpxv5n.rs:13:34\n   |\n13 |     let\
    \ mut string_palindrome = ''; // longest palindrome that starts with supplied\
    \ string\n   |                                  ^ empty character literal\n\n\
    error: empty character literal\n  --> /tmp/tmpc9wpxv5n.rs:14:32\n   |\n14 |  \
    \   let mut longest_postfix = ''; // longest postfix of supplied string that is\
    \ a palindrome\n   |                                ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmpc9wpxv5n.rs:15:31\n   |\n15 |\
    \     let mut longest_prefix = ''; // longest prefix of supplied string that is\
    \ a palindrome\n   |                               ^ empty character literal\n\
    \nerror: expected one of `.`, `?`, `]`, or an operator, found `{`\n  --> /tmp/tmpc9wpxv5n.rs:19:18\n\
    \   |\n19 |         if string[longest_postfix[-i].len() > longest_prefix[-i].len()\
    \ {\n   |                  ^                                                 \
    \   -^\n   |                  |                                              \
    \      |\n   |                  unclosed delimiter                           \
    \        help: `]` may belong here\n\nerror: expected expression, found `]`\n\
    \  --> /tmp/tmpc9wpxv5n.rs:24:5\n   |\n24 |     }\n   |     ^ expected expression\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpc9wpxv5n.rs:19:35\n\
    \   |\n19 |         if string[longest_postfix[-i].len() > longest_prefix[-i].len()\
    \ {\n   |                                   ^^ cannot apply unary operator `-`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `usize`\n  --> /tmp/tmpc9wpxv5n.rs:19:19\n   |\n\
    19 |         if string[longest_postfix[-i].len() > longest_prefix[-i].len() {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceInd"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut len =\
    \ string.len();\n    let mut i = 0;\n    let mut res = String::with_capacity(len);\n\
    \    while i < len {\n        if string.starts_with(string[..i]) {\n         \
    \   res.push_str(&string[..i]);\n        } else {\n            i += 1;\n     \
    \   }\n    }\n    res.push_str(&string[..i]);\n    res\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpw5q6vno_.rs:16:31\n     |\n16   |         if string.starts_with(string[..i])\
    \ {\n     |                   ----------- ^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n     |                   |\n     |                   required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `str`\n    --> /tmp/tmpw5q6vno_.rs:16:31\n\
    \     |\n16   |         if string.starts_with(string[..i]) {\n     |         \
    \          ----------- ^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                   |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `str: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n16   |         if string.starts_with(&string[..i])\
    \ {\n     |                               +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut reverse_string = String::with_capacity(string);\n\
    \    for ch in string.chars() {\n        if let Some(index) = reverse_string.find_first_index(|&b|\
    \ b != ch) {\n            reverse_string.push(c); reverse_string.push(String::from(&string[index..index]));\n\
    \        }\n    }\n\n    reverse_string.chars()\n        .chain(reverse_string.chars().enumerate().rev())\n\
    \        .filter(|(_, x)| x == x.rev())\n        .filter(|(_, x)| x.len() == 1)\n\
    \        .map(|(_, x)| x.first())\n        .collect::<String>() + reverse_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp9gs9dnf3.rs:19:33\n\
    \   |\n19 |             reverse_string.push(c); reverse_string.push(String::from(&string[index..index]));\n\
    \   |                                 ^ help: a local variable with a similar\
    \ name exists: `ch`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gs9dnf3.rs:16:52\n\
    \   |\n16 |     let mut reverse_string = String::with_capacity(string);\n   |\
    \                                                    ^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0599]: no method named `find_first_index` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp9gs9dnf3.rs:18:45\n\
    \   |\n18 |         if let Some(index) = reverse_string.find_first_index(|&b|\
    \ b != ch) {\n   |                                             ^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gs9dnf3.rs:19:57\n\
    \   |\n19 |             reverse_string.push(c); reverse_string.push(String::from(&string[index..index]));\n\
    \   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmp9gs9dnf3.rs:24:51\n   \
    \  |\n24   |         .chain(reverse_string.chars().enumerate().rev())\n     |\
    \                                                   ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0271]:\
    \ type mismatch resolving `<Rev<Enumerate<Chars<'_>>> as IntoIterator>::Item ==\
    \ char`\n   --> /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    use std::cmp::Ordering;\n\
    \    fn is_palindrome(string: String) -> bool {\n        string.chars().enumerate().rev().all(|&(_,\
    \ c)| c.to_lowercase() == c)\n    }\n    let mut suffixes = string\n        .chars()\n\
    \        .filter(|c| !c.is_whitespace() && !c.is_ascii_letter())\n        .map(|c|\
    \ c.to_lowercase())\n        .collect::<Vec<_>>();\n    let mut suffix_len = 0;\n\
    \    let mut postfix = String::from(\"\");\n    let mut longest = 0;\n    while\
    \ let Some(pos) = suffixes.iter().position(|&c| c.is_ascii_letter()) {\n     \
    \   suffix_len = pos - suffixes.len() - 1;\n        postfix = (&string[..pos]).to_string().reverse().to_owned();\n\
    \        if longest < suffix_len {\n            longest = suffix_len;\n      \
    \  }\n        suffixes.remove(pos);\n    }\n    if is_palindrome(postfix + &string[..longest])\
    \ {\n        postfix.append(&string[..longest]).to_string().reverse().to_owned()\n\
    \    } else {\n        postfix\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpag2gypv2.rs:12:9\n\
    \   |\n12 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for reference `&char` in the current scope\n \
    \ --> /tmp/tmpag2gypv2.rs:18:46\n   |\n18 |         .filter(|c| !c.is_whitespace()\
    \ && !c.is_ascii_letter())\n   |                                             \
    \ ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_ascii`\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpag2gypv2.rs:24:59\n   |\n24 |     while\
    \ let Some(pos) = suffixes.iter().position(|&c| c.is_ascii_letter()) {\n   | \
    \                                                          ^^^^^^^^^^^^^^^ method\
    \ not found in `ToLowercase`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpag2gypv2.rs:26:48\n\
    \   |\n26 |         postfix = (&string[..pos]).to_string().reverse().to_owned();\n\
    \   |                                                ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpag2gypv2.rs:33:17\n\
    \   |\n33 |         postfix.append(&string[..longest]).to_string().reverse().to_owned()\n\
    \   |                 ^^^^^^ method not found in `String`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpag2gypv2.rs:14:36\n\
    \     |\n14   |         string.chars().enumerate().rev().all(|&(_, c)| c.to_lowercase()\
    \ == c)\n     |                                    ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse_string\
    \ = string;\n    reverse_string.rev();\n    let mut suffix;\n    let mut suffix_length;\n\
    \n    for suffix_length in 0..string.len() {\n        suffix.clear();\n\n    \
    \    if suffix_length == 0 {\n            suffix = &reverse_string[..];\n    \
    \    } else {\n            suffix = &reverse_string[suffix_length..];\n      \
    \  }\n\n        if suffix.iter().all(|c| *c != *suffix[0]) {\n            break;\n\
    \        }\n\n        reverse_string[suffix_length..suffix_length + suffix.len()]\
    \ = suffix;\n    }\n\n    reverse_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpueeiv5_r.rs:13:20\n\
    \    |\n13  |       reverse_string.rev();\n    |                      ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpueeiv5_r.rs:30:9\n\
    \   |\n30 |         reverse_string[suffix_length..suffix_length + suffix.len()]\
    \ = suffix;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string;\n    let mut index = 0;\n    while !palindrome.starts_with(&string[index..])\
    \ {\n        index += 1;\n        if index >= string.len() {\n            break;\n\
    \        }\n    }\n    let palindrome_suffix = &string[index..];\n    palindrome\
    \ += &string[index..].rev();\n    palindrome += &palindrome_suffix;\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `str` is not an iterator\n  --> /tmp/tmp1rc9w8st.rs:21:36\n\
    \   |\n21 |     palindrome += &string[index..].rev();\n   |                  \
    \                  ^^^ `str` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `str: Iterator`\n           which\
    \ is required by `&mut str: Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    shortest_palindrome(\n\
    \        string,\n        |string| {\n            palindrome_prefix(string)\n\
    \        }\n    )\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shortest_palindrome` in this scope\n\
    \  --> /tmp/tmp2ata5rs_.rs:12:5\n   |\n12 |     shortest_palindrome(\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `palindrome_prefix` in this scope\n  --> /tmp/tmp2ata5rs_.rs:15:13\n   |\n15\
    \ |             palindrome_prefix(string)\n   |             ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.len()\
    \ <= 1 {\n        return string;\n    }\n\n    let (prefix, suffix) = string.split_first();\n\
    \    let reversed_prefix = prefix.chars()\n        .cloned()\n        .collect::<String>()\n\
    \        .reverse()\n        .collect::<String>();\n    let reversed_suffix =\
    \ (&suffix)\n        .chars()\n        .cloned()\n        .collect::<String>()\n\
    \        .reverse()\n        .collect::<String>();\n    prefix + &reversed_prefix[..]\
    \ + \"cata\" + &reversed_suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpys2b9vjz.rs:16:35\n   |\n16 |     let (prefix,\
    \ suffix) = string.split_first();\n   |                                   ^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = String::new();\n    loop {\n        let mut palindrome = String::new();\n\
    \        for pos in string.rfind('a') {\n            if pos == 0 {\n         \
    \       continue;\n            }\n            palindrome.append(&string[..pos]);\n\
    \        }\n        if longest_postfix_length < palindrome.len() {\n         \
    \   longest_postfix_length = palindrome.len();\n            longest_postfix =\
    \ palindrome;\n        }\n        if palindrome.len() < string.len() {\n     \
    \       string = &palindrome[..];\n        } else {\n            break;\n    \
    \    }\n    }\n    longest_postfix.append(&string[..]);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpefdxgz0a.rs:21:24\n   |\n21 |             palindrome.append(&string[..pos]);\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefdxgz0a.rs:28:22\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    28 |             string = &palindrome[..];\n   |                      ^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n28 |             string = (&palindrome[..]).to_string();\n   |        \
    \              +               +++++++++++++\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmpefdxgz0a.rs:33:21\n\
    \   |\n33 |     longest_postfix.append(&string[..]);\n   |                   \
    \  ^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string[..];\n    let mut pos = 0;\n    while reverse != reverse {\n      \
    \  reverse[pos] = reverse[pos + 1]; // move char to the right\n        pos++;\n\
    \    }\n    string[..] = reverse;\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpa2bkzaxs.rs:16:12\n\
    \   |\n16 |         pos++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n16 |         { let tmp = pos; pos += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n16 -         pos++;\n\
    16 +         pos += 1;\n   | \n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpa2bkzaxs.rs:12:9\n   |\n\
    12 |     let mut reverse = string[..];\n   |         ^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n12 |     let mut reverse = &string[..];\n   |                  \
    \     +\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpa2bkzaxs.rs:15:9\n   |\n15 |         reverse[pos] = reverse[pos + 1];\
    \ // move char to the right\n   |         ^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpa2bkzaxs.rs:15:24\n\
    \   |\n15 |         reverse[pos] = reverse[pos + 1]; // move char to the right\n\
    \   |                        ^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n\
    \   = note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more\
    \ information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string\n    }\n\n    let mut reverse = String::new();\n  \
    \  let mut prefix = String::new();\n\n    for c in string.chars() {\n        prefix.push(c);\n\
    \n        if string.starts_with(string[c.len_utf8()..].to_lowercase()) {\n   \
    \         reverse.push_str(&string[c.len_utf8()..]);\n        }\n    }\n\n   \
    \ reverse.push_str(&prefix);\n    reverse.trim_end_matches('a');\n\n    if reverse.starts_with('c')\
    \ {\n        reverse.push('a');\n    }\n\n    match reverse.to_lowercase().len()\
    \ {\n        0 => string[..],\n        1 => reverse,\n        2 => string,\n \
    \       _ => return string,\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpffqkd2qi.rs:22:31\n     |\n22   |         if string.starts_with(string[c.len_utf8()..].to_lowercase())\
    \ {\n     |                   ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                   |\n\
    \     |                   required by a bound introduced by this call\n     |\n\
    \     = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n22   |         if string.starts_with(&string[c.len_utf8()..].to_lowercase())\
    \ {\n     |                               +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpffqkd2qi.rs:35:14\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n35 |         0 => string[..],\n   |           \
    \   ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |    \
    \          |\n   |              expected struct `String`, found `str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    string\n    \
    \    .chars()\n        .filter(|c| !c.is_ascii_lowercase())\n        .collect()\n\
    \        .filter(|c| !c.is_ascii_uppercase())\n        .map(|c| c.to_ascii_lowercase())\n\
    \        .collect()\n        .iter()\n        .map(|s| s[..])\n        .filter(|s|\
    \ s.chars().all(|c| s.chars().any(|cc| cc == c)))\n        .next()\n        .chars()\n\
    \        .collect()\n        .filter(|c| c.is_ascii_lowercase())\n        .map(|c|\
    \ c.to_ascii_uppercase())\n        .collect()\n        .iter()\n        .map(|s|\
    \ s[..])\n        .filter(|s| s.chars().all(|c| s.chars().any(|cc| cc == c)))\n\
    \        .next()\n        .to_string()\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpwaewerbj.rs:15:10\n\
    \   |\n15 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n15 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_prefix:\
    \ String = string.to_string();\n    let mut reversed_suffix: String = \"\";\n\n\
    \    for (i, &ch) in string.chars().enumerate() {\n        if i == string.len()\
    \ - 1 {\n            reversed_suffix += &ch;\n            continue;\n        }\n\
    \n        if let Some(prev_ch) = &string[i - 1] {\n            if prev_ch != ch\
    \ {\n                reversed_prefix += &ch;\n                break;\n       \
    \     }\n        }\n    }\n\n    reversed_prefix += &reversed_suffix;\n    reversed_prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppf3c0t7l.rs:13:39\n   |\n\
    13 |     let mut reversed_suffix: String = \"\";\n   |                       \
    \       ------   ^^- help: try using a conversion method: `.to_string()`\n   |\
    \                              |        |\n   |                              |\
    \        expected struct `String`, found `&str`\n   |                        \
    \      expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppf3c0t7l.rs:15:13\n\
    \   |\n15 |     for (i, &ch) in string.chars().enumerate() {\n   |           \
    \  ^^^     -------------------------- this expression has type `Option<(usize,\
    \ char)>`\n   |             |\n   |             expected `char`, found reference\n\
    \   |             help: you can probably remove the explicit borrow: `ch`\n  \
    \ |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmppf3c0t7l.rs:15:14\n   |\n15 |     for (i, &ch) in string.chars().enumerate()\
    \ {\n   |              ^^ doesn't have a size known at compile-time\n   |\n  \
    \ = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmppf3c0t7l.rs:21:33\n   |\n21 |         if let Some(prev_ch)\
    \ = &string[i - 1] {\n   |                                 ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `str`\n  --> /tmp/tmppf3c0t7l.rs:22:"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut len =\
    \ string.len();\n    let mut revd_string = \"\";\n\n    while let Some(r) = reverse_iter(&string)\
    \ {\n        revd_string.push(r);\n        if len == 0 {\n            break;\n\
    \        }\n        len -= 1;\n    }\n    revd_string += &string[len..];\n   \
    \ revd_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse_iter` in this scope\n  -->\
    \ /tmp/tmpc7qu4_k7.rs:15:25\n   |\n15 |     while let Some(r) = reverse_iter(&string)\
    \ {\n   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpc7qu4_k7.rs:16:21\n   |\n16 |         revd_string.push(r);\n   |   \
    \                  ^^^^ method not found in `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpc7qu4_k7.rs:22:5\n\
    \   |\n22 |     revd_string += &string[len..];\n   |     -----------^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc7qu4_k7.rs:23:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n23 |     revd_string\n   |     ^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0425, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut pos =\
    \ 0;\n    while let Some(i) = string.rposition(|c| c != string[pos - 1]) {\n \
    \       pos = i;\n    }\n    let postfix_len = string.len() - pos as usize;\n\
    \    let prefix_len = string.len().saturating_sub((string.len() - pos).saturating_mul(postfix_len\
    \ as u32 + 1));\n    let postfix = &string[..pos];\n    let prefix = &string[..prefix_len];\n\
    \    prefix.reverse();\n    let mut suffix = [prefix.to_lowercase()];\n    suffix.extend(&postfix);\n\
    \    suffix.reverse();\n    prefix + suffix.to_string()\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rposition` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpdn_ufv4c.rs:13:32\n   |\n13 |     while let\
    \ Some(i) = string.rposition(|c| c != string[pos - 1]) {\n   |               \
    \                 ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdn_ufv4c.rs:13:51\n\
    \   |\n13 |     while let Some(i) = string.rposition(|c| c != string[pos - 1])\
    \ {\n   |                                                   ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdn_ufv4c.rs:17:86\n\
    \   |\n17 |     let prefix_len = string.len().saturating_sub((string.len() - pos).saturating_mul(postfix_len\
    \ as u32 + 1));\n   |                                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `u32`\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let prefix_len = string.len().saturating_sub((string.len()\
    \ - pos).saturating_mul((postfix_len as u32 + 1).try_into().unwrap()));\n   |\
    \                                                                            \
    \          +                      +++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `reverse` found for reference `&str` in the current scope\n  --> /tmp/tmpdn_ufv4c.rs:20:12\n\
    \   |\n20 |     prefix.reverse();\n   |            ^^^^^^^ method not found in\
    \ `&str`\n\nerror[E0599]: no method named `extend` found for array `[String; 1]`\
    \ in the current scope\n  --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n    let (longest, middle) = longest_postfix_palindrome(string);\n\
    \    let mut middle = middle\n        .iter()\n        .cloned()\n        .chain(longest_prefix_palindrome(&middle))\n\
    \        .chain(string.chars())\n        .collect();\n    middle.reverse();\n\
    \    middle\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_postfix_palindrome` in this\
    \ scope\n  --> /tmp/tmpn6fir2vr.rs:15:29\n   |\n15 |     let (longest, middle)\
    \ = longest_postfix_palindrome(string);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `longest_prefix_palindrome`\
    \ in this scope\n  --> /tmp/tmpn6fir2vr.rs:19:16\n   |\n19 |         .chain(longest_prefix_palindrome(&middle))\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = \"\";\n    for i in string.chars().rposition(|x| !x.is_alphanumeric()) {\n\
    \        result = result + &string[i as usize];\n    }\n    result = &string[string.len()\
    \ - result.len()..].to_string() + result;\n    result.rev().to_owned()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpai4efj6b.rs:13:29\n     |\n13   |     for i in string.chars().rposition(|x|\
    \ !x.is_alphanumeric()) {\n     |                             ^^^^^^^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\nnote: required by a bound in `rposition`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpai4efj6b.rs:14:28\n\
    \   |\n14 |         result = result + &string[i as usize];\n   |             \
    \               ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]:\
    \ cannot add `&_` to `&str`\n  --> /tmp/tmpai4efj6b.rs:14:25\n   |\n14 |     \
    \    result = result + &string[i as usize];\n   |                  ------ ^ -------------------\
    \ &_\n   |                  |\n   |                  &str\n\nerror[E0369]: cannot\
    \ add `&str` to `&String`\n  --> /tmp/tmpai4efj6b.rs:16:65\n   |\n16 |     result\
    \ = &string[string.len() - result.len()..].to_string() + result;\n   |       \
    \       -------------------------------------------------- ^ ------ &str\n   |\
    \              |                                                  |\n   |    \
    \          |                                                  `+` cannot be used\
    \ to conca"
  exit_code: 1
  status: SyntaxError
