name: HumanEval_147_get_max_triples
language: rust
prompt: "/// You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// Input:\
  \ n = 5\n/// Output: 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only\
  \ valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    let mut a = vec![];\n    let mut cnt = 0;\n    for _ in 1..n{\n\
    \        a.push(0);\n        cnt += 1;\n    }\n    for i in 1..n{\n        for\
    \ j in (i+1)..n{\n            if(a[i] + a[j] > 3) {\n                a[i] += 1;\n\
    \                a[j] += 1;\n                a[i] += a[j];\n                cnt\
    \ -= 1;\n                break;\n            }\n        }\n    }\n    cnt", " \
    \   // brute force \n    let mut a: [usize; n] = [0; n];\n    for i in 0..n {\n\
    \        a[i] = i * i - i + 1;\n    }\n    let mut triples = 0;\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            for k in 0..n {\n             \
    \   if a[i] < a[j] && a[j] < a[k] {\n                    triples++;\n        \
    \        }\n            }\n        }\n    }\n    triples", "    if n == 0 {\n\
    \        return 0;\n    }\n\n    let mut num_triplets: isize = 0;\n    let mut\
    \ a_array: [isize; n] = [n; n];\n    let mut a_sum: isize = 0;\n\n    for i in\
    \ 0..n {\n        let mut sum: isize = i;\n        for j in i..n {\n         \
    \   a_array[j] += sum;\n            sum += i - j + 1;\n        }\n        a_sum\
    \ += i;\n    }\n\n    for i in 0..n {\n        for j in i..n {\n            for\
    \ k in i..n {\n                let current_triple = (a_array[i], a_array[j], a_array[k]);\n\
    \                if current_triple.is_multiple_of_three() && current_triple !=\
    \ (0, 0, 0) {\n                    num_triplets += 1;\n                    break;\n\
    \                }\n            }\n        }\n    }\n\n    return num_triplets;",
  "    let mut a = [1isize; n];\n\n    for i in 0..(n) {\n        a[i] = i * i - i\
    \ + 1;\n    }\n\n    a.iter().filter(|x| x%3 == 0).count()", "    use std::cmp::Ordering;\n\
    \n    let mut a = [1isize; n];\n    let mut min_val = a[0];\n    let mut max_val\
    \ = a[n-1];\n\n    for i in 1..n-1 {\n        a[i] = i * i - i + 1;\n        if\
    \ i < n-1 && (a[i] > min_val as isize + Ordering::Greater) && a[i] <= max_val\
    \ as isize + Ordering::Less {\n            min_val = a[i];\n        }\n    }\n\
    \n    for i in 1..n-1 {\n        for j in i..n-1 {\n            let k = i + j;\n\
    \            if k >= n-1 && a[k] > min_val as isize + Ordering::Greater) {\n \
    \               min_val = a[k];\n            }\n        }\n    }\n    \n    for\
    \ (ii, jj) in a.iter().zip(&a[..n-1]).filter(|&x| x % 3 == 0) {\n        if jj\
    \ < min_val as isize + Ordering::Less {\n            return ii;\n        }\n \
    \   }\n    \n    a.len()", "    let mut a = Vec::new();\n    for i in 1..n {\n\
    \        let mut current = i;\n        while current < n {\n            a.push(i\
    \ * i - i + 1);\n            current += i;\n        }\n    }\n\n    for i in 1..n\
    \ {\n        let mut current = i;\n        let mut current_min = i;\n        while\
    \ current < n {\n            if a[i] > a[current] {\n                a[i] = a[current];\n\
    \                a[current] = a[i] - a[i];\n                a[current_min] +=\
    \ 1;\n            }\n            current += i;\n            current_min += i;\n\
    \        }\n    }\n\n    for i in 1..n {\n        if a[i] % 3 == 0 {\n       \
    \     return i;\n        }\n    }\n    0", '    ', "    let mut arr: [isize; n\
    \ + 1] = vec![0; n + 1];\n    for i in 0..n {\n        arr[i] = i * i - i + 1;\n\
    \    }\n    let mut ans = 0;\n    for j in 0..n {\n        for k in 0..n {\n \
    \           if j + 1 < k {\n                let sum = arr[j] + arr[k];\n     \
    \           if sum % 3 == 0 {\n                    ans += 1;\n               \
    \ }\n            }\n        }\n    }\n    ans", "    let mut count = 0\n    let\
    \ mut arr = vec![0; n]\n    for i in 1..n{\n        for j in 1..n{\n         \
    \   for k in 1..n{\n                let sum = i*i + j*j + k*k;\n             \
    \   if sum%3 == 0 {\n                    arr[i] = arr[i] + arr[j] + arr[k];\n\
    \                    count = count + 1;\n                }\n            }\n  \
    \      }\n    }\n    return count;", "    let mut a = vec![0; n];\n    for x in\
    \ 1..n {\n        for y in 1..n {\n            a[x - 1] = (x * x - x + 1) * y;\n\
    \        }\n    }\n    \n    let mut cnt = 0;\n    for x in 1..n {\n        for\
    \ y in 1..n {\n            cnt += a[x - 1] + a[y - 1] + a[y - 1] == 3;\n     \
    \   }\n    }\n    \n    return cnt;", "    let mut triplets = 0;\n    let mut\
    \ arr = vec![isize; n];\n\n    for i in 0..n {\n        arr[i] = i * i - i + 1;\n\
    \    }\n    for i in 0..n {\n        for j in 0..n {\n            for k in 0..n\
    \ {\n                if i >= j && j >= k {\n                    continue;\n  \
    \              }\n                triplets +=\n                    match (arr[i],\
    \ arr[j], arr[k]) {\n                        (w, x, _) => (w) * w + (x) * x +\
    \ (_) * _,\n                        (_, _, _) => 0\n                    };\n \
    \           }\n        }\n    }\n    triplets", "    let mut a: Vec<isize> = vec![0;\
    \ n];\n    \n    for j in 0..n {\n        for i in 0..n {\n            let mut\
    \ triplets = 0;\n            let mut k = j;\n            let mut i = i;\n    \
    \        let mut j = j;\n            let mut a = a[j..j + i];\n            \n\
    \            for k in 0..n {\n                if i <  k {\n                  \
    \  break;\n                }\n                \n                if a[k] % 3 ==\
    \ 0 {\n                    triplets += 1;\n                }\n               \
    \ \n                i = k;\n            }\n            \n            a[j..j +\
    \ i] += 1;\n            \n            if triplets == 3 {\n                println!(\"\
    a = {}\", a);\n                break;\n            }\n        }\n    }\n    \n\
    \    a.iter().filter(|x| x > 1).count()", "    let mut triple_sum = 0;\n    let\
    \ mut a = vec![0; n];\n    for i in 1..n {\n        for j in i..n {\n        \
    \    for k in i..n {\n                if i == j && j == k {\n                \
    \    continue;\n                }\n                let v = (a[i] + a[j] + a[k])\
    \ % 3;\n                if v == 0 {\n                    triple_sum += 3;\n  \
    \              }\n            }\n        }\n    }\n    triple_sum", "    let mut\
    \ a: [f32; n + 1] = Default::default();\n    let mut cnt: isize = 0;\n    for\
    \ i in 1..n + 1 {\n        a[i] = i * i - i + 1; // i * i - i + 1 = i * i * i\
    \ + i + 1, so a[i] = i * i - i + 1\n    }\n    for i in 0..n - 1 {\n        for\
    \ j in i + 1..n + 1 {\n            for k in 0..n - 1 {\n                if i !=\
    \ j && i != k && j != k {\n                    if a[i] - a[j] - a[k] == a[i] -\
    \ a[j] + a[k] {\n                        cnt += 1;\n                    }\n  \
    \              }\n            }\n        }\n    }\n    cnt", "    let mut a =\
    \ vec![0; n];\n    let mut n = 0;\n    \n    for _ in 0..n {\n        a[..] =\
    \ a.clone();\n    }\n    \n    for &i in 0..n {\n        let mut j = 0;\n    \
    \    let mut k = 0;\n        \n        while j < k {\n            if a[i] + a[j]\
    \ + a[k] == 3 {\n                n += 1;\n                break;\n           \
    \ }\n            \n            if a[i] < a[j] {\n                k += 1;\n   \
    \         } else {\n                j += 1;\n            }\n        }\n    }\n\
    \    \n    n", "    let mut arr: [isize; n] = [0; n];\n    for i in 1..n-1 { arr[i]\
    \ = i * i - i + 1 };\n    arr\n        .iter()\n        .filter(|&x| x > 0 &&\
    \ x % 3 == 0)\n        .count()", "    loop {\n        let mut a = vec![];\n \
    \       a.push((*n).abs() as isize);\n        n -= 1;\n        if n % 3 != 0 {\n\
    \            break;\n        }\n        a.push(3 * a.last().unwrap() + 1); \n\
    \        if a[a.len()-1] != 3*a[a.len()-1]+1 {\n            break;\n        }\n\
    \        a.push(3*a.last().unwrap());\n        if a[a.len()-1] != 3*a[a.len()-1]+2\
    \ {\n            break;\n        }\n        // println!(\"{}\", a);\n    }\n \
    \   a.len()", "    (0..n).filter(|i| {\n        i % 3 == 0 || i % 7 == 0 || i\
    \ % 13 == 0\n    }).count() * 3", "    debug_assert!(n >= 0);\n    let mut max_triple_so_far\
    \ = n / 3;\n    for a in (0..n)\n        .filter(|&i| i % 3 == 0)\n        .enumerate()\n\
    \    {\n        let triple = a.0;\n        let i = a.1;\n        let j = a.2;\n\
    \        if triple*triple + i*i + j*j > max_triple_so_far * max_triple_so_far\
    \ {\n            max_triple_so_far = triple*triple + i*i + j*j;\n        }\n \
    \   }\n    1 + max_triple_so_far", "    let mut a_vec = [0; n];\n    let mut cnt\
    \ = 0;\n    let mut triples = 1;\n    for i in (0..n-1).rev() {\n        for j\
    \ in (i+1..n).rev() {\n            for k in (i+1..n).rev() {\n               \
    \ let mut total = 0;\n                total += i;\n                total += j;\n\
    \                total += k;\n                if total == 3 {\n              \
    \      cnt+=triples;\n                    triples=1;\n                }\n    \
    \            total += a_vec[j]+a_vec[k]+a_vec[i];\n                if total ==\
    \ 3 {\n                    cnt+=triples;\n                    triples=1;\n   \
    \             }\n                a_vec[j] = total;\n                a_vec[k] =\
    \ total;\n                a_vec[i] = total;\n            }\n        }\n    }\n\
    \    return cnt;", "    let mut a = vec![0; n + 1];\n    \n    for i in 1..=n\
    \ {\n        a[i] = i * i - i + 1;\n    }\n\n    for i in 1..=n {\n        for\
    \ j in 1..=n {\n            for k in 1..=n {\n                if i != j && i !=\
    \ k && j != k {\n                    let res = a[i] + a[j] + a[k];\n         \
    \           if res == 3 * (i * i + j * j + k * k) {\n                        return\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    \n    0", "    a.iter().filter(|&i| {\n        a[i] % 3 == 0 && a[j]\
    \ % 3 == 0 && k % 3 == 0\n    }).count()", "    let mut a: [isize; n + 1] = [isize::MAX;\
    \ n + 1];\n    a[1] = 1;\n    for i in 2..n + 1 {\n        a[i] = i * i - i +\
    \ 1;\n    }\n    let mut cnt = 0;\n    for i in 1..n + 1 {\n        for j in (i\
    \ + 1)..n + 1 {\n            if a[i] - a[j] > 0 {\n                for k in (i\
    \ + 1)..n + 1 {\n                    if a[i] - a[k] > 0 {\n                  \
    \      if a[j] - a[k] > 0 {\n                            if a[i] - a[j] - a[k]\
    \ == 0 {\n                                break;\n                           \
    \ }\n                        }\n                    }\n                }\n   \
    \             cnt += 1;\n            }\n        }\n    }\n    cnt", "    let mut\
    \ a = vec![1i; n];\n\n    for i in 1..n-1.iter() {\n        a[i] = i * i - i +\
    \ 1;\n    }\n\n    for i in 1..n-1.iter() {\n        for j in i + 1..n-1.iter()\
    \ {\n            for k in j + 1..n-1.iter() {\n                if a[i] > a[j]\
    \ && a[j] > a[k] {\n                    a[i] -= a[j] - a[k];\n               \
    \     return a.len();\n                }\n            }\n        }\n    }\n  \
    \  return a.len();", "    if n == 0 {\n        return 0;\n    }\n    \n    //\
    \ First create an array of the given size\n    let mut a: [isize; n] = [0; n];\n\
    \    \n    // Fill in the array\n    for i in 1..n {\n        a[i] = i * (i -\
    \ 1) + i;\n    }\n    \n    // Now find all triples a[i], a[j], a[k]\n    let\
    \ mut total: isize = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n {\n\
    \            let k = i + j;\n            \n            // If the array elements\
    \ are all multiples of 3, \n            // we add them to the count\n        \
    \    if a[j] % 3 == 0 || a[k] % 3 == 0 {\n                total += 1;\n      \
    \      }\n        }\n    }\n    \n    total", "    let mut a = vec![0; n];\n \
    \   for i in 1..n{\n        a[i] = i * i - i + 1;\n    }\n    a.iter().filter_map(|x|\
    \ if x.1 % 3 == 0 { Some(x) } else { None }).count()", "    let mut a = vec![0;\
    \ n];\n    let mut count = 0;\n    let mut triple_count = 0;\n\n    for i in 1..n\
    \ {\n        for j in 0..i-1 {\n            for k in 0..(n-i-1) {\n          \
    \      if i <= j && j+k <= n {\n                    a[i] += j;\n             \
    \       a[j] += k;\n                    a[k] += i;\n                }\n      \
    \      }\n        }\n    }\n\n    for i in 1..n {\n        if i % 3 != 0 {\n \
    \           triple_count += 1;\n        }\n    }\n\n    for i in 1..n {\n    \
    \    if a[i] == (i % 3) {\n            triple_count += 1;\n        }\n    }\n\n\
    \    for i in 1..n {\n        if a[i] - i == 3 {\n            triple_count +=\
    \ 1;\n        }\n    }\n\n    count", "    let mut sum_of_a = 0;\n    let mut\
    \ a = [0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n        sum_of_a\
    \ += a[i];\n    }\n    let mut min_triples = std::cmp::min(n, 3);\n    for i in\
    \ 0..n {\n        if a[i] % 3 == 0 || a[i] % 3 == 0 || a[i] % 3 == 0 {\n     \
    \       min_triples = std::cmp::min(min_triples, i + 1);\n        }\n    }\n \
    \   return min_triples;", "    (1..n).filter(|i| i * i > n && i * i - i + 1 <\
    \ n).filter(|i| {\n        (i * i - i + 1) % 3 == 0\n    }).count()", "    let\
    \ mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n  \
    \  }\n    let mut count = 0;\n    let mut triple = 0;\n    for i1 in 0..n {\n\
    \        for i2 in i1..n {\n            for i3 in i2..n {\n                if\
    \ triple%3 == 0 {\n                    count += 1;\n                } else {\n\
    \                    triple = a[i1] + a[i2] + a[i3];\n                }\n    \
    \        }\n        }\n    }\n    count", "    // Your code here\n    let mut\
    \ a: Vec<i32> = vec![0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n\
    \    }\n    a.iter().filter(|&x| x >= 3).count()", "    let mut a = Vec::new();\n\
    \    let mut total = 0;\n    for i in 0..n {\n        a.push(3 * (i + 1) / 2 -\
    \ i + 1);\n    }\n    for i in 1..n-1 {\n        for j in 2..n-1 {\n         \
    \   for k in 3..n-1 {\n                if i + j + k == 3 * i {\n             \
    \       total += 1;\n                }\n            }\n        }\n    }\n    total",
  "    if n < 3 { return 0; }\n    let mut a = vec![0; n];\n    let mut count = 0usize;\n\
    \    for i in 1..n-1 { \n        for j in i+1..n-1 { \n            if i != j {\
    \ \n                if a[j] - a[i] == 3 { \n                    count++;\n   \
    \             }\n            }\n        }\n    }\n    count", "    let mut a =\
    \ vec![0; n + 1];\n    a[1] = 1;\n    for i in 2..n + 1 {\n        a[i] = a[i]\
    \ * i - i + 1;\n    }\n    \n    for i in 2..n + 1 {\n        for j in 2..n +\
    \ 1 {\n            for k in 2..n + 1 {\n                if a[i] < a[j] && a[j]\
    \ < a[k] && a[i] < a[j] + a[k] {\n                    return 1\n             \
    \   }\n            }\n        }\n    }\n    0", "    let mut sum = 0;\n    let\
    \ mut a: [usize; n] = [i64::MIN; n];\n    let mut cnt: isize = 0;\n    for i in\
    \ 0..n {\n        a[i] = i * i - i + 1;\n        for j in (i + 1)..n {\n     \
    \       if a[i] < a[j] {\n                sum -= 1;\n                break;\n\
    \            }\n            if a[j] < a[i] {\n                sum -= 1;\n    \
    \            break;\n            }\n            sum += 1;\n            cnt +=\
    \ 1;\n        }\n    }\n    sum", "    // Fill this in.\n    let mut triple_count\
    \ = 0;\n    for _ in 0..(n-1) {\n        triple_count += 1;\n    }\n    return\
    \ triple_count;", "    let mut a = vec![1; n];\n    a[n - 1] = 3 * n - 1;\n  \
    \  for i in 0..n {\n        for j in 0..n {\n            let k = n - i - j + 1;\n\
    \            a[i + j] = (a[i + j] + (i * i) - i) + j;\n        }\n    }\n    a.iter().filter(|&x|\
    \ x % 3 == 0).count()", "    if n < 3 {\n        return 0\n    }\n    \n    let\
    \ mut a = vec![0; n];\n    \n    // Initialize all elements to 1 so no pair is\
    \ counted twice\n    for i in 0..n {\n        a[i] = 1;\n    }\n    \n    // Update\
    \ elements a[i] and a[j] for all j < i\n    for j in 1..n {\n        for i in\
    \ 1..j {\n            let temp_a = a[i - 1];\n            let temp_b = a[j - 1];\n\
    \            \n            a[i] = a[j - 1] + temp_a;\n            a[j] = temp_a\
    \ + temp_b;\n        }\n    }\n    \n    \n    // Check condition (a[i] + a[j]\
    \ + a[k]) is a multiple of 3\n    let mut count = 0;\n    for i in 0..n {\n  \
    \      let k = a[i];\n        if k + 3 == a[j] {\n            count += 1;\n  \
    \      }\n    }\n    \n    return count", "    let mut res = 0;\n    let mut a\
    \ = vec![0; n];\n    for i in 1..n {\n        a[i] = i * (i - 1) + i + 1;\n  \
    \  }\n    for i in 1..n {\n        for j in 1..i {\n            for k in 1..j\
    \ {\n                if a[i] < a[j] && a[j] < a[k] && (a[i] + a[j] + a[k]) % 3\
    \ == 0 {\n                    res += 1;\n                }\n            }\n  \
    \      }\n    }\n    res", "    if n < 0 {\n        0\n    } else {\n        let\
    \ mut count = 1;\n        for _ in 0..(n-2) {\n            let mut sum = 0;\n\
    \            for i in 0..(n-2) {\n                let j = i + 1;\n           \
    \     let k = i + 2;\n                sum += a[i].wrapping_add(a[j].wrapping_add(a[k].wrapping_add(1)))\n\
    \            }\n            if sum % 3 == 0 {\n                count += 1;\n \
    \           }\n        }\n        count\n    }", "    let mut a = vec![0; n +\
    \ 1];\n    for i in 1..n + 1{\n        a[i] = i * i - i + 1;\n    }\n    \n  \
    \  let mut res = 0;\n    \n    for &i in &a[0..n] {\n        for &j in &a[i..n]\
    \ {\n            for &k in &a[j..n] {\n                let result = i*i*i + j*j*j\
    \ + k*k*k;\n                \n                if result % 3 == 0 {\n         \
    \           res++;\n                }\n            }\n        }\n    }\n    \n\
    \    res", "    let mut a: Vec<isize> = vec![0; n];\n    for i in 1..n {\n   \
    \     a[n - i - 1] = a[n - i] - i + 1;\n    }\n    for i in 1..n {\n        for\
    \ j in i..n {\n            for k in i..n {\n                if a[i] == a[j] +\
    \ a[k] {\n                    return 1;\n                }\n            }\n  \
    \      }\n    }\n    0", "    let mut triplesCounter = 0isize;\n\n    for mut\
    \ i in 1..n {\n        for mut j in (i + 1)..n {\n            for mut k in (i\
    \ + 1)..n {\n                if i * i + j * j + k * k == 3 {\n               \
    \     triplesCounter += 1;\n                }\n            }\n        }\n    }\n\
    \n    return triplesCounter;", "    let mut num = 0\n    let mut triple_num =\
    \ 0\n    \n    for _ in 0..(n * n - 1) {\n        let mut temp = 0\n        for\
    \ i in 0..n {\n            for j in (i + 1)..n {\n                for (k in (i\
    \ + 1)..j) {\n                    if i % 2 == j % 2 == k % 2 {\n             \
    \           temp += 1\n                    }\n                }\n            }\n\
    \        }\n        if temp % 3 == 0 {\n            triple_num += 1\n        }\n\
    \    }\n    \n    return triple_num", "    let mut triples = vec![0; n];\n   \
    \ let mut cnt = 0;\n    for i in 1..n  {\n        for j in 1..i  {\n         \
    \   for k in 1..j  {\n                if triples[k] == 0 && triples[j] == 0 &&\
    \ triples[i] == i * i - i + 1 {\n                    triples[k] = 1;\n       \
    \             triples[j] = 1;\n                    triples[i] = 1;\n         \
    \           cnt += 1;\n                }\n            }\n        }\n    }\n  \
    \  return cnt;", "    \n    for i in (1..n) {\n        let mut a = vec![];\n \
    \       let mut sum = 0;\n        for j in 0..n {\n            a.push(j * j -\
    \ i + 1);\n            sum += a[i];\n        }\n        if sum % 3 == 0 {\n  \
    \          return i;\n        }\n    }\n    0", "    let mut cnt = 0;\n\n    for\
    \ x in 1..n{\n        cnt += x;\n    }\n\n    let mut x = 1;\n    while x > 1{\n\
    \        cnt += x;\n        x -= 3;\n    }\n\n    cnt += 1;\n    cnt", "    let\
    \ mut a = vec![0; n];\n    for i in 1..n {\n        a[i] = i * i - i + 1;\n  \
    \  }\n    let mut result = 0;\n    for i in 0..n {\n        for j in 1..n {\n\
    \            for k in 1..n {\n                if i != j && i != k && j != k &&\
    \ (i + j + k) == (a[i] + a[j] + a[k]) {\n                    result += 1;\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    result", "    let mut a = vec![0; n];\n    for i in 1..n-1 {\n        for\
    \ j in 0..i-1 {\n            for k in 0..(i-1) + 1 {\n                let t =\
    \ a[i] + a[j] + a[k];\n                if t % 3 == 0 {\n                    return\
    \ 1;\n                }\n            }\n        }\n        a[i] = i*i - i + 1;\n\
    \    }\n    0", "    let mut a = vec![0; n];\n\n    for i in 1..n {\n        a[i]\
    \ = i * i - i + 1;\n    }\n\n    let mut i = 1usize;\n    let mut j = 1usize;\n\
    \    let mut k = 1usize;\n\n    while i * i + j * j < k * k + 3 {\n        if\
    \ a[i] < a[j] || a[j] < a[k] || a[k] < a[i * i + j * j] {\n            return\
    \ 0;\n        }\n\n        if i + j < k {\n            i += j;\n            j\
    \ += 1usize;\n        }\n        if j + k < n {\n            j += k;\n       \
    \     k += 1usize;\n        }\n    }\n    \n    1", "    let mut a: [isize; n\
    \ + 1] = [0; n + 1];\n    for i in 0..n + 1 {\n        a[i] = i * i - i + 1;\n\
    \    }\n    let mut c = 0;\n    let mut d = 0;\n    for i in 0..n {\n        if\
    \ i > 0 {\n            if c&1==0 {\n                if a[i] + a[i - 1] + a[i -\
    \ 2] == 3 {\n                    c += 1;\n                    d += 1;\n      \
    \          }\n            }\n            else {\n                if d&1==0 {\n\
    \                    if a[i] + a[i - 1] + a[i - 2] == 3 {\n                  \
    \      d += 1;\n                    }\n                }\n            }\n    \
    \    }\n    }\n    c", "    let mut arr = [0isize; n];\n    arr[0] = 1;\n    for\
    \ i in 1..n {\n        arr[i] = arr[i - 1] * arr[i - 1] - arr[i - 1] + 1;\n  \
    \  }\n    for i in 1..(n*n - n*n - n).ceil() as usize {\n        let x = i / n\
    \ as i32;\n        let y = i % n as i32;\n        let z = arr[x] - arr[y];\n \
    \       if z % 3 == 0 {\n            return i;\n        }\n    }\n    0", "  \
    \  let mut a = vec![n..=n].into_iter().map(|x| x*x - x + 1).collect();\n    \n\
    \    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if a[i] == a[j] + a[k] {\n                    return i + j +\
    \ k;\n                }\n            }\n        }\n    }\n    0", "    let mut\
    \ a = [1isize; n];\n    for i in 1..n {\n        a[i] = i * (i - 1) + 1;\n   \
    \ }\n    let mut res = 0;\n    for i in 1..n {\n        for j in (i + 1..n) {\n\
    \            for k in (j + 1..n) {\n                if a[i..j] + a[j..k] == 3\
    \ * i - j + k {\n                    res += 1;\n                }\n          \
    \  }\n        }\n    }\n    res", "    let mut a: [isize; n] = [];\n    for i\
    \ in 1..n {\n        for j in 1..i {\n            for k in 0..(n - i - j) {\n\
    \                let v = i * i + i + j;\n                if v <= 2 * k + 3 {\n\
    \                    a[i] = v;\n                    a[j] = v;\n              \
    \      a[k] = v;\n                    return a.len();\n                }\n   \
    \         }\n        }\n    }\n    a.len()", "    let mut a = vec![];\n    for\
    \ i in 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n\
    \ {\n                if i != j && j != k && a[j] + a[k] > a[i] {\n           \
    \         a.push(i * i - i + 1);\n                }\n            }\n        }\n\
    \    }\n    a.iter().filter(|&x| x % 3 == 0).count()", "    let mut a_vec: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n+1 {\n        a_vec.push(0*i - i + 1);\n   \
    \ }\n    a_vec.sort_unstable();\n    a_vec\n        .iter()\n        .filter(|&i|\
    \ i%3 == 0)\n        .count()", "    let mut a: Vec<_> = vec![];\n    let mut\
    \ sum = 0;\n    for i in 1..n {\n        sum += i * i - i + 1;\n        a.push(sum);\n\
    \    }\n\n    for i in 0..(n-2) {\n        for j in i+1..(n-1) {\n           \
    \ let mut k = 0;\n            for k in k..(n-1) {\n                let mut sum\
    \ = 0;\n                for _ in 0..(n-(i+1)) {\n                    sum += a[k];\n\
    \                }\n                if sum == sum % 3 {\n                    return\
    \ 1;\n                }\n            }\n        }\n    }\n\n    return 0;", " \
    \   let mut counter: isize = 0;\n    let mut arr = [1isize; n];\n    for i from\
    \ 1 .. n {\n        for j in 1 .. i {\n            arr[j] += j;\n        }\n \
    \       if arr[i] % 3 == 0 {\n            counter = counter + 1;\n        }\n\
    \    }\n    counter", "    let mut a = vec![0; n];\n    for &mut x in &mut a {\n\
    \        *x = *x + 1;\n    }\n    let mut result = 0;\n    for &mut x in &mut\
    \ a {\n        for &mut y in &mut a {\n            for &mut z in &mut a {\n  \
    \              if *x + *y + *z == 3 {\n                    result += 1;\n    \
    \            }\n            }\n        }\n    }\n    result", "    let mut a:\
    \ [isize; n] = [0, 1, 2];\n    for i in 0..n {\n        for j in 0..n {\n    \
    \        for k in 0..n {\n                if j < k && i < k {\n              \
    \      continue;\n                }\n                if a[i] + a[j] + a[k] ==\
    \ i * i * i {\n                    a[i] += 1;\n                    a[j] += 1;\n\
    \                    a[k] += 1;\n                }\n            }\n        }\n\
    \    }\n    a.iter().filter(|&n| n % 3 == 0).count()", "    let mut a = vec![0;\
    \ n];\n    a[0] = 1;\n    for i in 1..n {\n        a[i] = i * i - i + 1;\n   \
    \ }\n    let mut sum = 0;\n    for i in 0..n {\n        sum += (a[i], a[i], a[i]);\n\
    \    }\n    sum % 3 == 0", "    let mut a = vec![];\n    for i in 1..n+1 {\n \
    \       a.push(i*i - i + 1);\n    }\n    let mut triple_count = 0;\n    for i\
    \ in 1..n+1 {\n        for j in 1..n+1 {\n            if j != i {\n          \
    \      if a[i] + a[j] + a[k] % 3 == 0 {\n                    triple_count += 1;\n\
    \                }\n            }\n        }\n    }\n    triple_count", "    let\
    \ mut triplets = (0..n).map(|_| 0isize);\n    for i in 0..n {\n        let j =\
    \ i + 1;\n        let k = n - i;\n        let sum = (triplets[i] + triplets[j]\
    \ + triplets[k]) % (3*i);\n        triplets[i] = triplets[j];\n        triplets[j]\
    \ = triplets[k];\n        triplets[k] = sum;\n    }\n    return triplets.iter().filter(|&x|\
    \ x == x).count();", "    assert!(n > 1);\n\n    let mut sum = 0isize;\n\n   \
    \ for i in 1..(n-1).iter().rev() {\n        for j in (i + 1)..(n).iter() {\n \
    \           for k in (i + 1)..(n).iter() {\n                if i == j {\n    \
    \                continue 2;\n                }\n                if i == k {\n\
    \                    continue 3;\n                }\n\n                sum +=\
    \ (i * i - i + 1)*(i*i + j*j + k*k - i*j - i*k + j*k);\n            }\n      \
    \  }\n    }\n    sum % 3 == 0", "    let mut a = [0; n + 1];\n    for i in 1..n\
    \ + 1{\n        a[i] = i * i - i + 1;\n    }\n    let mut count = 0;\n    for\
    \ i in 0..n - 1 {\n        for j in 0..n - 1 {\n            for k in 0..n - 1\
    \ {\n                if i != j && i != k && j != k && a[i] + a[j] + a[k] == 3\
    \ {\n                    count++;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut a = [0; n];\n    a[0] = 1;\n    a.iter_mut().enumerate().for_each(|(_,\
    \ i)| *i = *i + 1);\n    for i in 1..n {\n        let mut j = 0;\n        while\
    \ j != i {\n            a[j] = (a[j] + a[i] + a[i - j] as isize) % 3;\n      \
    \      j = j + 1;\n        }\n    }\n    a.iter().filter(|&x| x % 3 == 0).count()",
  "    let mut a: Vec<isize> = vec![0; n];\n    for &i in &a {\n        i = i * i\
    \ - i + 1;\n    }\n    a.sort();\n    for i in a.iter() {\n        let mut j =\
    \ i;\n        let mut k = i + i;\n        let mut sum = 0;\n        while k <=\
    \ a.last() {\n            if k == a.last() || sum + k == 3*i + 3*j + k {\n   \
    \             return 1;\n            }\n            sum += k;\n            k +=\
    \ 1;\n        }\n    }\n    0", "    // TODO: implement get_max_triples function\n\
    \    return 0", "    let mut result = 0;\n\n    for _ in 0..n {\n        if n\
    \ % 3 == 0 {\n            result += 3;\n        }\n        n /= 3;\n    }\n\n\
    \    result", "    if n < 3 {\n        return 0;\n    }\n    \n    let mut a =\
    \ Vec::new();\n    \n    for i in 1..n {\n        for j in i..n {\n          \
    \  for k in i..n {\n                let triple = (i, j, k);\n                if\
    \ triple[0] == triple[1] == triple[2] {\n                    continue;\n     \
    \           }\n                let mut triple = triple;\n                while\
    \ triple[0] != triple[1] && triple[0] != triple[2] && triple[1] != triple[2] {\n\
    \                    triple = (triple[0] + triple[1], triple[0] + triple[2], triple[0]\
    \ + triple[3]);\n                }\n                a.push(triple);\n        \
    \    }\n        }\n    }\n    a.sort_by_key(|&x| x.0)\n        .filter(|x| x.1\
    \ == x.2 == x.3).count();", "    assert!(n >= 1);\n    let mut a = vec![0; n];\n\
    \    let mut triples: isize = 0;\n\n    for i in 0..n {\n        a[i] = i * i\
    \ - i + 1;\n    }\n\n    for i in 1..n-1 {\n        let x = a[i];\n        let\
    \ y = a[i-1];\n        let z = a[i-2];\n        if x * y + z == 0 {\n        \
    \    triples += 1;\n        }\n    }\n\n    triples", "    let mut max_triples\
    \ = 0.;\n    let mut a: [isize; n] = Default::default();\n    a[0] = 1.;\n   \
    \ for i in 1..n {\n        a[i] = i * i - i + 1.;\n        if a[i - 1] != 0.\n\
    \            && a[i - 1] + a[i] != 0.\n            && a[i - 1] + a[i] + a[i] !=\
    \ 0.\n        {\n            max_triples = std::cmp::max(max_triples, a[i - 1]\
    \ + a[i] + a[i - 1]);\n        }\n    }\n    max_triples", "    if n == 0 { return\
    \ 0; }\n\n    let mut cnt = 0;\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if i > j {\n                cnt += (a[i] - a[i - j + k]) % (a[i -\
    \ j + k] - a[j] + a[i - j + k]);\n            }\n        }\n    }\n\n    return\
    \ cnt;", "    fn f(&mut arr: [isize; n]){\n        for i in 0..n {\n         \
    \   for j in (i + 1..n){\n                for k in (i + 1..n){\n             \
    \       if arr[i] + arr[j] + arr[k] == 3 {\n                        arr[i] + arr[j]\
    \ + arr[k] -= 1;\n                    }\n                }\n            }\n  \
    \      }\n    }\n    \n    let mut arr = vec![0; n];\n    f(&mut arr);\n    \n\
    \    arr.iter().filter_map(|x|{\n        if x == 0 {\n            Some(0)\n  \
    \      } else {\n            Some(x)\n        }\n    }).sum()", "    let mut a\
    \ = vec![0; n];\n    let mut total = 0;\n    for i in 0..n {\n        a[i] = i\
    \ * i - i + 1;\n    }\n    for i in 0..n {\n        for j in i+1..n {\n      \
    \      for k in j+1..n {\n                total += a[j] * a[k] * a[i];\n     \
    \       }\n        }\n    }\n    total", "    let mut a: [isize; n] = [0; n];\n\
    \    for i in 1..n-1 {\n        a[i] = i * i - i + 1;\n    }\n    a\n        .iter()\n\
    \        .enumerate()\n        .filter(|(_, i)| i < a.len())\n        .filter(|(_,\
    \ i, _)| a[i] - a[i] == 3)\n        .count()", "    // let mut sum = (3 * n) -\
    \ 1;\n    let mut sum = (3 * n) - 2;\n    for i in 1..(n - 1) {\n        for j\
    \ in (i + 1)..(n - 1) {\n            for k in (i + 1)..(n - 1) {\n           \
    \     if i <= j <= k && sum > 0 &&\n                    ((i + j + k) % (3 * n)\
    \ == 0) &&\n                    ((i * i * i) + (j * j * j) + (k * k * k) == (3\
    \ * n)) {\n                    sum += 1;\n                }\n            }\n \
    \       }\n    }\n    sum", '    (1..n).map(|i| i * i - i + 1).count().filter(|&i|
    i < i < n).count() as isize', "    // brute force : O(n^3)\n    // if n was 100\
    \ or more, it's O(n^4)\n    for i in 0..n {\n        let mut count = 0;\n    \
    \    for j in 0..i {\n            for k in 0..i*j {\n                let res =\
    \ i + j + k;\n                if res > n {\n                    break;\n     \
    \           }\n                \n                let res = res * 3 - 1;\n    \
    \            if res == 0 {\n                    count += 1;\n                \
    \    break;\n                }\n            }\n        }\n        \n        if\
    \ count == 0 {\n            return i;\n        }\n    }\n    \n    0", "    let\
    \ mut a: Vec<isize> = vec![0; n];\n    for i in 1..n {\n        a[i] = i * i -\
    \ i + 1;\n    }\n    let mut triples: usize = 0;\n    for i in 1..n-1 {\n    \
    \    for j in (i + 1)..n {\n            for k in (j + 1)..n {\n              \
    \  if i == j &&\n                   j == k &&\n                   a[i] == a[j]\
    \ + a[k] {\n                    triples += 1;\n                }\n           \
    \ }\n        }\n    }\n    triples", "    let mut a: Vec<_> = vec![0; n];\n  \
    \  a[0] = 1 + a[0];\n    for i in 1..n {\n        a[i] = a[i - 1] * i - a[i -\
    \ 1] + i;\n    }\n    a.iter().cloned().filter(|x| *x % 3 == 0).count()", "  \
    \  let mut num_triples = 0;\n    let mut a: [isize; n+1] = [0; n+1];\n    for\
    \ i in 1..n+1 {\n        a[i] = i * i - i + 1;\n    }\n    for i in 1..n+1 {\n\
    \        for j in i+1..n+1 {\n            for k in j+1..n+1 {\n              \
    \  if a[i] < a[j] && a[i] < a[k] && a[j] < a[k] {\n                    num_triples\
    \ += 1;\n                }\n            }\n        }\n    }\n    return num_triples;",
  "    debug_assert!(n > 1);\n    let mut triples: Vec<_> = vec![n];\n    triples.clear();\n\
    \    let mut count = 0;\n    for _ in 0..n {\n        if triples[_] != 0 {\n \
    \           count++;\n            let a = triples[_].to_string();\n          \
    \  triples[_] = triples[_].checked_sub(1)?;\n            triples[_] = triples[_].checked_add(1)?;\n\
    \            triples[_] = triples[_].checked_mul(3)?;\n            triples[_]\
    \ = triples[_].checked_add(1)?;\n        }\n    }\n    count", "    let mut a\
    \ = Vec::new();\n    for _ in 0..n {\n        a.push(0);\n    }\n    for &n in\
    \ &a {\n        let mut sum = 0;\n        for &n in &a {\n            sum += *n;\n\
    \        }\n        if sum == 2 {\n            return a.iter().filter(|&n| n ==\
    \ 1).count();\n        }\n        a.push(*n + 1);\n    }\n    1", "    let mut\
    \ a = [0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n    }\n   \
    \ let mut t = 0;\n    for i in 1..n {\n        for j in 1..n {\n            for\
    \ k in 1..n {\n                if i != j && j != k && a[i] < a[j] + a[k] {\n \
    \                   t += 1;\n                }\n            }\n        }\n   \
    \ }\n    t", "    if n == 0 { return 0; }\n    let mut cnt = 0;\n    let mut a\
    \ = vec![0; n];\n    a[0] = 1;\n    for i in 1..n-1 {\n        a[i] = a[i-1] *\
    \ 2 - 1 + 1;\n        cnt += a.iter().skip(i).take(i).all(|&x| x * x % 3 == 0);\n\
    \    }\n    cnt", "    (0..n).map(|x| x*x - x + 1).filter(|x| *x >= 3)\n     \
    \   .count(|&i| i == 3*3*3)", "    use std::cmp::Ordering;\n\n    let mut a_vec\
    \ = vec![0; n];\n    let mut num = 0;\n\n    for &i in a_vec {\n        a_vec[i]\
    \ = i * i - i + 1;\n    }\n\n    for i in 1..n {\n        for j in 2..i {\n  \
    \          for k in 3..j {\n                if a_vec[k] * a_vec[j] + a_vec[i]\
    \ == 0 {\n                    return num;\n                }\n               \
    \ if a_vec[j] * a_vec[k] + a_vec[i] > 0 {\n                    a_vec[k] += a_vec[j];\n\
    \                    a_vec[j] -= a_vec[i];\n                    a_vec[i] += a_vec[k];\n\
    \                    num += 1;\n                }\n            }\n        }\n\
    \    }\n\n    num", "    fn triple(a: Vec<isize>) -> Vec<isize> {\n        let\
    \ mut c = a.iter().cloned().collect::<Vec<isize>>();\n        for (i, j) in c.iter_mut().zip(c)\
    \ {\n            if i < j {\n                continue;\n            }\n      \
    \      c[i] += 1;\n            c[j] += 1;\n            c[k] += 1;\n        }\n\
    \        return c;\n    }\n    triple(vec![0; n]).iter().filter(|&x| x * x ==\
    \ 3 * x).count()", "    let mut a = vec![0; n];\n    let mut cnt = 0;\n    let\
    \ mut triple = 0;\n    let mut j = n - 1;\n    \n    for i in 0..n {\n       \
    \ a[i] = i * i - i + 1;\n        triple = a[i] + a[j] + a[k];\n        cnt +=\
    \ 1;\n        while (triple%3 == 0 && j > 0) {\n            j -= 1;\n        \
    \    a[i] = i * i - i + 1;\n            triple = a[i] + a[j] + a[k];\n       \
    \     cnt += 1;\n        }\n    }\n    cnt", "    let mut result = 0;\n    for\
    \ i in 0..n {\n        let mut count = 0;\n        for j in (i + 1)..n {\n   \
    \         for k in (i + 1)..n {\n                if i + 1 < j + 1 && i + 1 < k\
    \ + 1 && j + 1 < k + 1 {\n                    if i * i + j * j == k * k + {i +\
    \ 1, j + 1, k + 1} + 1 {\n                        count += 1;\n              \
    \      }\n                }\n            }\n        }\n        if count > result\
    \ {\n            result = count;\n        }\n    }\n    result", "    if n ==\
    \ 0 {\n        return 0;\n    }\n\n    // To improve our time complexity, we'll\
    \ use the array a[] instead of counting triples\n    let mut a = vec![0; n];\n\
    \n    for i in 0..n {\n        a[i] = i * i - i + 1;\n    }\n\n    let mut cnt\
    \ = 0;\n    let mut j = 0;\n\n    for i in 0..n - 1 {\n        cnt += a[i];\n\n\
    \        if i >= 0 {\n            cnt += a[i];\n\n            if i >= 0 {\n  \
    \              cnt += a[i];\n                j = i;\n            }\n        }\n\
    \    }\n\n    cnt", "    let mut a: [isize; n + 1] = Default::default();\n   \
    \ for i in 0..n {\n        a[i] = i * i - i + 1;\n    }\n    let mut cnt: isize\
    \ = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if a[i] == a[j] + a[k] {\n                    cnt\
    \ += 1;\n                }\n            }\n        }\n    }\n    cnt", "    let\
    \ mut a = [1; n as usize];\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if i != j {\n                let k = a[j];\n                a[j] = a[i]\
    \ + a[j] + k;\n            }\n        }\n    }\n    a.iter().filter(|&x| x % 3\
    \ == 0).count().unwrap()", "    let mut triples_sum = 0;\n    let mut a: [usize;\
    \ n + 1] = Default::default();\n    for _ in 0..n {\n        a[0] += 1;\n    }\n\
    \    for i in 1..n {\n        for j in i+1..n {\n            if a[j] + a[i] ==\
    \ 3 {\n                triples_sum += 1;\n            }\n        }\n        a[i]\
    \ = i * i - i + 1;\n    }\n    triples_sum", "    if n < 3 {\n        return 0;\n\
    \    }\n\n    let mut a = vec![0; n + 1];\n    for i in 0..n + 1 {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    \n    let mut count = 0;\n    for _ in 0..n {\n\
    \        for j in 0..n {\n            if a[j] + a[j] > a[j] + a[j + 1] {\n   \
    \             a[j] += a[j];\n                a[j + 1] += a[j + 1];\n         \
    \       a[j] = a[j] - a[j + 1];\n                a[j + 1] = a[j + 1] - a[j];\n\
    \                count += 1;\n                break;\n            }\n        }\n\
    \    }\n    count", "    if n < 3 { return 0; }\n    let mut counter: usize =\
    \ 0;\n    let mut array = vec![];\n    for i in 1..n-1 {\n        array.push(i);\n\
    \    }\n    for i in 0..n-2 {\n        for j in i+1..n-3 {\n            for k\
    \ in j+1..n-2 {\n                if array[j] + array[k] + array[i] == 3 {\n  \
    \                  counter += 1;\n                }\n            }\n        }\n\
    \    }\n    return counter;", "    if n == 0 || n == 1 {\n        return 0;\n\
    \    }\n    if n % 3 == 1 {\n        return 1;\n    }\n    if n % 3 == 2 {\n \
    \       return 2;\n    }\n    let mut cnt = 0;\n    let mut a = vec![0; 3];\n\
    \    for i in 1..n {\n        let index = n - 1 - i;\n        a[index] = index\
    \ * index * index;\n        if a[index] > 3 {\n            cnt += 1;\n       \
    \ }\n    }\n    cnt", "    assert!(n > 1);\n    let mut a: [usize; n] = [0; n];\n\
    \    for i in 1..n {\n        a[i] = i * i - i + 1;\n    }\n    let mut num_triplets\
    \ = 0;\n    for i in 0..(n-2) {\n        for j in (i+1)..(n-1) {\n           \
    \ for k in (i+1)..(n-1) {\n                if a[i] == a[j] + a[k] {\n        \
    \            num_triplets += 1;\n                }\n            }\n        }\n\
    \    }\n    num_triplets", "    assert!(n >= 0);\n    let mut res = 0;\n    for\
    \ i in (1..n) {\n        for j in (i..n) {\n            for k in (i..j) {\n  \
    \              if i**3 + j**3 + k**3 == 3 {\n                    res += 1;\n \
    \               }\n            }\n        }\n    }\n    res", "    fn tripple(a:\
    \ [isize], i: isize, j: isize, k: isize) -> bool {\n        i < j && j < k &&\
    \ k < a[i] + a[j] + a[k]\n    }\n\n    let mut mut_a = vec![0, n + 1];\n\n   \
    \ for i in 1..=n {\n        mut_a[i] = mut_a[i-1] + i;\n    }\n\n    mut_a.iter().filter(|&x|\
    \ tripple(mut_a.as_slice(), x, x, x)).count()", "    \n    let mut triples = 0;\n\
    \    let mut a = vec![2..n];\n    for i in 1..n {\n        for j in a[0..i] {\n\
    \            for k in a[(i + 1..)..] {\n                if i + j + k == i {\n\
    \                    triples += 1;\n                    break;\n             \
    \   }\n            }\n        }\n        a = a.iter().filter(|&x| x == x).collect::<Vec<_>>();\n\
    \    }\n    \n    return triples;", "    if n < 3 {\n        return 0;\n    }\n\
    \    let mut a = vec![n];\n    for i in 1..(n-1){\n        a[i] = i*i-i+1;\n \
    \   }\n    for i in 0..(n-2) {\n        let mut c = 1;\n        let mut j = i+1;\n\
    \        for j in i+1..(n-1){\n            if a[j] + a[j] == 0 {\n           \
    \     c += 1;\n            }\n        }\n        if c == 3 {\n            return\
    \ i;\n        }\n    }\n    0", "    fn inner_count(a: [u64; n], i: usize) ->\
    \ (u64, u64, u64) {\n        (a[i], a[i], 0)\n    }\n    fn inner_count_aux(a:\
    \ [u64; n], i: usize) -> isize {\n        if i == 0 {\n            return 0\n\
    \        }\n        let (a1_i, a2_i, count_i) = inner_count_aux(a[..i], i - 1)\n\
    \        let (a1_j, a2_j, count_j) = inner_count_aux(a[i..n], i - 1)\n       \
    \ let (a1_k, a2_k, count_k) = inner_count_aux(a[i+1..n], i - 1)\n        let count_k\
    \ = count_k + count_j - count_i\n        let (a1_k_prime, a2_k_prime, count_k_prime)\
    \ = inner_count_aux(a[i+1..n], i + 1)\n        let count_k_prime = count_k_prime\
    \ + count_j - count_i\n        (a1_k_prime, a2_k_prime, count_k_prime)\n    }\n\
    \    inner_count_aux([u64; n], 0)", "    let mut sum = 0;\n    let mut arr: [isize;\
    \ n + 1] = [isize::MIN; n + 1];\n    for i in 1..n + 1 {\n        arr[i] = i *\
    \ i - i + 1;\n    }\n    for (i in 0..n) {\n        for j in (i + 1).. n {\n \
    \           sum += arr[j] - arr[i];\n        }\n    }\n    sum % 3 == 0", "  \
    \  loop {\n        let mut a: [isize; n] = [isize::MIN, isize::MAX];\n       \
    \ for i in 1..n {\n            a[i] = i * i - i + 1;\n        }\n        if a[n\
    \ - 1] % 3 == 0 {\n            return n - 1;\n        }\n        for (i1, j1,\
    \ k1) in 1..n-1 {\n            for (i2, j2, k2) in (i1 + 1, j1, k1 + 1) .. n -\
    \ 1 {\n                for (i3, j3, k3) in (i1, j1, k1) .. n - 1 {\n         \
    \           if i1 + j1 + k1 == i2 + j2 + k2 && i1 + j1 + k1 == i3 + j3 + k3 {\n\
    \                        if i1 + j1 + k1 == i + j + k {\n                    \
    \        return n + 1;\n                        }\n                    }\n   \
    \             }\n            }\n        }\n    }", '    (0..n).fold(0, |acc, i|
    acc + get_max_triples_recursive(i))', "    if n < 2 {\n        return 0\n    }\n\
    \    \n    let mut num_triples = 1;\n    \n    let mut a = [isize; n + 1];\n \
    \   for x in 0..n + 1 {\n        a[x] = (x * x - x) + 1;\n    }\n    \n    for\
    \ &x in &a[..n] {\n        let y = &a[x + 1];\n        let z = &a[x + 2];\n  \
    \      if (x * x + y * y + z * z) == 3 {\n            num_triples += 1;\n    \
    \    }\n    }\n    \n    return num_triples;", '    (1..n).filter(|x| x%3 == 0).count(|x|
    get_triple(x, n))', "    let mut a = [0; n];\n    a[1] = 1;\n    for i in 2..n-1\
    \ {\n        a[i] = a[i-1] + a[i-2];\n    }\n    a.iter().filter(|x| x <= 3).count()",
  "    let mut triples = vec![];\n    for i in 1..n {\n        for j in i + 1..n {\n\
    \            for k in j + 1..n {\n                if i + j + k == i * i * i {\n\
    \                    triples.push((i, j, k));\n                }\n           \
    \ }\n        }\n    }\n    triples.iter().filter(|&(_, i, _)| i % 3 == 0).count()",
  "    use std::cmp::Ordering;\n    let mut triples = Vec::new();\n    for i in 1..n\
    \ {\n        triples.push(i);\n    }\n    let mut a_prime = vec![1, 1, 2];\n \
    \   for i in 1..n {\n        let mut new_triples = triples;\n        for j in\
    \ new_triples.iter().rev() {\n            for k in new_triples.iter().rev() {\n\
    \                if j > i && k >= i {\n                    let result = a_prime[i]\
    \ + a_prime[j] + a_prime[k];\n                    if result == 3 {\n         \
    \               a_prime[i] = a_prime[j];\n                        a_prime[j] =\
    \ a_prime[k];\n                    }\n                }\n            }\n     \
    \   }\n    }\n    a_prime.iter().filter(|&x| x == 3).count()", "    let mut a\
    \ = Vec::new();\n    a.push(n);\n    for _ in 1..n+1 {\n        for j in 0..(n-1)+1\
    \ {\n            for i in 0..(n-1)+1 {\n                if i != j && i != k &&\
    \ j != k {\n                    a.push(i * i - i + 1);\n                }\n  \
    \          }\n        }\n    }\n    let mut cnt = 0;\n    for d in a.iter().cloned()\
    \ {\n        if *d % 3 == 0 {\n            cnt += 1;\n        }\n    }\n    return\
    \ cnt;", "    let mut a: [(isize, isize, isize)] = vec![(0, 0, 0)];\n    let mut\
    \ cnt = 0;\n    for i in 1..(n-1) {\n        for j in (i+1)..(n-1) {\n       \
    \     for k in (i+1)..(n-1) {\n                if i != j && j != k {\n       \
    \             if a[i] + a[j] + a[k] == 3 {\n                        cnt += 1;\n\
    \                    }\n                    a[i] = a[j];\n                   \
    \ a[j] = a[k];\n                    a[k] = 0;\n                }\n           \
    \ }\n        }\n    }\n    cnt", "    let mut a = vec![0; n];\n    for i in 1..n\
    \ {\n        for j in 1..i {\n            for k in 0..j {\n                a[i]\
    \ += 1;\n            }\n        }\n    }\n    \n    let mut count = 1;\n    for\
    \ j in 1..n {\n        if a[j] == 0 {\n            break;\n        }\n       \
    \ count += 1;\n        a[j] -= 1;\n        for a in 0..n {\n            if a[j]\
    \ == 0 {\n                break;\n            }\n            count += 1;\n   \
    \         a[j] -= 1;\n        }\n    }\n    \n    count", "    let mut counter:\
    \ Vec<isize> = vec![0; n];\n    \n    for i in 1..n {\n        for j in 0..(i-1)\
    \ {\n            for k in 0..(j-1) {\n                let triple = i*i - j*j +\
    \ k*k;\n                counter[i] += triple % 3 == 0;\n            }\n      \
    \  }\n    }\n    \n    counter.iter().sum::<isize>()", "    if n % 3 != 0 {\n\
    \        return 0;\n    }\n    let mut count = 0;\n    for i in 1..n / 3 {\n \
    \       if i * i == i * i + 1 {\n            count += 1;\n        }\n    }\n \
    \   count", "    assert!(n >= 3);\n    if n == 0 {\n        return 0;\n    }\n\
    \    if n == 1 {\n        return 1;\n    }\n    if n % 3 == 0 {\n        return\
    \ 0;\n    }\n    let mut sum = 0;\n    for i in 0..(n-1) {\n        for j in (i+1)..(n-1)\
    \ {\n            for k in (i+1)..(n-1) {\n                sum += (3*(i*i + i*j\
    \ + i*k) - i*i*i) / 3;\n                if sum > n {\n                    return\
    \ 0;\n                }\n            }\n        }\n    }\n    sum", "    let mut\
    \ a = vec![];\n    for i in 1..n{\n        a.push(i * i - i + 1);\n    }\n   \
    \ \n    for i in 1..n{\n        for j in (i + 1) .. n{\n            for k in 0..(n-i){\n\
    \                if (a[i] > a[j] && a[j] > a[k]){\n                    return\
    \ 1;\n                }\n            }\n        }\n    }\n    0", "    let mut\
    \ a = vec![n * (n + 1) / 2];\n    for i in 1..n {\n        for j in i + 1..n {\n\
    \            let k = j - i;\n            if i % j == 0 {\n                if i%3\
    \ == 0 || i%5 == 0 || j%3 == 0 || j%5 == 0 {\n                    a[i] = a[j]\
    \ + a[k];\n                }\n            }\n        }\n    }\n    a.iter().filter(|&x|\
    \ x%3 == 0).count()", "    let mut triples = vec![(0, 0, 0)];\n    for i in 1..n\
    \ {\n        for j in i+1..n {\n            let mut counter = 0;\n           \
    \ for k in 0..(j-i) { \n                if triples[j-i][k] != 0 {\n          \
    \          counter+=1;\n                }\n            }\n            triples[i]\
    \ += triples[j-i][k];\n            if triples[i] > triples[j-i][k] + triples[k]\
    \ {\n                triples[j-i][k] = triples[i] - triples[j-i][k];\n       \
    \         triples[k] = 0;\n            }\n        }\n    }\n    let mut cnt =\
    \ 0;\n    for i in 0..n {\n        if triples[i][2] != 0 {\n            cnt +=\
    \ 1;\n        }\n    }\n    cnt", "    let mut a = vec![0; n];\n    for i in 1..n\
    \ {\n        a[i] = i * i - i + 1;\n    }\n    let mut sum_ = a.iter().sum::<i32>();\n\
    \    for i in 0..(n-1){\n        for j in (i+1)..(n-1){\n            sum_.swap(i,\
    \ j);\n        }\n        if sum_ % 3 == 0 {\n            return i;\n        }\n\
    \    }\n    n", "    let mut total: usize = 0;\n    for i in 1..n {\n        if\
    \ get_triple(i) > total {\n            total = get_triple(i);\n        }\n   \
    \ }\n    total", "    let mut array = [0; n];\n    array[1] = 1;\n    for i in\
    \ 2..n-1 {\n        array[i] = i * i - i + 1;\n    }\n\n    let mut result = vec![0;\
    \ 3];\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut\
    \ cnt = 0;\n\n    for k in 0..n {\n        for j in (i + 1)..k {\n           \
    \ if array[i] > array[j] {\n                if array[i] > array[k] {\n       \
    \             cnt = (array[i] - array[j]) * (array[i] - array[k]) + 1;\n     \
    \           } else {\n                    cnt = array[k] - array[j] + 1;\n   \
    \             }\n            } else {\n                if array[j] > array[k]\
    \ {\n                    cnt = (array[j] - array[k]) * (array[i] - array[j]) +\
    \ 1;\n                } else {\n                    cnt = array[k] - array[i]\
    \ + 1;\n                }\n            }\n\n            if cnt % 3 == 0 {\n  \
    \              result[cnt] +=1;\n            }\n\n            i += 1;\n      \
    \      j += 1;\n            k += 1;\n        }\n\n        i = 0;\n        j =\
    \ 0;\n        k = 0;\n    }\n\n    // cnt % 3 == 0\n    for i in 0..cnt {\n  \
    \      if result[i % 3] > 0 {\n            result[i % 3] += 1;\n        } else\
    \ {\n            result[i % 3] += 1;\n        }\n    }\n\n    result.iter().max().unwrap()",
  "    let mut a: Vec<i32> = vec![];\n    for _ in 0..n {\n        a.push(0);\n  \
    \  }\n    for j in 1..n {\n        for i in 1..j {\n            if a[i] % 3 ==\
    \ 0 {\n                for (k, l) in (i..j).rev() {\n                    if a[k]\
    \ % 3 == 0 && a[k] + a[l] % 3 == 0 {\n                        println!(\"{}, {},\
    \ {}\", a[i], a[j], a[k]);\n                        return *;\n              \
    \      }\n                }\n            }\n            a[i] = a[i] + a[j];\n\
    \        }\n    }\n    None", "    if n < 0 {\n        return 0;\n    }\n\n  \
    \  let mut a = vec![0; n];\n    for i in 1..n {\n        for j in (i + 1)..n {\n\
    \            let k = n - i - j;\n            if j * j * j == k * k * k + i * i\
    \ * i {\n                a[i] = 1;\n            }\n        }\n    }\n\n    a.iter().filter(|&x|\
    \ x >= 3).count()", "    let mut a = vec![0, 1, 1, 1];\n    let mut ans = 0;\n\
    \    for i in 1..n{\n        for j in 1..i {\n            for k in 1..j {\n  \
    \              ans = max(ans, get_sum(a) + get_sum(a) + get_sum(a) + a[k] + a[j]\
    \ + a[i]);\n                a.push(3*k + j + i);\n            }\n        }\n \
    \   }\n    ans as isize", "    let mut num_triples = 0;\n    let mut a = vec![0;\
    \ n];\n    for i in 1..n {\n        a[i] = i * i - i + 1;\n    }\n    for i in\
    \ 1..n-1 { \n        for (j, n) in a.iter().enumerate() { \n            if i >\
    \ j && n < i*(j+1) { \n                num_triples += 1; \n                break;\
    \ \n            } \n        } \n    } \n    num_triples", "    let mut a: Vec<i32>\
    \ = vec![0; n];\n    let mut sum: i32 = n - 1;\n    for i in 0..n {\n        a[i]\
    \ = i * i - i + 1;\n        if a[i] % 3 == 0 {\n            sum += i;\n      \
    \  }\n    }\n    return sum;", "    let mut a = Vec::new();\n    for i in 1..n\
    \ {\n        let mut cur = a;\n        for j in 1..i {\n            let k = cur.get(j).unwrap();\n\
    \            if k != i + 1 {\n                cur.push((i, j, k));\n         \
    \   }\n        }\n    }\n    for (ai, aj, ak) in a.iter().cloned() {\n       \
    \ if (ai + aj + ak % 3 == 0) return 1;\n    }\n    0", "    assert!(n >= 1);\n\
    \n    let mut triples = Vec::new();\n    let mut a = vec![0; n];\n\n    // First\
    \ we fill the array with some values\n    for i in 0..n-1 {\n        a[i] = i\
    \ * i - i + 1;\n    }\n\n    // Now we calculate the triples (we do it using recursion)\n\
    \    let mut i = 1;\n    fn helper(a: &mut [isize], i: isize) {\n        if i\
    \ >= n {\n            return;\n        }\n\n        let j = i - 1;\n        let\
    \ k = i;\n\n        let triple = vec![a[i], a[j], a[k]];\n        triples.push(triple);\n\
    \n        helper(a, i+1);\n        helper(a, j+1);\n        helper(a, k+1);\n\
    \    }\n    helper(&mut a, 1);\n\n    // Now we return the number of triples whose\
    \ a[i] < a[j] < a[k]\n    triples.iter().filter(|&v| v[0] < a[0]).count() + triples.iter().filter(|&v|\
    \ v[1] < a[1]).count() + triples.iter().filter(|&v| v[2] < a[2]).count()", " \
    \   let mut a = vec![];\n    for i in 1..n {\n        let mut a0 = 1;\n      \
    \  let mut a1 = i;\n        let mut a2 = 1;\n        a[0] += a0;\n        a[1]\
    \ += a1;\n        a[2] += a2;\n        for j in 2..n {\n            let mut b0\
    \ = 1;\n            let mut b1 = j;\n            let mut b2 = 1;\n           \
    \ b[0] += b0;\n            b[1] += b1;\n            b[2] += b2;\n            if\
    \ a[0] > b[0] && b[0] > a[1] && a[1] > b[1] && a[0] > a[1] {\n               \
    \ a[0] = b[0];\n                a[1] = b[1];\n            }\n        }\n     \
    \   for k in 2..n {\n            if a[k] > b[k] {\n                b[k] = a[k];\n\
    \            }\n        }\n    }\n    a\n        .iter()\n        .filter(|&x|\
    \ x.0 % 3 != 0)\n        .count()", "    let mut res = 0;\n    let mut arr = [0i32;\
    \ n];\n    for i in 1..n {\n        arr[i] = i * i - i + 1;\n    }\n    arr.iter().for_each(|&v|\
    \ {\n        for &i in 1..n {\n            for &j in 1..n {\n                for\
    \ &k in 1..n {\n                    if i != j && i != k && j != k {\n        \
    \                let a = arr[i];\n                        let b = arr[j];\n  \
    \                      let c = arr[k];\n                        let sum = a +\
    \ b + c;\n                        if sum % 3 == 0 {\n                        \
    \    res += 1;\n                        }\n                    }\n           \
    \     }\n            }\n        }\n    });\n    res", "    let mut counter = 0;\n\
    \    for i in 1..n {\n        let j = i;\n        for _ in 1..(i + 1) {\n    \
    \        counter = counter + 1;\n            let k = j;\n            if ((counter\
    \ * counter) % 3 == 0){\n                return counter;\n            }\n    \
    \        j = k;\n        }\n    }\n    return counter;", "    let mut a = vec![n..].into_iter().map(|&x|\
    \ x*x-x+1).collect();\n    a.sort();\n    let mut cnt = 0;\n    for i in 1..n-1\
    \ {\n        for j in 1..n-1 {\n            if a[j] < a[i] && a[j] + a[i] > 3\
    \ {\n                cnt += 1;\n            }\n        }\n    }\n    cnt", " \
    \   let mut triples: isize = 0;\n    for i in 1..n {\n        for j in i..n {\n\
    \            for k in i..n {\n                if i != j && j != k && i != k {\n\
    \                    if j + k + 1 == i*i + 1 && i*i + 1 == i*i*i + 1 && i*i*i\
    \ + 1 == i*i*i*i + 1 {\n                        triples += 1;\n              \
    \      }\n                }\n            }\n        }\n    }\n    triples", " \
    \   let mut a: Vec<_> = vec![];\n    for i in 0..n {\n        a.push(i * i - i\
    \ + 1);\n    }\n    let mut triple_count = 0;\n    let mut i = 0;\n    while i\
    \ < a.len() {\n        for j in i + 1..a.len() {\n            let k = a.len()\
    \ - 1;\n            for k in i + 1..a.len() {\n                if a[k] + a[k +\
    \ 1] + a[k + 2] >= 3 {\n                    triple_count += 1;\n             \
    \   }\n            }\n        }\n        i += 1;\n    }\n    triple_count", " \
    \   let mut a = vec![0; n];\n    for &mut i in &mut a {\n        *i = *i * 3 -\
    \ i + 1;\n    }\n    a.iter().filter(|&mut i| i % 3 == 0).count()", "    let mut\
    \ a = [0i32; n];\n\n    for i in 1..n{\n        a[i] = i * i - i + 1;\n    }\n\
    \n    for i in 1..n{\n        for j in 1..n{\n            for k in 1..n{\n   \
    \             if i != j && i != k && j != k && (i * i - i + 1) % 3 == 0 {\n  \
    \                  return a.iter().filter(|&x| x == 0).count();\n            \
    \    }\n            }\n        }\n    }\n    0", "    let mut a: [isize; n] =\
    \ Default::default();\n    a[0] = 1;\n    a[1] = 1;\n    a[2] = 1;\n    for i\
    \ = 3..=n {\n        a[i*i - 1] = 1;\n        a[i*i] = 1;\n        a[i*i + 1]\
    \ = 1;\n    }\n    let mut sum = 0;\n    for i in 1..=n {\n        for j in 2..=i\
    \ {\n            for k in 2..=j {\n                if a[k] + a[j] + a[i] >= 3\
    \ {\n                    sum += 1;\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    sum", "    let mut counter: isize\
    \ = 0;\n    for _ in 1..n {\n        let mut counter: isize = 0;\n        let\
    \ mut temp_array: [i32; n] = [0];\n        for i in 0..n {\n            temp_array[i]\
    \ = temp_array[i] + (i * i) - i + 1;\n        }\n        for (a, b, c) in temp_array\
    \ {\n            if b == c + 3 {\n                counter = counter + 1;\n   \
    \         }\n        }\n    }\n    counter ", "    let mut a : [_; n] = [0; n];\n\
    \    for &i in &mut a {\n        i = i * i - i + 1;\n    }\n    let mut c = 0;\n\
    \    for i in a.iter_mut() {\n        *i += 1;\n        if *i % 3 == 0 {\n   \
    \         c += 1;\n        }\n    }\n    c", "    let mut a = vec![0; n];\n  \
    \  a.fill(0);\n    for _ in 0..n {\n        let mut index = 0;\n        let mut\
    \ sum = 0;\n        while index != 0 {\n            sum += a[index];\n       \
    \     if sum % 3 == 0 {\n                break;\n            }\n            index\
    \ += 1;\n        }\n        a[index] = sum - 1;\n    }\n    a.len()", "    let\
    \ mut a = vec![0; n];\n    a[0] = 1;\n    for i in 1..n {\n        a[i] = i *\
    \ i - i + 1;\n    }\n\n    let mut count = isize::MAX;\n    for i in 0..n {\n\
    \        for j in 0..n {\n            for k in 0..n {\n                if i !=\
    \ j && i != k && j != k {\n                    let triple = a[i] + a[j] + a[k];\n\
    \                    if count < triple {\n                        count = triple;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   count", "    let mut a = [0; n];\n    for i in 0..n {\n        a[i] = i *\
    \ i - i + 1;\n    }\n    let mut c = 0;\n    for i in 0..n {\n        for j in\
    \ i+1..n {\n            let k = j + 1;\n            if a[i] - a[j] < a[k] - a[i]\
    \ {\n                c += 1;\n            }\n        }\n    }\n    c", "    let\
    \ mut arr: [isize; n + 1] = Default::default();\n    for i in 0..n + 1 {\n   \
    \     arr[i] = i * i - i + 1;\n    }\n    let mut ans = 0;\n    for i in 0..n\
    \ {\n        for j in (i + 1..n).rev() {\n            if arr[i + j] % 3 == 0 {\n\
    \                ans += 1;\n            }\n        }\n    }\n    ans", "    let\
    \ mut a: [isize; n] = Default::default();\n    for i in 0..n {\n        a[i] =\
    \ i * i - i + 1;\n    }\n\n    a.iter().filter(|&i| i > 0).filter(|&i| i < n).filter(|&i|\
    \ a[i] == (3 * i + 1)).count()", "    let mut a = vec![0, 1, 2];\n    for i in\
    \ a.iter_mut() {\n        *i = i;\n    }\n    \n    for i in (0..n).rev() {\n\
    \        for j in &a[i..] {\n            if *j == *i {\n                *j = *j\
    \ + 3;\n            }\n        }\n    }\n    \n    a.iter().filter(|&x| x == 3).count()",
  "    let mut counter = 0;\n    let mut a = [i32; n];\n    for i in 0..n-1 {\n  \
    \      a[i] = i * i - i + 1;\n    }\n    for i in 0..n-1 {\n        for (j in\
    \ 0..n-1) {\n            for (k in 0..n-1) {\n                let k = k+1;\n \
    \               let a = a[i];\n                let b = a[j];\n               \
    \ let c = a[k];\n                if (a + b + c) == 3 {\n                    counter\
    \ += 1;\n                }\n            }\n        }\n    }\n    counter", " \
    \   let mut triplets: isize = 0;\n    let mut a = vec![1; n + 1];\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while j < n {\n        while\
    \ i < n && j < n && k < 3{\n            if a[i] == 0 && a[j] == 0 && a[k] == 0\
    \ {\n                triplets += 1;\n                break;\n            } else\
    \ if a[i] == 0 || a[j] == 0 || a[k] == 0 {\n                i += 1;\n        \
    \        j += 1;\n                k += 2;\n            } else {\n            \
    \    i += 1;\n                j += 1;\n                k += 1;\n            }\n\
    \        }\n        if i == n {\n            j += 1;\n            i += 1;\n  \
    \      }\n        if j == n {\n            i += 1;\n            j += 1;\n    \
    \    }\n        if k == n {\n            j += 1;\n            i += 1;\n      \
    \      k += 1;\n        }\n    }\n    triplets", "    let mut a = vec![1; n +\
    \ 1];\n\n    // O(n^2)\n    for i in 1..n {\n        for j in i..n {\n       \
    \     if a[i] == 0 {\n                a[i] = i * i - i + 1;\n                break;\n\
    \            }\n        }\n    }\n\n    a.iter().filter(|&v| v % 3 == 0).count()",
  "    let mut a = [0; n];\n    for n in 0..n {\n        a[n] = n * n - n + 1\n  \
    \  }\n    let mut triple = 0;\n    for n in 0..n {\n        for j in 0..n {\n\
    \            for k in 0..n {\n                if i <= j <= k && a[j] + a[k] >\
    \ a[j] + a[i] {\n                    triple += 1;\n                }\n       \
    \     }\n        }\n    }\n    triple", "    let mut count = 1;\n    for i in\
    \ 1..n+1 {\n        for j in 1..i+1 {\n            for k in 1..j+1 {\n       \
    \         if i+j+k < n {\n                    count += if i + j + k == i * i *\
    \ i { 1 } else { 0 };\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut count = 0;\n\n    let mut a = vec![];\n\n    for i in\
    \ 1..n {\n        let mut j = i;\n        while j < n {\n            a.push(j\
    \ * (j + 1) - i + 1);\n            j = j + i;\n        }\n    }\n\n    for i in\
    \ 0..n {\n        let mut j = i;\n        while j > 0 {\n            if a[j -\
    \ 1] == a[j] {\n                count++;\n                j = j - 1;\n       \
    \     } else {\n                break;\n            }\n        }\n    }\n\n  \
    \  count", "    fn get_sum(arr: &[isize]) -> isize {\n        if arr.len() ==\
    \ 0 {\n            return 0;\n        }\n        let mut total = 0;\n        for\
    \ i in 0..arr.len() {\n            total += arr[i];\n        }\n        return\
    \ total;\n    }\n\n    fn is_tripple(&mut arr: &[isize], i: usize, j: usize, k:\
    \ usize) -> bool {\n        if j == k {\n            return false;\n        }\n\
    \        if arr[j] > arr[k] {\n            return false;\n        }\n        if\
    \ arr[i] < arr[j] {\n            arr[i] = arr[j];\n            arr[j] = arr[k];\n\
    \        }\n        else {\n            arr[j] = arr[k];\n            arr[k] =\
    \ arr[i];\n        }\n        return true;\n    }\n\n    let mut arr = [0i32;\
    \ n];\n    for i in 0..n {\n        arr[i] = i * i - i + 1;\n    }\n    for i\
    \ in 0..n {\n        for j in 0..n {\n            for k in 0..n {\n          \
    \      let mut total = get_sum(&arr);\n                if i != j && i != k {\n\
    \                    total += arr[j] - arr[k];\n                }\n          \
    \      if j != k && i != k {\n                    total += arr[i] - arr[k];\n\
    \                }\n                if i != j && j != k {\n                  \
    \  total += arr[i] - arr[j];\n                }\n                if i != j &&\
    \ i != k && j != k {\n                    total += arr[j] - arr[i];\n        \
    \        }\n                if i != k && j != k && i != j {\n                \
    \    total += arr[i] - arr[j];\n                }\n                if j != k &&\
    \ i != k && j != k {\n                    total += arr[j] - arr[i];\n        \
    \        }\n                if i != j && i != k && j != k {\n                \
    \    total += arr[i] - arr[j];\n                }\n                if i != j &&\
    \ i != k && j != k {\n                    total += arr[j] - arr[i];\n        \
    \        }\n                if i != k && j != k && i != j {\n                \
    \    total += arr[i] - arr[j];\n                }\n                if i != j &&\
    \ i != k && j != k {\n                    total += arr[i] - arr[j];\n        \
    \        }\n                if i != k && j != k && i != j {\n                \
    \    total += arr[i] - arr[j];\n                }\n                if i != j &&\
    \ i != k && j != k {\n                    total += arr[j] - arr[i];\n        \
    \        }\n                if i != j && i != k && j != k {\n                \
    \    total += arr[i] - arr[j];\n                }\n                if i != k &&\
    \ j", "    if n < 1 {\n        0\n    }\n    let mut a: [usize; n] = [0; n];\n\
    \    for i in 1..n {\n        a[i] = i * i - i + 1;\n    }\n    let mut max_triples:\
    \ isize = 0;\n    for i in 0..n {\n        for j in 0..n {\n            for k\
    \ in 0..n {\n                if a[i] < a[j] && a[i] < a[k] && a[j] < a[k] && \n\
    \                    a[i] - a[j] - a[k] == i*i*i {\n                    max_triples\
    \ += 1;\n                }\n            }\n        }\n    }\n    max_triples",
  "    let mut a: [isize; n + 1] = [0; n + 1];\n\n    for i in 0..(n + 1) {\n    \
    \    for j in 0..(n + 1) {\n            let mut tmp = a[j];\n            for k\
    \ in 0..(n + 1) {\n                if i == k || j == k || i == j {\n         \
    \           continue;\n                }\n                if a[k] > tmp {\n  \
    \                  tmp = a[k];\n                }\n            }\n           \
    \ a[i] = tmp;\n        }\n    }\n\n    let mut result = 0;\n    for i in 0..(n\
    \ + 1) {\n        if a[i] % 3 == 0 {\n            result++;\n        }\n    }\n\
    \    result", "    let mut a = vec![0; n];\n    a.push(1);\n    for i in 1..n\
    \ {\n        a[i] = a[i] - a[i] + 1 + a[i];\n    }\n    for i in 0..(n-1) {\n\
    \        for j in (i..n) {\n            for k in (i..j) {\n                if\
    \ a[j] > a[k] + a[k] && a[j] + a[k] > a[j] + a[k] {\n                    return\
    \ 1;\n                }\n            }\n        }\n    }\n    0", "    let mut\
    \ triple : Vec<isize> = vec![];\n    for i in 1..=n {\n        for j in (i+1)..=n\
    \ {\n            for k in (i+1)..=n {\n                if i + j + k >= 3 * i {\n\
    \                    triple.push(i + j + k);\n                }\n            }\n\
    \        }\n    }\n    triple.iter().filter(|&x| x % 3 == 0).count()", "    let\
    \ mut cnt: isize = 0;\n    let mut a: Vec<i32> = vec![0;n];\n    for i in 0..(n-1)\
    \ /*n*/{\n        a[i] = i * i - i + 1;\n    }\n    for i in 0..(n-1) /*n*/{\n\
    \        for j in (i+1)..(n-1) /*n*/{\n            for k in (i+1)..(n-1) /*n*/{\n\
    \                if a[j] + a[k] > 3*a[i] {\n                    cnt += 1;\n  \
    \              }\n            }\n        }\n    }\n    cnt", "    if n <= 0 {\n\
    \        return 0\n    }\n    let mut a: Vec<isize> = vec![0; n];\n    for _ in\
    \ 0..n {\n        a.push(0)\n    }\n    let mut sum: isize = 0;\n    for i in\
    \ 1..n {\n        let mut j = i - 1;\n        sum = 0;\n        while j >= 0 {\n\
    \            sum += a[j] - a[j] + 1;\n            j--\n        }\n        a[i]\
    \ = sum;\n    }\n    a.iter().filter(|&x| x >= 3).count();", "    let mut res\
    \ = 0;\n    let mut a = vec![0, 1, 2, 3, 4, 5].iter().map(|&x| x * x - x + 1).collect();\n\
    \    let mut cur_val = 1;\n    let mut cur_pos = 0;\n    while cur_pos < n {\n\
    \        cur_val += cur_pos + 1;\n        if cur_val % 3 == 0 {\n            cur_pos\
    \ -= 1;\n        }\n        else {\n            a[cur_pos] = cur_val - 1;\n  \
    \          cur_val = 1;\n            cur_pos = 0;\n        }\n    }\n    for x\
    \ in &a[..] {\n        res += x;\n    }\n    res / 3;", "    fn compute(mut arr:\
    \ [isize; n], i: usize, j: usize, k: usize) -> isize {\n        if i == j {\n\
    \            arr[i] = arr[i] + arr[k]\n        } else if i > k {\n           \
    \ compute(arr, i, k - 1, k);\n            if arr[k] == 0 {\n                return\
    \ arr[k - 1]\n            }\n            compute(arr, i, k - 1, k);\n        \
    \    compute(arr, i, k - 1, k);\n            compute(arr, i, k - 1, k);\n    \
    \        return arr[k - 1];\n        } else if j > k {\n            compute(arr,\
    \ i, j, k - 1);\n            compute(arr, i, j, k - 1);\n            compute(arr,\
    \ i, j, k - 1);\n            compute(arr, i, j, k - 1);\n            return arr[k\
    \ - 1];\n        } else {\n            compute(arr, i, j, k - 1);\n          \
    \  compute(arr, i, j, k - 1);\n            compute(arr, i, j, k - 1);\n      \
    \      compute(arr, i, j, k - 1);\n            compute(arr, i, j, k - 1);\n  \
    \          return arr[k - 1];\n        }\n    }\n    compute([0; n], 0, 0, n)\
    \ - 1", "    let mut a = vec![0; n];\n    for i in 1..n {\n        a[i] = i *\
    \ i - i + 1;\n    }\n    let mut cnt = 0;\n    for i in 1..n {\n        for j\
    \ in i + 1..n {\n            for k in i + 2..n {\n                if a[i] == a[j]\
    \ && a[j] == a[k] {\n                    cnt += 1;\n                }\n      \
    \      }\n        }\n    }\n    cnt", "    debug_assert!(n >= 0);\n    let mut\
    \ sum = 1;\n    for i in 1..=n {\n        sum += i;\n    }\n    let mut count\
    \ = 1;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            for k\
    \ in (j + 1)..n {\n                let result = sum + i + j + k;\n           \
    \     if result % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    assert!(n > 0);\n    let mut\
    \ a = [0; n + 1];\n    for i in 1..n {\n        a[i] = i * i - i + 1;\n    }\n\
    \    \n    let mut triple = 0;\n    for i in 0..n {\n        for j in 0..n {\n\
    \            for k in 0..n {\n                if i != j && i != k && j != k &&\
    \ a[i] + a[j] + a[k] == 3 {\n                    triple = triple + 1;\n      \
    \          }\n            }\n        }\n    }\n    triple", "    let mut res:\
    \ Vec<isize> = Vec::with_capacity(n);\n    let mut j: isize = 1;\n    for i in\
    \ 1..n {\n        while j < i {\n            res[j] = i * i - i + 1;\n       \
    \     i += 1;\n            j += 1\n        }\n    }\n    res[0] // the number\
    \ of triples a[i], a[j], a[k]", "    let mut a = vec![0; n];\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < n {\n        a[i]\
    \ = i * i - i + 1;\n        i += 1;\n    }\n    while j < n {\n        a[j] =\
    \ j * j - j + 1;\n        j += 1;\n    }\n    while k < n {\n        a[k] = k\
    \ * k - k + 1;\n        k += 1;\n    }\n\n    for ii in 0..n {\n        for jj\
    \ in ii..n {\n            for kk in jj..n {\n                if ii == jj && jj\
    \ == kk {\n                    continue;\n                }\n                if\
    \ a[ii] + a[jj] + a[kk] % 3 == 0 {\n                    return a[ii] + a[jj] +\
    \ a[kk];\n                }\n            }\n        }\n    }\n    0", "    let\
    \ mut ans = 0;\n    let mut a = vec![0; n];\n\n    // a[i] = i * i - i + 1. \n\
    \    for i in 1..n {\n        a[i] = i * i - i + 1;\n        ans += a.iter().filter(|&x|\
    \ x % 3 == 0).count() as isize;\n    }\n    return ans;", "    let mut arr: [isize;\
    \ n] = [0isize; n];\n    for i in 0..n {\n        arr[i] = i * i - i + 1;\n  \
    \  }\n    let mut ans = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n\
    \            for k in (j + 1)..n {\n                if i != j && i != k && j !=\
    \ k {\n                    if arr[i] + arr[j] + arr[k] == 3*i - 3*j - 3*k + 3*i\
    \ + 3*j + 3*k {\n                        ans += 1;\n                    }\n  \
    \              }\n            }\n        }\n    }\n    ans", "    let mut a: [Vec<usize>;\
    \ n + 1] = [vec![0; n]; n + 1];\n    a[0][0] = 1 + 1;\n    for i in 1..n {\n \
    \       a[i][i] = i * i - 1 + 1;\n        for j in i..n {\n            a[i][j]\
    \ = a[i][j - i] + 1;\n            for k in i..n {\n                a[i][k] = a[i][k\
    \ - i] + 1;\n            }\n        }\n    }\n    a[n - 1][n - 1]", "    if n\
    \ < 3 { return 0 }\n    let mut a = vec![0; n - 1];\n    a.copy_from_slice(&[1,\
    \ 1, 1]);\n    for i in 1..n-1 {\n        for j in (i + 1)..n {\n            for\
    \ k in (i + 1)..n {\n                let sum = i * i - i + 1;\n              \
    \  if sum == k * k + j + j + i {\n                    let idx = a.len();\n   \
    \                 a[idx] = k * k + j + j + i;\n                    return idx\
    \ + 1;\n                }\n            }\n        }\n    }\n    return 0", " \
    \   let mut a = vec![0; n];\n    a[1] = 1;\n    for i in 2..n - 1 {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    let mut result: usize = 0;\n    for i in 0..n -\
    \ 1 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n - 1 {\n\
    \                let triple = (i + j + k, a[i], a[j], a[k]);\n               \
    \ if triple.0 == triple.1..triple.3 {\n                    result += triple.0;\n\
    \                }\n            }\n        }\n    }\n    result", "    let mut\
    \ a : [isize; n] = [0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n\
    \    }\n    for i in 1..n {\n        for j in i..n {\n            let mut triples\
    \ = 0;\n            for k in 0..n {\n                let triple = *a[k] + *a[j]\
    \ + *a[i];\n                if triple % 3 == 0 {\n                    triples\
    \ += 1;\n                }\n            }\n            if triples == 3 {\n   \
    \             return triples;\n            }\n        }\n    }\n    return 0;",
  "    (0..n).filter(|i| i * i * i != n).count(|i| {\n        let mut triple = 0;\n\
    \        for a in 0..i {\n            let j = i;\n            for b in 0..i-1\
    \ {\n                let k = i;\n                let s = a*a + b*b + k*k;\n  \
    \              if s == 3 {\n                    triple += 1;\n               \
    \     triple = triple > 3 ? 3 : triple;\n                }\n                k\
    \ = j;\n            }\n        }\n        triple > 3 ? triple : triple\n    })",
  "    let mut result = 0.0;\n    for i in 1..n {\n        for j in i+1..n {\n   \
    \         for k in j+1..n {\n                if i+j+k == 3 && i*i + j*j == k*k\
    \ {\n                    result += 1;\n                }\n            }\n    \
    \    }\n    }\n    result", "    let mut a = Vec::new();\n    for i in 1..n {\n\
    \        a.push(3 * i - 2 + 1);\n    }\n    let mut count = 0;\n    for &i in\
    \ a {\n        for &j in &a { \n            for &k in &a { \n                if\
    \ i + j + k == 3 {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    count", "    let mut triples = 0;\n    for i\
    \ in 1..n {\n        for j in (i + 1)..n {\n            for k in (i + 1)..n {\n\
    \                if is_triple_solution(i, j, k) {\n                    triples++;\n\
    \                }\n            }\n        }\n    }\n    triples", "    let mut\
    \ a: [isize; n] = Default::default();\n    for i in 1..n {\n        a[i] = i *\
    \ i - i + 1;\n    }\n    for i in 0..n {\n        let mut j: isize = 0;\n    \
    \    while j < (n - 1) && (i + j) < n {\n            a[i + j] = a[i + j] * 3;\n\
    \            j += 1;\n        }\n    }\n    for i in 0..n {\n        if a[i] ==\
    \ 0 {\n            return 0;\n        }\n    }\n    return a.iter().filter(|x|\
    \ x % 3 == 0).count();", "    let mut a = vec![0; n];\n    for i in 0..n-1 {\n\
    \        for j in i+1..n-1 {\n            for k in j+1..n-1 {\n              \
    \  if i != j && i != k && j != k {\n                    let mut triples = 0.;\n\
    \                    for (m, n) in a.iter().enumerate() {\n                  \
    \      if m == i && n == j && m != k {\n                            triples +=\
    \ 1;\n                        }\n                    }\n                    if\
    \ triples % 3 == 0 {\n                        return triples;\n              \
    \      }\n                }\n            }\n        }\n    }\n    0", "    let\
    \ mut triples: isize = 1;\n    let mut trip: isize = 1;\n    let mut trip_max:\
    \ isize = 0;\n    for _ in 1..n {\n        if trip + trip == 0 {\n           \
    \ triples += 1;\n        }\n        trip = 0;\n        if trip_max < triples {\n\
    \            trip_max = triples;\n        }\n    }\n    trip_max", "    fn check_triple(a:\
    \ [isize; 3]) -> bool {\n        a[0] + a[1] == a[2] + a[3]\n    }\n\n    (0..n).filter(|i|\
    \ check_triple(vec![i as isize; 3])).count()", "    let mut a: [isize; n + 1]\
    \ = Array::new(n + 1);\n    for i in 0..n + 1 {\n        a[i] = i * i - i + 1;\n\
    \    }\n    let mut cnt = 0;\n    for i in 1..n + 1 {\n        for j in i + 1..n\
    \ + 1 {\n            for k in j + 1..n + 1 {\n                if a[j] >= a[i]\
    \ && a[k] >= a[i] && a[j] + a[k] % 3 == 0 {\n                    cnt += 1;\n \
    \               }\n            }\n        }\n    }\n    cnt", "    let mut a =\
    \ vec![0; n];\n    for i in 1..n {\n        a[i] = i * i - i + 1;\n    }\n   \
    \ a.iter().filter(|&x| x % 3 == 0).count() as isize", "    let mut counter: isize\
    \ = 0;\n    for i in 1..n {\n        for j in i..n {\n            for k in i..n\
    \ {\n                if (i * i - j + k) % 3 == 0 {\n                    counter\
    \ += 1;\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    counter", "    (1..=n)\n        .filter(|i| {\n            if\
    \ let Ok(i) = find_triple(i, (i+1) as isize) {\n                false\n      \
    \      } else {\n                true\n            }\n        })\n        .count();",
  "    let mut a: [isize; n] = [0, 1, 2];\n    \n    for i in 1..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (i + 1)..n {\n                if a[i]\
    \ < a[j] && a[j] < a[k] && a[i] < a[j + a[k]] {\n                    a[i] = a[j]\
    \ + a[k];\n                }\n            }\n        }\n    }\n    a.iter().filter(|&i|\
    \ i % 3 == 0).count()", "    loop {\n        let mut a = vec![0; n];\n       \
    \ a.iter().for_each(|&i| a[i] = (i * i - i + 1));\n        if a.iter().all(|&i|\
    \ i >= 3) {\n            return a.iter().filter(|&i| i >= 3).count();\n      \
    \  }\n    }", "    let mut a = vec![0; n + 1];\n    for i in 0..(n + 1) {\n  \
    \      a[i] = i * i - i + 1;\n    }\n    for i in 0..(n + 1) {\n        for j\
    \ in (i + 1)..(n + 1) {\n            let k = i + j;\n            a[k] = a[k] *\
    \ 3;\n            if a[i] < a[j] {\n                a[i] = a[j];\n           \
    \ }\n            if a[i] < a[k] {\n                a[i] = a[k];\n            }\n\
    \        }\n    }\n    a.len()", "    fn helper(i: isize, j: isize, k: isize)\
    \ -> isize {\n        if j > k || i + j + k > n || i * i + j * j > 3 * n * n {\n\
    \            return 0;\n        }\n        if k == 0 || j == i || k == j {\n \
    \           return 1;\n        }\n        if a[i] - a[j] < a[k] - a[j] {\n   \
    \         return helper(i+1, j, k-1);\n        } else {\n            return helper(i+1,\
    \ j, k);\n        }\n    }\n    let mut a = vec![0; n];\n    for i in 1..n-1 {\n\
    \        a[i] = i * i - i + 1;\n    }\n    for i in 1..n-1 {\n        for j in\
    \ 1..n-1 {\n            for k in 1..n-1 {\n                if i != j && i != k\
    \ && j != k {\n                    if a[i] - a[j] < a[k] - a[j] {\n          \
    \              helper(i, j, k);\n                    } else if a[i] - a[j] > a[k]\
    \ - a[j] {\n                        helper(i, j, k-1);\n                    }\
    \ else {\n                        helper(i, j, k);\n                    }\n  \
    \              }\n            }\n        }\n    }\n    return a.len();", "   \
    \ let mut total = 0;\n    let mut a = vec![1isize; n];\n    for i in 1..n{\n \
    \       a[i] = i * i - i + 1;\n    }\n    for i in 1..n{\n        for j in i +\
    \ 1..n{\n            for k in j + 1..n{\n                if (a[i] == a[j] || a[i]\
    \ == a[k]) && \n                    (a[j] == a[k] || a[j] == a[i]){\n        \
    \            total += 1;\n                }\n            }\n        }\n    }\n\
    \    total", "    \n    \n    \n    let mut a = [0; n + 1];\n    for i in 0 ..\
    \ n - 1 {\n        a[i] = i * i - i + 1;\n    }\n    \n    let mut res = 0;\n\
    \    let mut last = [0; n + 1];\n    \n    for &mut aa in &mut a[0..n] {\n   \
    \     \n        last[aa - 1] = aa - 1;\n        if last[aa] >= n {\n         \
    \   last[aa] = n - 1;\n        }\n        \n        if aa > 1 && last[aa - 2]\
    \ >= n{\n            \n            if last[aa - 1] + last[aa - 2] < n {\n    \
    \            \n                let mut temp = aa - 2;\n                let mut\
    \ j1 = last[aa - 1];\n                let mut j2 = last[aa];\n               \
    \ while temp > 0 && j2 > 0 && j1 + j2 < n {\n                    if a[temp - 1]\
    \ + a[j1] == a[j2] + a[k1]{\n                        res = res + 1;\n        \
    \            }\n                    temp--;\n                    j1--;\n     \
    \               j2--;\n                }\n            }\n        }\n    }\n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    ", "    let mut a: [isize; n] = [0; n];\n    a.iter_mut().cloned().for_each(|&mut\
    \ x| x = x * 3 - 1 + 1);\n    for i in 0..n {\n        let mut j = i + 1;\n  \
    \      let mut k = n - 1;\n        loop {\n            match j {\n           \
    \     j @ _ => break,\n                _ => {\n                    match k {\n\
    \                        k @ _ => break,\n                        _ => {\n   \
    \                         a[k] = a[i] + a[j] + a[k];\n                       \
    \     j -= 1;\n                            k -= 1;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   let mut sum = 0;\n    for i in 0..n {\n        sum += a[i] + a[i + n] + a[i\
    \ + 2 * n];\n    }\n    sum % 3 == 0", "    let mut a = vec![];\n    for i in\
    \ 1..n {\n        a.push(2 * i - 1);\n    }\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            for k in 0..n {\n                let sum = a[i] + a[j]\
    \ + a[k];\n                if sum % 3 == 0 {\n                    return i;\n\
    \                }\n            }\n        }\n    }\n    return n", "    let mut\
    \ array = [0 as isize; 3];\n    for a in 0..n {\n        let mut c = array.clone();\n\
    \        for b in 0..n {\n            a[b] = b * b - b + a[b];\n        }\n  \
    \      for i in 0..n {\n            for j in 0..n {\n                for k in\
    \ 0..n {\n                    c[i] += i * i - j + a[a[k]];\n                }\n\
    \            }\n        }\n        if c.iter().any(|x| x == 3 * c.iter().max(|y|\
    \ y - x)) {\n            return 1;\n        }\n    }\n    0", "    let mut a =\
    \ vec![0; n];\n    a[0] = 1;\n    for i in 1..n {\n        a[i] = i * i - i +\
    \ 1;\n    }\n    let mut cnt = 0;\n    for i in 0..n {\n        for j in i + 1..n\
    \ {\n            for k in i + 1..n {\n                if a[i] == a[j] + a[k] {\n\
    \                    cnt += 1;\n                }\n            }\n        }\n\
    \    }\n    cnt", "    let mut sum = 1;\n    for i in 1..=n {\n        let mut\
    \ temp = i;\n        sum = sum + temp * temp - temp + 1;\n    }\n    if sum %\
    \ 3 == 0 {\n        1\n    } else {\n        0\n    }", "    let mut mut num_triples\
    \ = 0;\n    let mut a = [0; n];\n    for i in 0..n {\n        a[i] = i * i - i\
    \ + 1;\n    }\n\n    for i in 0..n {\n        for j in 0..n {\n            for\
    \ k in 0..n {\n                if i != j && i != k && j != k && a[i] + a[j] +\
    \ a[k] % 3 == 0 {\n                    num_triples += 1;\n                }\n\
    \            }\n        }\n    }\n    return num_triples;", "    let mut arr =\
    \ vec![0; n];\n    for i in 1..n {\n        arr[i] = i * i - i + 1;\n    }\n \
    \   let mut cnt = 0;\n    for i in 0..n {\n        for j in 0..n {\n         \
    \   for k in 0..n {\n                if i != j && i != k && j != k && (arr[i]\
    \ + arr[j] + arr[k]) % 3 == 0 {\n                    cnt += 1;\n             \
    \   }\n            }\n        }\n    }\n    cnt"]
stop_tokens:
- "\n}"
