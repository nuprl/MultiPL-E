name: HumanEval_72_will_it_fly
language: rust
results:
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 { \n  \
    \      return true\n    }\n    let mut balanced = false\n    let mut sum_of_elements\
    \ = 0\n    for &i in q {\n        sum_of_elements += i;\n        if balanced &&\
    \ sum_of_elements >= w {\n            return true\n        }\n        sum_of_elements\
    \ -= i;\n        balanced = true\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpa3ohlf89.rs:16:29\n\
    \   |\n16 |     let mut balanced = false\n   |                             ^ help:\
    \ add `;` here\n17 |     let mut sum_of_elements = 0\n   |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa3ohlf89.rs:17:32\n\
    \   |\n17 |     let mut sum_of_elements = 0\n   |                            \
    \    ^ help: add `;` here\n18 |     for &i in q {\n   |     --- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa3ohlf89.rs:18:9\n   |\n18 | \
    \    for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    \n\
    \    let mut is_balanced = true;\n    \n    // The algorithm is designed to work\
    \ for a palindromic list as long as we can find the minimum number in the list.\n\
    \    // So if we find the minimum number in the list, we know that our list will\
    \ be balanced.\n    // Otherwise, we assume that the minimum number is not in\
    \ the list.\n    // If the minimum number is not in the list, we will assume that\
    \ it is balanced.\n    \n    let mut min_element = q.iter().min();\n    \n   \
    \ for e in q {\n        sum += e;\n        if (sum > w) {\n            is_balanced\
    \ = false;\n            break;\n        }\n        if (sum < w) {\n          \
    \  min_element = e;\n        }\n    }\n    \n    is_balanced && min_element ==\
    \ q.iter().min();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3xe8b107.rs:26:12\n\
    \   |\n26 |         if (sum > w) {\n   |            ^       ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    26 -         if (sum > w) {\n26 +         if sum > w {\n   | \n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmp3xe8b107.rs:30:12\n   |\n30\
    \ |         if (sum < w) {\n   |            ^       ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n30 -         if (sum < w) {\n30 +         if sum < w {\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3xe8b107.rs:31:27\n  \
    \ |\n22 |     let mut min_element = q.iter().min();\n   |                    \
    \       -------------- expected due to this value\n...\n31 |             min_element\
    \ = e;\n   |                           ^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<&isize>`\n              found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3xe8b107.rs:12:44\n   |\n12 |\
    \ fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------     \
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n...\n\
    35 |     is_balanced && min_element == q.iter().min();\n   |                 \
    \                                - help: remove this semicolon\n\nerror: aborting\
    \ due to 2 previous errors; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = q.len() - 1;\n\
    \    let mut j = q.len() - 1;\n\n    let mut sum = 0;\n    while i >= 0 && j >=\
    \ 0 {\n        sum += q[i] - q[j];\n        i -= 1;\n        j -= 1;\n    }\n\
    \    sum <= w && i == 0 && j == 0 && sum == w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpraaawkfw.rs:19:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w.is_positive() {\n\
    \        if q.is_empty() {\n            return false;\n        }\n        if will_it_fly(q.iter().rev().take(q.len()\
    \ / 2), w) {\n            return true;\n        }\n        return false;\n   \
    \ }\n    if q.is_empty() {\n        return false;\n    }\n    let mut maximum\
    \ = w;\n    for e in q {\n        maximum = maximum - e;\n    }\n    if maximum.abs()\
    \ < w {\n        return false;\n    }\n    let mut n = q.len() / 2;\n    if n\
    \ < q.len() {\n        // q might be balanced\n        while n > 0 {\n       \
    \     let q = &q[n];\n            if will_it_fly(q.iter().rev().take(q.len() /\
    \ 2).rev(), w) {\n                return true;\n            }\n            n =\
    \ n / 2;\n        }\n        // q might not be balanced\n        return false;\n\
    \    }\n    let mut n2 = q.len() / 2;\n    while n2 > 0 {\n        let q = &q[n2];\n\
    \        if will_it_fly(q.iter().rev().take(q.len() / 2).rev(), w) {\n       \
    \     return true;\n        }\n        n2 = n2 / 2;\n    }\n    // q might be\
    \ balanced\n    let mut n = q.len() / 2;\n    while n <= q.len() {\n        let\
    \ q = &q[n];\n        if will_it_fly(q.iter().rev().take(q.len() / 2).rev(), w)\
    \ {\n            return true;\n        }\n        n = n + 1;\n    }\n    // q\
    \ might not be balanced\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiibysoe8.rs:17:24\n   |\n\
    17 |         if will_it_fly(q.iter().rev().take(q.len() / 2), w) {\n   |     \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `std::iter::Take`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \            found struct `std::iter::Take<Rev<std::slice::Iter<'_, isize>>>`\n\
    \nerror[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpiibysoe8.rs:37:30\n   |\n37 |             if will_it_fly(q.iter().rev().take(q.len()\
    \ / 2).rev(), w) {\n   |                              ^^^^ method not found in\
    \ `&isize`\n\nerror[E0599]: no method named `len` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpiibysoe8.rs:37:50\n   |\n37 |          \
    \   if will_it_fly(q.iter().rev().take(q.len() / 2).rev(), w) {\n   |        \
    \                                          ^^^ method not found in `&isize`\n\n\
    error[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpiibysoe8.rs:48:26\n   |\n48 |         if will_it_fly(q.iter().rev().take(q.len()\
    \ / 2).rev(), w) {\n   |                          ^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `len` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpiibysoe8.rs:48:46\n   |\n48 |         if will_it_fly(q.iter().rev().take(q.len()\
    \ / 2).rev(), w) {\n   |                                              ^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `iter` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpiibysoe8.rs:57:26\n   |\n57 | \
    \        if will_it_fly(q.iter().rev().take(q.len() / 2).rev(), w) {\n   |   \
    \                       ^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `len` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmpiibysoe8.rs:57:46\n   |\n57 |         if will_it_fly(q.iter().rev().take(q.len()\
    \ / 2).rev(), w) {\n   |                                              ^^^ method\
    \ not found in `&isize`\n\nerror: aborting due to 7 previo"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     let max_len = w.powi(-1);\n        q.iter().all(|e| *e <= max_len && e !=\
    \ 0)\n    }\n    else {\n        let mut b = true; // balance check\n        let\
    \ mut s = q[0]; // current sum\n        let mut w = w;\n        for (pos, item)\
    \ in q.iter().enumerate() {\n            let delta = item.powf(-1) - w.powf(-1);\
    \ // delta\n            if delta < 0 {\n                s = q[pos];\n        \
    \        b = false;\n                break;\n            }\n            s += item;\n\
    \            if s == 0 {\n                b = true;\n                break;\n\
    \            }\n            w += delta;\n        }\n        b\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `powi` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphdh38t6k.rs:14:25\n   |\n14 |         let max_len = w.powi(-1);\n\
    \   |                         ^^^^ help: there is an associated function with\
    \ a similar name: `pow`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmphdh38t6k.rs:15:45\n   |\n15 |         q.iter().all(|e| *e <= max_len\
    \ && e != 0)\n   |                                             ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `powf`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmphdh38t6k.rs:22:30\n\
    \   |\n22 |             let delta = item.powf(-1) - w.powf(-1); // delta\n   |\
    \                              ^^^^ help: there is an associated function with\
    \ a similar name: `pow`\n\nerror[E0599]: no method named `powf` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmphdh38t6k.rs:22:43\n   |\n22 |  \
    \           let delta = item.powf(-1) - w.powf(-1); // delta\n   |           \
    \                                ^^^^ help: there is an associated function with\
    \ a similar name: `pow`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let max_weight = w.sqrt();\n\
    \    let mut q_balanced = true;\n    let mut q_reversed = q.iter().rev();\n  \
    \  let mut max_sum = 0;\n\n    while q_balanced {\n        if *q_reversed > max_weight\
    \ {\n            q_balanced = false;\n        } else if *q_reversed == max_weight\
    \ {\n            max_sum += *q_reversed;\n            q_reversed.pop();\n    \
    \    } else {\n            q_reversed.pop();\n        }\n    }\n    *q_reversed\
    \ <= max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpzkc_nhpj.rs:13:24\n   |\n13 |     let max_weight = w.sqrt();\n\
    \   |                        ^^^^ method not found in `isize`\n\nerror[E0614]:\
    \ type `Rev<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmpzkc_nhpj.rs:19:12\n\
    \   |\n19 |         if *q_reversed > max_weight {\n   |            ^^^^^^^^^^^\n\
    \nerror[E0614]: type `Rev<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmpzkc_nhpj.rs:21:19\n   |\n21 |         } else if *q_reversed ==\
    \ max_weight {\n   |                   ^^^^^^^^^^^\n\nerror[E0614]: type `Rev<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmpzkc_nhpj.rs:22:24\n   |\n22 |\
    \             max_sum += *q_reversed;\n   |                        ^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `pop` found for struct `Rev` in the current scope\n\
    \  --> /tmp/tmpzkc_nhpj.rs:23:24\n   |\n23 |             q_reversed.pop();\n \
    \  |                        ^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `pop` found for struct `Rev` in the\
    \ current scope\n  --> /tmp/tmpzkc_nhpj.rs:25:24\n   |\n25 |             q_reversed.pop();\n\
    \   |                        ^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0614]: type `Rev<std::slice::Iter<'_, isize>>` cannot be\
    \ dereferenced\n  --> /tmp/tmpzkc_nhpj.rs:28:5\n   |\n28 |     *q_reversed <=\
    \ max_weight\n   |     ^^^^^^^^^^^\n   |\nhelp: parentheses are required to parse\
    \ this as an expression\n   |\n18 ~     (while q_balanced {\n19 |         if *q_reversed\
    \ > max_weight {\n20 |             q_balanced = false;\n21 |         } else if\
    \ *q_reversed == max_weight {\n22 |             max_sum += *q_reversed;\n23 |\
    \             q_reversed.pop();\n ...\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n\
    \    let mut q_rev_sum = q_rev.fold(0, |sum, i| sum + i);\n    let mut max_weight\
    \ = q_rev.last().unwrap() + w;\n    q_rev_sum <= max_weight\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpywwe555e.rs:13:9\n\
    \   |\n13 |     let mut q_rev = q.iter().rev();\n   |         ----^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpywwe555e.rs:14:9\n\
    \   |\n14 |     let mut q_rev_sum = q_rev.fold(0, |sum, i| sum + i);\n   |   \
    \      ----^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\n\
    warning: variable does not need to be mutable\n  --> /tmp/tmpywwe555e.rs:15:9\n\
    \   |\n15 |     let mut max_weight = q_rev.last().unwrap() + w;\n   |        \
    \ ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\nerror[E0382]:\
    \ use of moved value: `q_rev`\n    --> /tmp/tmpywwe555e.rs:15:26\n     |\n13 \
    \  |     let mut q_rev = q.iter().rev();\n     |         --------- move occurs\
    \ because `q_rev` has type `Rev<std::slice::Iter<'_, isize>>`, which does not\
    \ implement the `Copy` trait\n14   |     let mut q_rev_sum = q_rev.fold(0, |sum,\
    \ i| sum + i);\n     |                               -------------------------\
    \ `q_rev` moved due to this method call\n15   |     let mut max_weight = q_rev.last().unwrap()\
    \ + w;\n     |                          ^^^^^ value used here after move\n   \
    \  |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q_rev`\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut b = false;\n  \
    \  let mut sum = 0;\n    for i in q.iter() {\n        sum += i;\n        if sum\
    \ < w {\n            b = true;\n            break;\n        }\n    }\n    b\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc3ud4qz6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    debug_assert_eq!(q.len(),\
    \ w.to_usize());\n    let mut total_weight = 0;\n    let mut max_weight = w;\n\
    \    let mut is_palindromic = false;\n\n    for v in q.iter() {\n        total_weight\
    \ += v;\n        if total_weight > max_weight {\n            max_weight = total_weight;\n\
    \        }\n        is_palindromic = is_palindromic && v == v.to_reverse();\n\
    \    }\n\n    !is_palindromic && total_weight <= max_weight\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_usize` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp5nr6yww_.rs:13:33\n   |\n13 |     debug_assert_eq!(q.len(),\
    \ w.to_usize());\n   |                                 ^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `to_reverse` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp5nr6yww_.rs:23:51\n   |\n23 | \
    \        is_palindromic = is_palindromic && v == v.to_reverse();\n   |       \
    \                                            ^^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if !is_palindrome(q) {\n\
    \        return false;\n    }\n    let mut sum: isize = 0;\n    for i in q.iter()\
    \ {\n        sum += i;\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6ta13ove.rs:13:9\n   |\n13 |     if !is_palindrome(q) {\n   |      \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut reverse = q.iter().rev();\n\
    \    let mut sum = 0;\n    while let Some(i) = reverse.next() {\n        sum +=\
    \ i;\n    }\n    return q.is_empty() || sum == w && q == q[..q.len() - 1];\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc3jvj0sk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut w = w;\n    for x in q.iter().rev() {\n        w = w - x;\n\
    \        if w < 0 {\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpb2ojhqok.rs:21:14\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n13  |     let mut sum = 0;\n14  |     for x in q {\n    |\
    \              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    21  |     for x in q.iter().rev() {\n    |              ^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\n    = note: borrow occurs due to deref coercion to\
    \ `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n14  |     for x in &q {\n    | \
    \             +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_owned();\n\
    \    q.sort_unstable();\n    let mut i = q;\n    let mut j = 0;\n    let mut max_weight\
    \ = w;\n    while i >= 1 {\n        if *i < *j {\n            if i < max_weight\
    \ {\n                i += 1;\n            }\n            else {\n            \
    \    return false;\n            }\n        }\n        else {\n            if max_weight\
    \ > 0 {\n                max_weight -= *i;\n            }\n            else {\n\
    \                return false;\n            }\n            i += 1;\n        }\n\
    \        j += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfo036q26.rs:18:16\n   |\n\
    18 |     while i >= 1 {\n   |                ^ expected struct `Vec`, found integer\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpfo036q26.rs:19:17\n\
    \   |\n19 |         if *i < *j {\n   |                 ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfo036q26.rs:20:20\n   |\n20 |             if i < max_weight\
    \ {\n   |                    ^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n\
    \  --> /tmp/tmpfo036q26.rs:21:17\n   |\n21 |                 i += 1;\n   |   \
    \              -^^^^^\n   |                 |\n   |                 cannot use\
    \ `+=` on type `Vec<isize>`\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpfo036q26.rs:29:28\n   |\n\
    29 |                 max_weight -= *i;\n   |                            ^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[isize]`\n\nerror[E0277]: cannot subtract-assign `[isize]`\
    \ from `isize`\n  --> /tmp/tmpfo036q26.rs:29:28\n   |\n29 |                 max_weight\
    \ -= *i;\n   |                            ^^ no implementation for `isize -= [isize]`\n\
    \   |\n   = help: the trait `SubAssign<[isize]>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n\
    \  --> /tmp/tmpfo036q26.rs:34:13\n   |\n34 |             i += 1;\n   |       \
    \      -^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut result = false;\n\
    \    match q.pop() {\n        None => return false,\n        Some(i) => {\n  \
    \          if let Some(j) = (q.pop()).cloned() {\n                q.push(j);\n\
    \                result = true;\n            }\n        }\n    };\n    match q.pop()\
    \ {\n        None => return true,\n        _ => false,\n    };\n    if q.len()\
    \ == 0 {\n        result = true;\n    }\n    result && q.len() <= w && will_it_fly(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<isize>` is not an iterator\n   --> /tmp/tmpuxpan7i7.rs:17:40\n\
    \    |\n17  |               if let Some(j) = (q.pop()).cloned() {\n    |     \
    \                                     ^^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuxpan7i7.rs:30:26\n\
    \   |\n30 |     result && q.len() <= w && will_it_fly(q, w)\n   |            \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    30 |     result && q.len() <= w.try_into().unwrap() && will_it_fly(q, w)\n   |\
    \                           ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 || w ==\
    \ 0 {\n        return true\n    }\n    let mut maximum = q.iter().sum::<isize>();\n\
    \    if maximum < w {\n        return false;\n    }\n\n    maximum -= w;\n   \
    \ match q.iter().rev().zip(q).all(|(v, u)| *u > v) {\n        true => return true,\n\
    \        false => return false,\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp0ggo51_l.rs:22:46\n\
    \   |\n22 |     match q.iter().rev().zip(q).all(|(v, u)| *u > v) {\n   |     \
    \                                         ^^\n\nwarning: unreachable expression\n\
    \  --> /tmp/tmp0ggo51_l.rs:26:5\n   |\n22 | /     match q.iter().rev().zip(q).all(|(v,\
    \ u)| *u > v) {\n23 | |         true => return true,\n24 | |         false =>\
    \ return false,\n25 | |     }\n   | |_____- any code following this `match` expression\
    \ is unreachable, as all arms diverge\n26 |       false\n   |       ^^^^^ unreachable\
    \ expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w.is_balanced() {\n\
    \        let mut sum = 0;\n        for v in q {\n            sum += v;\n     \
    \   }\n        sum <= w && is_palindromic_vec(q)\n    } else {\n        will_it_fly(q,\
    \ w)\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic_vec` in this scope\n\
    \  --> /tmp/tmpy67bou9o.rs:18:21\n   |\n18 |         sum <= w && is_palindromic_vec(q)\n\
    \   |                     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `is_balanced` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpy67bou9o.rs:13:10\n   |\n13 |     if w.is_balanced() {\n   |  \
    \        ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return false;\n    }\n\n    if q.len() == 1 {\n        return q[0] == 0;\n\
    \    }\n\n    if q.len() <= w {\n        return false;\n    }\n\n    let mut wsum\
    \ = q.iter().sum();\n\n    if wsum > w {\n        return false;\n    }\n\n   \
    \ if wsum == w {\n        // q must be a palindrome\n        let mut p = q.clone();\n\
    \        p.reverse();\n\n        if p.iter().zip(q.iter()).all(|(a, b)| a == b)\
    \ {\n            return true;\n        }\n    }\n\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkvio0vmi.rs:21:19\n   |\n\
    21 |     if q.len() <= w {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     if q.len() <= w.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= w {\n   \
    \     return true;\n    }\n    let mut s = q.len();\n    let mut sum = 0;\n  \
    \  loop {\n        if s <= w {\n            return false;\n        }\n       \
    \ sum += q[s - 1];\n        if sum < w {\n            break;\n        }\n    \
    \    s--;\n    }\n    let mut m = 0;\n    loop {\n        let m = m + (q[w - s])\
    \ * (q[w - s - 1]);\n        if m < w {\n            return true;\n        }\n\
    \        if m == w {\n            break;\n        }\n        s -= 1;\n    }\n\
    \    if m == w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp9p2egu0f.rs:26:12\n\
    \   |\n26 |         s--;\n   |            ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9p2egu0f.rs:13:19\n   |\n13 |     if q.len()\
    \ <= w {\n   |                   ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n13 |     if q.len() <= w.try_into().unwrap() {\n   |            \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9p2egu0f.rs:19:17\n\
    \   |\n19 |         if s <= w {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |         if s <= w.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9p2egu0f.rs:30:28\n   |\n30 |         let m = m + (q[w - s]) *\
    \ (q[w - s - 1]);\n   |                            ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmp9p2egu0f.rs:30:26\n\
    \   |\n30 |         let m = m + (q[w - s]) * (q[w - s - 1]);\n   |           \
    \               ^ no implementation for `isize - usize`\n   |\n   = help: the\
    \ trait `Sub<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9p2egu0f.rs:30:21\n  \
    \ |\n30 |         let m = m + (q[w - s]) * (q[w - s - 1]);\n   |             \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max: isize = 0;\n\
    \    for e in q {\n        if w == 0 {\n            return false;\n        }\n\
    \        max = std::cmp::max(max, w-e)\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3khtpj8n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet mut q = q.to_vec();\n\
    \tlet mut ans = false;\n\tq.sort_unstable();\n\twhile q.len() > 0 {\n\t\tlet w\
    \ = q.front();\n\t\tq.pop();\n\t\tif w > w {\n\t\t\tbreak;\n\t\t}\n\t\tans = true;\n\
    \t}\n\tans && q.iter().all(|&i| i / w <= isize as f64)\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpyu0udpws.rs:24:36\n\
    \   |\n24 |     ans && q.iter().all(|&i| i / w <= isize as f64)\n   |        \
    \                               ^^^^^ not a value\n\nerror[E0599]: no method named\
    \ `front` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpyu0udpws.rs:17:13\n\
    \   |\n17 |         let w = q.front();\n   |                   ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0423, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // If we are able to get\
    \ to maximum weight, no need to fly.\n    if q.len() == w {\n        return true;\n\
    \    }\n\n    // Check balanced w.\n    let mut bal = 0;\n    for i in q.iter().rev()\
    \ {\n        bal += i;\n        if bal >= w {\n            return false;\n   \
    \     }\n    }\n\n    // If we got here, the list is not balanced.\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ir2whp_.rs:14:19\n   |\n\
    14 |     if q.len() == w {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     if q.len() == w.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // TODO: \n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2m3v68n.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut max = w;\n\n    for x in q.iter().rev() {\n        if x + max > w\
    \ {\n            balanced = false;\n            break;\n        }\n        max\
    \ = max - x;\n        balanced = true;\n    }\n\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5wmw63jv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    match q.pop() {\n     \
    \   None => return false, 0,\n        Some(x) => x <= w && (x == q.len() || will_it_fly(q,\
    \ x-w)) && true,\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmp7fx0rd0b.rs:14:32\n   |\n\
    14 |         None => return false, 0,\n   |                                ^\n\
    \   |\nhelp: try adding parentheses to match on a tuple...\n   |\n14 ~       \
    \  None => return false, (0,\n15 ~         Some(x)) => x <= w && (x == q.len()\
    \ || will_it_fly(q, x-w)) && true,\n   |\nhelp: ...or a vertical bar to match\
    \ on multiple alternatives\n   |\n14 ~         None => return false, 0 |\n15 ~\
    \         Some(x) => x <= w && (x == q.len() || will_it_fly(q, x-w)) && true,\n\
    \   |\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Base case\n    if q.len()\
    \ == 0 {\n        return false;\n    }\n    // Recursive case\n    if q[0] ==\
    \ w {\n        return will_it_fly(q[1..], w);\n    }\n    // Check if we're beyond\
    \ the maximum\n    if q[0] == w || q[q.len() - 1] <= w {\n        return false;\n\
    \    }\n    // Check if the sum of all the numbers is less than the maximum\n\
    \    if q.iter().map(|&n| n).sum() >= w {\n        return false;\n    }\n    //\
    \ Otherwise, we have our answer\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpso2_clsm.rs:19:28\n   |\n\
    19 |         return will_it_fly(q[1..], w);\n   |                            ^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                     \
    \       |\n   |                            expected struct `Vec`, found slice\
    \ `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ slice `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight_so_far\
    \ = w;\n\n    for p in q.rbegin().rev() {\n        if p > max_weight_so_far {\n\
    \            max_weight_so_far = p;\n        }\n    }\n\n    let mut balancedness\
    \ = true;\n\n    for &qi in q.rbegin().rev() {\n        if qi > max_weight_so_far\
    \ {\n            balancedness = false;\n        }\n    }\n\n    balancedness &&\
    \ q.iter().sum::<isize>() <= w && max_weight_so_far <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rbegin` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpp72reqib.rs:15:16\n   |\n15 |     for p in\
    \ q.rbegin().rev() {\n   |                ^^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `rbegin` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpp72reqib.rs:23:18\n   |\n23 |     for &qi in q.rbegin().rev()\
    \ {\n   |                  ^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_reversed = q;\n\
    \    q_reversed.reverse();\n    \n    let mut sum_of_elements = 0;\n    \n   \
    \ for i in q_reversed {\n        sum_of_elements += i;\n        if sum_of_elements\
    \ > w {\n            return false;\n        }\n    }\n    \n    if sum_of_elements\
    \ <= w {\n        return true;\n    }\n    \n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfe98cc7e.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 {\n   \
    \     return false;\n    }\n    \n    let mut wsum = 0;\n    for &i in q.iter()\
    \ {\n        wsum += i;\n    }\n    \n    if wsum > w {\n        return false;\n\
    \    }\n    \n    let mut isalen = q.len() as isize;\n    for &i in q.iter() {\n\
    \        isalen = q.len() as isize;\n        if i < w {\n            wsum += i;\n\
    \            if wsum > w {\n                return false;\n            }\n   \
    \     }\n        \n        isalen /= 2;\n    }\n    \n    return true;\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz8cz4xbc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut qb = q.clone();\n\
    \    let mut w = w;\n    let mut sum = 0;\n    while qb.len() > 0 {\n        if\
    \ w == 0 {\n            return false;\n        }\n        let mut max_w = *qb.iter().max().unwrap();\n\
    \        qb.sort_by_key(|&i| {\n            sum += i;\n            sum\n     \
    \   })\n        .iter()\n        .for_each(|&i| {\n            if i < max_w {\n\
    \                w -= i;\n            }\n        });\n    }\n    w < 0\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpn926qbh9.rs:25:10\n   |\n25 |         .iter()\n   |   \
    \       ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() != 1 {\n   \
    \     return false;\n    }\n    \n    let mut n = &q[0];\n    \n    if n == q[q.len()\
    \ - 1] {\n        return false;\n    }\n    \n    for i in 0..=q.len() {\n   \
    \     if n == q[q.len() - i] {\n            return false;\n        }\n    }\n\
    \    \n    let mut sum = 0;\n    \n    for i in 0..=q.len() {\n        sum +=\
    \ q[i];\n    }\n    \n    if sum > w {\n        return false;\n    }\n    \n \
    \   true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmppvq180l7.rs:19:10\n\
    \   |\n19 |     if n == q[q.len() - 1] {\n   |          ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmppvq180l7.rs:24:14\n   |\n24 |         if n == q[q.len() - i] {\n   |\
    \              ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\
    \ // True if the list q is balanced w.\n    let mut sum = 0;\n\n    let mut max_weight\
    \ = 0;\n\n    for i in 0..q.len() - 1 {\n        let curr = q[i];\n\n        if\
    \ curr > max_weight {\n            max_weight = curr;\n        }\n\n        sum\
    \ += curr;\n    }\n\n    if balanced && (sum + w <= max_weight) {\n        //\
    \ The sum is less than or equal to the maximum weight\n        return true;\n\
    \    } else {\n        // The list q is not balanced w.\n        return false;\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8n8k1lo4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \n    for elem in q.iter().rev() {\n        if elem == elem {\n            balanced\
    \ = true;\n        }\n        else {\n            balanced = false;\n        \
    \    break;\n        }\n    }\n\n    if !balanced {\n        return false;\n \
    \   }\n\n    let mut s = q.iter().rev().fold(0, |acc, x| acc + x);\n\n    if s\
    \ >= w {\n        return true;\n    }\n    else {\n        return false;\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnnf4h71h.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Balance the list\n \
    \   let mut q = q.iter().cloned().collect::<Vec<_>>();\n    let mut max_sum =\
    \ w;\n    while q.len() > 1 {\n        // If it's balanced, find the max sum\n\
    \        let max_sum = q.iter().fold(0, |s, &x| s + x);\n        // Remove max\
    \ sum from list\n        q.pop();\n        // If it's balanced, check the remaining\
    \ sum\n        if q.len() == 1 {\n            return max_sum >= w;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0i8a43e6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Check to see if the\
    \ object is balanced.\n    let mut sum = 0;\n    let mut i = 0;\n    while i <\
    \ q.len() {\n        sum += q[i];\n        if sum < w {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnzsh2m80.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    fn helper(v: Vec<isize>)\
    \ -> bool {\n        let mut max = 0;\n        let mut sum = 0;\n\n        for\
    \ i in v.iter().rev() {\n            if max < i {\n                max = i;\n\
    \            }\n\n            sum += i;\n        }\n\n        sum == w && v.reverse().iter().all(|i|\
    \ i <= max)\n    }\n\n    will_it_fly_r(&q, w, &helper)\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpdugixm8l.rs:25:16\n\
    \   |\n25 |         sum == w && v.reverse().iter().all(|i| i <= max)\n   |   \
    \             ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\n\
    error[E0425]: cannot find function `will_it_fly_r` in this scope\n  --> /tmp/tmpdugixm8l.rs:28:5\n\
    \   |\n28 |     will_it_fly_r(&q, w, &helper)\n   |     ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdugixm8l.rs:19:23\n\
    \   |\n14 |         let mut max = 0;\n   |                       - expected due\
    \ to this value\n...\n19 |                 max = i;\n   |                    \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |                 max = *i;\n   |                       +\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpdugixm8l.rs:18:20\n\
    \   |\n18 |             if max < i {\n   |                    ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `iter`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpdugixm8l.rs:25:33\n\
    \   |\n25 |         sum == w && v.reverse().iter().all(|i| i <= max)\n   |   \
    \                              ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425, E0434, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Return True if we balance\
    \ the list, and it's possible to fly.\n    let mut balanced = true;\n    let mut\
    \ sum = 0;\n    for element in q.iter() {\n        // The next iteration will\
    \ fly.\n        balanced = true;\n        sum += element;\n    }\n    balanced\
    \ = sum <= w;\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprvuefsw_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Write your solution\
    \ here\n    if q.len() == 0 || w == 0 {\n        return false;\n    }\n    \n\
    \    let mut max = 0;\n    let mut cnt = 0;\n    let mut last = q.len()-1;\n \
    \   \n    while cnt <= last/2 && cnt < w {\n        if q[cnt] != last {\n    \
    \        max = 0;\n        }\n        \n        max += q[cnt];\n        cnt +=\
    \ 1;\n    }\n    \n    if max == w {\n        return true;\n    }\n    \n    max\
    \ = 0;\n    cnt = 0;\n    \n    while cnt < last/2 {\n        if q[cnt] != last\
    \ {\n            max = 0;\n        }\n        \n        max += q[cnt];\n     \
    \   cnt += 1;\n    }\n    \n    if cnt > last/2 {\n        return false;\n   \
    \ }\n    \n    let mut cnt2 = 0;\n    let mut max2 = 0;\n    \n    while cnt <\
    \ last/2 && cnt < w {\n        if q[cnt] != last {\n            max2 = 0;\n  \
    \      }\n        \n        max2 += q[cnt];\n        cnt += 1;\n    }\n    \n\
    \    if max2 == w {\n        return true;\n    }\n    \n    max2 = 0;\n    cnt\
    \ = 0;\n    \n    while cnt < last/2 {\n        if q[cnt] != last {\n        \
    \    max2 = 0;\n        }\n        \n        max2 += q[cnt];\n        cnt += 1;\n\
    \    }\n    \n    if max2 < w {\n        return false;\n    }\n    \n    \n  \
    \  \n    \n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxg_1kiq6.rs:22:34\n   |\n\
    22 |     while cnt <= last/2 && cnt < w {\n   |                              \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n22 |     while\
    \ cnt <= last/2 && cnt < w.try_into().unwrap() {\n   |                       \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxg_1kiq6.rs:23:22\n\
    \   |\n23 |         if q[cnt] != last {\n   |                      ^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |         if q[cnt] !=\
    \ last.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxg_1kiq6.rs:39:22\n   |\n39 |\
    \         if q[cnt] != last {\n   |                      ^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n39 |         if q[cnt] != last.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxg_1kiq6.rs:54:33\n   |\n54 |     while cnt < last/2 &&\
    \ cnt < w {\n   |                                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n54 |     while cnt < last/2 && cnt < w.try_into().unwrap()\
    \ {\n   |                                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxg_1kiq6.rs:55:22\n   |\n55 |         if q[cnt]\
    \ != last {\n   |                      ^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n55 |         if q[cnt] != last.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxg_1kiq6.rs:71:22\n   |\n71 |         if q[cnt] != last\
    \ {\n   |                      ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return false;\n    }\n\n    let mut q = q.clone();\n\n    q.sort_unstable();\n\
    \n    if q[0] % 2 == 0 {\n        q.push(q[0]);\n    }\n\n    if q.len() > w {\n\
    \        return false;\n    }\n\n    let mut total = 0;\n    total = (total +\
    \ &q[..q.len() - 1] + &q[q.len() - 1]) / 2;\n\n    if total <= w {\n        return\
    \ false;\n    }\n\n    q.sort_unstable();\n\n    for i in 0..q.len() {\n     \
    \   if q[i] % 2 == 0 {\n            continue;\n        }\n\n        let mut j\
    \ = 0;\n        let mut last = 0;\n\n        while j < q.len() && last + 1 ==\
    \ q[j].to_isize() {\n            last += 1;\n            j += 1\n        }\n\n\
    \        if j == q.len() {\n            return true;\n        }\n\n        if\
    \ j == 0 {\n            total += q[j].to_isize() - last;\n        }\n\n      \
    \  total += (q[j - 1] + q[j + 1] + last) / 2;\n    }\n\n    total <= w\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8jx2h3y.rs:25:18\n   |\n\
    25 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0277]: cannot add `&[isize]`\
    \ to `{integer}`\n  --> /tmp/tmpq8jx2h3y.rs:30:20\n   |\n30 |     total = (total\
    \ + &q[..q.len() - 1] + &q[q.len() - 1]) / 2;\n   |                    ^ no implementation\
    \ for `{integer} + &[isize]`\n   |\n   = help: the trait `Add<&[isize]>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0599]: no method named `to_isize` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpq8jx2h3y.rs:46:47\n   |\n46\
    \ |         while j < q.len() && last + 1 == q[j].to_isize() {\n   |         \
    \                                      ^^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `to_isize` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpq8jx2h3y.rs:56:27\n   |\n56 |             total += q[j].to_isize()\
    \ - last;\n   |                           ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    match is_palindromic(&q[..q.len()\
    \ - 1]) {\n        true => { \n            if q.iter().take(qlen()).sum::<isize>()\
    \ <= w {\n                true\n            } else {\n                false\n\
    \            }\n        },\n        false => { \n            if q.iter().take(qlen()).sum::<isize>()\
    \ <= w {\n                true\n            } else {\n                false\n\
    \            }\n        },\n        _ => { \n            if q.iter().take(qlen()).sum::<isize>()\
    \ <= w {\n                true\n            } else {\n                false\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp2z7xuuei.rs:13:11\n   |\n13 |     match is_palindromic(&q[..q.len()\
    \ - 1]) {\n   |           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `qlen` in this scope\n  --> /tmp/tmp2z7xuuei.rs:15:30\n\
    \   |\n15 |             if q.iter().take(qlen()).sum::<isize>() <= w {\n   | \
    \                             ^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `qlen` in this scope\n  --> /tmp/tmp2z7xuuei.rs:22:30\n   |\n\
    22 |             if q.iter().take(qlen()).sum::<isize>() <= w {\n   |        \
    \                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `qlen` in this scope\n  --> /tmp/tmp2z7xuuei.rs:29:30\n   |\n29 | \
    \            if q.iter().take(qlen()).sum::<isize>() <= w {\n   |            \
    \                  ^^^^ not found in this scope\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q1 = q.clone();\n\
    \    loop {\n        if q1.len() > 0 && (q1[0] % w).is_positive() {\n        \
    \    return false;\n        }\n        let last = q1.pop().unwrap();\n       \
    \ if last == 0 {\n            return true;\n        }\n        let mut q2 = q.clone();\n\
    \        q2.remove(last);\n        if q2.len() > 0 && (q2[0] % w).is_positive()\
    \ {\n            q1[0] = last;\n            break;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpptqs8qeg.rs:23:19\n   |\n\
    23 |         q2.remove(last);\n   |                   ^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |         q2.remove(last.try_into().unwrap());\n\
    \   |                       ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let max_possible_weight\
    \ = w + 1;\n    let mut is_palindromic = true;\n    let mut sum = 0;\n    for\
    \ (index, element) in q.iter().enumerate() {\n        sum += element;\n      \
    \  if sum > max_possible_weight {\n            is_palindromic = false;\n     \
    \       break;\n        }\n    }\n    \n    if is_palindromic && sum == max_possible_weight\
    \ {\n        return true;\n    }\n    else if is_palindromic && sum < max_possible_weight\
    \ {\n        return false;\n    }\n    else {\n        return false;\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_vv2hsry.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return false;\n    }\n\n    let mut will_it_fly = true;\n\n    for j in\
    \ (0..q.len()).rev() {\n        if q[j] != q[j].rev() {\n            will_it_fly\
    \ = false;\n            break;\n        }\n    }\n\n    will_it_fly && (q.iter().sum()\
    \ <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmpzvwj7l_j.rs:20:25\n\
    \   |\n20 |         if q[j] != q[j].rev() {\n   |                         ^^^\
    \ `isize` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `isize: Iterator`\n           which is required by\
    \ `&mut isize: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Your code here\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeehser6w.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balance = true;\n\
    \    let mut wq = q.clone();\n    let mut max_possible = w + 1;\n    loop {\n\
    \        match wq.pop() {\n            None => false,\n            Some(w) =>\
    \ balance = w >= max_possible,\n        }\n        if balance { break; }\n   \
    \     match wq.pop() {\n            None => balance = false,\n            Some(w)\
    \ => balance = w >= max_possible,\n        }\n        max_possible += 1;\n   \
    \ }\n    balance\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp59ng7xl4.rs:19:24\n\
    \   |\n17 | /         match wq.pop() {\n18 | |             None => false,\n  \
    \ | |                     ----- this is found to be of type `bool`\n19 | |   \
    \          Some(w) => balance = w >= max_possible,\n   | |                   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n20 | |        \
    \ }\n   | |_________- `match` arms have incompatible types\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ &i in q {\n        sum += i;\n    }\n    return sum < w && is_palindromic(q)\
    \ && sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpn3jxe0j9.rs:17:23\n   |\n17 |     return sum < w && is_palindromic(q)\
    \ && sum == w\n   |                       ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn3jxe0j9.rs:14:9\n   |\n14 | \
    \    for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    \n    // Base cases\n \
    \   if q.len() == 0 {\n        return true;\n    } else if q.len() == 1 {\n  \
    \      if q.iter().cloned().collect::<Vec<_>>() == q {\n            return true;\n\
    \        }\n    }\n    // The algorithm works as follows: We need to find the\
    \ largest sum such that w-sum < w.\n    // We are looking for an i such that w-(sum(q[i..])\
    \ < w\n\n    // Calculate the sum of q.\n    // If q is unbalanced, this sum will\
    \ be non-terminating.\n    let mut sum = 0;\n    for (i, c) in q.iter().enumerate()\
    \ {\n        sum += c;\n    }\n    if sum == w {\n        return true;\n    }\n\
    \n    // Calculate the maximum possible weight of any balanced list.\n    let\
    \ max_weight = w;\n    let mut max_sum_so_far = 0;\n    // The goal is to find\
    \ the sum of q[i..j] such that w-(sum(q[i..j] < w\n    for (i, c) in q.iter().cloned().enumerate()\
    \ {\n        sum += c;\n        if sum > max_sum_so_far {\n            max_sum_so_far\
    \ = sum;\n            max_weight = w-(sum);\n        }\n    }\n\n    // If we\
    \ are left with a weight larger than our max weight, we can't solve the problem\
    \ and should return false.\n    if max_weight > w {\n        return false;\n \
    \   }\n\n    // We have found a solution. Now we simply need to check whether\
    \ sum is equal to the weight - max_weight.\n    // If it is, we return true.\n\
    \    if sum == max_weight {\n        return true;\n    }\n\n    // If we made\
    \ it here, we didn't find a solution. Return false.\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpms9uos2h.rs:28:10\n   |\n\
    28 |     for (i, c) in q.iter().enumerate() {\n   |          ^ help: if this is\
    \ intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `i`\n  --> /tmp/tmpms9uos2h.rs:39:10\n\
    \   |\n39 |     for (i, c) in q.iter().cloned().enumerate() {\n   |          ^\
    \ help: if this is intentional, prefix it with an underscore: `_i`\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `max_weight`\n  --> /tmp/tmpms9uos2h.rs:43:13\n\
    \   |\n36 |     let max_weight = w;\n   |         ----------\n   |         |\n\
    \   |         first assignment to `max_weight`\n   |         help: consider making\
    \ this binding mutable: `mut max_weight`\n...\n43 |             max_weight = w-(sum);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().rev().fold(true,\
    \ |acc, x| {\n        if acc && x <= w {\n            false\n        } else {\n\
    \            true\n        }\n    })\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbeax_xy.rs:14:24\n   |\n\
    14 |         if acc && x <= w {\n   |                        ^\n   |         \
    \               |\n   |                        expected `&isize`, found `isize`\n\
    \   |                        help: consider borrowing here: `&w`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut min_weight: isize\
    \ = 0;\n    let mut is_balanced = false;\n    let mut i = q.len() - 1;\n    let\
    \ mut j = q.len() - 1;\n    let mut total = 0;\n    while i >= 0 || j >= 0 {\n\
    \        if i >= 0 && j >= 0 && q[i] == q[j] {\n            total += q[i];\n \
    \           i -= 1;\n            j -= 1;\n        }\n        else if i >= 0 {\n\
    \            total += q[i];\n            i -= 1;\n        }\n        else if j\
    \ >= 0 {\n            total += q[j];\n            j -= 1;\n        }\n       \
    \ if total >= w {\n            min_weight = total;\n            is_balanced =\
    \ true;\n            break;\n        }\n    }\n    \n    return is_balanced &&\
    \ min_weight <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjfv8aib0.rs:21:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut max = 0;\n    for &x in q {\n        max = std::cmp::max(max, x);\n\
    \        if *x == *q.rbegin() {\n            balanced = true;\n        }\n   \
    \ }\n    balanced && max <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyall_4ij.rs:15:9\n   |\n\
    15 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpyall_4ij.rs:17:12\n   |\n17 |        \
    \ if *x == *q.rbegin() {\n   |            ^^\n\nerror[E0599]: no method named\
    \ `rbegin` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpyall_4ij.rs:17:21\n\
    \   |\n17 |         if *x == *q.rbegin() {\n   |                     ^^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if !q.is_balanced() ||\
    \ q.is_empty() {\n        return false;\n    }\n    let mut total: isize = 0;\n\
    \    for x in q {\n        total += x;\n    }\n    total <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_balanced` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp7mzhw6v7.rs:13:11\n   |\n13 |     if !q.is_balanced()\
    \ || q.is_empty() {\n   |           ^^^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if !is_balanced(q) {\n\
    \        return false;\n    }\n    q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpgjgf6ped.rs:13:9\n\
    \   |\n13 |     if !is_balanced(q) {\n   |         ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    debug_assert!(q.is_palindromic());\n\
    \    debug_assert!(q.len() <= w);\n    let mut sum = 0;\n    for &i in q {\n \
    \       sum += i;\n    }\n    sum < w || sum == w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_palindromic` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp9d5cbbks.rs:13:21\n   |\n13 |     debug_assert!(q.is_palindromic());\n\
    \   |                     ^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9d5cbbks.rs:14:30\n   |\n14 |  \
    \   debug_assert!(q.len() <= w);\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |     debug_assert!(q.len()\
    \ <= w.try_into().unwrap());\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9d5cbbks.rs:16:9\n   |\n16 | \
    \    for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    let\
    \ mut max_w = 0;\n\n    for i in 0..n {\n        let w_i = q[i];\n\n        if\
    \ w_i > max_w {\n            max_w = w_i;\n        }\n    }\n\n    if n == 0 {\n\
    \        return true;\n    }\n\n    let mut w = 0;\n    let mut i = 0;\n\n   \
    \ while i < n {\n        w += q[i];\n        if w > w {\n            break;\n\
    \        }\n        i += 1;\n    }\n\n    for i in 0..(n - i) {\n        if q[i]\
    \ != w {\n            return false;\n        }\n    }\n\n    return true;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr0qq6xhi.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut bal = 0;\n\n    for x in q {\n        sum += x;\n        bal += 1;\n\n \
    \       if sum > w {\n            sum -= x;\n            bal -= 1;\n        }\n\
    \    }\n\n    (bal == 0 && sum == w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbp5eux_4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut wsum = 0isize;\n\
    \    for v in q.iter() {\n        wsum += v;\n    }\n    w == wsum\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3dq7wydh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 || w ==\
    \ 0 {\n        return false;\n    }\n    let mut sum_so_far = 0;\n    for x in\
    \ q {\n        if x >= w {\n            return false;\n        }\n        sum_so_far\
    \ += x;\n    }\n    sum_so_far <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqgvghzy5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = w.into();\n\
    \    q.reverse().for_each(|x|{\n        if x % 2 == 0 {\n            max -= x;\n\
    \        }\n        else {\n            max += x;\n        }\n    });\n    let\
    \ mut is_balanced = false;\n    for x in q {\n        if x >= max {\n        \
    \    is_balanced = true;\n            break;\n        }\n    }\n    is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpx0q0_zh9.rs:14:17\n\
    \   |\n14 |     q.reverse().for_each(|x|{\n   |                 ^^^^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut f = true.into();\n\
    \    let mut t = true;\n    for w in q.reverse() {\n        t &= ((q.pop() ==\
    \ w) && (f && (q.is_empty()) || (q.is_empty() && q.is_full())));\n    }\n    f\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpd0d868r5.rs:16:14\n\
    \   |\n16 |         t &= ((q.pop() == w) && (f && (q.is_empty()) || (q.is_empty()\
    \ && q.is_full())));\n   |              ^                                    \
    \                                    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -         t &= ((q.pop()\
    \ == w) && (f && (q.is_empty()) || (q.is_empty() && q.is_full())));\n16 +    \
    \     t &= (q.pop() == w) && (f && (q.is_empty()) || (q.is_empty() && q.is_full()));\n\
    \   | \n\nerror[E0277]: `()` is not an iterator\n  --> /tmp/tmpd0d868r5.rs:15:14\n\
    \   |\n15 |     for w in q.reverse() {\n   |              ^^^^^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `()`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `()`\n\nerror[E0599]: no method named `is_full` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpd0d868r5.rs:16:76\n   |\n16 |         t\
    \ &= ((q.pop() == w) && (f && (q.is_empty()) || (q.is_empty() && q.is_full())));\n\
    \   |                                                                        \
    \    ^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0277,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return false;\n    }\n\n    // We want to balance the list as much as we\
    \ can.\n    let mut best_sum = w;\n    let mut best_vec = q;\n\n    // We need\
    \ to find out the minimum element of q.\n    let mut min_element = q[0];\n\n \
    \   // We need to find the minimum element of q.\n    for (i, &e) in q.iter().enumerate()\
    \ {\n        if e < min_element {\n            min_element = e;\n        }\n \
    \   }\n\n    // We need to find the maximum possible sum of elements.\n    for\
    \ (i, &e) in q.iter().enumerate() {\n        best_sum += e;\n    }\n\n    // We\
    \ need to check if a palindrome list with sum < the maximum possible weight.\n\
    \    for &e in q.iter().rev() {\n        if e < best_sum {\n            return\
    \ false;\n        }\n    }\n\n    // We need to check if a palindrome list with\
    \ sum >= the maximum possible weight.\n    for &e in q.iter() {\n        if e\
    \ >= best_sum {\n            return true;\n        }\n    }\n\n    // If all are\
    \ balanced and sum > w then we can fly.\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `best_vec`\n  --> /tmp/tmp_ief6zs5.rs:19:13\n\
    \   |\n19 |     let mut best_vec = q;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_best_vec`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `i`\n\
    \  --> /tmp/tmp_ief6zs5.rs:25:10\n   |\n25 |     for (i, &e) in q.iter().enumerate()\
    \ {\n   |          ^ help: if this is intentional, prefix it with an underscore:\
    \ `_i`\n\nwarning: unused variable: `i`\n  --> /tmp/tmp_ief6zs5.rs:32:10\n   |\n\
    32 |     for (i, &e) in q.iter().enumerate() {\n   |          ^ help: if this\
    \ is intentional, prefix it with an underscore: `_i`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmp_ief6zs5.rs:19:9\n   |\n19 |     let mut\
    \ best_vec = q;\n   |         ----^^^^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\n\
    error[E0382]: borrow of moved value: `q`\n  --> /tmp/tmp_ief6zs5.rs:22:27\n  \
    \ |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |            \
    \    - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n19 |     let mut best_vec = q;\n   |                \
    \        - value moved here\n...\n22 |     let mut min_element = q[0];\n   | \
    \                          ^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error; 4 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().all(|&x| x >=\
    \ w) && is_balanced(q.iter().cloned()) && q.iter().sum() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpz4sg7l7n.rs:13:34\n\
    \   |\n13 |     q.iter().all(|&x| x >= w) && is_balanced(q.iter().cloned()) &&\
    \ q.iter().sum() <= w\n   |                                  ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut ans = false;\n\n\
    \    let mut current_weight = q[0];\n    let mut current_sum = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_reversed_q: Vec<isize> = q.iter().cloned().rev();\n\
    \n    for &current_sum in current_reversed_q.iter() {\n        if current_sum\
    \ == w {\n            ans = true;\n            break;\n        } else if current_sum\
    \ > w {\n            break;\n        }\n\n        let current_current_weight =\
    \ current_weight;\n        let current_current_sum = current_sum;\n        let\
    \ current_current_pos = current_pos;\n\n        while current_current_pos < q.len()\
    \ {\n            current_sum += q[current_current_pos];\n            if current_sum\
    \ > w {\n                break;\n            } else if current_sum == w {\n  \
    \              current_sum += q[current_current_pos];\n                current_weight\
    \ = current_current_weight;\n                current_pos = current_current_pos;\n\
    \                break;\n            } else {\n                current_sum +=\
    \ q[current_current_pos];\n                current_current_weight++;\n       \
    \         current_pos++;\n            }\n        }\n    }\n\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd5o34l64.rs:43:39\n\
    \   |\n43 |                 current_current_weight++;\n   |                  \
    \                     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n43 |                 { let tmp = current_current_weight; current_current_weight\
    \ += 1; tmp };\n   |                 +++++++++++                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    43 -                 current_current_weight++;\n43 +                 current_current_weight\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd5o34l64.rs:18:46\n\
    \   |\n18 |     let mut current_reversed_q: Vec<isize> = q.iter().cloned().rev();\n\
    \   |                                 ----------   ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Rev`\n   |                                 |\n \
    \  |                                 expected due to this\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced: bool\
    \ = true;\n    let mut sum_q: isize = 0;\n    for i in q {\n        sum_q += i;\n\
    \        if sum_q > w {\n            balanced = false;\n            break;\n \
    \       }\n    }\n    !balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi4zhgg9o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.palindromic_sum().is_less_than_or_equal_to(w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `palindromic_sum` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpbv2rc01g.rs:13:7\n   |\n13 |     q.palindromic_sum().is_less_than_or_equal_to(w)\n\
    \   |       ^^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return false;\n    }\n    let mut i = q.len() - 1;\n    let mut j = 0;\n\
    \    let mut sum = 0;\n    while i >= 0 {\n        sum += q[i];\n        j +=\
    \ 1;\n        if sum >= w {\n            i -= 1;\n        } else {\n         \
    \   break;\n        }\n    }\n    if i == q.len() - 1 {\n        return sum ==\
    \ w;\n    }\n    else if sum > w {\n        return false;\n    }\n    else {\n\
    \        let mut j = 0;\n        while j < q.len() - 1 {\n            sum += q[j\
    \ + 1];\n            j += 1;\n            if sum >= w {\n                break;\n\
    \            }\n        }\n        return sum == w;\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj0rn0rjc.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    match w {\n        0 =>\
    \ false,\n        _ => {\n            let mut max_sum = 0;\n            let mut\
    \ is_balanced = true;\n            for el in q {\n                if el != q.len()\
    \ - 1 {\n                    max_sum += el;\n                } else {\n      \
    \              is_balanced = false;\n                }\n            }\n      \
    \      if max_sum == w && is_balanced {\n                true\n            } else\
    \ {\n                false\n            }\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo3_zye2.rs:19:26\n   |\n\
    19 |                 if el != q.len() - 1 {\n   |                          ^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |           \
    \      if el != (q.len() - 1).try_into().unwrap() {\n   |                    \
    \      +           +++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut rev = q.reverse();\n    let mut sum = 0;\n    while !rev.is_empty()\
    \ {\n        sum += rev.remove(0);\n        if sum >= max_weight {\n         \
    \   return true;\n        }\n        max_weight -= 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpnotqqfvx.rs:16:16\n   |\n16 |     while !rev.is_empty()\
    \ {\n   |                ^^^^^^^^ method not found in `()`\n\nerror[E0599]: no\
    \ method named `remove` found for unit type `()` in the current scope\n  --> /tmp/tmpnotqqfvx.rs:17:20\n\
    \   |\n17 |         sum += rev.remove(0);\n   |                    ^^^^^^ method\
    \ not found in `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut l = q.len();\n\
    \    let mut r = 0;\n    let mut q2 = q.clone();\n    let mut r = q2.len();\n\
    \    while l > 0 {\n        if r == 0 {\n            r = q2.len() - 1;\n     \
    \   }\n        let mut found = false;\n        if q2[r] != 0 {\n            if\
    \ q2[r] == q2[r - 1] {\n                r -= 1;\n            } else {\n      \
    \          r -= 1;\n                found = true;\n            }\n        }\n\
    \        if r < q2.len() - 1 {\n            if q2[r] < q2[r + 1] {\n         \
    \       r += 1;\n            } else {\n                r += 1;\n             \
    \   found = true;\n            }\n        }\n        l -= 1;\n        if found\
    \ {\n            break;\n        }\n    }\n    let mut j = 0;\n    let mut c =\
    \ 0;\n    for v in q {\n        c += v;\n        j += 1;\n        if j >= w {\n\
    \            return true;\n        }\n    }\n    if q2.len() <= w {\n        return\
    \ false;\n    }\n    let mut r = q2.len();\n    let mut i = 0;\n    for v in q2\
    \ {\n        i += v;\n        j -= 1;\n        if j < 0 {\n            return\
    \ false;\n        }\n        if i >= w {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6rwqaft.rs:52:20\n   |\n\
    52 |     if q2.len() <= w {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n52 |     if q2.len() <= w.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < w {\n    \
    \    return false\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n    \
    \    sum += i;\n    }\n    sum < w && sum == q.iter().rev().fold(0, |x, y| x +\
    \ y);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt6r8mfjl.rs:13:18\n   |\n\
    13 |     if q.len() < w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     if q.len() < w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpt6r8mfjl.rs:12:44\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |    -----------                             ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n20 |     sum < w && sum == q.iter().rev().fold(0,\
    \ |x, y| x + y);\n   |                                                       \
    \    - help: remove this semicolon\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.sort_unstable();\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n    }\n    return\
    \ sum <= w && is_palindrome(q);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmporr8kiuq.rs:18:24\n   |\n18 |     return sum <= w && is_palindrome(q);\n\
    \   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ `()` is not an iterator\n  --> /tmp/tmporr8kiuq.rs:15:15\n   |\n15 |     for\
    \ &i in q {\n   |               ^ `()` is not an iterator\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `()`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return false\n    }\n    let mut sum_q = 0_isize;\n    for i in q.iter()\
    \ {\n        sum_q += i;\n    }\n    if sum_q <= w {\n        return true;\n \
    \   }\n    if will_it_fly(q.rev(), w) {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpk_mymm7r.rs:23:22\n\
    \    |\n23  |       if will_it_fly(q.rev(), w) {\n    |                      \
    \  ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n    let mut q0: Vec<isize> = q.clone();\n    let mut\
    \ w0 = w;\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum = 0;\n    loop\
    \ {\n        if i > q0.len() - 1 {\n            return false;\n        }\n   \
    \     if w0 > q0[i] {\n            w0 -= q0[i];\n            q0.swap(i, j);\n\
    \        } else {\n            q0.swap(i, j);\n            sum += q0[i];\n   \
    \         j++;\n        }\n        i += 1;\n    }\n    let w1 = w0 + sum;\n  \
    \  if w1 < w {\n        return false;\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgacypbmn.rs:31:14\n\
    \   |\n31 |             j++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n31 |             { let tmp = j; j += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n31 -             j++;\n\
    31 +             j += 1;\n   | \n\nwarning: unreachable statement\n  --> /tmp/tmpgacypbmn.rs:35:5\n\
    \   |\n21 | /     loop {\n22 | |         if i > q0.len() - 1 {\n23 | |       \
    \      return false;\n24 | |         }\n...  |\n33 | |         i += 1;\n34 | |\
    \     }\n   | |_____- any code following this expression is unreachable\n35 |\
    \       let w1 = w0 + sum;\n   |       ^^^^^^^^^^^^^^^^^^ unreachable statement\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q {\n        sum += i;\n    }\n\n    if sum >= w {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmperhm9m_6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut palindromes = Vec::new();\n\
    \    let mut sum = q.iter().sum();\n    while sum < w {\n        palindromes.push(palindrom(&q,\
    \ sum));\n        sum += q.iter().sum();\n    }\n    let mut max = 0;\n    palindromes.iter().for_each(|palindrome|\
    \ {\n        max = max if palindrome == palindromes[palindromes.len() - 1];\n\
    \    });\n    max <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpwzzkut3z.rs:21:19\n   |\n21 |         max\
    \ = max if palindrome == palindromes[palindromes.len() - 1];\n   |           \
    \        ^^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find function\
    \ `palindrom` in this scope\n  --> /tmp/tmpwzzkut3z.rs:16:26\n   |\n16 |     \
    \    palindromes.push(palindrom(&q, sum));\n   |                          ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `palindromes`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet mut l = q;\n\tlet mut\
    \ r = q;\n\tlet mut i = q.len();\n\tlet mut n = q;\n\n\twhile i >= 1 {\n\t\tlet\
    \ (mut a, mut b) = (l[0], r[0]);\n\t\twhile i >= 2 && a != b {\n\t\t\tlet (mut\
    \ a, mut b) = (l[i - 1], r[i - 1]);\n\t\t\ti -= 1;\n\t\t}\n\t\tif i == 1 {\n\t\
    \t\treturn a == b;\n\t\t}\n\t\tl += 1;\n\t\tr += 1;\n\t\ti -= 1;\n\t}\n\n\ttrue\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmp3efwbpr2.rs:27:3\n   |\n27 |         l += 1;\n \
    \  |         -^^^^^\n   |         |\n   |         cannot use `+=` on type `Vec<isize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<isize>`\n\
    \  --> /tmp/tmp3efwbpr2.rs:28:3\n   |\n28 |         r += 1;\n   |         -^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut fly_flag = false;\n\
    \    let mut sum_weight = 0;\n    for i in 0..q.len() {\n        let mut curr_weight\
    \ = q.len() - i;\n        while curr_weight != 0 {\n            sum_weight +=\
    \ curr_weight % 10;\n            curr_weight /= 10;\n        }\n        if sum_weight\
    \ <= w {\n            fly_flag = true;\n            break;\n        }\n    }\n\
    \    fly_flag\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu4dseifr.rs:21:26\n   |\n\
    21 |         if sum_weight <= w {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if sum_weight <= w.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.sort_unstable();\n  \
    \  let mut max: isize = 0;\n    for element in q.iter() {\n        max = max.max(element);\n\
    \    }\n    max <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdedaqjac.rs:16:23\n   |\n\
    16 |         max = max.max(element);\n   |                       ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |         max = max.max(*element);\n   |                       +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut i = 0;\n\n    while i < q.len() - 1 {\n        if q[i..].iter().sum::<isize>()\
    \ <= w {\n            i += 1;\n        } else {\n            balanced = false;\n\
    \            break;\n        }\n    }\n\n    balancing(balanced, w, q, i);\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `balancing` in this scope\n  --> /tmp/tmpj3chlfzl.rs:25:5\n\
    \   |\n25 |     balancing(balanced, w, q, i);\n   |     ^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `balanced`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj3chlfzl.rs:12:44\n   |\n12 | fn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n   |    -----------                             ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut balanced = false;\n    let mut max_weight = 0;\n    for i in q.iter() {\n\
    \        if i % 2 == 1 {\n            sum += i;\n            if sum > max_weight\
    \ {\n                max_weight = sum;\n            }\n        } else if i % 2\
    \ == 0 {\n            sum += i;\n            if sum >= w {\n                balanced\
    \ = true;\n            }\n        }\n    }\n    balanced && sum <= w && max_weight\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoqjqbclz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 {\n   \
    \     true\n    } else {\n        if will_it_fly(q, w - q[q.len() - 1]) {\n  \
    \          true\n        } else {\n            false\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n  --> /tmp/tmpiunk1jjw.rs:16:31\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |          \
    \      - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16 |         if will_it_fly(q, w - q[q.len() - 1]) {\n\
    \   |                        -      ^ value borrowed here after move\n   |   \
    \                     |\n   |                        value moved here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.rev().reverse().iter().all(|&x|\
    \ x <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpk_4bmbbj.rs:13:7\n\
    \    |\n13  |       q.rev().reverse().iter().all(|&x| x <= w)\n    |         ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 0 {\n   \
    \     return false\n    }\n    let mut balanced_palindrome = is_balanced_palindrome(q);\n\
    \    if balanced_palindrome {\n        if w <= q.sum() {\n            return false\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced_palindrome` in this scope\n\
    \  --> /tmp/tmptxgt95fc.rs:16:35\n   |\n16 |     let mut balanced_palindrome =\
    \ is_balanced_palindrome(q);\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: `Vec<isize>` is not an iterator\n \
    \  --> /tmp/tmptxgt95fc.rs:18:19\n    |\n18  |           if w <= q.sum() {\n \
    \   |                     ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut pal_sum = w;\n\
    \    let mut balanced = false;\n    for x in q.iter() {\n        let y = q\n \
    \           .iter()\n            .map(|&i| {\n                if i == x {\n  \
    \                  return true;\n                }\n                else {\n \
    \                   return false;\n                }\n            })\n       \
    \     .collect::<bool>();\n        if !y.any() {\n            pal_sum -= x;\n\
    \        }\n        balanced = balanced || y;\n        if pal_sum < w {\n    \
    \        pal_sum += x;\n        }\n    }\n    balanced\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpot13umlw.rs:19:25\n   |\n\
    19 |                 if i == x {\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \               if i == *x {\n   |                         +\n\nerror[E0277]:\
    \ a value of type `bool` cannot be built from an iterator over elements of type\
    \ `bool`\n    --> /tmp/tmpot13umlw.rs:26:14\n     |\n26   |             .collect::<bool>();\n\
    \     |              ^^^^^^^ value of type `bool` cannot be built from `std::iter::Iterator<Item=bool>`\n\
    \     |\n     = help: the trait `FromIterator<bool>` is not implemented for `bool`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `any`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmpot13umlw.rs:27:15\n\
    \   |\n27 |         if !y.any() {\n   |               ^^^ method not found in\
    \ `bool`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true\n\
    \    for elt in q {\n        if balanced {\n            if will_it_fly(q.rev(),\
    \ elt) {\n                return false\n            }\n        } else {\n    \
    \        if elt != will_it_fly(q.rev(), elt) {\n                balanced = false\n\
    \            }\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpqv6jk1yp.rs:13:28\n\
    \   |\n13 |     let mut balanced = true\n   |                            ^ help:\
    \ add `;` here\n14 |     for elt in q {\n   |     --- unexpected token\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpqv6jk1yp.rs:16:30\n    |\n16\
    \  |               if will_it_fly(q.rev(), elt) {\n    |                     \
    \           ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpqv6jk1yp.rs:20:37\n    |\n20\
    \  |               if elt != will_it_fly(q.rev(), elt) {\n    |              \
    \                         ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqv6jk1yp.rs:20:23\n   |\n20 |             if\
    \ elt != will_it_fly(q.rev(), elt) {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     // the list has been balanced\n        return true;\n    }\n\n    let mut\
    \ sum = 0;\n    q.iter().for_each(|&x| sum += x);\n\n    if sum < w {\n      \
    \  // the list is balanced but contains elements that sum to more than the maximum\
    \ possible weight\n        return false;\n    }\n\n    let mut max_sum = 0;\n\
    \    q.iter().for_each(|&x| if x > max_sum { max_sum = x });\n\n    if max_sum\
    \ == w {\n        // the list is balanced and the sum of its elements is less\
    \ than the maximum possible weight\n        return true;\n    }\n\n    // the\
    \ list is unbalanced or the sum of its elements is more than the maximum possible\
    \ weight\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4q9zxpij.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let max_w = q.reduce(|a,\
    \ &b| a.checked_add(b).unwrap()).unwrap();\n    q.reduce(|a, &b| a.checked_mul(b).unwrap()).unwrap()\n\
    \        .checked_add(&w).unwrap()\n        .add1()\n        .checked_le(&max_w).unwrap()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpekjk0xph.rs:13:19\n\
    \    |\n13  |       let max_w = q.reduce(|a, &b| a.checked_add(b).unwrap()).unwrap();\n\
    \    |                     ^^^^^^ `Vec<isize>` is not an iterator\n    |\n   \
    \ = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpekjk0xph.rs:14:7\n\
    \    |\n14  |       q.reduce(|a, &b| a.checked_mul(b).unwrap()).unwrap()\n   \
    \ |         ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut b = true;\n   \
    \ let mut sum = 0;\n    for &i in q.iter() {\n        sum += i;\n        if sum\
    \ > w {\n            b = false;\n            break;\n        }\n    }\n    b\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9pj5uce7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w.is_zero() {\n    \
    \    true\n    } else {\n        let mut maxw = w;\n        let mut bal = false;\n\
    \        for i in q.iter() {\n            if i > maxw {\n                maxw\
    \ = i;\n            }\n            elseif i <= w {\n                bal = !bal;\n\
    \            }\n        }\n        bal\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `i`\n  --> /tmp/tmpj50r2a5j.rs:22:20\n   |\n22 |             elseif i\
    \ <= w {\n   |                    ^ expected one of 8 possible tokens\n\nerror[E0599]:\
    \ no method named `is_zero` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpj50r2a5j.rs:13:10\n   |\n13 |     if w.is_zero() {\n   |          ^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj50r2a5j.rs:19:20\n\
    \   |\n19 |             if i > maxw {\n   |                    ^^^^\n   |    \
    \                |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&maxw`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj50r2a5j.rs:20:24\n   |\n16 |         let mut\
    \ maxw = w;\n   |                        - expected due to this value\n...\n20\
    \ |                 maxw = i;\n   |                        ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |  \
    \               maxw = *i;\n   |                        +\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 {\n   \
    \     return true;\n    }\n\n    let mut sum = 0;\n    for &e in q {\n       \
    \ sum += e;\n    }\n\n    if sum >= w {\n        return false;\n    }\n\n    let\
    \ mut max = w;\n    for &e in q.iter().rev() {\n        max -= e;\n        if\
    \ max < 0 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8h03v5nn.rs:18:9\n   |\n\
    18 |     for &e in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `e`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    q.sort_unstable();\n\
    \    for val in q.iter() {\n        sum += val;\n    }\n    sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpqhz8omlg.rs:14:5\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n13 |     let mut sum = 0;\n14 |     q.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // if list has zero length,\
    \ this is not a palindromic list\n    let len = q.len();\n    let mut sum_of_elements\
    \ = 0;\n    let mut max_weights = w;\n    let mut bal = 0;\n\n    // reverse and\
    \ remove duplicate elements\n    q.reverse();\n    q.remove(&q[0]);\n\n    for\
    \ ele in q.iter().skip(1) {\n        sum_of_elements += ele;\n        max_weights\
    \ -= ele;\n    }\n\n    bal = sum_of_elements as isize; // cast to isize\n\n \
    \   // return True if the list has length and balance is correct\n    len > 0\
    \ && max_weights == bal\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3lvh4_1e.rs:21:14\n   |\n\
    21 |     q.remove(&q[0]);\n   |              ^^^^^ expected `usize`, found `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // TODO: implement the\
    \ function\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyuyqcol0.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return true\n    }\n    \n    if q.len() == 2 {\n        return q[0] ==\
    \ q[1]\n    }\n    \n    let mut min = q[0];\n    let mut max = q[0];\n    \n\
    \    for v in q.iter() {\n        if v < min {\n            min = v;\n       \
    \ }\n        \n        if v > max {\n            max = v;\n        }\n    }\n\
    \    \n    let mut balanced = true;\n    \n    let mut sum = 0;\n    \n    for\
    \ v in q.iter() {\n        sum += v;\n    }\n    \n    while sum < w && balanced\
    \ {\n        let mut sum = 0;\n        \n        for v in q.iter() {\n       \
    \     sum += v;\n        }\n        \n        if sum < w {\n            balanced\
    \ = false;\n        } else {\n            sum += min;\n        }\n    }\n    \n\
    \    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbqiu07e.rs:25:16\n   |\n\
    25 |         if v < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcbqiu07e.rs:26:19\n\
    \   |\n21 |     let mut min = q[0];\n   |                   ---- expected due\
    \ to this value\n...\n26 |             min = v;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    26 |             min = *v;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcbqiu07e.rs:29:16\n   |\n29 |         if v > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcbqiu07e.rs:30:19\n   |\n22 |  \
    \   let mut max = q[0];\n   |                   ---- expected due to this value\n\
    ...\n30 |             max = v;\n   |                   ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n30 |        \
    \     max = *v;\n   |                   +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut fly_sum = 0;\n\n\
    \    for el in q {\n        if el < 0 {\n            return false;\n        }\n\
    \        fly_sum += el;\n    }\n\n    if fly_sum < w {\n        return false;\n\
    \    }\n    if fly_sum >= w {\n        return true;\n    }\n    let mut balance\
    \ = 0;\n\n    for el in q {\n        if el > 0 {\n            balance += el;\n\
    \        }\n    }\n\n    balance == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpkyblj4x3.rs:30:15\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for el in q {\n    |               - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n30  |     for el in q {\n\
    \    |               ^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for el in &q {\n    |               +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n    let mut max_sum = 0;\n    let mut current_sum =\
    \ 0;\n    let mut current_weight = 0;\n    let mut max_weight = 0;\n    let mut\
    \ min_weight = std::i32::MAX;\n    for v in q.iter().rev() {\n        if current_weight\
    \ + v > w {\n            // if we're not allowed to use the current weight, just\
    \ break\n            break;\n        }\n        current_sum += v;\n        current_weight\
    \ += v;\n        if current_weight > max_weight {\n            max_weight = current_weight;\n\
    \            max_sum = current_sum;\n        }\n    }\n    if max_weight >= w\
    \ {\n        // max_weight is greater than or equal to w\n        let mut is_balanced\
    \ = true;\n        for v in q.iter() {\n            if v != max_sum {\n      \
    \          is_balanced = false;\n                break;\n            }\n     \
    \   }\n        if is_balanced {\n            return true;\n        }\n    }\n\
    \    // max_weight is not greater than or equal to w\n    for v in q.iter() {\n\
    \        if v != max_sum {\n            break;\n        }\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpwdkgwims.rs:37:18\n\
    \   |\n37 |             if v != max_sum {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpwdkgwims.rs:48:14\n   |\n48 |         if v != max_sum\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut left = q.len();\n\
    \    let mut right = q.len();\n\n    while left > 0 && right > 0 && q[left] ==\
    \ q[right] {\n        left -= 1;\n        right -= 1;\n    }\n\n    left <= 0\
    \ && right <= 0 && q == q.to_vec().rev().iter().cloned().collect::<Vec<_>>() ==\
    \ q.to_vec()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpojomkc2e.rs:21:34\n\
    \   |\n21 |     left <= 0 && right <= 0 && q == q.to_vec().rev().iter().cloned().collect::<Vec<_>>()\
    \ == q.to_vec()\n   |                                  ^^                    \
    \                                  ^^\n   |\nhelp: split the comparison into two\n\
    \   |\n21 |     left <= 0 && right <= 0 && q == q.to_vec().rev().iter().cloned().collect::<Vec<_>>()\
    \ && q.to_vec().rev().iter().cloned().collect::<Vec<_>>() == q.to_vec()\n   |\
    \                                                                            \
    \              +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpojomkc2e.rs:21:48\n    |\n21\
    \  |       left <= 0 && right <= 0 && q == q.to_vec().rev().iter().cloned().collect::<Vec<_>>()\
    \ == q.to_vec()\n    |                                                  ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpojomkc2e.rs:21:93\n\
    \   |\n21 |     left <= 0 && right <= 0 && q == q.to_vec().rev().iter().cloned().collect::<Vec<_>>()\
    \ == q.to_vec()\n   |                                                        \
    \                                     ^^^^^^^^^^ expected `bool`, found struct\
    \ `Vec`\n   |\n   = note: expected type `bool`\n            found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Write code here.\n \
    \   \n    let mut sum = 0;\n    q.iter().for_each(|x|{\n        sum = sum + x;\n\
    \    });\n    let mut max_sum = w;\n    let mut max_value = q.iter().max();\n\
    \    \n    while(sum > max_sum){\n        sum -= max_value;\n        \n      \
    \  let mut i = q.iter().skip(1).next();\n        \n        while(i.is_some()){\n\
    \            sum += *i;\n            i = q.iter().skip(1).next();\n        }\n\
    \        \n        max_sum += max_value;\n        max_value = q.iter().max();\n\
    \    }\n    \n    sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxe7djar2.rs:22:10\n\
    \   |\n22 |     while(sum > max_sum){\n   |          ^             ^\n   |\n \
    \  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n22 -     while(sum > max_sum){\n22 +     while sum > max_sum {\n   | \n\
    \nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxe7djar2.rs:27:14\n\
    \   |\n27 |         while(i.is_some()){\n   |              ^           ^\n   |\n\
    help: remove these parentheses\n   |\n27 -         while(i.is_some()){\n27 + \
    \        while i.is_some() {\n   | \n\nerror[E0277]: cannot subtract-assign `Option<&isize>`\
    \ from `isize`\n  --> /tmp/tmpxe7djar2.rs:23:13\n   |\n23 |         sum -= max_value;\n\
    \   |             ^^ no implementation for `isize -= Option<&isize>`\n   |\n \
    \  = help: the trait `SubAssign<Option<&isize>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpxe7djar2.rs:28:20\n\
    \   |\n28 |             sum += *i;\n   |                    ^^\n\nerror[E0277]:\
    \ cannot add-assign `Option<&isize>` to `isize`\n  --> /tmp/tmpxe7djar2.rs:32:17\n\
    \   |\n32 |         max_sum += max_value;\n   |                 ^^ no implementation\
    \ for `isize += Option<&isize>`\n   |\n   = help: the trait `AddAssign<Option<&isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAss"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Your code here\n   \
    \ for i in q.len() {\n        if q[i] == w {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmprnebbbey.rs:14:14\n\
    \   |\n14 |     for i in q.len() {\n   |              ^^^^^^^ `usize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `usize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().fold(false, |b,\
    \ e| b && bal_pq(e, w))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bal_pq` in this scope\n  --> /tmp/tmp593o8c0c.rs:13:38\n\
    \   |\n13 |     q.iter().fold(false, |b, e| b && bal_pq(e, w))\n   |         \
    \                             ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     true\n    } else {\n        let mut i = q.len() - 1;\n        let mut b\
    \ = false;\n        let mut sum = 0;\n        let mut max = w;\n        while\
    \ i != -1 {\n            let elem = q[i];\n            sum += elem;\n        \
    \    if sum > max {\n                sum -= max;\n                b = true;\n\
    \            }\n            if sum < 0 {\n                sum += max;\n      \
    \          b = true;\n            }\n            i -= 1;\n        }\n        b\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp2vkl16hf.rs:20:20\n\
    \   |\n20 |         while i != -1 {\n   |                    ^^\n   |        \
    \            |\n   |                    cannot apply unary operator `-`\n   |\
    \                    help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0600`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_balanced = true;\n\
    \    let mut q = q.clone(); // clone() is a cheap operation\n    q.sort_unstable();\n\
    \    let mut min_weight = q.len();\n    let mut max_weight = 0;\n    while !q_balanced\
    \ {\n        // let min_weight = q.len();\n        q_balanced = false;\n     \
    \   // max_weight = 0;\n        for &x in q {\n            if x >= w {\n     \
    \           q.push(x);\n                if x < min_weight {\n                \
    \    min_weight = x;\n                }\n                if x > max_weight {\n\
    \                    max_weight = x;\n                }\n                q_balanced\
    \ = true;\n            }\n        }\n    }\n    let q_len = q.len();\n    if q_len\
    \ < min_weight {\n        return false;\n    }\n    if q_len > max_weight {\n\
    \        return true;\n    }\n    // if q_len > max_weight && q_len < min_weight\
    \ {\n    //     return true;\n    // }\n    // if q_len > max_weight {\n    //\
    \     return false;\n    // }\n    // if q_len < min_weight {\n    //     return\
    \ true;\n    // }\n    // if q_len == min_weight {\n    //     return true;\n\
    \    // }\n    // return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqub04c2t.rs:22:13\n   |\n\
    22 |         for &x in q {\n   |             ^^    - this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `x`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqub04c2t.rs:25:24\n   |\n25 |\
    \                 if x < min_weight {\n   |                        ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n25 |           \
    \      if x < min_weight.try_into().unwrap() {\n   |                         \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqub04c2t.rs:26:34\n\
    \   |\n16 |     let mut min_weight = q.len();\n   |                          -------\
    \ expected due to this value\n...\n26 |                     min_weight = x;\n\
    \   |                                  ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqub04c2t.rs:39:16\n   |\n39 |     if q_len >\
    \ max_weight {\n   |                ^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n39 |     if q_len > max_weight.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0317]: `if`\
    \ may be missing an `else` clause\n  --> /tmp/tmpqub04c2t.rs:39:5\n   |\n12 |\
    \   fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |                  \
    \                            ---- expected `bool` because of this return type\n\
    ...\n39 | /     if q_len > max_weight {\n40 | |         return true;\n41 | | \
    \    }\n   | |_____^ expected `bool`, found `()`\n   |\n   = note: `if` expressions\
    \ without `else` evaluate to `()`\n   = help: consider adding an `else` block\
    \ that evaluates to the expected type\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0317.\nFor m"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() || w ==\
    \ 0 {\n        return true\n    }\n    if q.len() > w {\n        return false\n\
    \    }\n\n    let mut sum = 0;\n    let mut max_weight = 0;\n    for i in q {\n\
    \        sum += i;\n        max_weight = std::cmp::max(max_weight, sum);\n   \
    \ }\n\n    if sum < max_weight {\n        return false\n    }\n\n    true\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsao3dm0s.rs:16:18\n   |\n\
    16 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut weight: isize =\
    \ 0;\n    let mut balanced = true; // assume balanced\n    for (i, &e) in q.iter().enumerate()\
    \ {\n        // update weight\n        weight += e;\n        // check if it's\
    \ balanced\n        if weight > w {\n            balanced = false;\n         \
    \   break;\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpspsx7kpx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 || q.len()\
    \ > w {\n        return false;\n    }\n    let mut sum = q[0] as usize;\n    for\
    \ i in 1..q.len() {\n        if q[i] as usize != sum {\n            return false;\n\
    \        }\n        sum += q[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa63bongg.rs:13:34\n   |\n\
    13 |     if q.len() == 0 || q.len() > w {\n   |                              \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n13 |     if\
    \ q.len() == 0 || q.len() > w.try_into().unwrap() {\n   |                    \
    \               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa63bongg.rs:21:16\n   |\n21 |         sum += q[i];\n   |           \
    \     ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpa63bongg.rs:21:13\n   |\n21 |         sum\
    \ += q[i];\n   |             ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_sum = 0;\n\
    \    for i in q {\n        max_sum += i;\n    }\n    let mut q: Vec<isize>;\n\
    \    if let Some(_) = q.reverse() {\n        q = q.clone();\n    } else {\n  \
    \      return false;\n    }\n    let mut counter = 0;\n    let mut is_palindromic\
    \ = true;\n    while let Some(x) = q.pop() {\n        if max_sum - x >= w {\n\
    \            counter = counter +1;\n        } else {\n            is_palindromic\
    \ = false;\n            break;\n        }\n    }\n    if is_palindromic {\n  \
    \      max_sum -= w;\n    }\n    counter >= 2\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_81jmkad.rs:18:12\n   |\n\
    18 |     if let Some(_) = q.reverse() {\n   |            ^^^^^^^   -----------\
    \ this expression has type `()`\n   |            |\n   |            expected `()`,\
    \ found enum `Option`\n   |\n   = note: expected unit type `()`\n            \
    \       found enum `Option<_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q\n        .iter()\n  \
    \      .rev()\n        .fold1(|acc, &x| {\n            if acc {\n            \
    \    if acc == x {\n                    false\n                } else {\n    \
    \                true\n                }\n            } else {\n             \
    \   if x <= w {\n                    acc == x - x\n                } else {\n\
    \                    false\n                }\n            }\n        })\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `fold1` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmpmzxwszon.rs:16:10\n   |\n16 |         .fold1(|acc, &x|\
    \ {\n   |          ^^^^^ method not found in `Rev<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmzxwszon.rs:24:25\n   |\n24 |\
    \                 if x <= w {\n   |                         ^ expected `bool`,\
    \ found `isize`\n\nerror[E0369]: cannot subtract `bool` from `bool`\n  --> /tmp/tmpmzxwszon.rs:25:30\n\
    \   |\n25 |                     acc == x - x\n   |                           \
    \ - ^ - bool\n   |                            |\n   |                        \
    \    bool\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    q.sort_by(|a,\
    \ b| a.cmp(&b));\n    for x in q.iter() {\n        sum += x;\n    }\n    sum <\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpcdha5a7e.rs:14:5\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n13 |     let mut sum = 0;\n14 |     q.sort_by(|a, b| a.cmp(&b));\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut stack = Vec::<isize>::new();\n\
    \    let mut was_odd = false;\n    let mut q: Vec<isize> = q.to_vec();\n    loop\
    \ {\n        stack.pop();\n        let mut weight = q.iter().fold(0, |wsum, i|\
    \ wsum + i);\n        if weight > w {\n            return false;\n        }\n\
    \        if weight == w && !was_odd {\n            return true;\n        }\n \
    \       was_odd = !was_odd;\n        if was_odd {\n            q.push(weight as\
    \ isize);\n        }\n        if stack.len() == 1 {\n            break;\n    \
    \    }\n        q.push(weight as isize);\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1_1gpowy.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut fly_it = false;\n\
    \    let mut last_sum = q.iter().sum::<isize>();\n    let mut sum = 0;\n    let\
    \ mut max_possible = w;\n    for e in q.iter() {\n        sum += e;\n        max_possible\
    \ -= e;\n    }\n    if sum < max_possible {\n        fly_it = true;\n    }\n \
    \   fly_it\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgatpta2w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w.is_zero() {\n    \
    \    true\n    } else {\n        let mut q: Vec<isize> = q.to_vec();\n       \
    \ let mut w: isize = 0;\n        let mut max: isize = 0;\n        let mut maxweight:\
    \ isize = 0;\n        let mut max_i: isize = 0;\n        let mut min_i: isize\
    \ = 0;\n        q.sort();\n        q.iter().cloned().for_each(|&i| {\n       \
    \     w.push(i as isize);\n            if w > max {\n                max = w;\n\
    \                max_i = i;\n            }\n            if i == 0 {\n        \
    \        minweight = 1;\n            } else {\n                minweight = q[i\
    \ - 1];\n            }\n            if w > maxweight {\n                maxweight\
    \ = w;\n                min_i = i;\n            }\n        });\n        if max_i\
    \ == min_i && maxweight >= w {\n            return true;\n        } else {\n \
    \           false\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `minweight` in this scope\n  --> /tmp/tmper8kdhvl.rs:30:17\n\
    \   |\n30 |                 minweight = 1;\n   |                 ^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `maxweight`\n\nerror[E0425]: cannot\
    \ find value `minweight` in this scope\n  --> /tmp/tmper8kdhvl.rs:32:17\n   |\n\
    32 |                 minweight = q[i - 1];\n   |                 ^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `maxweight`\n\nerror[E0599]: no\
    \ method named `is_zero` found for type `isize` in the current scope\n  --> /tmp/tmper8kdhvl.rs:13:10\n\
    \   |\n13 |     if w.is_zero() {\n   |          ^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmper8kdhvl.rs:23:37\n   |\n23 |\
    \         q.iter().cloned().for_each(|&i| {\n   |                            \
    \         ^--\n   |                                     ||\n   |             \
    \                        |expected due to this\n   |                         \
    \            expected `isize`, found reference\n   |                         \
    \            help: did you mean `i`: `&isize`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0599]: no method named `push`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmper8kdhvl.rs:24:15\n\
    \   |\n24 |             w.push(i as isize);\n   |               ^^^^ method not\
    \ found in `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmper8kdhvl.rs:32:29\n   |\n32 |                 minweight = q[i -\
    \ 1];\n   |                             ^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet mut q_rev = q.reverse();\n\
    \tlet mut sum = 0;\n\tlet mut max_weight = w;\n\twhile q.len() != 0 {\n\t\tsum\
    \ += *q.last().unwrap();\n\t\tif sum > max_weight {\n\t\t\treturn false;\n\t\t\
    }\n\t\tmax_weight -= *q.last().unwrap();\n\t\tq.last_mut().unwrap().push(q_rev.len());\n\
    \t\tq_rev.pop_back();\n\t}\n\tsum == max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for mutable reference `&mut\
    \ isize` in the current scope\n  --> /tmp/tmpa0u3e72k.rs:22:25\n   |\n22 |   \
    \      q.last_mut().unwrap().push(q_rev.len());\n   |                        \
    \       ^^^^ method not found in `&mut isize`\n\nerror[E0599]: no method named\
    \ `len` found for unit type `()` in the current scope\n  --> /tmp/tmpa0u3e72k.rs:22:36\n\
    \   |\n22 |         q.last_mut().unwrap().push(q_rev.len());\n   |           \
    \                               ^^^ method not found in `()`\n\nerror[E0599]:\
    \ no method named `pop_back` found for unit type `()` in the current scope\n \
    \ --> /tmp/tmpa0u3e72k.rs:23:9\n   |\n23 |         q_rev.pop_back();\n   |   \
    \            ^^^^^^^^ method not found in `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q2 = q.clone();\
    \ q2.reverse();\n    q2.sort();\n    q2[0] < w && q2[q.len() - 1] < w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp052rr3h1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.reverse();\n    if q.len() < 2 * w {\n        return false;\n    }\n  \
    \  let mut balanced = true;\n    let mut sum = 0;\n    for &x in &q {\n      \
    \  balanced &= x >= w;\n        sum += x;\n    }\n    sum >= 2 * w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7lpocifi.rs:15:18\n   |\n\
    15 |     if q.len() < 2 * w {\n   |                  ^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |     if q.len() < (2 * w).try_into().unwrap()\
    \ {\n   |                  +     +++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // write your function\
    \ here\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3mvrajz9.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    if\
    \ n == 0 || w == 0 {\n        return false;\n    }\n    let max_weight = w * n\
    \ - 1;\n    for i in 0..q.len() {\n        if q[i] > max_weight {\n          \
    \  return false;\n        }\n    }\n    let mut sum = 0;\n    for i in q {\n \
    \       sum += i;\n        if sum > max_weight {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdub1rcp_.rs:17:26\n   |\n\
    17 |     let max_weight = w * n - 1;\n   |                          ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmpdub1rcp_.rs:17:24\n   |\n17 |     let max_weight = w * n - 1;\n\
    \   |                        ^ no implementation for `isize * usize`\n   |\n \
    \  = help: the trait `Mul<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Mul<Rhs>`:\n             <&'a f32 as\
    \ Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n\
    \             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n    \
    \         <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n          \
    \   <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q\n        .iter()\n  \
    \      .cloned()\n        .fold(false, |acc, x| acc && will_it_fly_inner(x, w))\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `will_it_fly_inner` in this scope\n\
    \  --> /tmp/tmppynqg5do.rs:16:38\n   |\n16 |         .fold(false, |acc, x| acc\
    \ && will_it_fly_inner(x, w))\n   |                                      ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut w = w;\n    let\
    \ mut i = q.len();\n    let mut is_balanced = true;\n    while i >= 0 {\n    \
    \    if q[i] != w.rev() {\n            is_balanced = false;\n            break;\n\
    \        }\n        i -= 1;\n        w -= 1;\n    }\n    is_balanced\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmp8b8i8zhv.rs:17:22\n\
    \   |\n17 |         if q[i] != w.rev() {\n   |                      ^^^ `isize`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: Iterator`\n           which is required by `&mut isize: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n\n    q.sort_unstable();\n    q.push(0);\n    q.push(1);\n\
    \n    for i in q {\n        balanced = balanced || (i > 0 && w-i == i);\n    \
    \    sum += i;\n    }\n\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpcypk_diq.rs:16:5\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n16 |     q.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `q` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpcypk_diq.rs:17:5\n   |\n12 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |                - help: consider changing\
    \ this to be mutable: `mut q`\n...\n17 |     q.push(0);\n   |     ^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `q` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpcypk_diq.rs:18:5\n   |\n12 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |                - help: consider changing\
    \ this to be mutable: `mut q`\n...\n18 |     q.push(1);\n   |     ^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut w1 = q.len();\n\
    \    if w1 > w {\n        return false;\n    }\n    for i in 0..w1 {\n       \
    \ let mut w2 = 0;\n        let mut maxw = q.len();\n        if i > w1 {\n    \
    \        w2 = i - w1;\n        }\n        for j in 0..w2 {\n            if q[j]\
    \ != q[j - i] {\n                w2 += 1;\n                if w2 < maxw {\n  \
    \                  maxw = w2;\n                }\n            }\n        }\n \
    \       if maxw == w {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2sed_nuw.rs:14:13\n   |\n\
    14 |     if w1 > w {\n   |             ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n14 |     if w1 > w.try_into().unwrap() {\n   |          \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sed_nuw.rs:31:20\n\
    \   |\n31 |         if maxw == w {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |         if maxw == w.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    \n\
    \    for i in q.iter() {\n        sum += i;\n    }\n    \n    (sum < w && is_balanced(q))\
    \ || (sum == w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpb11b4hes.rs:19:17\n\
    \   |\n19 |     (sum < w && is_balanced(q)) || (sum == w)\n   |              \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return false;\n    }\n\n    // The palindromic sublist must have a balance\
    \ greater than the given maximum weight.\n    let mut balance = 0;\n    for e\
    \ in q {\n        balance += e;\n        if balance < w {\n            return\
    \ false;\n        }\n    }\n\n    // The palindromic sublist must have the same\
    \ weight as the given maximum weight.\n    if q.iter().zip(q.iter().cloned()).any(|(a,\
    \ b)| a != b) {\n        return false;\n    }\n\n    // The palindromic sublist\
    \ must have the same weight.\n    let mut total_weight = 0;\n    for e in q {\n\
    \        total_weight += e;\n    }\n    if total_weight != w {\n        return\
    \ false;\n    }\n\n    // The palindromic sublist must have a balance equal to\
    \ the maximum weight.\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmprilyhu7q.rs:27:55\n\
    \   |\n27 |     if q.iter().zip(q.iter().cloned()).any(|(a, b)| a != b) {\n  \
    \ |                                                       ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n\n    let mut reversed = q.clone();\n    std::reverse(reversed.iter_mut().cloned(),\
    \ reversed.iter_mut().cloned());\n    let mut reversed_sum = reversed.iter().sum::<isize>();\n\
    \    reversed_sum -= w;\n    if reversed_sum < 0 {\n        return false;\n  \
    \  }\n\n    let mut reversed_list = reversed.clone();\n    reversed_list.push(reversed.iter().sum::<isize>());\n\
    \n    let mut q_size = q.len();\n    let mut q_list_size = q.len();\n    let mut\
    \ max_w = w;\n    let mut max_reversed_sum = 0;\n    while q_size > 0 {\n    \
    \    q_size--;\n        let mut next_sum = 0;\n        for _ in 0..q_list_size\
    \ {\n            next_sum += reversed_list.remove(0);\n        }\n        if max_w\
    \ == w && next_sum == 0 {\n            return true;\n        }\n        if next_sum\
    \ > max_w {\n            max_w = next_sum;\n        }\n        let mut next_max_reversed_sum\
    \ = 0;\n        for _ in 0..q_list_size {\n            next_max_reversed_sum +=\
    \ reversed_list.remove(0);\n        }\n        if max_reversed_sum < next_max_reversed_sum\
    \ {\n            max_reversed_sum = next_max_reversed_sum;\n        }\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpjryozgze.rs:37:17\n\
    \   |\n37 |         q_size--;\n   |                 ^ expected expression\n\n\
    error[E0425]: cannot find function `reverse` in crate `std`\n  --> /tmp/tmpjryozgze.rs:22:10\n\
    \   |\n22 |     std::reverse(reversed.iter_mut().cloned(), reversed.iter_mut().cloned());\n\
    \   |          ^^^^^^^ not found in `std`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::slice::IterMut<'_, isize> as Iterator>::Item == &_`\n    --> /tmp/tmpjryozgze.rs:22:38\n\
    \     |\n22   |     std::reverse(reversed.iter_mut().cloned(), reversed.iter_mut().cloned());\n\
    \     |                                      ^^^^^^ types differ in mutability\n\
    \     |\n     = note:      expected reference `&_`\n             found mutable\
    \ reference `&mut isize`\nnote: required by a bound in `cloned`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::slice::IterMut<'_, isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpjryozgze.rs:22:68\n     |\n22   |     std::reverse(reversed.iter_mut().cloned(),\
    \ reversed.iter_mut().cloned());\n     |                                     \
    \                               ^^^^^^ types differ in mutability\n     |\n  \
    \   = note:      expected reference `&_`\n             found mutable reference\
    \ `&mut isize`\nnote: required by a bound in `cloned`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0271, E0425.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Balance the list by\
    \ summing its elements.\n    let mut sum = 0;\n    for i in q.iter() {\n     \
    \   sum += i;\n    }\n\n    if sum >= w {\n        // The list is balanced.\n\
    \        return true\n    }\n\n    // It's unbalanced. Check it by comparing last\
    \ and first element.\n    match q.len() {\n        1 => return false\n       \
    \ _ => will_it_fly(q[0..q.len() - 1], w),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found reserved\
    \ identifier `_`\n  --> /tmp/tmp9bk_1_4u.rs:27:9\n   |\n26 |         1 => return\
    \ false\n   |           --             - expected one of `,`, `.`, `?`, `}`, or\
    \ an operator\n   |           |\n   |           while parsing the `match` arm\
    \ starting here\n27 |         _ => will_it_fly(q[0..q.len() - 1], w),\n   |  \
    \       ^ unexpected token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut f = q.as_mut();\n\
    \    let mut s = w;\n    loop {\n        // If f is not empty, q is a palindromic\
    \ list\n        if f.len() > 0 {\n            // f cannot be a palindromic list\
    \ if w is greater than the sum of the elements of the list\n            if w >\
    \ f.iter().reduce(|acc, elem| acc + elem) {\n                // If w is greater\
    \ than the sum of the elements of the list,\n                // the sum of the\
    \ elements of the list cannot be bigger than w,\n                // and the list\
    \ cannot be balanced.\n                return false;\n            }\n        \
    \    f =\n                f\n                    .iter()\n                   \
    \ .filter(|elem| elem != s[f.len() - 1 - elem])\n                    .cloned()\n\
    \                    .collect();\n        } else {\n            // f can now be\
    \ palindromic because s <= w\n            f.push(s[f.len() - 1]);\n          \
    \  s += f;\n            f = Vec::new();\n        }\n    }\n    // We have reached\
    \ the end of the function without returning true\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&mut T`\n  --> /tmp/tmpsw1mtuwd.rs:13:19\n\
    \   |\n13 |     let mut f = q.as_mut();\n   |         -----     ^^^^^^ cannot\
    \ infer type for type parameter `T` declared on the trait `AsMut`\n   |      \
    \   |\n   |         consider giving `f` the explicit type `&mut T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nwarning: unreachable expression\n  --> /tmp/tmpsw1mtuwd.rs:39:5\n \
    \  |\n15 | /     loop {\n16 | |         // If f is not empty, q is a palindromic\
    \ list\n17 | |         if f.len() > 0 {\n18 | |             // f cannot be a palindromic\
    \ list if w is greater than the sum of the elements of the list\n...  |\n36 |\
    \ |         }\n37 | |     }\n   | |_____- any code following this expression is\
    \ unreachable\n38 |       // We have reached the end of the function without returning\
    \ true\n39 |       true\n   |       ^^^^ unreachable expression\n   |\n   = note:\
    \ `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut v = Vec::new();\n\
    \    let mut p = Vec::new();\n    p.push(q[0]);\n    let mut w1 = Vec::new();\n\
    \    w1.push(q[0]);\n    while p.len() != 0 {\n        let e = p.pop();\n    \
    \    v.push(e);\n        while w1.len() != 0 {\n            let e = w1.pop();\n\
    \            if e < w {\n                return false;\n            }\n      \
    \      w1.push(e);\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1p61swfl.rs:23:20\n   |\n\
    23 |             if e < w {\n   |                    ^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n23 |\
    \             if e < Some(w) {\n   |                    +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1p61swfl.rs:26:21\n   |\n26 |             w1.push(e);\n\
    \   |                     ^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected type `isize`\n              found enum `Option<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut fly_p = false;\n\
    \    let mut is_balanced = false;\n    let mut sum = 0;\n    for i in q.iter()\
    \ {\n        if sum + i <= w {\n            sum += i;\n            fly_p = true;\n\
    \        } else {\n            sum -= i;\n            is_balanced = true;\n  \
    \      }\n    }\n    fly_p && is_balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzhjx7evs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().rev().fold(true,\
    \ (l, &x) => {\n        if l && l == x.clone() {\n            l.clone() != x\n\
    \        } else {\n            l.clone() != x.clone() && x\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmp4xub279p.rs:13:39\n   |\n13 |     q.iter().rev().fold(true, (l,\
    \ &x) => {\n   |                                       ^^ expected one of `)`,\
    \ `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3q0z6qyn.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max = 0;\n    for\
    \ i in 0..q.len() {\n        if q[i] > max {\n            max = q[i];\n      \
    \  }\n    }\n    for i in 0..q.len() {\n        let l = q[q.len() - 1 - i];\n\
    \        if q[i] + l > max {\n            return false;\n        }\n    }\n  \
    \  for i in 0..q.len() {\n        let l = q[q.len() - 1 - i];\n        let m =\
    \ q[i];\n        if ((max == 0) || (m + l < max)) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4r889b4l.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut wq = 0isize;\n\
    \    let mut sum = 0isize;\n    for elem in q.iter() {\n        wq += elem;\n\
    \        sum += elem;\n    }\n    wq <= w && sum >= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1mct0u8c.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    fn is_balanced(l: Vec<isize>)\
    \ -> bool {\n        let mut n = l;\n        let mut sum = 0;\n        while !n.is_empty()\
    \ {\n            let mut x = n.remove(0);\n            sum += x;\n           \
    \ n += x;\n        }\n        sum == w\n    }\n\n    let mut n = q;\n    let mut\
    \ sum = 0;\n    while !n.is_empty() {\n        let mut x = n.remove(0);\n    \
    \    sum += x;\n        n += x;\n    }\n    sum == w && is_balanced(q)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpr7vmxnd_.rs:21:16\n\
    \   |\n21 |         sum == w\n   |                ^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmpr7vmxnd_.rs:29:9\n\
    \   |\n29 |         n += x;\n   |         -^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `Vec<isize>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmpr7vmxnd_.rs:19:13\n\
    \   |\n19 |             n += x;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `Vec<isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0368, E0434.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w.is_zero() {\n    \
    \    return true;\n    }\n    if q.is_empty() {\n        return false;\n    }\n\
    \    let mut left = q[0] as isize;\n    let mut right = q[q.len() - 1] as isize;\n\
    \    let mut total = left + right;\n    for i in 1..q.len() {\n        if total\
    \ > w {\n            total -= w;\n            right += w - 1;\n        }\n   \
    \     if total < w {\n            total += w;\n            left -= w - 1;\n  \
    \      }\n    }\n    left == 0 && right == 0 && total == w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpbhdfnrm6.rs:13:10\n   |\n13 |     if w.is_zero() {\n  \
    \ |          ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = q.clone();\n\
    \    s.push(i);\n    let mut j = 0;\n    while j < q.len() {\n        if q[j]\
    \ != i {\n            break;\n        }\n        j += 1\n    }\n    \n    if j\
    \ - 1 < 1 {\n        return false\n    }\n\n    let mut max_weight = 0\n    let\
    \ mut sum = 0\n    let mut i = 1;\n    while i < w {\n        if let Ok(k) = s.iter().rev().find(|&x|\
    \ x == i) {\n            sum += k;\n            i += 1;\n        } else {\n  \
    \          break;\n        }\n    }\n    max_weight = sum;\n    if max_weight\
    \ < w {\n        return true\n    }\n    \n    if let Ok(k) = s.iter().rev().find(|&x|\
    \ x == max_weight) {\n        return will_it_fly(q, max_weight)\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpmm8ihzud.rs:27:27\n\
    \   |\n27 |     let mut max_weight = 0\n   |                           ^ help:\
    \ add `;` here\n28 |     let mut sum = 0\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `let`\n  --> /tmp/tmpmm8ihzud.rs:28:20\n   |\n28\
    \ |     let mut sum = 0\n   |                    ^ help: add `;` here\n29 |  \
    \   let mut i = 1;\n   |     --- unexpected token\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpmm8ihzud.rs:14:12\n   |\n14 |     s.push(i);\n\
    \   |            ^ help: a local variable with a similar name exists: `q`\n\n\
    error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpmm8ihzud.rs:17:20\n\
    \   |\n17 |         if q[j] != i {\n   |                    ^ help: a local variable\
    \ with a similar name exists: `j`\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmpmm8ihzud.rs:31:51\n   |\n31 |         if let Ok(k) =\
    \ s.iter().rev().find(|&x| x == i) {\n   |                                   \
    \                ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmm8ihzud.rs:31:16\n   |\n31 |\
    \         if let Ok(k) = s.iter().rev().find(|&x| x == i) {\n   |            \
    \    ^^^^^   -------------------------------- this expression has type `Option<&isize>`\n\
    \   |                |\n   |                expected enum `Option`, found enum\
    \ `Result`\n   |\n   = note: expected enum `Option<&isize>`\n              found\
    \ enum `Result<_, _>`\n\nerror[E0277]: can't compare `&isize` with `isize`\n \
    \ --> /tmp/tmpmm8ihzud.rs:43:47\n   |\n43 |     if let Ok(k) = s.iter().rev().find(|&x|\
    \ x == max_weight) {\n   |                                               ^^ no\
    \ implementation for `&isize == isize`\n   |\n   = help: the trait `Partia"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ n in q.iter() {\n        sum += n;\n    }\n    sum <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsxllgo5v.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Write your solution\
    \ here\n    let mut max = 0;\n    for a in q {\n        if max < a.checked_mul(w)?\
    \ {\n            max = 0;\n        } else {\n            max += a.checked_mul(w)?\
    \ a;\n        }\n    }\n    max == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmpc3ff9n9d.rs:19:38\n   |\n19 |             max += a.checked_mul(w)?\
    \ a;\n   |                                      ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0277]: the `?` operator can only be used in a\
    \ function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpc3ff9n9d.rs:16:34\n   |\n12 | / fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n13 | |     // Write your solution here\n14\
    \ | |     let mut max = 0;\n15 | |     for a in q {\n16 | |         if max < a.checked_mul(w)?\
    \ {\n   | |                                  ^ cannot use the `?` operator in\
    \ a function that returns `bool`\n...  |\n22 | |     max == w\n23 | | }\n   |\
    \ |_- this function should return `Result` or `Option` to accept `?`\n   |\n \
    \  = help: the trait `FromResidual<Option<Infallible>>` is not implemented for\
    \ `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // reverse the list, then\
    \ iterate from the end to the front \n    // and sum up the elements. \n    q.iter().rev().fold(true,\
    \ |result, element| {\n        if result {\n            return false;\n      \
    \  }\n        result += element;\n        if result > w {\n            return\
    \ false;\n        }\n        true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `bool`\n  --> /tmp/tmp3x8zowat.rs:19:9\n   |\n19 |         result += element;\n\
    \   |         ------^^^^^^^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3x8zowat.rs:20:21\n\
    \   |\n20 |         if result > w {\n   |                     ^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 0 || w ==\
    \ 0 {\n        return true;\n    }\n\n    let mut m = q.len().min(w);\n\n    for\
    \ e in q.iter().rev() {\n        if m == 0 {\n            return false;\n    \
    \    }\n        m--;\n        if e == m[..] {\n            return true;\n    \
    \    }\n    }\n\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp558tv88p.rs:23:12\n\
    \   |\n23 |         m--;\n   |            ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp558tv88p.rs:17:29\n   |\n17 |     let mut m\
    \ = q.len().min(w);\n   |                             ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     let mut m = q.len().min(w.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut left = w;\n   \
    \ let mut right = 0 - w;\n    let mut mid = q.len() / 2;\n    let mut ans = false;\n\
    \    let mut max = q.len();\n    while left < right {\n        if q.len() > 0\
    \ && q.len() < max {\n            ans = false;\n            left = mid + 1;\n\
    \        } else {\n            ans = true;\n            left = mid;\n        }\n\
    \        right = 0;\n        while q.len() > 0 {\n            if q.len() > left\
    \ {\n                q.swap(0, left);\n            }\n            left -= 1;\n\
    \            right += 1;\n            mid = (left + right) / 2;\n            if\
    \ q.len() > 0 {\n                q.swap(0, mid);\n            }\n            if\
    \ q.len() <= max {\n                max = q.len();\n            }\n        }\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0a5c2fxd.rs:21:20\n   |\n\
    13 |     let mut left = w;\n   |                    - expected due to this value\n\
    ...\n21 |             left = mid + 1;\n   |                    ^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0a5c2fxd.rs:24:20\n\
    \   |\n13 |     let mut left = w;\n   |                    - expected due to this\
    \ value\n...\n24 |             left = mid;\n   |                    ^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0a5c2fxd.rs:28:26\n\
    \   |\n28 |             if q.len() > left {\n   |                          ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |           \
    \  if q.len() > left.try_into().unwrap() {\n   |                             \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0a5c2fxd.rs:29:27\n\
    \   |\n29 |                 q.swap(0, left);\n   |                           ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n29 |           \
    \      q.swap(0, left.try_into().unwrap());\n   |                            \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0a5c2fxd.rs:33:19\n\
    \   |\n15 |     let mut mid = q.len() / 2;\n   |                   -----------\
    \ expected due to this value\n...\n33 |             mid = (left + right) / 2;\n\
    \   |                   ^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    while q.len() > 0 {\n   \
    \     let mut i = 0;\n        while i < q.len() && q[i] < sum {\n            i\
    \ += 1;\n        }\n        if i == q.len() {\n            break;\n        }\n\
    \        q.remove(i);\n        sum += q[i];\n        if sum > w {\n          \
    \  break;\n        }\n        if sum >= max_sum {\n            max_sum = sum;\n\
    \        }\n    }\n    q.reverse();\n    q.len() <= 1\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqaz7sdpj.rs:25:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ element in q {\n        sum += element;\n    }\n    sum < w && is_balanced(q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpdmto20i8.rs:17:16\n\
    \   |\n17 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n\n    // Sort the elements by descending order\
    \ (so the highest weight comes first)\n    // This makes sure that even weights\
    \ are considered to be palindromic since we assume that any number will be palindromic\n\
    \    q.sort_by(|a, b| b.cmp(&a).reverse());\n\n    // Get the sum of the elements\n\
    \    let sum_q = q.reduce(0, |sum, i| sum + i);\n\n    if sum_q == w {\n     \
    \   // All weights are equal and the sum of them is equal to the weight we're\
    \ looking for\n        // Return the answer directly\n        return true;\n \
    \   }\n\n    // The sum is not equal to the weight we're looking for, so iterate\
    \ over every element and\n    // check if that is the maximum possible weight\n\
    \    for i in 0..q.len() {\n        // The current weight of the element we're\
    \ checking\n        let curr_weight = q[i];\n        // The current maximum possible\
    \ weight\n        let curr_max_weight = if i == q.len() - 1 { max_weight } else\
    \ { max_weight - q[i + 1] };\n\n        // If the current element is the maximum\
    \ possible weight, set the flag so the function ends\n        // This is important\
    \ to prevent infinite loops when there is a palindromic list with the current\
    \ max weight\n        if curr_max_weight == max_weight {\n            balanced\
    \ = true;\n            break;\n        }\n\n        // If the current element\
    \ exceeds the current max weight, the current element will be considered to be\
    \ balanced\n        // We have to check this before moving on to the next element\n\
    \        if curr_weight > curr_max_weight {\n            max_weight = curr_weight;\n\
    \            balanced = false;\n        } else {\n            max_weight = curr_max_weight;\n\
    \            balanced = true;\n            break;\n        }\n    }\n\n    //\
    \ Return the answer\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpbz8h_x8z.rs:21:19\n\
    \    |\n21  |       let sum_q = q.reduce(0, |sum, i| sum + i);\n    |        \
    \             ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut balanced = false;\n    for &el in q {\n        sum += el;\n        if sum\
    \ >= w {\n            balanced = true;\n            break;\n        }\n    }\n\
    \    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvf0w20s1.rs:15:9\n   |\n\
    15 |     for &el in q {\n   |         ^^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `el`\n   |\n   = note:  \
    \ expected type `isize`\n           found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.rev();\n    let mut w = 0;\n    for i in q.iter() {\n        w = w + i;\n\
    \        if w > w as i32 || w%w as i32 != 0 {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpxo32ykw_.rs:14:7\n\
    \    |\n14  |       q.rev();\n    |         ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxo32ykw_.rs:18:16\n\
    \   |\n18 |         if w > w as i32 || w%w as i32 != 0 {\n   |               \
    \ ^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     \
    \    if w > (w as i32).try_into().unwrap() || w%w as i32 != 0 {\n   |        \
    \        +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxo32ykw_.rs:18:30\n   |\n18 |         if w > w as i32 || w%w as i32\
    \ != 0 {\n   |                              ^^^^^^^^ expected `isize`, found `i32`\n\
    \nerror[E0277]: cannot mod `isize` by `i32`\n  --> /tmp/tmpxo32ykw_.rs:18:29\n\
    \   |\n18 |         if w > w as i32 || w%w as i32 != 0 {\n   |               \
    \              ^ no implementation for `isize % i32`\n   |\n   = help: the trait\
    \ `Rem<i32>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n          \
    \   <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n            \
    \ <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a\
    \ i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a isize\
    \ as Rem<isize>>\n           and 54 others\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // If the vector is empty,\
    \ return true\n    if q.len() == 0 {\n        return true;\n    }\n    // If the\
    \ vector is not balanced, return false\n    let mut sum = 0;\n    for e in q {\n\
    \        sum += e;\n    }\n    if sum < w {\n        return false;\n    }\n  \
    \  // If the vector is balanced, calculate the sum of the elements modulo w\n\
    \    let mut sum = (w as isize) % q.len();\n    let mut i = (w as isize) / q.len();\n\
    \    for e in q {\n        sum += e % i;\n        i /= q.len();\n    }\n    sum\
    \ == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4i23ju0.rs:26:34\n   |\n\
    26 |     let mut sum = (w as isize) % q.len();\n   |                         \
    \         ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod\
    \ `isize` by `usize`\n  --> /tmp/tmpb4i23ju0.rs:26:32\n   |\n26 |     let mut\
    \ sum = (w as isize) % q.len();\n   |                                ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4i23ju0.rs:27:32\n\
    \   |\n27 |     let mut i = (w as isize) / q.len();\n   |                    \
    \            ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot divide\
    \ `isize` by `usize`\n  --> /tmp/tmpb4i23ju0.rs:27:30\n   |\n27 |     let mut\
    \ i = (w as isize) / q.len();\n   |                              ^ no implementation\
    \ for `isize / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4i23ju0.rs:30:14\n\
    \   |\n30 |         i /= q.len();\n   |              ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  -->\
    \ /tmp/tmpb4i23ju0.rs:30:11\n   |\n30 |         i /= q.len();\n   |          \
    \ ^^ no implementation for `isize /= usize`\n   |\n   = help: the trait `DivAssign<u"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_val = w;\n\
    \    let mut balanced = 0;\n    let mut q_iter = q.rbegin();\n    while q_iter\
    \ != q.rend() {\n        if *q_iter > max_val {\n            max_val = *q_iter;\n\
    \        }\n        q_iter += 1;\n    }\n    for (val, i) in q.iter().zip(q.iter().rev())\
    \ {\n        let cur_weight = val + i;\n        if cur_weight > max_val {\n  \
    \          return false;\n        }\n        if cur_weight < w && cur_weight ==\
    \ max_val {\n            balance += 1;\n        }\n    }\n    balance == 0\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `balance` in this scope\n  --> /tmp/tmpde4ymsnz.rs:28:13\n\
    \   |\n28 |             balance += 1;\n   |             ^^^^^^^ help: a local\
    \ variable with a similar name exists: `balanced`\n\nerror[E0425]: cannot find\
    \ value `balance` in this scope\n  --> /tmp/tmpde4ymsnz.rs:31:5\n   |\n31 |  \
    \   balance == 0\n   |     ^^^^^^^ help: a local variable with a similar name\
    \ exists: `balanced`\n\nerror[E0599]: no method named `rbegin` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpde4ymsnz.rs:15:24\n   |\n15\
    \ |     let mut q_iter = q.rbegin();\n   |                        ^^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `rend` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpde4ymsnz.rs:16:23\n\
    \   |\n16 |     while q_iter != q.rend() {\n   |                       ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    debug_assert!(q.len() ==\
    \ w);\n    let mut ans = false;\n    let mut sum = 0;\n    let mut max_weight\
    \ = w;\n    for i in q.iter().rev() {\n        sum += i;\n        if sum >= max_weight\
    \ {\n            ans = true;\n            break;\n        }\n        max_weight\
    \ -= i;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0duuo91d.rs:13:30\n   |\n\
    13 |     debug_assert!(q.len() == w);\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     debug_assert!(q.len()\
    \ == w.try_into().unwrap());\n   |                               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut qs = q.to_string().chars().collect::<Vec<isize>>();\n\
    \    qs.pop();\n    qs.reverse();\n    \n    if let Some(ref mut b) = &mut max_weight[qs[0]]\
    \ {\n        b += qs[1..].iter().fold(0, |a, b| {\n            if a == 0 {\n \
    \               a\n            } else {\n                b + b\n            }\n\
    \        });\n    }\n    \n    balance_q.insert(w, q);\n    balance_q.insert(w,\
    \ &qs[..]);\n    \n    // For all possible weights:\n    // For balanced objects,\
    \ add all their elements to the running sum \n    // For unbalanced objects, add\
    \ the minimum weight needed to make them balanced\n    // The result is the sum\
    \ of all possible balanced weight functions for this object\n    \n    let mut\
    \ sum: isize = 0;\n    \n    for w in 0..w {\n        if w == w {\n          \
    \  if balance_q.contains(w) {\n                sum += *&max_weight[*&balance_q.find(w).unwrap()];\n\
    \            }\n            continue;\n        }\n        \n        let mut found\
    \ = false;\n        while !found {\n            let mut qs = balance_q[w];\n \
    \           let q: &[isize] = &qs[..];\n            \n            if balance_q.contains(w)\
    \ {\n                sum += *&max_weight[*&balance_q.find(w).unwrap()];\n    \
    \        }\n            \n            if q.len() <= 1 {\n                found\
    \ = true;\n                continue;\n            }\n            \n          \
    \  if balance_q[w].len() > 0 {\n                if balance_q[w].len() >= q.len()\
    \ {\n                    sum += *&max_weight[*q.iter().rev().rev().collect::<Vec<_>>()];\n\
    \                } else {\n                    let mut qs = balance_q[w];\n  \
    \                  let q: &[isize] = &qs[..];\n                    \n        \
    \            if balance_q.contains(w) {\n                        sum += *&max_weight[*&balance_q.find(w).unwrap()];\n\
    \                    }\n                    \n                    let mut b =\
    \ *&max_weight[*q.iter().rev().collect::<Vec<_>>()];\n                    \n \
    \                   if q != q.clone() {\n                        b += *q.iter().rev().fold(0,\
    \ |a, b| {\n                            if a == 0 {\n                        \
    \        a\n                            } else {\n                           \
    \     b + b\n                            }\n                        });\n    \
    \                }\n                    sum += b;\n                }\n       \
    \     }\n        }\n    }\n    \n    sum == w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_weight` in this scope\n  --> /tmp/tmps7orv1yc.rs:17:35\n\
    \   |\n17 |     if let Some(ref mut b) = &mut max_weight[qs[0]] {\n   |      \
    \                             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `balance_q` in this scope\n  --> /tmp/tmps7orv1yc.rs:27:5\n\
    \   |\n27 |     balance_q.insert(w, q);\n   |     ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `balance_q` in this scope\n  --> /tmp/tmps7orv1yc.rs:28:5\n\
    \   |\n28 |     balance_q.insert(w, &qs[..]);\n   |     ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `balance_q` in this scope\n  -->\
    \ /tmp/tmps7orv1yc.rs:39:16\n   |\n39 |             if balance_q.contains(w) {\n\
    \   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `max_weight` in this scope\n  --> /tmp/tmps7orv1yc.rs:40:26\n   |\n\
    40 |                 sum += *&max_weight[*&balance_q.find(w).unwrap()];\n   |\
    \                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `balance_q` in this scope\n  --> /tmp/tmps7orv1yc.rs:40:39\n\
    \   |\n40 |                 sum += *&max_weight[*&balance_q.find(w).unwrap()];\n\
    \   |                                       ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `balance_q` in this scope\n  --> /tmp/tmps7orv1yc.rs:47:26\n\
    \   |\n47 |             let mut qs = balance_q[w];\n   |                     \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `balance_q`\
    \ in this scope\n  --> /tmp/tmps7orv1yc.rs:50:16\n   |\n50 |             if balance_q.contains(w)\
    \ {\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `max_weight` in this scope\n  --> /tmp/tmps7orv1yc.rs:51:26\n   |\n\
    51 |                 sum += *&max_weight[*&balance_q.find(w).unwrap()];\n   |\
    \                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `balance_q` in this scope\n  --> /tmp/tmps7orv1yc.rs:51:39\n\
    \   |\n51 |                 sum += *&max_weight[*&balance_q.find(w).unwrap()]"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = std::collections::HashSet::new();\n\
    \    let mut max = std::collections::HashSet::new();\n    let mut max_len = std::collections::HashSet::new();\n\
    \    for i in q.iter() {\n        if s.contains(i) || max.contains(i) || max_len.contains(i)\
    \ {\n            return false;\n        } else {\n            s.push(i);\n   \
    \         max.insert(*i as isize);\n            max_len.insert(*i as isize);\n\
    \        }\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n        sum\
    \ += i;\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for struct `HashSet` in the\
    \ current scope\n  --> /tmp/tmp7zrc4o9p.rs:20:15\n   |\n20 |             s.push(i);\n\
    \   |               ^^^^ method not found in `HashSet<_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.is_empty() || will_it_fly(q.clone(),\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n\n    // Sort the list to ensure the palindromic condition.\n\
    \    q.sort_unstable();\n\n    let mut sum = 0;\n    let mut max_sum = w;\n\n\
    \    // Get the sum till the index of the last element (which is also the length\
    \ of the list)\n    for i in 0..q.len() {\n        sum += q[i];\n        if sum\
    \ >= max_sum {\n            return false;\n        }\n\n        // Update max_sum\
    \ if the current element is greater than the previous sum\n        if q[i] > sum\
    \ {\n            max_sum = sum;\n        }\n    }\n\n    // The list is balanced\
    \ and max sum matches the maximum possible weight\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpr8gi8qnt.rs:18:5\n   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n18 |     q.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return false;\n    }\n    let mut sum: isize = 0;\n    for i in q {\n   \
    \     sum += i;\n    }\n    if sum == w && will_it_fly(q.clone(), w / sum) {\n\
    \        return true;\n    }\n    if sum > w {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    for i in q.clone() {\n        sum += i;\n        if\
    \ sum > w {\n            return false;\n        }\n    }\n    return true;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpv_j9h29u.rs:20:32\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n20  |     if sum == w && will_it_fly(q.clone(),\
    \ w / sum) {\n    |                                ^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |     for i in &q {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return false;\n    }\n    if q.pop() as usize + q.pop() as usize >= w {\n\
    \        return false;\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n\
    \        if i > 0 && i < q.len() - 1 {\n            sum += q[i];\n        }\n\
    \    }\n    if sum > w {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkgdv8u4.rs:16:47\n   |\n\
    16 |     if q.pop() as usize + q.pop() as usize >= w {\n   |                 \
    \                              ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |     if q.pop() as usize + q.pop() as usize >= w.try_into().unwrap()\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxkgdv8u4.rs:21:16\n   |\n21 |\
    \         if i > 0 && i < q.len() - 1 {\n   |                ^\n   |         \
    \       |\n   |                expected `&isize`, found integer\n   |        \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxkgdv8u4.rs:21:25\n   |\n21 |         if i > 0 && i < q.len() -\
    \ 1 {\n   |                         ^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpxkgdv8u4.rs:22:20\n\
    \   |\n22 |             sum += q[i];\n   |                    ^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0605]: non-primitive cast: `Option<isize>`\
    \ as `usize`\n  --> /tmp/tmpxkgdv8u4.rs:16:8\n   |\n16 |     if q.pop() as usize\
    \ + q.pop() as usize >= w {\n   |        ^^^^^^^^^^^^^^^^ an `as` expression can\
    \ only be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror[E0605]: non-primitive cast: `Option<isize>` as `usize`\n  -->\
    \ /tmp/tmpxkgdv8u4.rs:16:27\n   |\n16 |     if q.pop() as usize + q.pop() as usize\
    \ >= w {\n   |                           ^^^^^^^^^^^^^^^^ an `as` expression can\
    \ only be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanat"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_owned();\n\
    \    let mut w: isize = 0;\n    let mut max_weight = 0;\n    for i in q.iter()\
    \ {\n        if i < w {\n            return false;\n        }\n        if i ==\
    \ w {\n            w = 0;\n        }\n        w += i;\n        if w > max_weight\
    \ {\n            max_weight = w;\n        }\n    }\n    if max_weight == 0 {\n\
    \        return false;\n    }\n    let mut s = q.len() / 2;\n    let mut f = 0;\n\
    \    while s < q.len() {\n        f += q[s];\n        if f > max_weight {\n  \
    \          return false;\n        }\n        if f == max_weight {\n          \
    \  w = 0;\n        }\n        w += q[s];\n        if w > max_weight {\n      \
    \      return false;\n        }\n        s++;\n    }\n    if max_weight > w {\n\
    \        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp38iah440.rs:45:10\n\
    \   |\n45 |         s++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n45 |         { let tmp = s; s += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n45 -         s++;\n45 +         s +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38iah440.rs:17:16\n\
    \   |\n17 |         if i < w {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&w`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp38iah440.rs:20:14\n   |\n20 |         if i == w {\n   |       \
    \       ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut m = q.len();\n    let mut sum = 0;\n    let mut max = 0;\n    let\
    \ mut maxi = q.len();\n\n    q.sort_unstable();\n\n    while max < w {\n     \
    \   max = q.iter().max().unwrap();\n        max += 1;\n        q.pop_back();\n\
    \    }\n\n    for x in q {\n        sum += x;\n    }\n\n    if sum == max {\n\
    \        return true;\n    }\n\n    if sum >= w {\n        return false;\n   \
    \ }\n\n    let mut k = maxi;\n    while k != 0 {\n        let mut x = q[maxi -\
    \ (k as usize)];\n        q[k] = x;\n        sum += x;\n        k /= 2;\n    }\n\
    \n    sum == max && q == q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwc1b_77.rs:22:15\n   |\n\
    16 |     let mut max = 0;\n   |                   - expected due to this value\n\
    ...\n22 |         max = q.iter().max().unwrap();\n   |               ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         max = *q.iter().max().unwrap();\n   |               +\n\n\
    error[E0599]: no method named `pop_back` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpbwc1b_77.rs:24:11\n   |\n24 |         q.pop_back();\n\
    \   |           ^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut total = 0;\n  \
    \  for element in &q {\n        if element % 2 == 1 {\n            total += element;\n\
    \        }\n    }\n    total <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv979tup5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = w;\n\
    \    let mut balanced = false;\n    let mut sum = 0;\n    for v in q.iter() {\n\
    \        sum += v;\n        if sum > max_weight {\n            balanced = false;\n\
    \            break;\n        } else if sum == max_weight {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxa10w20y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n    \n    let mut sum = 0;\n    let mut found = false;\n\
    \    let mut i = q.len() - 1;\n    \n    while i >= 0 && !found {\n        sum\
    \ += q.unwrap()?;\n        if sum == w {\n            found = true;\n        }\n\
    \        i -= 1;\n    }\n    \n    found\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmph3gemd_g.rs:22:18\n   |\n22 |         sum +=\
    \ q.unwrap()?;\n   |                  ^^^^^^ help: there is an associated function\
    \ with a similar name: `swap`\n\nerror[E0277]: the `?` operator can only be used\
    \ in a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmph3gemd_g.rs:22:26\n   |\n12 | / fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n13 | |     if q.is_empty() {\n14 | |      \
    \   return true;\n15 | |     }\n...  |\n22 | |         sum += q.unwrap()?;\n \
    \  | |                          ^ cannot use the `?` operator in a function that\
    \ returns `bool`\n...  |\n29 | |     found\n30 | | }\n   | |_- this function should\
    \ return `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `bool`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     true\n    } else if !q.iter().all().is_ok() {\n        false\n    } else\
    \ {\n        let mut max_weight = 0;\n        let mut max_palindrom = false;\n\
    \        let mut sum = 0;\n        for elt in q.iter() {\n            let mut\
    \ weight = elt;\n            let mut palindrom = false;\n            sum += weight;\n\
    \            while weight > 0 {\n                weight -= 1;\n              \
    \  palindrom = palindrom || weight == 0;\n            }\n            if palindrom\
    \ {\n                max_palindrom = true;\n                max_weight = *max_weight;\n\
    \            } else if sum >= w {\n                max_palindrom = false;\n  \
    \              max_weight = *max_weight;\n            } else {\n             \
    \   max_weight = *max_weight + 1;\n            }\n        }\n        max_palindrom\
    \ && sum == w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpzth0et4_.rs:15:25\n     |\n15   |     } else if !q.iter().all().is_ok()\
    \ {\n     |                         ^^^- supplied 0 arguments\n     |        \
    \                 |\n     |                         expected 1 argument\n    \
    \ |\nnote: associated function defined here\n\nerror[E0599]: no method named `is_ok`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmpzth0et4_.rs:15:31\n\
    \   |\n15 |     } else if !q.iter().all().is_ok() {\n   |                    \
    \           ^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzth0et4_.rs:25:28\n   |\n25 |             while weight > 0 {\n\
    \   |                            ^\n   |                            |\n   |  \
    \                          expected `&isize`, found integer\n   |            \
    \                help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpzth0et4_.rs:26:17\n\
    \   |\n26 |                 weight -= 1;\n   |                 ------^^^^^\n \
    \  |                 |\n   |                 cannot use `-=` on type `&isize`\n\
    \   |\nhelp: `-=` can be used on `isize`, you can dereference `weight`\n   |\n\
    26 |                 *weight -= 1;\n   |                 +\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpzth0et4_.rs:27:49\n   |\n27\
    \ |                 palindrom = palindrom || weight == 0;\n   |              \
    \                                   ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmpzth0et4_.rs:31:30\n   |\n31 |                 max_weight = *max_weight;\n\
    \   |                              ^^^^^^^^^^^\n\nerror[E0614]:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut w: isize = q.reduce(0);\n\
    \    let mut sum: isize = 0;\n    for i in q {\n        sum += i;\n        if\
    \ w > sum {\n            return false;\n        }\n        w = w - i;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp8r6u27lf.rs:13:26\n\
    \    |\n13  |       let mut w: isize = q.reduce(0);\n    |                   \
    \         ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut max = w;\n    let mut sum = 0;\n    let mut i = 0;\n\n    while i\
    \ < q.len() {\n        let mut j = q.len();\n        while j > i {\n         \
    \   let w = (q[i] - q[j]).abs();\n            if w > max {\n                max\
    \ = w;\n            }\n            j--;\n        }\n        sum += q[i];\n   \
    \     q.pop();\n        i += 1;\n    }\n    if sum < max {\n        return false;\n\
    \    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i] != i {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpstfzgzh3.rs:25:16\n\
    \   |\n25 |             j--;\n   |                ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpstfzgzh3.rs:36:20\n   |\n36 |         if q[i]\
    \ != i {\n   |                    ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n36 |         if q[i] != i.try_into().unwrap() {\n   |           \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if !is_balanced(q) || w\
    \ == 0 { false }\n    else {\n        let mut c = 0;\n        let mut i = 0;\n\
    \        while i < q.len() {\n            if q[i] == w {\n                c +=\
    \ 1;\n                i += 1;\n            } else {\n                if c > q.len()\
    \ / 2 {\n                    return true;\n                }\n               \
    \ i += 1;\n                c = 0;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmphb27qbr5.rs:13:9\n\
    \   |\n13 |     if !is_balanced(q) || w == 0 { false }\n   |         ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb27qbr5.rs:13:36\n\
    \   |\n13 |       if !is_balanced(q) || w == 0 { false }\n   |       -       \
    \                       ^^^^^ expected `()`, found `bool`\n   |  _____|\n   |\
    \ |\n14 | |     else {\n15 | |         let mut c = 0;\n16 | |         let mut\
    \ i = 0;\n...  |\n28 | |         }\n29 | |     }\n   | |_____- expected this to\
    \ be `()`\n   |\nhelp: you might have meant to return this value\n   |\n13 | \
    \    if !is_balanced(q) || w == 0 { return false; }\n   |                    \
    \                ++++++      +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return false;\n    }\n\n    let mut max_weight = 0;\n    let mut max_weight_position\
    \ = 0;\n    for i in q {\n        let mut w2 = i;\n        while let Some(i) =\
    \ q.remove(i) {\n            if i < w2 {\n                w2 -= i;\n         \
    \   } else {\n                return false;\n            }\n        }\n      \
    \  if w2 > max_weight {\n            max_weight = w2;\n            max_weight_position\
    \ = i;\n        }\n    }\n\n    let mut sum = 0;\n    for i in q {\n        sum\
    \ += i;\n    }\n\n    return sum == max_weight && max_weight_position == q.len()\
    \ - 1;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdszs64gk.rs:21:38\n   |\n\
    21 |         while let Some(i) = q.remove(i) {\n   |                         \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n21\
    \ |         while let Some(i) = q.remove(i.try_into().unwrap()) {\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdszs64gk.rs:21:19\n   |\n21 |         while let Some(i)\
    \ = q.remove(i) {\n   |                   ^^^^^^^   ----------- this expression\
    \ has type `isize`\n   |                   |\n   |                   expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdszs64gk.rs:39:56\n\
    \   |\n39 |     return sum == max_weight && max_weight_position == q.len() - 1;\n\
    \   |                                                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n39 |     return sum == max_weight\
    \ && max_weight_position == (q.len() - 1).try_into().unwrap();\n   |         \
    \                                               +           +++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut qr = q.to_vec();\n\
    \    qr.sort();\n    let mut max = q.len();\n    let mut sum = 0;\n    let mut\
    \ i = 0;\n    while i < qr.len() {\n        if qr[i] > max {\n            max\
    \ = qr[i];\n        }\n        sum += qr[i];\n        i += 1;\n    }\n    if sum\
    \ + w <= max {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvsbzwccs.rs:19:20\n   |\n\
    19 |         if qr[i] > max {\n   |                    ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |         if qr[i] > max.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvsbzwccs.rs:20:19\n   |\n15 |     let mut max = q.len();\n\
    \   |                   ------- expected due to this value\n...\n20 |        \
    \     max = qr[i];\n   |                   ^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvsbzwccs.rs:25:19\n   |\n25 |\
    \     if sum + w <= max {\n   |                   ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     if sum + w <= max.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    q.reverse();\n    let mut sum = 0;\n    let mut max_possible = w;\n    while\
    \ !q.is_empty() {\n        sum += q.last().unwrap();\n        if sum > max_possible\
    \ {\n            break;\n        }\n        q.pop();\n    }\n    sum == max_possible\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpggws6n56.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    (0..q.len()).all(|i| q[i]==i\
    \ || will_it_fly(q.iter().rev().take(i).collect::<Vec<_>>(), w))\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxeapskrc.rs:13:32\n   |\n\
    13 |     (0..q.len()).all(|i| q[i]==i || will_it_fly(q.iter().rev().take(i).collect::<Vec<_>>(),\
    \ w))\n   |                                ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     (0..q.len()).all(|i| q[i]==i.try_into().unwrap()\
    \ || will_it_fly(q.iter().rev().take(i).collect::<Vec<_>>(), w))\n   |       \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxeapskrc.rs:13:49\n   |\n13 |     (0..q.len()).all(|i| q[i]==i\
    \ || will_it_fly(q.iter().rev().take(i).collect::<Vec<_>>(), w))\n   |       \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n    let mut rev_q = q;\n    rev_q.swap(0, qlen - 1);\n\
    \    let mut max_weight = 0;\n    let mut is_balanced = false;\n    for &n in\
    \ &q {\n        if n != 0 {\n            (*q).remove(n);\n            if n ==\
    \ rev_q[0] {\n                if w == n {\n                    is_balanced = true;\n\
    \                } else {\n                    max_weight = max_weight + w;\n\
    \                }\n            }\n        }\n    }\n    !is_balanced && max_weight\
    \ <= w && max_weight <= qlen\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `qlen` in this scope\n  --> /tmp/tmpsip0n04c.rs:17:19\n\
    \   |\n17 |     rev_q.swap(0, qlen - 1);\n   |                   ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `qlen` in this scope\n  -->\
    \ /tmp/tmpsip0n04c.rs:32:54\n   |\n32 |     !is_balanced && max_weight <= w &&\
    \ max_weight <= qlen\n   |                                                   \
    \   ^^^^ not found in this scope\n\nerror[E0599]: no method named `remove` found\
    \ for slice `[isize]` in the current scope\n  --> /tmp/tmpsip0n04c.rs:22:18\n\
    \   |\n22 |             (*q).remove(n);\n   |                  ^^^^^^ method not\
    \ found in `[isize]`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut s = q.len() - 1;\n    while s != 0 {\n        let i = q.len() - 1;\n\
    \        if q[i] >= w {\n            q[i] = q[i] - (w - 1);\n            s -=\
    \ 1;\n        } else {\n            q[i] = (q[i] + w) % 10;\n            s -=\
    \ 1;\n        }\n    }\n    let len = q.len();\n    if len <= 1 {\n        false\n\
    \    } else if len <= 2 {\n        q.iter().all(|&x| x == q[len-1])\n    } else\
    \ {\n        let a = q[len-2], b = q[len-1];\n        q.iter().all(|&x| x == a\
    \ || x == b)\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n\
    \  --> /tmp/tmprlbtxynz.rs:31:25\n   |\n31 |         let a = q[len-2], b = q[len-1];\n\
    \   |                         ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_owned();\n\
    \    let mut c = 0;\n    while c.cmp(&0) == 1 {\n        if q.len() == 0 {\n \
    \           return false;\n        }\n        c += q.front();\n        q.pop();\n\
    \    }\n    if w.is_negative() {\n        if q.is_empty() {\n            return\
    \ true;\n        } else {\n            return false;\n        }\n    } else {\n\
    \        if q.is_empty() {\n            return true;\n        } else {\n     \
    \       if q.len() <= w {\n                return false;\n            }\n    \
    \        for (mut i, w) in q.iter().enumerate() {\n                if w >= i {\n\
    \                    return false;\n                }\n            }\n       \
    \     true\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiozuvoms.rs:15:24\n   |\n\
    15 |     while c.cmp(&0) == 1 {\n   |                        ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpiozuvoms.rs:19:16\n   |\n19 |         c\
    \ += q.front();\n   |                ^^^^^ method not found in `Vec<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiozuvoms.rs:32:27\n   |\n32 |  \
    \           if q.len() <= w {\n   |                           ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n32 |             if q.len() <= w.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiozuvoms.rs:36:25\n   |\n36 |                 if w >= i\
    \ {\n   |                         ^ expected `&isize`, found `usize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced_sum =\
    \ 0;\n    for i in q {\n        balanced_sum += i;\n        if balanced_sum >\
    \ w {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptev8j2ua.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return false\n    }\n    if w == 0 {\n        return true\n    }\n    let\
    \ mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum >= w {\n\
    \        return true\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5tfm9907.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = true;\n\
    \    let mut max_weight = 0;\n    for x in q {\n        if x > w {\n         \
    \   continue;\n        }\n        \n        if x % 2 == 0 {\n            balanced\
    \ = !balanced;\n        }\n        max_weight += x;\n    }\n\n    balanced &&\
    \ (max_weight <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp748p7v3s.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return q.len() == 1;\n    }\n    let mut sum = 0;\n    let mut max_w = 0;\n\
    \    let mut first_element = q.iter().next().unwrap();\n    for i in q.iter()\
    \ {\n        if *i < first_element {\n            sum += *i;\n            if sum\
    \ > max_w {\n                max_w = sum;\n            }\n        }\n        if\
    \ *i == first_element {\n            sum += *i;\n        }\n    }\n    max_w ==\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvgc7lr6.rs:20:17\n   |\n\
    20 |         if *i < first_element {\n   |                 ^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    20 |         if *i < *first_element {\n   |                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzvgc7lr6.rs:26:18\n   |\n26 |         if *i\
    \ == first_element {\n   |                  ^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |        \
    \ if *i == *first_element {\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q\n        .iter()\n  \
    \      .fold(false, |acc, e| match acc {\n            true => acc,\n         \
    \   false => acc && ((w + e) % e == 0),\n        })\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppgdn4idd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    match will_it_fly_impl(&q,\
    \ w) {\n        true => true,\n        false => false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `will_it_fly_impl` in this scope\n \
    \ --> /tmp/tmpfxq_srgj.rs:13:11\n   |\n13 |     match will_it_fly_impl(&q, w)\
    \ {\n   |           ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut v = vec![false;\
    \ q.len()];\n    let mut j = -1;\n    for i in q.len() {\n        if v[i as usize]\
    \ {\n            return false;\n        }\n        v[i as usize] = true;\n   \
    \     let mut sum = 0;\n        for j in 0..v.len() {\n            if j == i as\
    \ usize {\n                continue;\n            }\n            sum += v[j as\
    \ usize];\n        }\n        if sum > w {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmplgwc2s3i.rs:15:14\n\
    \   |\n15 |     for i in q.len() {\n   |              ^^^^^^^ `usize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `usize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror[E0277]: cannot add-assign `bool` to `{integer}`\n  -->\
    \ /tmp/tmplgwc2s3i.rs:25:17\n   |\n25 |             sum += v[j as usize];\n  \
    \ |                 ^^ no implementation for `{integer} += bool`\n   |\n   = help:\
    \ the trait `AddAssign<bool>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut balanced = false;\n\
    \    let mut wmax = w;\n    loop {\n        if balanced {\n            break;\n\
    \        }\n        loop {\n            let mut cur = q.last().unwrap();\n   \
    \         q.last_mut().unwrap().push(balanced);\n            if w == wmax {\n\
    \                let mut i = 1;\n                while i < q.len() {\n       \
    \             if q[i] != cur {\n                        let balanced = false;\n\
    \                        break;\n                    }\n                    i\
    \ += 1;\n                }\n                break;\n            }\n          \
    \  wmax -= 1;\n        }\n        wmax += 1;\n        balanced = true;\n    }\n\
    \    !balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for mutable reference `&mut\
    \ isize` in the current scope\n  --> /tmp/tmpybk9dq7o.rs:21:35\n   |\n21 |   \
    \          q.last_mut().unwrap().push(balanced);\n   |                       \
    \            ^^^^ method not found in `&mut isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpybk9dq7o.rs:25:32\n   |\n25 |                     if q[i]\
    \ != cur {\n   |                                ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n25 |                   \
    \  if q[i] != *cur {\n   |                                +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let max_weight = |q| {\n\
    \        let mut sum = q[0];\n        for v in q.iter_mut() {\n            sum\
    \ += v;\n        }\n        sum\n    };\n    \n    let mut is_balanced = true;\n\
    \    if q.is_empty() {\n        is_balanced = false;\n    } else {\n        let\
    \ mut max_weight = max_weight(q);\n        let mut q = q.clone();\n        q.pop_back();\n\
    \        if q.len() > w {\n            is_balanced = false;\n            q = q.clone();\n\
    \            q.pop_back();\n        }\n        let mut sum = q[0];\n        for\
    \ v in q.iter_mut() {\n            sum += v;\n        }\n        if max_weight\
    \ == sum {\n            is_balanced = true;\n        }\n    }\n    is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpyo2ct_qy.rs:13:23\n\
    \   |\n13 |     let max_weight = |q| {\n   |                       ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0599]: no method named `pop_back` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpyo2ct_qy.rs:27:11\n   |\n27 |         q.pop_back();\n\
    \   |           ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyo2ct_qy.rs:28:22\n   |\n28 |         if q.len() > w {\n\
    \   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |         if q.len() > w.try_into().unwrap() {\n   |         \
    \              ++++++++++++++++++++\n\nerror[E0599]: no method named `pop_back`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpyo2ct_qy.rs:31:15\n\
    \   |\n31 |             q.pop_back();\n   |               ^^^^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0277]: cannot add-assign `&mut isize` to `isize`\n\
    \  --> /tmp/tmpyo2ct_qy.rs:35:17\n   |\n35 |             sum += v;\n   |     \
    \            ^^ no implementation for `isize += &mut isize`\n   |\n   = help:\
    \ the trait `AddAssign<&mut isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `AddAssign<Rhs>`:\n             <f32\
    \ as AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0282, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut b = true\n    \n\
    \    for i in q.iter() {\n        if i == q.len() - 1 {\n            b = false\n\
    \            break\n        }\n    \n        if !is_balanced(&q[..i]) {\n    \
    \        b = false\n            break\n        }\n    \n        for j in 0..i\
    \ {\n            let x = q[i..j + 1]\n            if !is_balanced(x) {\n     \
    \           b = false\n                break\n            }\n        }\n    }\n\
    \    \n    b && (q.rev().iter().sum() <= w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpc14y4jv8.rs:13:21\n\
    \   |\n13 |     let mut b = true\n   |                     ^ help: add `;` here\n\
    14 |     \n15 |     for i in q.iter() {\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `break`\n  --> /tmp/tmpc14y4jv8.rs:17:22\n   |\n\
    17 |             b = false\n   |                      ^ help: add `;` here\n18\
    \ |             break\n   |             ----- unexpected token\n\nerror: expected\
    \ `;`, found keyword `break`\n  --> /tmp/tmpc14y4jv8.rs:22:22\n   |\n22 |    \
    \         b = false\n   |                      ^ help: add `;` here\n23 |    \
    \         break\n   |             ----- unexpected token\n\nerror: expected `;`,\
    \ found keyword `if`\n  --> /tmp/tmpc14y4jv8.rs:27:32\n   |\n27 |            \
    \ let x = q[i..j + 1]\n   |                                ^ help: add `;` here\n\
    28 |             if !is_balanced(x) {\n   |             -- unexpected token\n\n\
    error: expected `;`, found keyword `break`\n  --> /tmp/tmpc14y4jv8.rs:29:26\n\
    \   |\n29 |                 b = false\n   |                          ^ help: add\
    \ `;` here\n30 |                 break\n   |                 ----- unexpected\
    \ token\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n  -->\
    \ /tmp/tmpc14y4jv8.rs:21:13\n   |\n21 |         if !is_balanced(&q[..i]) {\n \
    \  |             ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_balanced` in this scope\n  --> /tmp/tmpc14y4jv8.rs:28:17\n   |\n\
    28 |             if !is_balanced(x) {\n   |                 ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc14y4jv8.rs:16:17\n\
    \   |\n16 |         if i == q.len() - 1 {\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpc14y4jv8.rs:16:14\n   |\n16 |         if i == q.len() - 1 {\n \
    \  |              ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \    "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_owned();\n\
    \    let mut maximum = w;\n    q.sort_unstable();\n    match q.len() {\n     \
    \   1 => false,\n        2 => will_it_fly(q, w),\n        _ => {\n           \
    \ let mut runningSum = 0;\n            loop {\n                if maximum < q[0]\
    \ + q[1] {\n                    maximum = q[0] + q[1];\n                }\n  \
    \              if maximum < w {\n                    return true;\n          \
    \      }\n                if q[0] == q[1] {\n                    break;\n    \
    \            }\n                runningSum += q[0];\n                q.swap(0,\
    \ 1);\n            }\n            return runningSum >= w;\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return false;\n    }\n\n    let mut max_weight = 0;\n    for i in 0..q.len()\
    \ - 1 {\n        if q[i] > max_weight {\n            max_weight = q[i];\n    \
    \    }\n    }\n\n    for i in 0..q.len() - 1 {\n        if q[i] == max_weight\
    \ {\n            continue;\n        }\n        if q[i] > w-max_weight+q[i+1] {\n\
    \            return false;\n        }\n    }\n\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp6rlo2i4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q.to_vec();\n\
    \    let mut max = w;\n    while q.len() > 0 {\n        if *q % 10 == 0 {\n  \
    \          *q -= 10;\n        }\n        max += *q as isize;\n        q.pop();\n\
    \    }\n    max <= w && q.len() == 0\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `[isize]` by `{integer}`\n  --> /tmp/tmp0fehhm5u.rs:16:15\n\
    \   |\n16 |         if *q % 10 == 0 {\n   |            -- ^ -- {integer}\n   |\
    \            |\n   |            [isize]\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `[isize]`\n  --> /tmp/tmp0fehhm5u.rs:17:13\n\
    \   |\n17 |             *q -= 10;\n   |             --^^^^^^\n   |           \
    \  |\n   |             cannot use `-=` on type `[isize]`\n\nerror[E0605]: non-primitive\
    \ cast: `[isize]` as `isize`\n  --> /tmp/tmp0fehhm5u.rs:19:16\n   |\n19 |    \
    \     max += *q as isize;\n   |                ^^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0368, E0369, E0605.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    debug_assert!(q.len() ==\
    \ 2);\n    debug_assert!(w >= 0);\n    if will_it_fly_impl(q, w) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `will_it_fly_impl` in this scope\n \
    \ --> /tmp/tmp1rbao5lf.rs:15:8\n   |\n15 |     if will_it_fly_impl(q, w) {\n \
    \  |        ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max_weight = 0\
    \ as usize;\n    for num in q {\n        max_weight = std::cmp::max(num, max_weight);\n\
    \    }\n    if max_weight > w as usize {\n        return false;\n    }\n    let\
    \ mut sum_nums = 0; // the sum of all nums in q\n    for num in q.iter() {\n \
    \       sum_nums = sum_nums + num;\n    }\n    sum_nums <= w as usize\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3deebbq.rs:15:36\n   |\n\
    15 |         max_weight = std::cmp::max(num, max_weight);\n   |              \
    \                      ^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n15 |         max_weight = std::cmp::max(num.try_into().unwrap(), max_weight);\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph3deebbq.rs:24:17\n   |\n24 |     sum_nums <=\
    \ w as usize\n   |                 ^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     sum_nums <= (w as usize).try_into().unwrap()\n\
    \   |                 +          +++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return true;\n    }\n    if q.is_panic() {\n        return false;\n    }\n\
    \    let mut q = q.as_ref().to_owned();\n    let mut sum = 0;\n    for i in q.iter()\
    \ {\n        sum += i;\n    }\n    let mut max = 0;\n    for i in 0..q.len() {\n\
    \        if sum > max {\n            max = sum;\n        }\n        sum -= q[i];\n\
    \    }\n    sum >= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_panic` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpn0mbp3dl.rs:16:10\n   |\n16 |     if q.is_panic()\
    \ {\n   |          ^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut max: isize = 0;\n\
    \    for &e in q {\n        max += e;\n    }\n\n    let mut sum: isize = 0;\n\
    \    for &e in q {\n        if !q.is_palindrome() {\n            return false;\n\
    \        }\n\n        sum += e;\n    }\n\n    if sum < w {\n        return false;\n\
    \    }\n\n    let mut w1: isize = 0;\n    for &e in q {\n        if q[q.len()\
    \ - 1] == e {\n            w1 += e;\n        } else {\n            return false;\n\
    \        }\n    }\n\n    if w1 < w {\n        return false;\n    }\n\n    if sum\
    \ > max {\n        return true;\n    }\n\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc27oe67n.rs:14:9\n   |\n\
    14 |     for &e in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `e`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc27oe67n.rs:19:9\n   |\n19 |     for &e in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `e`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0599]: no method named `is_palindrome` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpc27oe67n.rs:20:15\n\
    \   |\n20 |         if !q.is_palindrome() {\n   |               ^^^^^^^^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc27oe67n.rs:32:9\n\
    \   |\n32 |     for &e in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `e`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    if q.len() == 0 || q.iter().next().unwrap() !=\
    \ q[0] {\n        return false;\n    }\n    let mut sum = 0;\n    for i in q.iter()\
    \ {\n        sum += i;\n    }\n    let mut max = w;\n    for i in q.iter().rev()\
    \ {\n        if i > max {\n            return false;\n        }\n        max -=\
    \ i;\n    }\n    sum < max\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp_g_wfql9.rs:16:49\n\
    \   |\n16 |     if q.len() == 0 || q.iter().next().unwrap() != q[0] {\n   |  \
    \                                               ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g_wfql9.rs:25:16\n\
    \   |\n25 |         if i > max {\n   |                ^^^\n   |              \
    \  |\n   |                expected `&isize`, found `isize`\n   |             \
    \   help: consider borrowing here: `&max`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut qr = q.len() /\
    \ 2;\n    let mut sum: isize = 0;\n    while qr.is_ok() && sum < w {\n       \
    \ let cur = qr / 2;\n        qr -= cur;\n        let a = q[cur as usize];\n  \
    \      let b = q[qr as usize];\n        sum += a.checked_add(b).unwrap();\n  \
    \  }\n    sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpllput3xf.rs:15:14\n   |\n15 |     while qr.is_ok() && sum\
    \ < w {\n   |              ^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().map(|x| x-w).all(|x|\
    \ x <= 0)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptvzz1p0w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return true;\n    }\n    let mut sum: isize = 0;\n    for i in 0..q.len()\
    \ {\n        sum += q[i];\n    }\n    if sum < w {\n        return false;\n  \
    \  }\n    let mut i = 1;\n    while i <= q.len() {\n        let mut j = 1;\n \
    \       while j <= q.len() {\n            if i == j {\n                return\
    \ false;\n            }\n            if q[i] == q[j] {\n                j++;\n\
    \            } else {\n                if q[i] == q[j - 1] {\n               \
    \     j--;\n                }\n                break;\n            }\n       \
    \ }\n        i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgdz_yjet.rs:31:18\n\
    \   |\n31 |                 j++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |                 { let tmp\
    \ = j; j += 1; tmp };\n   |                 +++++++++++  ~~~~~~~~~~~~~~~\n31 -\
    \                 j++;\n31 +                 j += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmpgdz_yjet.rs:34:24\n   |\n34 |         \
    \            j--;\n   |                        ^ expected expression\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = q.len();\n\
    \    while s > 0 {\n        if n % 2 == 0 {\n            s /= 2;\n        } else\
    \ {\n            s = s - 1;\n        }\n        n = n % 2;\n        if n < w {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `n` in this scope\n  --> /tmp/tmps9ikvod0.rs:15:12\n\
    \   |\n15 |         if n % 2 == 0 {\n   |            ^ help: a local variable\
    \ with a similar name exists: `q`\n\nerror[E0425]: cannot find value `n` in this\
    \ scope\n  --> /tmp/tmps9ikvod0.rs:20:9\n   |\n20 |         n = n % 2;\n   | \
    \        ^ help: a local variable with a similar name exists: `q`\n\nerror[E0425]:\
    \ cannot find value `n` in this scope\n  --> /tmp/tmps9ikvod0.rs:20:13\n   |\n\
    20 |         n = n % 2;\n   |             ^ help: a local variable with a similar\
    \ name exists: `q`\n\nerror[E0425]: cannot find value `n` in this scope\n  -->\
    \ /tmp/tmps9ikvod0.rs:21:12\n   |\n21 |         if n < w {\n   |            ^\
    \ help: a local variable with a similar name exists: `q`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() > 0 && q.len()\
    \ < w {\n        return q.reverse().iter().all(|&x| x == q[0]) || (q[0] + q[1]\
    \ == 2 * w);\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixd7s9dn.rs:13:33\n   |\n\
    13 |     if q.len() > 0 && q.len() < w {\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n13 |     if q.len()\
    \ > 0 && q.len() < w.try_into().unwrap() {\n   |                             \
    \     ++++++++++++++++++++\n\nerror[E0599]: no method named `iter` found for unit\
    \ type `()` in the current scope\n  --> /tmp/tmpixd7s9dn.rs:14:28\n   |\n14 |\
    \         return q.reverse().iter().all(|&x| x == q[0]) || (q[0] + q[1] == 2 *\
    \ w);\n   |                            ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // TODO: write code here.\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6p9jlgx_.rs:12:44\n   |\n\
    12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    \n    if q.len() <= 1 {\n\
    \        return false;\n    }\n\n    let mut q = q.to_vec();\n    q.sort();\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    let mut found = false;\n\
    \n    q.iter().for_each(|x| {\n        \n        if x == 0 {\n            sum\
    \ += 1;\n        } else {\n            sum += x;\n        }\n\n        if sum\
    \ == w {\n            found = true;\n        }\n\n        if sum > w {\n     \
    \       max_weight = sum;\n        }\n    });\n\n    if found {\n        max_weight\n\
    \    } else {\n        max_weight + 1\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmposh0dxzh.rs:26:14\n\
    \   |\n26 |         if x == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmposh0dxzh.rs:42:9\n\
    \   |\n12 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n42 |         max_weight\n   |         ^^^^^^^^^^ expected `bool`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmposh0dxzh.rs:44:9\n   |\n12 | fn\
    \ will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |                       \
    \                     ---- expected `bool` because of return type\n...\n44 | \
    \        max_weight + 1\n   |         ^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = q.len();\n\
    \    let mut max = w.to_f();\n    while i > 0 {\n        if will_it_fly_aux(i,\
    \ q[i ..], max, w) {\n            max = w + q[i ..].iter().map(|e| e.to_f()).max().unwrap();\n\
    \        }\n        i -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `will_it_fly_aux` in this scope\n  -->\
    \ /tmp/tmpf37tfomj.rs:16:12\n   |\n16 |         if will_it_fly_aux(i, q[i ..],\
    \ max, w) {\n   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `to_f` found for type `isize` in the current scope\n  --> /tmp/tmpf37tfomj.rs:14:21\n\
    \   |\n14 |     let mut max = w.to_f();\n   |                     ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `to_f` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpf37tfomj.rs:17:48\n   |\n17 | \
    \            max = w + q[i ..].iter().map(|e| e.to_f()).max().unwrap();\n   |\
    \                                                ^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum_weight: isize\
    \ = 0;\n    let mut is_balanced = true;\n\n    for el in q {\n        if el >\
    \ w {\n            is_balanced = false;\n            break;\n        }\n     \
    \   sum_weight += el;\n    }\n\n    if sum_weight > w {\n        is_balanced =\
    \ false;\n    }\n\n    is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw49l6yqj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.is_empty() {\n   \
    \     return false\n    }\n    let mut max_weight = 0;\n    let mut curr = q[0];\n\
    \    for &weight in q {\n        max_weight = max(max_weight, weight);\n     \
    \   if curr != weight {\n            if max_weight >= w {\n                return\
    \ true;\n            }\n        }\n        curr = weight;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp_2ch371x.rs:19:22\n\
    \   |\n19 |         max_weight = max(max_weight, weight);\n   |              \
    \        ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_2ch371x.rs:18:9\n   |\n18 |     for &weight in q {\n   |         ^^^^^^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `weight`\n   |\n   = note:   expected type `isize`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut is_balanced = true;\n\
    \    let mut max_weight = 0;\n    for i in q {\n        if i != i + w {\n    \
    \        is_balanced = false;\n        }\n        max_weight += i;\n    }\n  \
    \  if max_weight >= w {\n        return is_balanced;\n    }\n    else if max_weight\
    \ > w {\n        return false;\n    }\n    else if max_weight <= w && is_balanced\
    \ {\n        return true;\n    }\n    else {\n        return will_it_fly(q, w);\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpy6ns16yw.rs:31:28\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n31  |         return will_it_fly(q,\
    \ w);\n    |                            ^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `q`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let max_possible_weight\
    \ = w;\n    let mut sum = 0;\n    for el in q {\n        sum += el;\n    }\n \
    \   \n    let mut is_balanced = false;\n    for el in q {\n        if el > sum\
    \ / 2 {\n            is_balanced = true;\n            break;\n        }\n    }\n\
    \    \n    let is_palindromic = (&q == q.iter().rev().collect::<Vec<_>>()).all(|&x|\
    \ x == x.to_str());\n    \n    sum > max_possible_weight && is_balanced && is_palindromic\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `all` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpw89k4j6s.rs:27:69\n   |\n27 |     let is_palindromic =\
    \ (&q == q.iter().rev().collect::<Vec<_>>()).all(|&x| x == x.to_str());\n   |\
    \                                                                     ^^^ method\
    \ not found in `bool`\n\nerror[E0277]: can't compare `&Vec<isize>` with `Vec<&isize>`\n\
    \  --> /tmp/tmpw89k4j6s.rs:27:30\n   |\n27 |     let is_palindromic = (&q == q.iter().rev().collect::<Vec<_>>()).all(|&x|\
    \ x == x.to_str());\n   |                              ^^ no implementation for\
    \ `&Vec<isize> == Vec<&isize>`\n   |\n   = help: the trait `PartialEq<Vec<&isize>>`\
    \ is not implemented for `&Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    fn is_balanced(s: &[isize])\
    \ -> bool {\n        let mut a = s.iter().cloned().collect::<Vec<_>>();\n    \
    \    let mut b = s.iter().cloned().rev().collect::<Vec<_>>();\n        let mut\
    \ total = 0;\n        while a.len() > 0 && b.len() > 0 {\n            total +=\
    \ *a.last().unwrap();\n            a.pop();\n            b.pop();\n        }\n\
    \        total >= w\n    }\n    let mut l = q.iter().cloned().collect::<Vec<_>>();\n\
    \    match is_balanced(&l) {\n        true => true,\n        false => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpk2s0fa8i.rs:22:18\n\
    \   |\n22 |         total >= w\n   |                  ^\n   |\n   = help: use\
    \ the `|| { ... }` closure form instead\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Write your code here.\n\
    \    let mut sum = 0;\n    for i in q {\n        if i > w {\n            return\
    \ false;\n        }\n        sum += i;\n    }\n    if sum < w {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpugavzy73.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 {\n   \
    \     return true\n    }\n    let mut min_weight: isize = w.to_i();\n    let mut\
    \ balanced = false;\n    for elt in q.iter().rev() {\n        min_weight = elt.min(min_weight);\n\
    \        if min_weight > w {\n            balanced = true;\n            break;\n\
    \        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_i` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp47mnc0e5.rs:16:35\n   |\n16 |     let mut min_weight: isize\
    \ = w.to_i();\n   |                                   ^^^^ method not found in\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp47mnc0e5.rs:19:30\n\
    \   |\n19 |         min_weight = elt.min(min_weight);\n   |                  \
    \            ^^^^^^^^^^\n   |                              |\n   |           \
    \                   expected `&isize`, found `isize`\n   |                   \
    \           help: consider borrowing here: `&min_weight`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp47mnc0e5.rs:19:22\n   |\n16 |     let mut min_weight: isize\
    \ = w.to_i();\n   |                         ----- expected due to this type\n\
    ...\n19 |         min_weight = elt.min(min_weight);\n   |                    \
    \  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |         min_weight = *elt.min(min_weight);\n\
    \   |                      +\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
