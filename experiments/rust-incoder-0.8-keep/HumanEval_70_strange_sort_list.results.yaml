name: HumanEval_70_strange_sort_list
language: rust
results:
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min = *lst.iter().min().unwrap();\n    let mut max\
    \ = *lst.iter().max().unwrap();\n    for &i in &lst[..] {\n        if i > max\
    \ {\n            max = i;\n        }\n        if i < min {\n            min =\
    \ i;\n        }\n    }\n    let mut new_lst = vec![];\n    for i in &lst {\n \
    \       if i == min {\n            new_lst.push(*i);\n        }\n        if i\
    \ == max {\n            new_lst.push(*i);\n        }\n    }\n    new_lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2h6wmrr9.rs:21:14\n\
    \   |\n21 |         if i == min {\n   |              ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmp2h6wmrr9.rs:24:14\n   |\n24 |         if i == max {\n   |          \
    \    ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut min_num\
    \ = std::i32::MAX as isize;\n    let mut max_num = std::i32::MIN as isize;\n \
    \   let mut min_val = std::i32::MAX as isize;\n    let mut max_val = std::i32::MIN\
    \ as isize;\n\n    for val in lst {\n        if val < min_num {\n            min_num\
    \ = val;\n        }\n\n        if val > max_num {\n            max_num = val;\n\
    \        }\n\n        if val < min_val {\n            min_val = val;\n       \
    \ }\n\n        if val > max_val {\n            max_val = val;\n        }\n   \
    \ }\n\n    for i in min_val..max_val {\n        result.push(i);\n    }\n\n   \
    \ for i in max_num..min_num {\n        result.push(i);\n    }\n\n    for i in\
    \ min_num..max_num {\n        result.push(i);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 1, 2, 3]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpe3xp_tth.rs:50:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n   \
    \ let mut result = vec![lst[0]];\n    let mut current_min = lst[0];\n\n    for\
    \ ele in lst.iter().skip(1) {\n        if ele < current_min {\n            result.push(ele);\n\
    \        } else {\n            result.push(current_min);\n            result.push(ele);\n\
    \        }\n        current_min = ele;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqv9qfs5.rs:17:18\n   |\n\
    17 |         if ele < current_min {\n   |                  ^^^^^^^^^^^\n   | \
    \                 |\n   |                  expected `&isize`, found `isize`\n\
    \   |                  help: consider borrowing here: `&current_min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmqv9qfs5.rs:18:25\n   |\n18 |             result.push(ele);\n\
    \   |                         ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n18 |             result.push(*ele);\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmqv9qfs5.rs:21:25\n\
    \   |\n21 |             result.push(ele);\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |             result.push(*ele);\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmqv9qfs5.rs:23:23\n   |\n14 |     let mut current_min\
    \ = lst[0];\n   |                           ------ expected due to this value\n\
    ...\n23 |         current_min = ele;\n   |                       ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |         current_min = *ele;\n   |                       +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut reversed = lst;\n\n    reversed.reverse();\n\n   \
    \ reversed.reverse();\n\n    reversed\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpab2mjez3.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![std::ptr::null::<isize>(); lst.len()];\n\
    \n    let mut min_isize = std::ptr::null::<isize>();\n    let mut max_isize =\
    \ std::ptr::null::<isize>();\n\n    for v in lst {\n        min_isize = std::cmp::min(min_isize,\
    \ v);\n        max_isize = std::cmp::max(max_isize, v);\n    }\n\n    if max_isize\
    \ == min_isize {\n        return lst;\n    }\n\n    let mut min_val = min_isize;\n\
    \    let mut max_val = max_isize;\n    while min_val < max_val {\n        let\
    \ v = lst[min_val];\n        sorted_list.set_len(min_val + 1);\n        sorted_list.push(v);\n\
    \n        min_val += 1;\n        max_val -= 1;\n    }\n\n    return sorted_list;\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoiyam3f1.rs:15:46\n   |\n\
    15 |         min_isize = std::cmp::min(min_isize, v);\n   |                  \
    \                            ^ expected *-ptr, found `isize`\n   |\n   = note:\
    \ expected raw pointer `*const isize`\n                     found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoiyam3f1.rs:16:46\n   |\n16 |\
    \         max_isize = std::cmp::max(max_isize, v);\n   |                     \
    \                         ^ expected *-ptr, found `isize`\n   |\n   = note: expected\
    \ raw pointer `*const isize`\n                     found type `isize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `*const isize`\n  --> /tmp/tmpoiyam3f1.rs:26:17\n\
    \   |\n26 |         let v = lst[min_val];\n   |                 ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `*const isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<*const isize>` for `Vec<isize>`\n\n\
    error[E0369]: cannot add `{integer}` to `*const isize`\n  --> /tmp/tmpoiyam3f1.rs:27:37\n\
    \   |\n27 |         sorted_list.set_len(min_val + 1);\n   |                  \
    \           ------- ^ - {integer}\n   |                             |\n   |  \
    \                           *const isize\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `*const isize`\n  --> /tmp/tmpoiyam3f1.rs:30:9\n\
    \   |\n30 |         min_val += 1;\n   |         -------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `*const isize`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `*const isize`\n  --> /tmp/tmpoiyam3f1.rs:31:9\n\
    \   |\n31 |         max_val -= 1;\n   |         -------^^^^^\n   |         |\n\
    \   |         cannot use `-=` on type `*const isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoiyam3f1.rs:34:12\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list_copy: Vec<isize> = lst.clone();\n    list_copy.sort();\n\
    \    list_copy\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpyne_8hy2.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min_value = lst.iter().min().unwrap();\n    let mut\
    \ max_value = lst.iter().max().unwrap();\n    let mut new_list = lst;\n    while\
    \ min_value < max_value {\n        let mut new_list = lst;\n        while min_value\
    \ < max_value {\n            if new_list.iter().any(|&x| x == min_value) {\n \
    \               new_list.remove(min_value);\n                min_value += 1;\n\
    \            }\n        }\n        new_list = new_list.into_iter().sorted_by(|a,\
    \ b| b - a);\n        max_value -= 1;\n    }\n    new_list.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3nvyngx.rs:15:46\n   |\n\
    15 |             if new_list.iter().any(|&x| x == min_value) {\n   |         \
    \                                     ^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             if new_list.iter().any(|&x|\
    \ x == *min_value) {\n   |                                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd3nvyngx.rs:16:33\n   |\n16 |  \
    \               new_list.remove(min_value);\n   |                            \
    \     ^^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpd3nvyngx.rs:17:17\n\
    \   |\n17 |                 min_value += 1;\n   |                 ---------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&isize`\n\
    \   |\nhelp: `+=` can be used on `isize`, you can dereference `min_value`\n  \
    \ |\n17 |                 *min_value += 1;\n   |                 +\n\nerror[E0599]:\
    \ no method named `sorted_by` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpd3nvyngx.rs:20:41\n   |\n20 |         new_list = new_list.into_iter().sorted_by(|a,\
    \ b| b - a);\n   |                                         ^^^^^^^^^ method not\
    \ found in `std::vec::IntoIter<isize>`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpd3nvyngx.rs:21:9\n  \
    \ |\n21 |         max_value -= 1;\n   |         ---------^^^^^\n   |         |\n\
    \   |         cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used on\
    \ `isize`, you can dereference `max_value`\n   |\n21 |         *max_value -= 1;\n\
    \   |         +\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst;\n    let mut i = 0;\n    loop {\n     \
    \   let j = i;\n        while j < lst.len() && lst[j] > lst[j + 1] {\n       \
    \     lst.swap(j, j + 1);\n            j += 1;\n        }\n        if j == lst.len()\
    \ - 1 {\n            break;\n        }\n        lst.swap(i, j);\n        i +=\
    \ 1;\n    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `j`\n  --> /tmp/tmpkapzqbdx.rs:15:13\n\
    \   |\n12 |         let j = i;\n   |             -\n   |             |\n   | \
    \            first assignment to `j`\n   |             help: consider making this\
    \ binding mutable: `mut j`\n...\n15 |             j += 1;\n   |             ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|a, b| {\n        if *a > b {\n            *b\n\
    \        } else {\n            *a\n        }\n    });\n\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkur9wpex.rs:10:17\n   |\n\
    10 |         if *a > b {\n   |                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n10 |         if *a > *b\
    \ {\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkur9wpex.rs:11:13\n\
    \   |\n11 |             *b\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkur9wpex.rs:13:13\n\
    \   |\n13 |             *a\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n \
    \   let mut min = isize::MIN;\n    let mut max = isize::MAX;\n    for &i in lst\
    \ {\n        if i < min { min = i }\n        if i > max { max = i }\n    }\n \
    \   let mut min_idx = lst.iter().position(|x| x == min).unwrap();\n    let mut\
    \ max_idx = lst.iter().position(|x| x == max).unwrap();\n    for i in (min_idx..max_idx).rev()\
    \ {\n        let tmp = lst[i];\n        lst[i] = lst[max_idx];\n        lst[max_idx]\
    \ = tmp;\n    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5c37v_r4.rs:12:9\n   |\n\
    12 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmp5c37v_r4.rs:16:49\n   |\n16 |     let mut\
    \ min_idx = lst.iter().position(|x| x == min).unwrap();\n   |                \
    \                                 ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp5c37v_r4.rs:17:49\n\
    \   |\n17 |     let mut max_idx = lst.iter().position(|x| x == max).unwrap();\n\
    \   |                                                 ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = vec![vec![]];\n    for &x in lst {\n  \
    \      if new_list.len() == 0 {\n            new_list.append(vec![x]);\n     \
    \   } else {\n            let last = new_list.last().unwrap();\n            let\
    \ mut new_last = last.clone();\n            new_last.push(x);\n            new_list.append(new_last);\n\
    \        }\n    }\n\n    new_list.iter().map(|v| v.clone()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxrjn9f_.rs:10:9\n   |\n\
    10 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplxrjn9f_.rs:12:29\n   |\n12 |             new_list.append(vec![x]);\n\
    \   |                             ^^^^^^^ expected `&mut Vec<Vec<_>>`, found struct\
    \ `Vec`\n   |\n   = note: expected mutable reference `&mut Vec<Vec<_>>`\n    \
    \                     found struct `Vec<_>`\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplxrjn9f_.rs:17:29\n \
    \  |\n17 |             new_list.append(new_last);\n   |                      \
    \       ^^^^^^^^ expected `&mut Vec<Vec<_>>`, found struct `Vec`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<Vec<_>>`\n                         found\
    \ struct `Vec<_>`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built\
    \ from an iterator over elements of type `Vec<_>`\n    --> /tmp/tmplxrjn9f_.rs:21:40\n\
    \     |\n21   |     new_list.iter().map(|v| v.clone()).collect()\n     |     \
    \                                   ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=Vec<_>>`\n     |\n     = help: the trait\
    \ `FromIterator<Vec<_>>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    for i in 0..sorted_list.len()\
    \ {\n        let smallest = i;\n        let largest = i;\n        for j in smallest..=largest\
    \ {\n            if sorted_list[j] < sorted_list[smallest - 1] {\n           \
    \     smallest = j;\n            }\n            if sorted_list[j] > sorted_list[largest\
    \ - 1] {\n                largest = j;\n            }\n        }\n        let\
    \ tmp = sorted_list[i];\n        sorted_list[i] = sorted_list[smallest - 1];\n\
    \        sorted_list[smallest - 1] = tmp;\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `smallest`\n  -->\
    \ /tmp/tmplyjta8j1.rs:15:17\n   |\n11 |         let smallest = i;\n   |      \
    \       --------\n   |             |\n   |             first assignment to `smallest`\n\
    \   |             help: consider making this binding mutable: `mut smallest`\n\
    ...\n15 |                 smallest = j;\n   |                 ^^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `largest`\n  --> /tmp/tmplyjta8j1.rs:18:17\n   |\n12 |         let\
    \ largest = i;\n   |             -------\n   |             |\n   |           \
    \  first assignment to `largest`\n   |             help: consider making this\
    \ binding mutable: `mut largest`\n...\n18 |                 largest = j;\n   |\
    \                 ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = lst;\n    new_list.sort();\n    new_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwvkkm0i7.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|a, b| a.cmp(b));\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpf0i2mkym.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort_by(|a, b| a.cmp(b));\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let len = lst.len();\n    let mut lst = lst.clone();\n   \
    \ let mut cur = isize::MAX;\n\n    for i in 0..len {\n        let min_idx = i;\n\
    \        let min_val = lst[min_idx];\n\n        let max_idx = len - i;\n     \
    \   let max_val = lst[max_idx];\n\n        for j in 0..i {\n            let val\
    \ = lst[j];\n            let val_2 = lst[j + i];\n\n            if val < min_val\
    \ {\n                min_idx = j;\n                min_val = val;\n          \
    \  }\n\n            if val > max_val {\n                max_idx = j;\n       \
    \         max_val = val;\n            }\n        }\n\n        if min_val < cur\
    \ {\n            cur.swap(min_val);\n            lst[min_idx].swap(max_val);\n\
    \        }\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwwxa4930.rs:36:17\n   |\n36 |             cur.swap(min_val);\n\
    \   |                 ^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `swap` found for type `isize` in the current scope\n  --> /tmp/tmpwwxa4930.rs:37:26\n\
    \   |\n37 |             lst[min_idx].swap(max_val);\n   |                    \
    \      ^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ls = lst.clone();\n    loop {\n        let mut min_idx\
    \ = ls.iter().min_by_key(|&x| x).unwrap();\n        let mut max_idx = ls.iter().max_by_key(|&x|\
    \ x).unwrap();\n        if min_idx > max_idx {\n            ls.swap_remove(min_idx);\n\
    \            ls.swap_remove(max_idx);\n        } else {\n            break;\n\
    \        }\n    }\n    ls\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_9h_e06.rs:14:28\n   |\n\
    14 |             ls.swap_remove(min_idx);\n   |                            ^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk_9h_e06.rs:15:28\n\
    \   |\n15 |             ls.swap_remove(max_idx);\n   |                       \
    \     ^^^^^^^ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst;\n    lst.sort();\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp7vkmzpt0.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min_idx = lst.len() - 1;\n    while min_idx > 0 &&\
    \ lst[min_idx] < lst[0] {\n        min_idx -= 1;\n    }\n\n    let mut max_idx\
    \ = lst.len() - 1;\n    while max_idx > 0 && lst[max_idx] > lst[0] {\n       \
    \ max_idx -= 1;\n    }\n\n    while min_idx < max_idx {\n        let mut i = min_idx;\n\
    \        let mut j = max_idx;\n        while i < j {\n            let tmp = lst[i];\n\
    \            lst[i] = lst[j];\n            lst[j] = tmp;\n            i += 1;\n\
    \            j -= 1;\n        }\n        min_idx += 1;\n        max_idx -= 1;\n\
    \    }\n\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp2hxv_bxe.rs:24:13\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n24 |             lst[i] = lst[j];\n   |\
    \             ^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `lst`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp2hxv_bxe.rs:25:13\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    25 |             lst[j] = tmp;\n   |             ^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min_value = lst[0];\n    let mut max_value = lst[0];\n\
    \    for i in 1..lst.len() {\n        if lst[i] < min_value {\n            min_value\
    \ = lst[i];\n        }\n        if lst[i] > max_value {\n            max_value\
    \ = lst[i];\n        }\n    }\n    let mut sorted_lst = Vec::new();\n    for i\
    \ in 1..lst.len() {\n        sorted_lst.push((min_value - max_value) * (i - 1)\
    \ as isize);\n        max_value = max_value + lst[i];\n    }\n    sorted_lst.push((min_value\
    \ - max_value) * (lst.len() - 1) as isize);\n    sorted_lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, -5, -16, -36]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpg7jnkw99.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = lst;\n    let len = result.len();\n    if\
    \ len <= 2 {\n        result.sort();\n    } else {\n        // We need to sort\
    \ it by first element (minimum value).\n        // Then by second element (minimum\
    \ value of remaining elements).\n        // Then by third element (maximum of\
    \ remaining elements).\n        // And the last sorting is to sort by first element\
    \ (minimum value).\n        let mut sorted_result = vec![result[0]];\n       \
    \ for i in 1..len {\n            if result[i] > sorted_result.last().unwrap()\
    \ {\n                sorted_result.push(result[i]);\n            }\n        }\n\
    \        for i in 2..len {\n            if sorted_result.len() > 1 {\n       \
    \         sorted_result.swap(0, sorted_result.len() - 1);\n            }\n   \
    \         sorted_result.push(result[i]);\n        }\n        if sorted_result.len()\
    \ > 1 {\n            sorted_result.swap(0, sorted_result.len() - 1);\n       \
    \ }\n        result.swap(0, result.len() - 1);\n        result.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjop6gpi.rs:20:28\n   |\n\
    20 |             if result[i] > sorted_result.last().unwrap() {\n   |        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |             if result[i]\
    \ > *sorted_result.last().unwrap() {\n   |                            +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = lst;\n    sorted.sort_by_key(|x| {\n    \
    \    x % 10\n    });\n    sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8mo1dj8z.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst;\n    list.sort_by(|a, b| b.cmp(&a).reverse());\n\
    \    list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp1d4zk6j_.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n\
    \    let mut min = lst.min();\n    let mut max = lst.max();\n\n    // While min\
    \ is smaller than max,\n    // move min to the end and decrement max by one.\n\
    \    // If min > max, we do nothing.\n    // If min == max, we swap the position\
    \ of min and max.\n    while min < max {\n        let tmp = min;\n        min\
    \ = max;\n        max = tmp;\n    }\n\n    // Swap min and max so they stand on\
    \ their side of the list while maintaining the order.\n    // We do this after\
    \ we have swapped max and min because in that case, the list won't be sorted.\n\
    \    let tmp_max = max;\n    let tmp_min = min;\n\n    // Now we loop through\
    \ the list and move min to its proper position\n    // and swap its values with\
    \ each other to maintain order.\n    // We do this until the list has been sorted.\n\
    \    while min < tmp_max {\n        let tmp = min;\n        min = tmp;\n     \
    \   // We swap min and max so they stand on their side of the list while maintaining\
    \ the order.\n        tmp_min = min;\n        tmp_max = max;\n        // The swap\
    \ is done by swapping tmp_max with tmp_min.\n        // Now min < tmp_max so we\
    \ have swapped min and max to their proper positions.\n        // We move tmp_max\
    \ to its proper position and swap it with the tmp_min.\n        tmp = tmp_max;\n\
    \        tmp_max = tmp_min;\n        tmp_min = min;\n        max = tmp;\n    }\n\
    \n    // Finally we return the sorted list.\n    vec![tmp_min, tmp_max]\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmphuwlpw7a.rs:13:23\n    |\n13  |     let mut min = lst.min();\n\
    \    |                       ^^^- supplied 0 arguments\n    |                \
    \       |\n    |                       expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmphuwlpw7a.rs:14:23\n    |\n14  |    \
    \ let mut max = lst.max();\n    |                       ^^^- supplied 0 arguments\n\
    \    |                       |\n    |                       expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphuwlpw7a.rs:50:10\n   |\n50 |     vec![tmp_min, tmp_max]\n   |\
    \          ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut current = vec![0];\n    let mut max = lst[0];\n  \
    \  let mut min_ = lst[0];\n    for x in lst {\n        if x < max {\n        \
    \    current = vec![x - min, min];\n            max = x;\n        } else {\n \
    \           current = vec![x - max, max];\n            min_ = x;\n        }\n\
    \    }\n    vec![min_, max_, ..current]\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmplrnbg7qu.rs:14:32\n\
    \   |\n14 |             current = vec![x - min, min];\n   |                  \
    \              ^^^\n...\n24 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    14 |             current = vec![x - main, min];\n   |                        \
    \        ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmplrnbg7qu.rs:14:37\n\
    \   |\n14 |             current = vec![x - min, min];\n   |                  \
    \                   ^^^\n...\n24 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n14 |             current = vec![x - min, main];\n   |                 \
    \                    ~~~~\nhelp: consider importing this function\n   |\n1  |\
    \ use std::cmp::min;\n   |\n\nerror[E0425]: cannot find value `max_` in this scope\n\
    \  --> /tmp/tmplrnbg7qu.rs:21:16\n   |\n21 |     vec![min_, max_, ..current]\n\
    \   |                ^^^^ help: a local variable with a similar name exists: `max`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst;\n    let mut sorted_list = lst;\n    let\
    \ mut smallest: isize = std::cmp::min(&mut l);\n    let mut biggest: isize = std::cmp::max(&mut\
    \ l);\n\n    for i in l.iter().rev() {\n        if *i < smallest {\n         \
    \   smallest = i;\n        }\n        if *i > biggest {\n            biggest =\
    \ i;\n        }\n    }\n\n    sorted_list.sort();\n    for i in sorted_list.iter().rev()\
    \ {\n        *i += biggest - smallest;\n    }\n\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpeah9xztu.rs:11:31\n     |\n11   |     let mut smallest: isize\
    \ = std::cmp::min(&mut l);\n     |                               ^^^^^^^^^^^^^\
    \ ------ supplied 1 argument\n     |                               |\n     | \
    \                              expected 2 arguments\n     |\nnote: function defined\
    \ here\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpeah9xztu.rs:12:30\n     |\n12   |     let mut biggest: isize\
    \ = std::cmp::max(&mut l);\n     |                              ^^^^^^^^^^^^^\
    \ ------ supplied 1 argument\n     |                              |\n     |  \
    \                            expected 2 arguments\n     |\nnote: function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeah9xztu.rs:16:24\n  \
    \ |\n11 |     let mut smallest: isize = std::cmp::min(&mut l);\n   |         \
    \              ----- expected due to this type\n...\n16 |             smallest\
    \ = i;\n   |                        ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n16 |             smallest = *i;\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeah9xztu.rs:19:23\n\
    \   |\n12 |     let mut biggest: isize = std::cmp::max(&mut l);\n   |        \
    \              ----- expected due to this type\n...\n19 |             biggest\
    \ = i;\n   |                       ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n19 |             biggest = *i;\n\
    \   |                       +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut first_elem = lst[0];\n\
    \    result.push(first_elem);\n    for elem in &lst[1..] {\n        if elem <\
    \ first_elem {\n            result.push(elem);\n            first_elem = elem;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfcm66657.rs:13:19\n   |\n\
    13 |         if elem < first_elem {\n   |                   ^^^^^^^^^^\n   | \
    \                  |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&first_elem`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcm66657.rs:14:25\n   |\n14 |             result.push(elem);\n\
    \   |                         ^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n14 |             result.push(*elem);\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcm66657.rs:15:26\n\
    \   |\n10 |     let mut first_elem = lst[0];\n   |                          ------\
    \ expected due to this value\n...\n15 |             first_elem = elem;\n   | \
    \                         ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |             first_elem = *elem;\n   | \
    \                         +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst;\n    list.sort();\n    for i in 0..list.len()\
    \ {\n        list[..i].swap(list[i], list[list.len() - i - 1]);\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwuvu6zel.rs:12:24\n   |\n\
    12 |         list[..i].swap(list[i], list[list.len() - i - 1]);\n   |        \
    \                ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         list[..i].swap(list[i].try_into().unwrap(), list[list.len()\
    \ - i - 1]);\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwuvu6zel.rs:12:33\n   |\n12 |         list[..i].swap(list[i],\
    \ list[list.len() - i - 1]);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |         list[..i].swap(list[i],\
    \ list[list.len() - i - 1].try_into().unwrap());\n   |                       \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n\
    \    let mut first = lst.iter().min().unwrap();\n    let mut last = lst.iter().max().unwrap();\n\
    \    swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut\
    \ last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut\
    \ first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut\
    \ lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n \
    \   swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut\
    \ last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut\
    \ first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut\
    \ lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n \
    \   swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut\
    \ last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut\
    \ first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut\
    \ lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n \
    \   swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &mut\
    \ last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut lst, &mut\
    \ first, &mut last);\n    swap(&mut lst, &mut first, &mut last);\n    swap(&mut\
    \ lst, &mut first, &mut last);\n    swap(&mut lst, &mut first, &\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpoyxu6slf.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpoyxu6slf.rs:42:9\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                                     -\
    \ closing delimiter possibly meant for this\n...\n42 |     swap(&mut lst, &mut\
    \ first, &\n   |         ^ unclosed delimiter\n43 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find function `swap` in this scope\n  -->\
    \ /tmp/tmpoyxu6slf.rs:15:5\n   |\n15 |     swap(&mut lst, &mut first, &mut last);\n\
    \   |     ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpoyxu6slf.rs:16:5\n\
    \   |\n16 |     swap(&mut lst, &mut first, &mut last);\n   |     ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmpoyxu6slf.rs:17:5\n   |\n17\
    \ |     swap(&mut lst, &mut first, &mut last);\n   |     ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot find function `swap`\
    \ in this scope\n  --> /tmp/tmpoyxu6slf.rs:18:5\n   |\n18 |     swap(&mut lst,\
    \ &mut first, &mut last);\n   |     ^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::mem::swap;\n   |\n\
    1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot find function `swap` in\
    \ this scope\n  --> /tmp/tmpoyxu6slf.rs:19:5\n   |\n19 |     swap(&mut lst, &mut\
    \ first, &mut last);\n   |     ^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use\
    \ std::ptr::swap;\n   |\n\nerror[E0425]: cannot find function `swap` in this scope\n\
    \  --> /tmp/tmpoyxu6slf.rs:20:5\n   |\n20 |     swap(&mut lst, &"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst\n        .iter()\n        .cloned()\n        .chain(lst)\n\
    \        .iter()\n        .cloned()\n        .chain(lst)\n        .cloned()\n\
    \        .iter()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmp39275z1d.rs:137:1\n    |\n\
    137 | }\n    | ^\n\nerror[E0599]: no method named `iter` found for struct `std::iter::Chain`\
    \ in the current scope\n  --> /tmp/tmp39275z1d.rs:13:10\n   |\n13 |         .iter()\n\
    \   |          ^^^^ method not found in `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ isize>>, std::vec::IntoIter<isize>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n    }\n    let mut\
    \ sorted_list = lst;\n    sorted_list.sort();\n    sorted_list.sort();\n    sorted_list.sort();\n\
    \    sorted_list.sort();\n    sorted_list.sort();\n    sorted_list.sort();\n \
    \   sorted_list.sort();\n    sorted_list.sort();\n    sorted_list.sort();\n  \
    \  sorted_list.sort();\n    sorted_list.sort();\n    sorted_list.sort();\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpyq0nhg0g.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = String::new();\n    let mut i = String::new();\n\
    \    for v in lst.into_iter().rev() {\n        i.push_str(&format!(\"{}\", v).as_str());\n\
    \        s.push(i);\n        i = String::new();\n    }\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n    for v in s.split_whitespace() {\n        let v: isize = v.parse().unwrap();\n\
    \        ret.push(v);\n    }\n    ret\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vape16e.rs:13:16\n   |\n\
    13 |         s.push(i);\n   |                ^ expected `char`, found struct `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst;\n    lst.sort();\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpjhdudtrz.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_elem = *lst.iter().min_by_key(|e|\
    \ e).unwrap();\n    let mut max_elem = *lst.iter().max_by_key(|e| e).unwrap();\n\
    \n    for e in lst {\n        if *e <= max_elem {\n            result.push(*e\
    \ as isize);\n            max_elem = *e as isize;\n        } else {\n        \
    \    result.push(*min_elem as isize);\n            min_elem = *e as isize;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpfpgv593c.rs:14:12\n\
    \   |\n14 |         if *e <= max_elem {\n   |            ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpfpgv593c.rs:15:25\n   |\n15 |\
    \             result.push(*e as isize);\n   |                         ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpfpgv593c.rs:16:24\n   |\n\
    16 |             max_elem = *e as isize;\n   |                        ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpfpgv593c.rs:18:25\n   |\n\
    18 |             result.push(*min_elem as isize);\n   |                      \
    \   ^^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpfpgv593c.rs:19:24\n\
    \   |\n19 |             min_elem = *e as isize;\n   |                        ^^\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut smaller = lst.iter().min_by(|a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    });\n    let mut bigger = lst.iter().max_by(|a, b| {\n        if\
    \ a < b {\n            b\n        } else {\n            a\n        }\n    });\n\
    \n    for _ in 1..lst.len() {\n        result.push(smaller.unwrap());\n      \
    \  result.push(bigger.unwrap());\n        bigger = lst.iter().min_by(|a, b| {\n\
    \            if a < b {\n                b\n            } else {\n           \
    \     a\n            }\n        });\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:12:13\n   |\n\
    12 |             a\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:14:13\n\
    \   |\n14 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:19:13\n\
    \   |\n19 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:21:13\n\
    \   |\n21 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:30:17\n\
    \   |\n30 |                 b\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:32:17\n\
    \   |\n32 |                 a\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt2lm8chw.rs:36:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n36 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 7 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.into_iter().collect::<Vec<isize>>();\n\n\
    \    let mut min = lst[0].clone() + 1;\n    for &n in lst {\n        if n < min\
    \ {\n            min = n;\n        }\n    }\n\n    let mut max = lst[0].clone()\
    \ + 1;\n    for &n in lst {\n        if n > max {\n            max = n;\n    \
    \    }\n    }\n\n    for &n in lst {\n        if n < min || n > max {\n      \
    \      lst.push(n);\n        }\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9x1603_r.rs:12:9\n   |\n\
    12 |     for &n in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9x1603_r.rs:19:9\n   |\n19 |     for &n in lst {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9x1603_r.rs:25:9\n\
    \   |\n25 |     for &n in lst {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = lst;\n    s.sort_by(|x, y| y.cmp(x));\n    s\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp32ozf17j.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    // Initialize all vectors to minimum value\n    let mut min\
    \ = isize::MIN;\n    let mut max = isize::MAX;\n    let mut current = min;\n\n\
    \    // Iterate over each element in the list\n    for x in lst {\n        //\
    \ Keep track of the minimum value\n        if x > current {\n            max =\
    \ x;\n        } else {\n            current = x;\n        }\n    }\n\n    // Initialize\
    \ result vector\n    let mut result = vec![];\n\n    // Iterate through list again,\
    \ adding elements into the result vector\n    // until it is sorted\n    for x\
    \ in lst {\n        // Add element to result\n        result.push(x);\n\n    \
    \    // Iterate through list again, adding elements into the result vector\n \
    \       // until it is sorted\n        for x in lst {\n            // Add element\
    \ to result\n            result.push(x);\n\n            // If current value is\
    \ greater than max, keep track of the new minimum\n            // and iterate\
    \ through the list again\n            if x > max {\n                max = x;\n\
    \                for x in lst {\n                    result.push(x);\n       \
    \         }\n            }\n        }\n    }\n\n    // Return the result\n   \
    \ result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp00udg2n0.rs:10:9\n\
    \   |\n10 |     let mut min = isize::MIN;\n   |         ----^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmp00udg2n0.rs:29:14\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    29  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n15  |     for x in &lst {\n    |  \
    \            +\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmp00udg2n0.rs:35:18\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n29 |     for x in lst {\n   |         \
    \     --- `lst` moved due to this implicit call to `.into_iter()`\n...\n35 | \
    \        for x in lst {\n   |                  ^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n   |\n29 |     for x in &lst {\n   |     \
    \         +\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmp00udg2n0.rs:43:26\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n35 |         for x in lst {\n   |     \
    \             --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    43 |                 for x in lst {\n   |                          ^^^ value used\
    \ here after move\n   |\nhelp: consider iterating over "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = lst\n        .iter()\n        .cloned()\n    \
    \    .cloned()\n        .collect::<Vec<_>>();\n    s.sort_by_key(|x| x.clone());\n\
    \    s\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmp8t_z3n2g.rs:12:10\n     |\n12   | \
    \        .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp8t_z3n2g.rs:13:10\n\
    \   |\n13 |           .collect::<Vec<_>>();\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Cloned<std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n \
    \          which is required by `Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = lst.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut result = it.clone();\n\n    // reverse sort by adding min/max before\
    \ next min/max\n    for e in &mut result {\n        let mut min = *e;\n      \
    \  let mut max = *e;\n        for v in &mut it {\n            if *v < min {\n\
    \                min = *v;\n            }\n            if *v > max {\n       \
    \         max = *v;\n            }\n        }\n        *e = min;\n        *e =\
    \ max;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4, 4, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpzm23mc22.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n\
    \    let mut sorted = vec![None; lst.len()];\n    let mut first_val = None;\n\
    \    let mut last_val = Some(lst.len() - 1);\n    let mut cur = first_val;\n\n\
    \    for val in lst.iter() {\n        while cur != None && val < cur {\n     \
    \       sorted.push(cur.clone());\n            if val == cur {\n             \
    \   break;\n            }\n            cur = sorted[sorted.len() - 1];\n     \
    \   }\n        sorted.push(val);\n        if cur == None {\n            break;\n\
    \        }\n        cur = sorted[sorted.len() - 1];\n        last_val = Some(sorted.len());\n\
    \    }\n\n    if cur == first_val {\n        sorted\n    } else {\n        sorted.reverse()\n\
    \    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphsoznnc7.rs:19:36\n   |\n\
    19 |         while cur != None && val < cur {\n   |                          \
    \          ^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected\
    \ reference `&isize`\n                   found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `Option<_>`\n  --> /tmp/tmphsoznnc7.rs:21:20\n \
    \  |\n21 |             if val == cur {\n   |                    ^^ no implementation\
    \ for `&isize == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphsoznnc7.rs:26:21\n   |\n26 |         sorted.push(val);\n   |      \
    \               ^^^ expected enum `Option`, found `&isize`\n   |\n   = note: \
    \  expected enum `Option<_>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n26 |         sorted.push(Some(val));\n   | \
    \                    +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphsoznnc7.rs:35:9\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |         sorted\n   |         ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<_>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphsoznnc7.rs:37:9\n   |\n8  | fn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n37 |         sorted.reverse()\n  \
    \ |         ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut copy = lst;\n    let len = copy.len();\n    let mut\
    \ max_value = copy[len - 1];\n    copy.pop();\n    for i in 0..len - 1 {\n   \
    \     let mut min_value = copy[len - 1];\n        copy.pop();\n        copy.push((min_value\
    \ - max_value) / 2);\n        max_value = min_value;\n    }\n    copy\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmprdziycaj.rs:14:29\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min = *lst.iter().min().unwrap();\n\
    \    let mut max = *lst.iter().max().unwrap();\n    for x in lst {\n        if\
    \ x < min {\n            min = x;\n        }\n        if x > max {\n         \
    \   max = x;\n        }\n    }\n    for i in min..max {\n        let tmp = lst[i];\n\
    \        lst[i] = lst[max - i];\n        lst[max - i] = tmp;\n    }\n    for i\
    \ in 0..lst.len() - 1 {\n        result.push(lst[i]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpm769_kak.rs:21:19\n\
    \   |\n21 |         let tmp = lst[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpm769_kak.rs:22:9\n   |\n22 |         lst[i]\
    \ = lst[max - i];\n   |         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpm769_kak.rs:22:18\n   |\n22 |         lst[i] = lst[max - i];\n\
    \   |                  ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpm769_kak.rs:23:9\n   |\n23 |         lst[max - i] = tmp;\n   |\
    \         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.len() < 2 {\n        return lst;\n    }\n    let mut\
    \ min_val = lst[0];\n    let mut max_val = lst[0];\n    for val in lst {\n   \
    \     if val < min_val {\n            min_val = val;\n        }\n        if val\
    \ > max_val {\n            max_val = val;\n        }\n    }\n    let mut middle\
    \ = min_val + max_val / 2;\n    let mut swapped = false;\n    let mut new_lst\
    \ = Vec::new();\n    for val in lst {\n        if val < middle {\n           \
    \ new_lst.push(val);\n        } else {\n            while val > middle {\n   \
    \             new_lst.push(middle);\n                middle -= 1;\n          \
    \      swapped = true;\n            }\n            if val == middle {\n      \
    \          middle += 1;\n            }\n            new_lst.push(middle);\n  \
    \          swapped = false;\n        }\n    }\n    if !swapped {\n        new_lst.push(middle);\n\
    \    }\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "warning: value assigned to `swapped` is never read\n  --> /tmp/tmphtu7nv3_.rs:32:17\n\
    \   |\n32 |                 swapped = true;\n   |                 ^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nerror[E0382]: use of moved value: `lst`\n\
    \   --> /tmp/tmphtu7nv3_.rs:25:16\n    |\n8   | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n    |                      --- move occurs because `lst` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n14  |   \
    \  for val in lst {\n    |                --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n25  |     for val in lst {\n    |             \
    \   ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14\
    \  |     for val in &lst {\n    |                +\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp7v9m5aw9.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.iter().cloned().collect::<Vec<isize>>();\n\
    \    lst.sort_by_key(|x| x.clone());\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmps7qsdpvp.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min = lst[0];\n   \
    \ let mut max = lst[0];\n    for x in lst.iter() {\n        if x < min {\n   \
    \         min = x;\n        }\n        if x > max {\n            max = x;\n  \
    \      }\n    }\n    vec.push(min);\n    vec.push(max);\n    for x in lst.iter().rev()\
    \ {\n        if x > min {\n            vec.push(x);\n        }\n        if x <\
    \ max {\n            vec.push(min);\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphe8nydx1.rs:13:16\n   |\n\
    13 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphe8nydx1.rs:14:19\n\
    \   |\n10 |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n14 |             min = x;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |             min = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphe8nydx1.rs:16:16\n   |\n16 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphe8nydx1.rs:17:19\n   |\n11 |  \
    \   let mut max = lst[0];\n   |                   ------ expected due to this\
    \ value\n...\n17 |             max = x;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \           max = *x;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphe8nydx1.rs:23:16\n   |\n23 |         if x > min {\n   |      \
    \          ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&min`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphe8nydx1.rs:24:22\n   |\n24 |  \
    \           vec.push(x);\n   |                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |        \
    \     vec.push(*x);\n   |                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphe8nydx1.rs:26:16\n   |\n26 |         if x < max {\n   |      \
    \          ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error: aborting due to 7 previous errors\n\nFor more information about this err"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = lst;\n    new_list.sort_unstable();\n \
    \   new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpjpe6tqqk.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst.clone();\n    for idx in list.iter_mut()\
    \ {\n        *idx = *idx + (*idx - 1) as isize;\n    }\n    list.sort_unstable();\n\
    \    list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 5, 7]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpmp4zxiuw.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by_key(|x| {\n        match x {\n            x if\
    \ x == 5 => 0,\n            x if x == 6 => 1,\n            x if x == 7 => 2,\n\
    \            x if x == 8 => 3,\n            x if x == 9 => 4,\n            _ =>\
    \ 5,\n        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4hxwd31j.rs:11:20\n\
    \   |\n11 |             x if x == 5 => 0,\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp4hxwd31j.rs:12:20\n   |\n12 |             x\
    \ if x == 6 => 1,\n   |                    ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp4hxwd31j.rs:13:20\n   |\n13 |             x if x == 7 => 2,\n \
    \  |                    ^^ no implementation for `&isize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  -->\
    \ /tmp/tmp4hxwd31j.rs:14:20\n   |\n14 |             x if x == 8 => 3,\n   |  \
    \                  ^^ no implementation for `&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    // find min and max\n    let mut min = isize::MAX;\n    let\
    \ mut max = isize::MIN;\n    for x in lst {\n        if x < min {\n          \
    \  min = x;\n        }\n        if x > max {\n            max = x;\n        }\n\
    \    }\n    if min < max {\n        // swap min and max values\n        let tmp\
    \ = min;\n        min = max;\n        max = tmp;\n    }\n    // run through list\
    \ from min to max\n    let mut ans = vec![];\n    let mut i = 0;\n    while i\
    \ < lst.len() {\n        // find next place to swap\n        let mut j = i;\n\
    \        while j < lst.len() {\n            if lst[j] < min {\n              \
    \  break;\n            }\n            j += 1;\n        }\n        // swap\n  \
    \      ans.push(*j);\n        j = j - 1;\n        while j > 0 {\n            ans.push(lst[j]);\n\
    \            j -= 1;\n        }\n        i += 1;\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpa4m7adwf.rs:39:18\n\
    \   |\n39 |         ans.push(*j);\n   |                  ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_unstable_by_key(|v| {\n        let mut v = v;\n \
    \       while v > 0 && v % 2 != 0 {\n            v += 2;\n        }\n        v\n\
    \    });\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiq9zy55h.rs:11:19\n   |\n\
    11 |         while v > 0 && v % 2 != 0 {\n   |                   ^\n   |     \
    \              |\n   |                   expected `&isize`, found integer\n  \
    \ |                   help: consider borrowing here: `&0`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpiq9zy55h.rs:12:13\n\
    \   |\n12 |             v += 2;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can be used\
    \ on `isize`, you can dereference `v`\n   |\n12 |             *v += 2;\n   | \
    \            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n\n    for i in lst.iter()\
    \ {\n        j += 1; // Start with the maximum value and end with the minimum\
    \ value.\n        let mut temp = i;\n        while j <= i - 1 {\n            swap(&mut\
    \ temp, &mut lst[j]);\n            j += 1; // Iterate through the rest of items.\n\
    \        }\n    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpy28zui10.rs:16:13\n\
    \   |\n16 |             swap(&mut temp, &mut lst[j]);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy28zui10.rs:16:34\n\
    \   |\n16 |             swap(&mut temp, &mut lst[j]);\n   |                  \
    \                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut tmp = lst[0];\n    let mut sorted_lst = lst;\n   \
    \ while sorted_lst.len() > 0 {\n        if sorted_lst.len() > 1 {\n          \
    \  sorted_lst.sort();\n        }\n        let elem = sorted_lst[0];\n        sorted_lst.sort();\n\
    \        sorted_lst[0] = elem;\n        tmp += 1;\n    }\n    sorted_lst.sort();\n\
    \    return sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut min = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    max = max - 1;\n    let mut s = vec![];\n    for i in lst.iter() {\n    \
    \    if min <= i && i <= max {\n            s.push(min + i);\n            min\
    \ += 1;\n        } else {\n            s.push(i - 1);\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_i22laj.rs:14:11\n   |\n\
    13 |     let mut max = lst.iter().max().unwrap();\n   |                   -------------------------\
    \ expected due to this value\n14 |     max = max - 1;\n   |           ^^^^^^^\n\
    \   |           |\n   |           expected `&isize`, found `isize`\n   |     \
    \      help: consider borrowing here: `&(max - 1)`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&isize`\n  --> /tmp/tmp9_i22laj.rs:19:13\n\
    \   |\n19 |             min += 1;\n   |             ---^^^^^\n   |           \
    \  |\n   |             cannot use `+=` on type `&isize`\n   |\nhelp: `+=` can\
    \ be used on `isize`, you can dereference `min`\n   |\n19 |             *min +=\
    \ 1;\n   |             +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.len() < 2 {\n        return lst;\n    }\n    let mut\
    \ i1 = lst.min_by(|a, b| a.cmp(b)).unwrap();\n    let mut i2 = lst.max_by(|a,\
    \ b| a.cmp(b)).unwrap();\n    while i2 < i1 {\n        let tmp = i1;\n       \
    \ i1 = i2;\n        i2 = tmp;\n    }\n    let mut i1 = lst.min_by(|a, b| a.cmp(b)).unwrap();\n\
    \    let mut i2 = lst.max_by(|a, b| a.cmp(b)).unwrap();\n    while i2 < i1 {\n\
    \        let tmp = i1;\n        i1 = i2;\n        i2 = tmp;\n    }\n    [i1, i2].iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg81nou_3.rs:12:22\n\
    \    |\n12  |       let mut i1 = lst.min_by(|a, b| a.cmp(b)).unwrap();\n    |\
    \                        ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg81nou_3.rs:13:22\n\
    \    |\n13  |       let mut i2 = lst.max_by(|a, b| a.cmp(b)).unwrap();\n    |\
    \                        ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg81nou_3.rs:19:22\n\
    \    |\n19  |       let mut i1 = lst.min_by(|a, b| a.cmp(b)).unwrap();\n    |\
    \                        ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg81nou_3.rs:20:22\n\
    \    |\n20  |       let mut i2 = lst.max_by(|a, b| a.cmp(b)).unwrap();\n    |\
    \                        ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut temp = Vec::new();\n    let mut min;\n    let mut\
    \ max;\n    let mut sorted_list = Vec::new();\n\n    // First pass, find min and\
    \ max\n    for &i in lst {\n        if min == Some(i as isize) {\n           \
    \ min = Some(i);\n        } else {\n            max = Some(i);\n        }\n  \
    \  }\n    if min == Some(0) {\n        sorted_list.push(0);\n        min = Some(0);\n\
    \    }\n    if max == Some(9) {\n        sorted_list.push(9);\n        max = Some(9);\n\
    \    }\n\n    // Second pass, swap min with max\n    while let Some(min) = min\
    \ {\n        if let Some(max) = (&lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == min).unwrap().0) as usize]).min() {\n            temp = &lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == min).unwrap().0) as usize];\n            lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == min).unwrap().0) as usize] = &lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == max).unwrap().0) as usize];\n            lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == max).unwrap().0) as usize] = temp;\n            sorted_list.push(min);\n\
    \            sorted_list.push(max);\n        }\n    }\n\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmply_n18ac.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmply_n18ac.rs:33:80\n   |\n33 |        \
    \ if let Some(max) = (&lst[(*lst.iter().rev().enumerate().find(|&(i, _)| *i ==\
    \ min).unwrap().0) as usize]).min() {\n   |                                  \
    \                                              ^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmply_n18ac.rs:33:34\n   |\n33 |        \
    \ if let Some(max) = (&lst[(*lst.iter().rev().enumerate().find(|&(i, _)| *i ==\
    \ min).unwrap().0) as usize]).min() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmply_n18ac.rs:34:71\n\
    \   |\n34 |             temp = &lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == min).unwrap().0) as usize];\n   |                                \
    \                                       ^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmply_n18ac.rs:34:25\n   |\n34 |             temp\
    \ = &lst[(*lst.iter().rev().enumerate().find(|&(i, _)| *i == min).unwrap().0)\
    \ as usize];\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmply_n18ac.rs:35:63\n\
    \   |\n35 | ...   lst[(*lst.iter().rev().enumerate().find(|&(i, _)| *i == min).unwrap().0)\
    \ as usize] = &lst[(*lst.iter().rev().enumerate().find(|&(i,...\n   |        \
    \                                                 ^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmply_n18ac.rs:35:17\n   |\n35 | ...   lst[(*lst.iter().rev().enumerate().find(|&(i,\
    \ _)| *i == min).unwrap().0) as usize] = &lst[(*lst.iter("
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    sort.quicksort_by(|| {\n        -1\n    });\n    lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `sort` in this scope\n --> /tmp/tmp3_o1jd4m.rs:9:5\n\
    \  |\n9 |     sort.quicksort_by(|| {\n  |     ^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|a, b| {\n        let mut a: isize = 0;\n    \
    \    let mut b: isize = 0;\n        loop {\n            match a {\n          \
    \      a if b == a => break,\n                _ => a = a + 1,\n            }\n\
    \            match b {\n                a if b == a => break,\n              \
    \  _ => b = b + 1,\n            }\n        }\n        a.cmp(b)\n    })\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1o62zb04.rs:22:15\n   |\n\
    22 |         a.cmp(b)\n   |               ^\n   |               |\n   |      \
    \         expected `&isize`, found `isize`\n   |               help: consider\
    \ borrowing here: `&b`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1o62zb04.rs:9:5\n\
    \   |\n8  |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n9  | /     lst.sort_by(|a, b| {\n10 | |         let mut a: isize\
    \ = 0;\n11 | |         let mut b: isize = 0;\n12 | |         loop {\n...  |\n\
    22 | |         a.cmp(b)\n23 | |     })\n   | |______^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut temp = Vec::new();\n    let mut i = 0;\n    while\
    \ i < lst.len() {\n        let item = lst[i];\n        let mut j = i + 1;\n  \
    \      while j < lst.len() {\n            if item > lst[j] {\n               \
    \ break;\n            }\n            i += 1;\n            temp.push(item);\n \
    \       }\n        i += 1;\n    }\n    while i < lst.len() {\n        temp.push(lst[i]);\n\
    \        i += 1;\n    }\n    temp\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut temp = Vec::new();\n    let mut min_val = lst[0];\n\
    \n    for i in 1..lst.len() {\n        if lst[i] < min_val {\n            min_val\
    \ = lst[i];\n        }\n        temp = temp.append(&min_val).append(&lst[i]);\n\
    \    }\n\n    temp\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzn2hmnfs.rs:16:28\n   |\n\
    16 |         temp = temp.append(&min_val).append(&lst[i]);\n   |             \
    \               ^^^^^^^^ types differ in mutability\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<_>`\n                      found reference `&isize`\n\
    \nerror[E0599]: no method named `append` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpzn2hmnfs.rs:16:38\n   |\n16 |         temp = temp.append(&min_val).append(&lst[i]);\n\
    \   |                                      ^^^^^^ method not found in `()`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst2 = lst.clone();\n\n    lst2.sort();\n\n    let\
    \ mut res = [lst2.last().unwrap()];\n\n    for el in lst2.iter().skip(1) {\n \
    \       res.push(el);\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for array `[&isize; 1]` in the\
    \ current scope\n  --> /tmp/tmp3ot_zd9d.rs:16:13\n   |\n16 |         res.push(el);\n\
    \   |             ^^^^ method not found in `[&isize; 1]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3ot_zd9d.rs:19:5\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n19 |     res\n   |     ^^^\
    \ expected struct `Vec`, found array `[&isize; 1]`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n               found array `[&isize; 1]`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    for i in lst {\n        if i ==\
    \ res.len() {\n            res.push(i);\n        } else {\n            let mut\
    \ j = i + 1;\n            while j < res.len() {\n                if res[j] > res[i]\
    \ {\n                    res[j] = i;\n                    break;\n           \
    \     }\n                j += 1;\n            }\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxqppmesz.rs:11:17\n   |\n\
    11 |         if i == res.len() {\n   |                 ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |         if i == res.len().try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxqppmesz.rs:15:23\n   |\n15 |             while j < res.len()\
    \ {\n   |                       ^^^^^^^^^ expected `isize`, found `usize`\n  \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |             while j < res.len().try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxqppmesz.rs:16:20\n\
    \   |\n16 |                 if res[j] > res[i] {\n   |                    ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxqppmesz.rs:16:29\n\
    \   |\n16 |                 if res[j] > res[i] {\n   |                       \
    \      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n  \
    \ = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxqppmesz.rs:17:21\n\
    \   |\n17 |                     res[j] = i;\n   |                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut current = Vec::new();\n\
    \n    let mut min_val = min::<isize>();\n    let mut max_val = max::<isize>();\n\
    \n    for ele in lst {\n        if ele < min_val {\n            min_val = ele;\n\
    \            current.clear();\n        } else if ele > max_val {\n           \
    \ max_val = ele;\n        }\n\n        if current.len() > 0 {\n            result.push(*current);\n\
    \            current.clear();\n        }\n\n        current.push(ele);\n    }\n\
    \n    result.push(*current);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpiub2aoy1.rs:12:23\n\
    \   |\n12 |     let mut min_val = min::<isize>();\n   |                      \
    \ ^^^\n...\n35 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n12 |     let\
    \ mut min_val = main::<isize>();\n   |                       ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpiub2aoy1.rs:13:23\n\
    \   |\n13 |     let mut max_val = max::<isize>();\n   |                      \
    \ ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0277]: the size for values of type\
    \ `[_]` cannot be known at compilation time\n   --> /tmp/tmpiub2aoy1.rs:24:25\n\
    \    |\n24  |             result.push(*current);\n    |                    ----\
    \ ^^^^^^^^ doesn't have a size known at compile-time\n    |                  \
    \  |\n    |                    required by a bound introduced by this call\n \
    \   |\n    = help: the trait `Sized` is not implemented for `[_]`\nnote: required\
    \ by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `[_]` cannot be known at compilation time\n   --> /tmp/tmpiub2aoy1.rs:9:22\n\
    \    |\n9   |     let mut result = Vec::new();\n    |                      ^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[_]`\nnote: required by a bound in `Vec::<T>::new`\n\
    \nerror[E0277]: the size for values of type `[_]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpiub2aoy1.rs:9:22\n    |\n9   |     let mut result = Vec::new();\n\
    \    |                      ^^^ doesn't have a size known at compile-time\n  \
    \  |\n    = help: the trait `Sized` is not implemented for `[_]`\nnote: required\
    \ by a bound in `Vec`\n\nerror[E0599]: the method `push` exists for struct `Vec<[isize]>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpiub2aoy1.rs:31:12\n \
    \  |\n31 |     result.push(*current);\n   |        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.len() < 2 {\n        return lst;\n    }\n\n    let\
    \ mut min = std::ptr::mem::uninitialized();\n    let mut max = std::ptr::mem::uninitialized();\n\
    \    let mut idx = 1;\n\n    while idx < lst.len() {\n        let minval = *std::min_element(\n\
    \            &lst.iter().take(idx),\n            &lst.iter().skip(idx),\n    \
    \    );\n        let maxval = *std::max_element(\n            &lst.iter().take(idx),\n\
    \            &lst.iter().skip(idx),\n        );\n        *min = minval if minval\
    \ < min || min == std::ptr::null_mut() else min;\n        *max = maxval if maxval\
    \ > max || max == std::ptr::null_mut() else max;\n        idx += 1;\n    }\n\n\
    \    while idx < lst.len() {\n        let minval = *std::min_element(\n      \
    \      &lst.iter().take(idx),\n            &lst.iter().skip(idx),\n        );\n\
    \        let maxval = *std::max_element(\n            &lst.iter().take(idx),\n\
    \            &lst.iter().skip(idx),\n        );\n        if minval > max {\n \
    \           max = minval;\n        }\n        if maxval < min {\n            min\
    \ = maxval;\n        }\n        idx += 1;\n    }\n\n    let mut result = Vec::new();\n\
    \    result.extend_from_slice(&lst[min..]);\n    result.extend_from_slice(&lst[min..]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, `}`, or an\
    \ operator, found keyword `if`\n  --> /tmp/tmpe1rwsvwi.rs:26:23\n   |\n26 |  \
    \       *min = minval if minval < min || min == std::ptr::null_mut() else min;\n\
    \   |                       ^^ expected one of 9 possible tokens\n\nerror[E0425]:\
    \ cannot find function `min_element` in crate `std`\n  --> /tmp/tmpe1rwsvwi.rs:18:28\n\
    \   |\n18 |         let minval = *std::min_element(\n   |                    \
    \        ^^^^^^^^^^^ not found in `std`\n\nerror[E0425]: cannot find function\
    \ `max_element` in crate `std`\n  --> /tmp/tmpe1rwsvwi.rs:22:28\n   |\n22 |  \
    \       let maxval = *std::max_element(\n   |                            ^^^^^^^^^^^\
    \ not found in `std`\n\nerror[E0425]: cannot find function `min_element` in crate\
    \ `std`\n  --> /tmp/tmpe1rwsvwi.rs:32:28\n   |\n32 |         let minval = *std::min_element(\n\
    \   |                            ^^^^^^^^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `max_element` in crate `std`\n  --> /tmp/tmpe1rwsvwi.rs:36:28\n\
    \   |\n36 |         let maxval = *std::max_element(\n   |                    \
    \        ^^^^^^^^^^^ not found in `std`\n\nerror[E0603]: module `mem` is private\n\
    \   --> /tmp/tmpe1rwsvwi.rs:13:29\n    |\n13  |     let mut min = std::ptr::mem::uninitialized();\n\
    \    |                             ^^^ private module\n    |\nnote: the module\
    \ `mem` is defined here\n\nerror[E0603]: module `mem` is private\n   --> /tmp/tmpe1rwsvwi.rs:14:29\n\
    \    |\n14  |     let mut max = std::ptr::mem::uninitialized();\n    |       \
    \                      ^^^ private module\n    |\nnote: the module `mem` is defined\
    \ here\n\nwarning: use of deprecated function `std::mem::uninitialized`: use `mem::MaybeUninit`\
    \ instead\n  --> /tmp/tmpe1rwsvwi.rs:13:34\n   |\n13 |     let mut min = std::ptr::mem::uninitialized();\n\
    \   |                                  ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated function `std::mem::uninitialized`:\
    \ use `mem::MaybeUninit` instead\n  --> /tmp/tmpe1rwsvwi.rs:14:34\n   |\n14 |\
    \     let mut max = std::ptr::m"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|a, b| b.partial_cmp(a).unwrap());\n    lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmptsrsvvpi.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n    for\
    \ n in &lst {\n        if n < min {\n            min = n;\n        }\n       \
    \ if n > max {\n            max = n;\n        }\n    }\n\n    let mut lst_out\
    \ = vec![];\n    while min != max {\n        if min < max {\n            min +=\
    \ 1;\n        } else {\n            max -= 1;\n        }\n        lst_out.push(min);\n\
    \    }\n    lst_out\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwr60eddq.rs:12:16\n   |\n\
    12 |         if n < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwr60eddq.rs:13:19\n\
    \   |\n9  |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n13 |             min = n;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *n;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwr60eddq.rs:15:16\n   |\n15 |         if n > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwr60eddq.rs:16:19\n   |\n10 |  \
    \   let mut max = lst[0];\n   |                   ------ expected due to this\
    \ value\n...\n16 |             max = n;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \           max = *n;\n   |                   +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst;\n    let mut max = 0;\n    let mut min\
    \ = 0;\n    let mut next_min = 0;\n\n    loop {\n        if max < list[next_min]\
    \ {\n            max = list[next_min];\n        }\n\n        if min > list[next_min]\
    \ {\n            min = list[next_min];\n        }\n\n        if max >= min {\n\
    \            list.swap(next_min, list[next_min]);\n            next_min++;\n \
    \       } else {\n            break;\n        }\n    }\n\n    list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp3me12pmy.rs:25:21\n\
    \   |\n25 |             next_min++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp =\
    \ next_min; next_min += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             next_min++;\n25 +             next_min += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3me12pmy.rs:24:33\n   |\n24 |             list.swap(next_min,\
    \ list[next_min]);\n   |                                 ^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |             list.swap(next_min,\
    \ list[next_min].try_into().unwrap());\n   |                                 \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 1;\n    let mut max = *lst.iter().max_unwrap_or(&i).unwrap();\n\
    \    let mut min = 1;\n\n    for e in lst {\n        let r = *e.cmp(&max);\n\n\
    \        if r > 0 {\n            i += 1;\n            max = e;\n        } else\
    \ if r == 0 {\n            min = i;\n            max = e;\n        } else {\n\
    \            max = e;\n        }\n    }\n\n    return vec.split_off(min, max).collect();\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpv84vva85.rs:27:12\n\
    \   |\n27 |     return vec.split_off(min, max).collect();\n   |            ^^^\
    \ not a value\n\nerror[E0599]: no method named `max_unwrap_or` found for struct\
    \ `std::slice::Iter` in the current scope\n  --> /tmp/tmpv84vva85.rs:10:31\n \
    \  |\n10 |     let mut max = *lst.iter().max_unwrap_or(&i).unwrap();\n   |   \
    \                            ^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `std::cmp::Ordering` cannot be dereferenced\n\
    \  --> /tmp/tmpv84vva85.rs:14:17\n   |\n14 |         let r = *e.cmp(&max);\n \
    \  |                 ^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0423, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.into_iter().cloned().collect::<Vec<isize>>();\n\
    \    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpvr19ircs.rs:9:35\n     |\n9    |     let mut lst = lst.into_iter().cloned().collect::<Vec<isize>>();\n\
    \     |                                   ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpvr19ircs.rs:9:44\n   |\n9  |       let mut\
    \ lst = lst.into_iter().cloned().collect::<Vec<isize>>();\n   |              \
    \                                ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst.iter().cloned().collect::<Vec<isize>>();\n\
    \    l.sort();\n    l\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpj2_29ps4.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut slst = vec![0; lst.len()];\n\n    let mut curmin =\
    \ i32::MAX;\n    for i in 0..lst.len() {\n        slst[i] = i;\n        if i ==\
    \ 0 {\n            curmin = i32::MAX;\n        }\n\n        if slst[i - 1] < curmin\
    \ {\n            slst[i] = slst[i - 1];\n        }\n\n        if slst[i - 1] >\
    \ curmin {\n            slst[i] = slst[i - 1];\n        }\n\n        curmin =\
    \ slst[i];\n    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n\
    \    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\
    \n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for\
    \ i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len()\
    \ {\n        slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n  \
    \      slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i]\
    \ = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i\
    \ - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n\
    \    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\
    \n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for\
    \ i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len()\
    \ {\n        slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n  \
    \      slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i]\
    \ = slst[i - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i\
    \ - 1];\n    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n\
    \    }\n\n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\
    \n    for i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for\
    \ i in 0..lst.len() {\n        slst[i] = slst[i - 1];\n    }\n\n    for i in 0..lst.len()\
    \ {\n        sl\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8s_gozto.rs:124:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    109 |     for i in 0..lst.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n110 |         sl\n111 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n124 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `sl` in this scope\n   --> /tmp/tmp8s_gozto.rs:110:9\n   \
    \ |\n110 |         sl\n    |         ^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s_gozto.rs:18:26\n   |\n18 |         if slst[i\
    \ - 1] < curmin {\n   |                          ^^^^^^ expected `usize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if slst[i - 1] < curmin.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s_gozto.rs:22:26\n   |\n22 |         if slst[i\
    \ - 1] > curmin {\n   |                          ^^^^^^ expected `usize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         if slst[i - 1] > curmin.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s_gozto.rs:26:18\n   |\n11 |     let mut curmin\
    \ = i32::MAX;\n   |                      -------- expected due to this value\n\
    ...\n26 |         curmin = slst[i];\n   |                  ^^^^^^^ expected `i32`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8s_gozto.rs:8:42\n\
    \  |\n8 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  |    -----------------\
    \                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 6 p"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    sort::stable::sort(&lst);\n    lst\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `sort`\n\
    \ --> /tmp/tmphtgpixgc.rs:9:5\n  |\n9 |     sort::stable::sort(&lst);\n  |   \
    \  ^^^^ use of undeclared crate or module `sort`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = lst;\n    s.sort_by(|a, b| {\n        let mut\
    \ c = a;\n        if b < c {\n            c = b;\n        }\n        c\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8sopfdwd.rs:15:9\n   |\n\
    15 |         c\n   |         ^ expected enum `std::cmp::Ordering`, found `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst.len() as isize;\n    let mut i = 0;\n    let\
    \ mut max = lst.iter().max();\n    while i < l {\n        let item = lst[i];\n\
    \        let n = item as isize;\n        let mut j = i;\n        while j < l {\n\
    \            let item_j = lst[j];\n            let n_j = item_j as isize;\n  \
    \          if n_j > n {\n                break;\n            }\n            l\
    \ -= 1;\n            i += 1;\n        }\n        i += 1;\n        j += 1;\n  \
    \      lst[j - 1] = item;\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4x_cv4ow.rs:13:20\n\
    \   |\n13 |         let item = lst[i];\n   |                    ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4x_cv4ow.rs:17:26\n   |\n17 |            \
    \ let item_j = lst[j];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4x_cv4ow.rs:27:9\n   |\n27 |         lst[j\
    \ - 1] = item;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = lst;\n    res\n        .iter()\n        .sort_by_key(|&x|\
    \ {\n            match x {\n                x if x > res.min() => (*res as f32).max(&x).min(),\n\
    \                x if x < res.min() => (*res as f32).min(&x),\n              \
    \  x if x == res.min() => (*res as f32).min(&x),\n                x if x == res.max()\
    \ => (*res as f32).max(&x),\n                _ => x,\n            }\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpkydhwn2n.rs:12:10\n   |\n12 |         .sort_by_key(|&x|\
    \ {\n   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpkydhwn2n.rs:14:30\n    |\n14  |                 x if x > res.min()\
    \ => (*res as f32).max(&x).min(),\n    |                              ^^^- supplied\
    \ 0 arguments\n    |                              |\n    |                   \
    \           expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkydhwn2n.rs:14:57\n   |\n14 |\
    \                 x if x > res.min() => (*res as f32).max(&x).min(),\n   |   \
    \                                                      ^^ expected `f32`, found\
    \ reference\n   |\n   = note:   expected type `f32`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n14 -                 x if x\
    \ > res.min() => (*res as f32).max(&x).min(),\n14 +                 x if x > res.min()\
    \ => (*res as f32).max(x).min(),\n   | \n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmpkydhwn2n.rs:14:61\n \
    \   |\n14  |                 x if x > res.min() => (*res as f32).max(&x).min(),\n\
    \    |                                                             ^^^- supplied\
    \ 0 arguments\n    |                                                         \
    \    |\n    |                                                             expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpkydhwn2n.rs:15:30\n\
    \    |\n15  |                 x if x < res.min() => (*res as f32).min(&x),\n \
    \   |                              ^^^- supplied 0 arguments\n    |          \
    \                    |\n    |                              expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkydhwn2n.rs:15"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max_value = -std::i64::MAX;\n\
    \    let mut min_value = 0;\n    for el in lst {\n        if el < min_value {\n\
    \            min_value = el;\n        }\n        if el > max_value {\n       \
    \     max_value = el;\n        }\n    }\n    for i in (0..(lst.len() - 1)) as\
    \ usize {\n        let el = lst[i];\n        if el < min_value {\n           \
    \ ret.push(min_value);\n            min_value = el;\n        }\n        if el\
    \ > max_value {\n            ret.push(max_value);\n            max_value = el;\n\
    \        } else {\n            ret.push(el);\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9vvwnfjq.rs:16:17\n   |\n\
    16 |         if el > max_value {\n   |                 ^^^^^^^^^ expected `isize`,\
    \ found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if el > max_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9vvwnfjq.rs:17:25\n   |\n10 |     let mut max_value = -std::i64::MAX;\n\
    \   |                         -------------- expected due to this value\n...\n\
    17 |             max_value = el;\n   |                         ^^ expected `i64`,\
    \ found `isize`\n\nerror[E0277]: `usize` is not an iterator\n  --> /tmp/tmp9vvwnfjq.rs:20:14\n\
    \   |\n20 |     for i in (0..(lst.len() - 1)) as usize {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9vvwnfjq.rs:26:17\n\
    \   |\n26 |         if el > max_value {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n26 |         if el > max_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9vvwnfjq.rs:27:22\n   |\n27 |             ret.push(max_value);\n\
    \   |                      ^^^^^^^^^ expected `isize`, found `i64`\n   |\nhelp:\
    \ you can convert an `i64` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |             ret.push(max_value.try_into().unwrap());\n   | \
    \                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9vvwnfjq.rs:28:25\n   |\n10 |     let mut max_value = -std::i64::MAX;\n\
    \   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n    }\n\n    let\
    \ mut lst_out = Vec::new();\n    let mut mn = lst.min();\n    for elem in lst\
    \ {\n        if elem < mn {\n            lst_out.push(elem);\n        } else {\n\
    \            mn = lst.max();\n            lst_out.push(mn);\n        }\n    }\n\
    \    lst_out\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpu90bfxx0.rs:14:22\n    |\n14  |     let mut mn = lst.min();\n\
    \    |                      ^^^- supplied 0 arguments\n    |                 \
    \     |\n    |                      expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu90bfxx0.rs:16:19\n\
    \   |\n16 |         if elem < mn {\n   |                   ^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpu90bfxx0.rs:19:22\n    |\n19  |             mn\
    \ = lst.max();\n    |                      ^^^- supplied 0 arguments\n    |  \
    \                    |\n    |                      expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpu90bfxx0.rs:20:26\n   |\n20 |             lst_out.push(mn);\n   |  \
    \                        ^^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let min_idx = lst.iter().min_by_key(|x|\
    \ x).unwrap();\n    let max_idx = lst.iter().max_by_key(|x| x).unwrap();\n\n \
    \   loop {\n        lst.swap_remove(min_idx);\n        if min_idx == max_idx {\n\
    \            break;\n        }\n        lst.swap_remove(max_idx);\n    }\n\n \
    \   lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp383mpivc.rs:14:25\n   |\n\
    14 |         lst.swap_remove(min_idx);\n   |                         ^^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp383mpivc.rs:18:25\n\
    \   |\n18 |         lst.swap_remove(max_idx);\n   |                         ^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n \
    \   let len = lst.len();\n    let mut n = len - 1;\n    let mut i = 0;\n    let\
    \ mut max = lst[0];\n    let mut min = 0;\n    while i < len {\n        if *lst[i]\
    \ > max {\n            max = *lst[i];\n        }\n        if *lst[i] < min {\n\
    \            min = *lst[i];\n        }\n        i += 1;\n    }\n    while n >\
    \ 0 {\n        if max < min {\n            lst[i] = min;\n            i += 1;\n\
    \            n -= 1;\n        } else {\n            lst[i] = max;\n          \
    \  i += 1;\n            n -= 1;\n        }\n    }\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpiovseuqg.rs:16:12\n\
    \   |\n16 |         if *lst[i] > max {\n   |            ^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpiovseuqg.rs:17:19\n   |\n\
    17 |             max = *lst[i];\n   |                   ^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpiovseuqg.rs:19:12\n   |\n\
    19 |         if *lst[i] < min {\n   |            ^^^^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpiovseuqg.rs:20:19\n   |\n20 |\
    \             min = *lst[i];\n   |                   ^^^^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = vec![];\n    let mut current = Vec::new();\n\
    \    let mut min_value = std::isize::MAX;\n    for i in lst.iter() {\n       \
    \ current.push(i);\n        if i == min_value {\n            min_value = i;\n\
    \        }\n    }\n    for n in current {\n        for i in 0..lst.len() {\n \
    \           if n == lst[i] {\n                ret.unpush(0);\n            }\n\
    \        }\n    }\n    let mut current_iter = ret.iter();\n    if min_value ==\
    \ std::isize::MAX {\n        for _ in 0..lst.len() {\n            ret.push(current_iter.next().unwrap());\n\
    \        }\n    } else {\n        for _ in 0..lst.len() {\n            ret.push(min_value);\n\
    \        }\n        for i in 0..lst.len() {\n            if i != min_value {\n\
    \                ret.push(min_value);\n            }\n        }\n        for _\
    \ in 0..lst.len() {\n            ret.push(current_iter.next().unwrap());\n   \
    \     }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16grhbrb.rs:15:25\n   |\n\
    11 |     let mut min_value = std::isize::MAX;\n   |                         ---------------\
    \ expected due to this value\n...\n15 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp16grhbrb.rs:14:14\n   |\n14 |         if i == min_value {\n   |\
    \              ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp16grhbrb.rs:20:18\n   |\n\
    20 |             if n == lst[i] {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `unpush`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp16grhbrb.rs:21:21\n\
    \   |\n21 |                 ret.unpush(0);\n   |                     ^^^^^^ help:\
    \ there is an associated function with a similar name: `push`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp16grhbrb.rs:28:22\n   |\n28 |             ret.push(current_iter.next().unwrap());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    cyclic type of infinite size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp16grhbrb.rs:35:21\n\
    \   |\n35 |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_val = lst[0];\n\
    \    for x in lst.iter().cloned() {\n        match x {\n            x if x > min_val\
    \ => {\n                result.push(x);\n                min_val = x;\n      \
    \      }\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp0or0o_ld.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_idx = std::cmp::min(lst);\n\
    \    let mut max_idx = std::cmp::max(lst);\n    while min_idx < max_idx {\n  \
    \      result.push(min_idx);\n        min_idx = min_idx + 1;\n    }\n    while\
    \ max_idx > 0 {\n        result.push(max_idx);\n        max_idx = max_idx - 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpi_vwrvtd.rs:10:23\n     |\n10   |     let mut min_idx = std::cmp::min(lst);\n\
    \     |                       ^^^^^^^^^^^^^ --- supplied 1 argument\n     |  \
    \                     |\n     |                       expected 2 arguments\n \
    \    |\nnote: function defined here\n\nerror[E0061]: this function takes 2 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpi_vwrvtd.rs:11:23\n     |\n11 \
    \  |     let mut max_idx = std::cmp::max(lst);\n     |                       ^^^^^^^^^^^^^\
    \ --- supplied 1 argument\n     |                       |\n     |            \
    \           expected 2 arguments\n     |\nnote: function defined here\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    debug_assert!(lst.len() >= 1);\n    let mut tmp = lst.clone();\
    \ // clone original list, otherwise it will modify original list\n    let mut\
    \ min_value = tmp[0];\n    for v in tmp.iter_mut() { // iterate through the mutable\
    \ list\n        if *v < min_value { // if current value is smaller than the minimum\
    \ value\n            min_value = *v;\n        }\n        *v = *v + min_value;\
    \ // set current value to current value + minimum\n    }\n    tmp\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 5]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpfqi83c1c.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min = vec![0i32; 4];\n    let mut max = vec![0i32;\
    \ 4];\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut i = 1;\n\
    \    let mut j = lst[0];\n    while i < lst.len() {\n        let mut tmp: Vec<isize>;\n\
    \        if *i < *min {\n            tmp = [*i];\n            min_pos = i;\n \
    \       } else {\n            tmp = min;\n        }\n        if *j < *max {\n\
    \            if *j < *tmp {\n                tmp.push(*j);\n                max_pos\
    \ = j;\n            } else {\n                tmp.push(*j);\n            }\n \
    \       } else {\n            tmp.push(*j);\n        }\n        i += 1;\n    \
    \    j += 1;\n        if j == lst[i] {\n            i += 1;\n            j +=\
    \ 1;\n        }\n    }\n    if min_pos == 0 {\n        return min;\n    }\n  \
    \  if max_pos == 0 {\n        return max;\n    }\n    let mut ret = vec![];\n\
    \    for i in 0..max_pos {\n        ret.push(min[min_pos - i]);\n    }\n    for\
    \ i in 0..max_pos {\n        ret.push(max[i]);\n    }\n    for i in 0..max_pos\
    \ {\n        ret.push(min[i]);\n    }\n    for i in 0..min_pos {\n        ret.push(max[max_pos\
    \ - i]);\n    }\n    return ret;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:17:12\n\
    \   |\n17 |         if *i < *min {\n   |            ^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:18:20\n   |\n18 |        \
    \     tmp = [*i];\n   |                    ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpolckrzfs.rs:21:19\n   |\n16 |         let mut tmp: Vec<isize>;\n\
    \   |                      ---------- expected due to this type\n...\n21 |   \
    \          tmp = min;\n   |                   ^^^ expected `isize`, found `i32`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:23:12\n\
    \   |\n23 |         if *j < *max {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:24:16\n   |\n24 |        \
    \     if *j < *tmp {\n   |                ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpolckrzfs.rs:25:26\n   |\n25 |               \
    \  tmp.push(*j);\n   |                          ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:28:26\n   |\n28 |        \
    \         tmp.push(*j);\n   |                          ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpolckrzfs.rs:31:22\n   |\n31 |\
    \             tmp.push(*j);\n   |                      ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpolckrzfs.rs:41:16\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n41 |         return min;\n\
    \   |                ^^^ expected `isize`, found `i32`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpolckrzfs.rs:48:32\n   |\n48 |         ret.push(min[min_pos\
    \ - i]);\n   |                                ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpolckrzfs.rs:48:30\n\
    \   |\n48 |         ret.push(min"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut iter = lst.iter().cloned();\n    let mut result =\
    \ iter.next();\n    let mut next = iter.next();\n    while let Some(next) = next\
    \ {\n        if next.0 > next.1 {\n            result = Some(next.1);\n      \
    \      result = Some(next.0);\n        } else {\n            result = Some(next.0);\n\
    \            result = Some(next.1);\n        }\n        next = iter.next();\n\
    \    }\n    result.unwrap()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp_yu945b5.rs:13:17\n   |\n13 |         if next.0 > next.1 {\n  \
    \ |                 ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp_yu945b5.rs:13:26\n   |\n13 |         if\
    \ next.0 > next.1 {\n   |                          ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp_yu945b5.rs:14:32\n\
    \   |\n14 |             result = Some(next.1);\n   |                         \
    \       ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmp_yu945b5.rs:15:32\n   |\n15 |             result = Some(next.0);\n\
    \   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmp_yu945b5.rs:17:32\n  \
    \ |\n17 |             result = Some(next.0);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmp_yu945b5.rs:18:32\n   |\n18 |             result = Some(next.1);\n\
    \   |                                ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_yu945b5.rs:20:16\n   |\n12 |     while let Some(next) = next {\n  \
    \ |                    ---- expected due to the type of this binding\n...\n20\
    \ |         next = iter.next();\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_yu945b5.rs:22:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     result.unwrap()\n   |     ^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 8 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut slst = lst;\n    let mut sw = lst.len() - 1;\n   \
    \ while sw >= 0 {\n        while sw >= 0 {\n            slst.swap(sw + 1, sw);\n\
    \            sw--;\n        }\n        slst.swap(0, 0);\n    }\n    slst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpbenb77t9.rs:14:17\n\
    \   |\n14 |             sw--;\n   |                 ^ expected expression\n\n\
    error: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_lst = Vec::new();\n    for el in lst {\n     \
    \   let mut i = el;\n        while i /= 2 {\n            new_lst.push(i);\n  \
    \          i /= 2;\n        }\n    }\n    new_lst.push(0);\n    new_lst.sort();\n\
    \    new_lst.reverse();\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9yxpg8n.rs:12:15\n   |\n\
    12 |         while i /= 2 {\n   |               ^^^^^^ expected `bool`, found\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst.clone();\n    l.sort();\n    while l.len()\
    \ > 2 {\n        let mut m1 = l.pop().unwrap();\n        let mut m2 = l.pop().unwrap();\n\
    \        while m2 >= m1 {\n            l.push(*m2);\n            m2 = l.pop().unwrap();\n\
    \        }\n        l.push(*m1);\n        m1 = l.pop().unwrap();\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpxjse_b9h.rs:15:20\n\
    \   |\n15 |             l.push(*m2);\n   |                    ^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpxjse_b9h.rs:18:16\n   |\n\
    18 |         l.push(*m1);\n   |                ^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    if sorted_list.len() < 2 {\n\
    \        return sorted_list;\n    }\n    let mut min_element = sorted_list[0];\n\
    \    for i in 1..sorted_list.len() {\n        let mut element = sorted_list[i];\n\
    \        if min_element > element {\n            min_element = element;\n    \
    \    }\n    }\n    sorted_list = sorted_list\n        .iter()\n        .cloned()\n\
    \        .skip_while(|&x| x != min_element)\n        .collect();\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpo2mag5_5.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut min_val\
    \ = lst[0];\n    let mut max_val = lst[0];\n    for i in lst.iter() {\n      \
    \  if i < min_val {\n            min_val = i;\n        } else if i > max_val {\n\
    \            max_val = i;\n        }\n    }\n    for i in (0..lst.len() - 1).rev()\
    \ {\n        if i <= min_val {\n            let tmp = lst[i];\n            lst[i]\
    \ = min_val;\n            lst[min_val] = tmp;\n            min_val += 1;\n   \
    \     }\n        if i > max_val {\n            let tmp = lst[i];\n           \
    \ lst[i] = max_val;\n            lst[max_val] = tmp;\n            max_val -= 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9xj7il24.rs:13:16\n   |\n\
    13 |         if i < min_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&isize`, found `isize`\n   |            \
    \    help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9xj7il24.rs:14:23\n   |\n10 |     let mut min_val = lst[0];\n \
    \  |                       ------ expected due to this value\n...\n14 |      \
    \       min_val = i;\n   |                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             min_val\
    \ = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9xj7il24.rs:15:23\n   |\n15 |         } else if i > max_val {\n   |\
    \                       ^^^^^^^\n   |                       |\n   |          \
    \             expected `&isize`, found `isize`\n   |                       help:\
    \ consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9xj7il24.rs:16:23\n   |\n11 |     let mut max_val = lst[0];\n   |  \
    \                     ------ expected due to this value\n...\n16 |           \
    \  max_val = i;\n   |                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             max_val\
    \ = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9xj7il24.rs:20:17\n   |\n20 |         if i <= min_val {\n   |      \
    \           ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    20 |         if i <= min_val.try_into().unwrap() {\n   |                     \
    \   ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9xj7il24.rs:23:13\n   |\n23 |             lst[min_val]\
    \ = tmp;\n   |             ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: requ"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = lst.iter();\n    let mut first = it.next();\n\
    \    let mut last = it.next();\n\n    let mut next = first;\n    loop {\n    \
    \    if next == last {\n            break;\n        }\n        if *next < *last\
    \ {\n            // Swap next and last\n            let tmp = next;\n        \
    \    next = last;\n            last = tmp;\n        }\n    }\n\n    let mut result\
    \ = vec![first];\n    while let Some(item) = next {\n        result.push(item);\n\
    \        next = it.next();\n    }\n    result.push(last);\n\n    result\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmphqqzyd0u.rs:18:12\n\
    \   |\n18 |         if *next < *last {\n   |            ^^^^^\n\nerror[E0614]:\
    \ type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmphqqzyd0u.rs:18:20\n\
    \   |\n18 |         if *next < *last {\n   |                    ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphqqzyd0u.rs:28:21\n   |\n28 |         result.push(item);\n\
    \   |                     ^^^^ expected enum `Option`, found `&isize`\n   |\n\
    \   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\n\
    help: try wrapping the expression in `Some`\n   |\n28 |         result.push(Some(item));\n\
    \   |                     +++++    +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphqqzyd0u.rs:33:5\n   |\n8  | fn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n33 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<&isize>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = vec![lst[0]; lst.len()];\n    let mut i =\
    \ 0;\n    let mut max = vec![0; lst.len()];\n\n    for val in lst {\n        max\
    \ = vec![max[0], val, max[1]];\n        i += 1;\n    }\n\n    for i in 0..lst.len()\
    \ {\n        for j in i..lst.len() {\n            if max[j] > max[j + i] {\n \
    \               sorted[i] = max[j];\n                i += 1;\n            } else\
    \ {\n                sorted[i] = max[j + i];\n            }\n        }\n    }\n\
    \n    sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmpyqau8u8f.rs:10:13\n\
    \   |\n10 |     let mut i = 0;\n   |             ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_i` instead\n\nerror[E0382]: borrow\
    \ of moved value: `lst`\n   --> /tmp/tmpyqau8u8f.rs:18:17\n    |\n8   | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    13  |     for val in lst {\n    |                --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n18  |     for i in 0..lst.len() {\n    |      \
    \           ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for val in &lst {\n    |                +\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `i`\n  --> /tmp/tmpyqau8u8f.rs:22:17\n  \
    \ |\n18 |     for i in 0..lst.len() {\n   |         -\n   |         |\n   |  \
    \       first assignment to `i`\n   |         help: consider making this binding\
    \ mutable: `mut i`\n...\n22 |                 i += 1;\n   |                 ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0382,\
    \ E0384.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    use std::cmp::Ordering::{Gt,  Lt};\n\n    let mut lst = lst.to_vec();\n\
    \    let len = lst.len();\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n\
    \        i += 1;\n        i %= len;\n        let mut tmp = lst[i];\n        lst[i]\
    \ = lst[j];\n        lst[j] = tmp;\n        j += 1;\n        j %= len;\n     \
    \   if i == j {\n            break;\n        }\n    }\n\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved imports `std::cmp::Ordering::Gt`, `std::cmp::Ordering::Lt`\n\
    \ --> /tmp/tmp5w5lzrrq.rs:9:30\n  |\n9 |     use std::cmp::Ordering::{Gt,  Lt};\n\
    \  |                              ^^   ^^ no `Lt` in `cmp::Ordering`\n  |    \
    \                          |\n  |                              no `Gt` in `cmp::Ordering`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst.to_vec();\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpu65mp3x7.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = vec![];\n\n    for i in lst.iter().cloned().rev()\
    \ {\n        sorted.push(i);\n    }\n\n    sorted.reverse();\n\n    sorted\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpcet9rq8h.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_lst = lst.clone();\n    let mut current_min\
    \ = sorted_lst.len();\n\n    for i in 1..current_min {\n        let min = sorted_lst.iter().find(|&x|\
    \ *x == min(*sorted_lst.rbegin()).unwrap()).unwrap();\n        sorted_lst.swap(min,\
    \ i);\n    }\n\n    for i in 1..current_min {\n        let max = sorted_lst.iter().find(|&x|\
    \ *x == max(*sorted_lst.rbegin()).unwrap()).unwrap();\n        sorted_lst.swap(max,\
    \ i);\n    }\n\n    sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpjk8dcuoo.rs:13:53\n\
    \   |\n13 |         let min = sorted_lst.iter().find(|&x| *x == min(*sorted_lst.rbegin()).unwrap()).unwrap();\n\
    \   |                                                     ^^^\n...\n25 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n13 |         let min = sorted_lst.iter().find(|&x|\
    \ *x == main(*sorted_lst.rbegin()).unwrap()).unwrap();\n   |                 \
    \                                    ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max`\
    \ in this scope\n  --> /tmp/tmpjk8dcuoo.rs:18:53\n   |\n18 |         let max =\
    \ sorted_lst.iter().find(|&x| *x == max(*sorted_lst.rbegin()).unwrap()).unwrap();\n\
    \   |                                                     ^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0599]: no method named `rbegin` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpjk8dcuoo.rs:13:69\n   |\n13 |         let\
    \ min = sorted_lst.iter().find(|&x| *x == min(*sorted_lst.rbegin()).unwrap()).unwrap();\n\
    \   |                                                                     ^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjk8dcuoo.rs:14:25\n\
    \   |\n14 |         sorted_lst.swap(min, i);\n   |                         ^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0599]: no method named `rbegin` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpjk8dcuoo.rs:18:69\n\
    \   |\n18 |         let max = sorted_lst.iter().find(|&x| *x == max(*sorted_lst.rbegin()).unwrap()).unwrap();\n\
    \   |                                                                     ^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjk8dcuoo.rs:19:25\n\
    \   |\n19 |         sorted_lst.swap(max, i);\n   |                         ^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 6"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n    }\n    let mut\
    \ max = lst.iter().max();\n    let mut min = lst.iter().min();\n\n    // Start\
    \ from max and min\n    let mut sorted_list = vec![];\n    sorted_list.push(max);\n\
    \    sorted_list.push(min);\n\n    // Iterate and swap max and min\n    for (i,\
    \ val) in lst.iter().enumerate() {\n        if val > max {\n            sorted_list.push(val);\n\
    \            max = val;\n        }\n        if val < min {\n            sorted_list.push(val);\n\
    \            min = val;\n        }\n        sorted_list.push(min);\n        sorted_list.push(max);\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1hxybwc.rs:22:18\n   |\n\
    22 |         if val > max {\n   |                  ^^^ expected `&isize`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&isize`\n              \
    \     found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1hxybwc.rs:23:30\n\
    \   |\n23 |             sorted_list.push(val);\n   |                         \
    \     ^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n23 |             sorted_list.push(Some(val));\n\
    \   |                              +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph1hxybwc.rs:24:19\n   |\n12 |     let mut max = lst.iter().max();\n\
    \   |                   ---------------- expected due to this value\n...\n24 |\
    \             max = val;\n   |                   ^^^ expected enum `Option`, found\
    \ `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found\
    \ reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n24 |\
    \             max = Some(val);\n   |                   +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph1hxybwc.rs:26:18\n   |\n26 |         if val\
    \ < min {\n   |                  ^^^ expected `&isize`, found enum `Option`\n\
    \   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph1hxybwc.rs:27:30\n   |\n27 |\
    \             sorted_list.push(val);\n   |                              ^^^ expected\
    \ enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n27 |             sorted_list.push(Some(val));\n   |                   \
    \           +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1hxybwc.rs:28:19\n\
    \   |\n13 |     let mut min = lst.iter().min();\n   |                   ----------------\
    \ expected due to this value\n...\n28 |             min = val;\n   |         \
    \          ^^^ expected en"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_unstable();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmp7ev9krvg.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort_unstable();\n  |     ^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let min_value = lst[0];\n \
    \   let max_value = lst[0];\n    for elem in lst {\n        if elem > max_value\
    \ {\n            max_value = elem;\n        }\n        if elem < min_value {\n\
    \            min_value = elem;\n        }\n    }\n    for elem in lst {\n    \
    \    res.push(min_value + elem);\n    }\n    for elem in lst {\n        res.push(max_value\
    \ - elem);\n    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `max_value`\n \
    \ --> /tmp/tmpij4ez40i.rs:14:13\n   |\n11 |     let max_value = lst[0];\n   |\
    \         ---------\n   |         |\n   |         first assignment to `max_value`\n\
    \   |         help: consider making this binding mutable: `mut max_value`\n...\n\
    14 |             max_value = elem;\n   |             ^^^^^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `min_value`\n  --> /tmp/tmpij4ez40i.rs:17:13\n   |\n10 |     let min_value\
    \ = lst[0];\n   |         ---------\n   |         |\n   |         first assignment\
    \ to `min_value`\n   |         help: consider making this binding mutable: `mut\
    \ min_value`\n...\n17 |             min_value = elem;\n   |             ^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value:\
    \ `lst`\n   --> /tmp/tmpij4ez40i.rs:20:17\n    |\n8   | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    12  |     for elem in lst {\n    |                 --- `lst` moved due to this\
    \ implicit call to `.into_iter()`\n...\n20  |     for elem in lst {\n    |   \
    \              ^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |     for elem in &lst {\n    |                 +\n\nerror[E0382]:\
    \ use of moved value: `lst`\n  --> /tmp/tmpij4ez40i.rs:23:17\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    20 |     for elem in lst {\n   |                 --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n23 |     for elem in lst {\n   |              \
    \   ^^^ value used here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s con"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut slst = lst.to_vec();\n    slst.sort();\n    slst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp8vku8en6.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut max = lst.iter().max().unwrap();\n    let mut min\
    \ = lst.iter().min().unwrap();\n\n    let mut i = 0;\n    let mut j = 0;\n   \
    \ let mut k = -1;\n\n    let mut result = vec![];\n\n    while i <= max && j <=\
    \ min {\n        if lst[j] < lst[i] {\n            result.push(lst[j]);\n    \
    \        j++;\n        } else {\n            result.push(lst[i]);\n          \
    \  i++;\n        }\n    }\n\n    while i <= max {\n        result.push(lst[i]);\n\
    \        i += 1;\n    }\n\n    while j <= min {\n        result.push(lst[j]);\n\
    \        j += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp8va7nq6k.rs:21:14\n\
    \   |\n21 |             j++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n21 |             { let tmp = j; j += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n21 -             j++;\n\
    21 +             j += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmp8va7nq6k.rs:24:14\n   |\n24 |             i++;\n   |          \
    \    ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24\
    \ |             { let tmp = i; i += 1; tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n\
    24 -             i++;\n24 +             i += 1;\n   | \n\nerror[E0277]: can't\
    \ compare `isize` with `&isize`\n  --> /tmp/tmp8va7nq6k.rs:18:13\n   |\n18 | \
    \    while i <= max && j <= min {\n   |             ^^ no implementation for `isize\
    \ < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `isize`\
    \ with `&isize`\n  --> /tmp/tmp8va7nq6k.rs:18:25\n   |\n18 |     while i <= max\
    \ && j <= min {\n   |                         ^^ no implementation for `isize\
    \ < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp8va7nq6k.rs:19:12\n   |\n19 |         if\
    \ lst[j] < lst[i] {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut curr_min_int = std::i32::MAX;\n\
    \    let mut curr_max_int = std::i32::MIN;\n    let mut curr_min_idx = -1;\n\n\
    \    // Iterate over all integers in the list\n    for el in lst.iter() {\n  \
    \      // Update the minimum and maximum int values\n        if el < curr_min_int\
    \ {\n            curr_min_int = el;\n            curr_min_idx = res.len();\n \
    \       }\n        if el > curr_max_int {\n            curr_max_int = el;\n  \
    \      }\n\n        // Update the sorted res\n        if el < curr_min_int {\n\
    \            res.insert(curr_min_idx, el);\n        } else if (el >= curr_max_int\
    \ && el > curr_min_int) {\n            res.insert(curr_min_idx, el);\n       \
    \ } else if (el == curr_min_int && el == curr_max_int) {\n            res.insert(curr_min_idx,\
    \ el);\n        } else {\n            // Update the min idx for remaining numbers\n\
    \            let mut el_idx = curr_min_idx;\n            while el_idx > 0 && el_idx\
    \ % 2 == 0 {\n                el_idx /= 2;\n            }\n            res.insert(el_idx,\
    \ el);\n        }\n    }\n\n    // Return the res\n    res\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe2ivzfsy.rs:28:19\n\
    \   |\n28 |         } else if (el >= curr_max_int && el > curr_min_int) {\n  \
    \ |                   ^                                       ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    28 -         } else if (el >= curr_max_int && el > curr_min_int) {\n28 +     \
    \    } else if el >= curr_max_int && el > curr_min_int {\n   | \n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmpe2ivzfsy.rs:30:19\n   |\n30\
    \ |         } else if (el == curr_min_int && el == curr_max_int) {\n   |     \
    \              ^                                        ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n30 -         } else if (el == curr_min_int && el ==\
    \ curr_max_int) {\n30 +         } else if el == curr_min_int && el == curr_max_int\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2ivzfsy.rs:17:17\n\
    \   |\n17 |         if el < curr_min_int {\n   |                 ^^^^^^^^^^^^\
    \ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2ivzfsy.rs:18:28\n\
    \   |\n10 |     let mut curr_min_int = std::i32::MAX;\n   |                  \
    \          ------------- expected due to this value\n...\n18 |             curr_min_int\
    \ = el;\n   |                            ^^ expected `i32`, found `&isize`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpe2ivzfsy.rs:12:28\n\
    \   |\n12 |     let mut curr_min_idx = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe2ivzfsy.rs:21:17\n   |\n21 |         if el\
    \ > curr_max_int {\n   |                 ^^^^^^^^^^^^ expected `&isize`, found\
    \ `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2ivzfsy.rs:22:28\n \
    \  |\n11 |     let mut curr_max_int = "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpkvrnayn4.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n \
    \   lst.sort_unstable();\n    return lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpwopmfdqh.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut current = lst[0];\n    let mut result = Vec::with_capacity(lst.len());\n\
    \    for n in lst.iter() {\n        if n <= current {\n            result.push(n);\n\
    \        } else {\n            result.push(current);\n            result.push(n);\n\
    \        }\n        current = n;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc4cdr62u.rs:12:17\n   |\n\
    12 |         if n <= current {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected `&isize`, found `isize`\n   |        \
    \         help: consider borrowing here: `&current`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc4cdr62u.rs:15:25\n   |\n15 |             result.push(current);\n\
    \   |                         ^^^^^^^\n   |                         |\n   |  \
    \                       expected `&isize`, found `isize`\n   |               \
    \          help: consider borrowing here: `&current`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc4cdr62u.rs:18:19\n   |\n9  |     let mut current = lst[0];\n\
    \   |                       ------ expected due to this value\n...\n18 |     \
    \    current = n;\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |         current = *n;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc4cdr62u.rs:20:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = lst.len();\n    while i > 0 {\n        let min\
    \ = lst[i / 2];\n        let max = lst.len() - i - 1;\n        let (mut mx, mut\
    \ mn) = if min > max { (max, min) } else { (min, max) };\n        for i in 1..i\
    \ {\n            let mut tmp = mn;\n            mx = mn;\n            mn = tmp;\n\
    \            let mut c = lst[i];\n            if mx < c {\n                let\
    \ tmp = mx;\n                mx = c;\n                mn = tmp;\n            }\n\
    \            lst[i] = mn;\n        }\n        i -= 1;\n    }\n    lst\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqn79lwq6.rs:13:41\n   |\n\
    13 |         let (mut mx, mut mn) = if min > max { (max, min) } else { (min, max)\
    \ };\n   |                                         ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |         let (mut mx, mut mn) = if min\
    \ > max.try_into().unwrap() { (max, min) } else { (min, max) };\n   |        \
    \                                    ++++++++++++++++++++\n\nerror[E0308]: `if`\
    \ and `else` have incompatible types\n  --> /tmp/tmpqn79lwq6.rs:13:67\n   |\n\
    13 |         let (mut mx, mut mn) = if min > max { (max, min) } else { (min, max)\
    \ };\n   |                                               ----------          ^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |                                      \
    \         |\n   |                                               expected because\
    \ of this\n   |\n   = note: expected tuple `(usize, isize)`\n              found\
    \ tuple `(isize, usize)`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min = i32::MAX;\n    let mut max = i32::MIN;\n   \
    \ let mut middle = 0;\n    let mut sorted: Vec<isize> = Vec::new();\n    for elt\
    \ in lst {\n        min = elt;\n        max = elt;\n        middle = elt;\n  \
    \  }\n    while max > min {\n        middle = min + (max - min) / 2;\n       \
    \ if lst[middle] < min {\n            min = middle + 1;\n        } else {\n  \
    \          max = middle;\n        }\n    }\n    for elt in lst {\n        if elt\
    \ >= min && elt <= max {\n            sorted.push(elt);\n        }\n    }\n  \
    \  sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeaw_f9lq.rs:14:15\n   |\n\
    9  |     let mut min = i32::MAX;\n   |                   -------- expected due\
    \ to this value\n...\n14 |         min = elt;\n   |               ^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeaw_f9lq.rs:15:15\n\
    \   |\n10 |     let mut max = i32::MIN;\n   |                   -------- expected\
    \ due to this value\n...\n15 |         max = elt;\n   |               ^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeaw_f9lq.rs:19:18\n\
    \   |\n11 |     let mut middle = 0;\n   |                      - expected due\
    \ to this value\n...\n19 |         middle = min + (max - min) / 2;\n   |     \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpeaw_f9lq.rs:20:12\n\
    \   |\n20 |         if lst[middle] < min {\n   |            ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeaw_f9lq.rs:21:19\n   |\n9  |     let mut min = i32::MAX;\n   |\
    \                   -------- expected due to this value\n...\n21 |           \
    \  min = middle + 1;\n   |                   ^^^^^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeaw_f9lq.rs:23:19\n\
    \   |\n10 |     let mut max = i32::MIN;\n   |                   -------- expected\
    \ due to this value\n...\n23 |             max = middle;\n   |               \
    \    ^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeaw_f9lq.rs:27:19\n   |\n27 |         if elt >= min && elt <= max\
    \ {\n   |                   ^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         if elt >= min.try_into().unw"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    let mut min_val = lst.min();\n\
    \    let mut max_val = lst.max();\n    loop {\n        lst.remove(&min_val);\n\
    \        lst.remove(&max_val);\n        if lst.len() == 0 {\n            break;\n\
    \        }\n        min_val = lst.min();\n        max_val = lst.max();\n    }\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp76m00_ti.rs:10:27\n    |\n10  |     let mut min_val = lst.min();\n\
    \    |                           ^^^- supplied 0 arguments\n    |            \
    \               |\n    |                           expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmp76m00_ti.rs:11:27\n \
    \   |\n11  |     let mut max_val = lst.max();\n    |                         \
    \  ^^^- supplied 0 arguments\n    |                           |\n    |       \
    \                    expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76m00_ti.rs:13:20\n  \
    \ |\n13 |         lst.remove(&min_val);\n   |                    ^^^^^^^^ expected\
    \ `usize`, found `&Vec<isize>`\n   |\n   = note:   expected type `usize`\n   \
    \        found reference `&Vec<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp76m00_ti.rs:14:20\n   |\n14 |         lst.remove(&max_val);\n   |  \
    \                  ^^^^^^^^ expected `usize`, found `&Vec<isize>`\n   |\n   =\
    \ note:   expected type `usize`\n           found reference `&Vec<isize>`\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \  --> /tmp/tmp76m00_ti.rs:18:23\n    |\n18  |         min_val = lst.min();\n\
    \    |                       ^^^- supplied 0 arguments\n    |                \
    \       |\n    |                       expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmp76m00_ti.rs:19:23\n    |\n19  |    \
    \     max_val = lst.max();\n    |                       ^^^- supplied 0 arguments\n\
    \    |                       |\n    |                       expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut current = vec![lst[0]];\n    let mut sorted = vec![current];\n\
    \n    for x in lst.iter().skip(1).rev() {\n        sorted.push(current);\n   \
    \     current = vec![*current];\n        current.push(x);\n    }\n\n    sorted\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl62t8e5e.rs:14:24\n   |\n\
    14 |         current = vec![*current];\n   |                        ^^^^^^^^ expected\
    \ `isize`, found slice `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl62t8e5e.rs:15:22\n\
    \   |\n15 |         current.push(x);\n   |                      ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \       current.push(*x);\n   |                      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl62t8e5e.rs:18:5\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n18 |     sorted\n   |   \
    \  ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = lst.to_vec();\n    for mut val in result.iter_mut()\
    \ {\n        if val == result.len() - 1 {\n            *val = val.clone()\n  \
    \      } else {\n            let last = val.clone();\n            for mut c in\
    \ result.iter() {\n                if c == last {\n                    *c = val.clone()\
    \ + 1;\n                }\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&mut isize` with `usize`\n  --> /tmp/tmpnt0ttrpk.rs:11:16\n\
    \   |\n11 |         if val == result.len() - 1 {\n   |                ^^ no implementation\
    \ for `&mut isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is\
    \ not implemented for `&mut isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpnt0ttrpk.rs:16:22\n   |\n16 |                 if\
    \ c == last {\n   |                      ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut largest = lst.iter().max().unwrap();\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    sorted_list.push(smallest);\n\
    \    for i in lst.iter().skip(1) {\n        if *i > *largest {\n            sorted_list.push(*largest);\n\
    \            largest = i;\n        } else {\n            sorted_list.push(*i);\n\
    \        }\n    }\n    sorted_list.push(largest);\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhupsm7f.rs:15:30\n   |\n\
    15 |             sorted_list.push(*largest);\n   |                           \
    \   ^^^^^^^^\n   |                              |\n   |                      \
    \        expected `&isize`, found `isize`\n   |                              help:\
    \ consider borrowing here: `&*largest`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphhupsm7f.rs:18:30\n   |\n18 |             sorted_list.push(*i);\n  \
    \ |                              ^^\n   |                              |\n   |\
    \                              expected `&isize`, found `isize`\n   |        \
    \                      help: consider borrowing here: `&*i`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphhupsm7f.rs:22:5\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n22 |     sorted_list\n  \
    \ |     ^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut current = std::collections::HashSet::new();\n    let\
    \ mut max = lst.iter().max().unwrap();\n    let mut min = lst.iter().min().unwrap();\n\
    \n    while let Some(next) = current.pop() {\n        let next = cmp::min(cmp::max(next,\
    \ min), max);\n        current = current.insert(next);\n        min = next;\n\
    \    }\n\n    lst.iter().cloned().collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp9trbw41b.rs:14:20\n   |\n14 |         let next = cmp::min(cmp::max(next,\
    \ min), max);\n   |                    ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmp9trbw41b.rs:14:29\n   |\n14 |         let next = cmp::min(cmp::max(next,\
    \ min), max);\n   |                             ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror[E0599]: no method named `pop` found for struct `HashSet`\
    \ in the current scope\n  --> /tmp/tmp9trbw41b.rs:13:36\n   |\n13 |     while\
    \ let Some(next) = current.pop() {\n   |                                    ^^^\
    \ method not found in `HashSet<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9trbw41b.rs:15:19\n\
    \   |\n9  |     let mut current = std::collections::HashSet::new();\n   |    \
    \                   -------------------------------- expected due to this value\n\
    ...\n15 |         current = current.insert(next);\n   |                   ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashSet`, found `bool`\n   |\n   = note: expected struct `HashSet<_>`\n\
    \                found type `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n   \
    \ // Split list into sublists (sublists are in reverse order).\n    let mut a\
    \ = lst.to_vec();\n    let mut b = a.clone();\n\n    for sub in b.chunks_mut(2)\
    \ {\n        let min_val = sub.iter().min().unwrap();\n        let max_val = sub.iter().max().unwrap();\n\
    \        std::mem::swap(&mut sub[0], &mut sub[sub.len() - 1]);\n        sub[sub.len()\
    \ - 1] = min_val;\n        sub[0] = max_val;\n    }\n\n    b.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppnjpijkt.rs:21:30\n   |\n\
    21 |         sub[sub.len() - 1] = min_val;\n   |         ------------------  \
    \ ^^^^^^^ expected `isize`, found `&isize`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         sub[sub.len() - 1] = *min_val;\n   |                     \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnjpijkt.rs:22:18\n\
    \   |\n22 |         sub[0] = max_val;\n   |         ------   ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |         |\n   |         expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n22 | \
    \        sub[0] = *max_val;\n   |                  +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpcl4q9noe.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|a, b| if b < a { b } else { a })\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplamyrer4.rs:9:35\n  |\n9 |\
    \     lst.sort_by(|a, b| if b < a { b } else { a })\n  |                     \
    \              ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmplamyrer4.rs:9:46\n  |\n9 |     lst.sort_by(|a,\
    \ b| if b < a { b } else { a })\n  |                                         \
    \     ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmplamyrer4.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n9 |     lst.sort_by(|a, b| if b < a { b\
    \ } else { a })\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n    \
    \      found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n    for i in lst {\n      \
    \  sorted_list.push(i);\n    }\n    sorted_list.sort_by_key(|x| x % 10);\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpjp1qy00p.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = lst.len();\n\
    \    while i < k {\n        while j < k {\n            if lst[i] > lst[j] {\n\
    \                swap(j, k);\n            }\n            j += 1\n        }\n \
    \       i += 1;\n        j = 0;\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp9zvvfu8l.rs:15:17\n\
    \   |\n15 |                 swap(j, k);\n   |                 ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.clone();\n    lst.sort();\n    lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpuxo24641.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort_by_key(|&i|\
    \ {\n        i as isize\n    });\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9qx6d5du.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    // Return list if length is 0\n    if lst.len() == 0 {\n \
    \       return vec![];\n    }\n\n    // Get first element from list\n    let mut\
    \ first_element = lst[0];\n    let mut rest_of_list = lst.iter().skip(1);\n\n\
    \    // Iterate through remaining elements\n    for element in rest_of_list {\n\
    \        // If element is greater than first element\n        if element > first_element\
    \ {\n            // Swap with first element\n            let tmp = first_element;\n\
    \            first_element = element;\n            element = tmp;\n        }\n\
    \    }\n\n    // Return list after first element is swapped with rest of elements\n\
    \    vec![first_element] + rest_of_list\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqier53fh.rs:21:22\n   |\n\
    21 |         if element > first_element {\n   |                      ^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&first_element`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqier53fh.rs:24:29\n   |\n15 |\
    \     let mut first_element = lst[0];\n   |                             ------\
    \ expected due to this value\n...\n24 |             first_element = element;\n\
    \   |                             ^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n24 |             first_element\
    \ = *element;\n   |                             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqier53fh.rs:25:23\n   |\n19 |     for element in rest_of_list\
    \ {\n   |         ------- expected due to the type of this binding\n...\n25 |\
    \             element = tmp;\n   |                       ^^^\n   |           \
    \            |\n   |                       expected `&isize`, found `isize`\n\
    \   |                       help: consider borrowing here: `&tmp`\n\nerror[E0369]:\
    \ cannot add `Skip<std::slice::Iter<'_, isize>>` to `Vec<isize>`\n  --> /tmp/tmpqier53fh.rs:30:25\n\
    \   |\n30 |     vec![first_element] + rest_of_list\n   |     -------------------\
    \ ^ ------------ Skip<std::slice::Iter<'_, isize>>\n   |     |\n   |     Vec<isize>\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst.len();\n    let mut min: isize = 0;\n    let\
    \ mut max: isize = 0;\n    loop {\n        let min_idx = l.iter().min_by_key(|i|\
    \ if i < min { i } else { min = i });\n        let max_idx = l.iter().max_by_key(|i|\
    \ if i > max { i } else { max = i });\n        if min_idx == max_idx {\n     \
    \       return vec![];\n        }\n        let mut mid = min_idx + ((max_idx -\
    \ min_idx) >> 1);\n        let rest = &mut l[mid..];\n        l = &mut rest;\n\
    \    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpzx_9y1bo.rs:13:25\n   |\n13 |         let min_idx = l.iter().min_by_key(|i|\
    \ if i < min { i } else { min = i });\n   |                         ^^^^ method\
    \ not found in `usize`\n\nerror[E0308]: `if` and `else` have incompatible types\n\
    \  --> /tmp/tmpzx_9y1bo.rs:13:71\n   |\n13 |         let min_idx = l.iter().min_by_key(|i|\
    \ if i < min { i } else { min = i });\n   |                                  \
    \                          -          ^^^^^^^ expected `isize`, found `()`\n \
    \  |                                                            |\n   |      \
    \                                                      expected because of this\n\
    \nerror[E0599]: no method named `iter` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpzx_9y1bo.rs:14:25\n   |\n14 |         let max_idx = l.iter().max_by_key(|i|\
    \ if i > max { i } else { max = i });\n   |                         ^^^^ method\
    \ not found in `usize`\n\nerror[E0308]: `if` and `else` have incompatible types\n\
    \  --> /tmp/tmpzx_9y1bo.rs:14:71\n   |\n14 |         let max_idx = l.iter().max_by_key(|i|\
    \ if i > max { i } else { max = i });\n   |                                  \
    \                          -          ^^^^^^^ expected `isize`, found `()`\n \
    \  |                                                            |\n   |      \
    \                                                      expected because of this\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpzx_9y1bo.rs:19:25\n\
    \   |\n19 |         let rest = &mut l[mid..];\n   |                         ^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzx_9y1bo.rs:20:13\n   |\n9  |\
    \     let mut l = lst.len();\n   |                 --------- expected due to this\
    \ value\n...\n20 |         l = &mut rest;\n   |             ^^^^^^^^^ expected\
    \ `usize`, found `&mut _`\n   |\n   = note:           expected type `usize`\n\
    \           found mutable reference `&mut _`\nhelp: consider removing the borrow\n\
    \   |\n20 -         l = &mut rest;\n20 +         l = rest;\n   | \n\nerror: ab"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min = isize::MAX;\n    for e in lst {\n        if\
    \ e < min {\n            min = e;\n        }\n    }\n    let mut max = lst.len()\
    \ - 1;\n    let mut tmp;\n    while tmp < max {\n        if min < lst[tmp] {\n\
    \            lst[tmp] = min;\n            min = lst[tmp + 1];\n        }\n   \
    \     if lst[tmp] > max {\n            lst[tmp] = max;\n            max = tmp;\n\
    \        }\n        tmp += 1;\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `usize`\n  --> /tmp/tmpgqhwstb5.rs:22:21\n\
    \   |\n22 |         if lst[tmp] > max {\n   |                     ^ no implementation\
    \ for `isize < usize` and `isize > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0271]: type mismatch resolving\
    \ `<usize as SliceIndex<[isize]>>::Output == usize`\n  --> /tmp/tmpgqhwstb5.rs:23:13\n\
    \   |\n23 |             lst[tmp] = max;\n   |             ^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0271, E0277.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = lst.iter().cloned();\n    let mut min = it.next();\n\
    \    let mut max = it.next();\n\n    // Check if any element is the minimum\n\
    \    if min.peek().is_some() {\n        min = it.next();\n    }\n    // Check\
    \ if any element is the maximum\n    if max.peek().is_some() {\n        max =\
    \ it.next();\n    }\n\n    match min.peek() {\n        Some(i) => {\n        \
    \    it.next();\n            let mut next = it;\n            repeat_block(&mut\
    \ it, &mut max, &mut min, &mut next);\n            it.extend(next.filter_map(|i|\
    \ i));\n        }\n        None => return lst,\n    }\n\n    match max.peek()\
    \ {\n        Some(i) => {\n            let mut next = it;\n            repeat_block(&mut\
    \ it, &mut min, &mut max, &mut next);\n            it.extend(next.filter_map(|i|\
    \ i));\n        }\n        None => return lst,\n    }\n\n    match min.peek()\
    \ {\n        Some(i) => {\n            let mut next = it;\n            repeat_block(&mut\
    \ it, &mut min, &mut max, &mut next);\n            it.extend(next.filter_map(|i|\
    \ i));\n        }\n        None => return lst,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `repeat_block` in this scope\n  -->\
    \ /tmp/tmpvipwdw8d.rs:26:13\n   |\n26 |             repeat_block(&mut it, &mut\
    \ max, &mut min, &mut next);\n   |             ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `repeat_block` in this scope\n \
    \ --> /tmp/tmpvipwdw8d.rs:35:13\n   |\n35 |             repeat_block(&mut it,\
    \ &mut min, &mut max, &mut next);\n   |             ^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `repeat_block` in this scope\n\
    \  --> /tmp/tmpvipwdw8d.rs:44:13\n   |\n44 |             repeat_block(&mut it,\
    \ &mut min, &mut max, &mut next);\n   |             ^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `peek` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpvipwdw8d.rs:14:12\n   |\n14 |     if min.peek().is_some()\
    \ {\n   |            ^^^^ method not found in `Option<isize>`\n\nerror[E0599]:\
    \ no method named `peek` found for enum `Option` in the current scope\n  --> /tmp/tmpvipwdw8d.rs:18:12\n\
    \   |\n18 |     if max.peek().is_some() {\n   |            ^^^^ method not found\
    \ in `Option<isize>`\n\nerror[E0599]: no method named `peek` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpvipwdw8d.rs:22:15\n   |\n22 |     match\
    \ min.peek() {\n   |               ^^^^ method not found in `Option<isize>`\n\n\
    error[E0599]: no method named `extend` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpvipwdw8d.rs:27:16\n   |\n27 |             it.extend(next.filter_map(|i|\
    \ i));\n   |                ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvipwdw8d.rs:27:43\n\
    \   |\n27 |             it.extend(next.filter_map(|i| i));\n   |             \
    \                              ^ expected enum `Option`, found `isize`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found type `isize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n27 |             it.extend(next.filter_map(|i|\
    \ Some(i)));\n   |                                           +++++ +\n\nerror[E0599]:\
    \ no method named"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.len() <= 1 {\n        return lst\n    }\n    let mut\
    \ max = lst.iter().max();\n    let mut min = lst.iter().min();\n    let mut res\
    \ = Vec::new();\n    while let Some(mut i) = lst.iter().cloned().find(|&x| *x\
    \ > max) {\n        lst.remove(i);\n        res.push(i);\n    }\n    while let\
    \ Some(mut i) = lst.iter().cloned().find(|&x| *x < min) {\n        lst.remove(i);\n\
    \        res.push(i);\n    }\n    res.sort_unstable();\n    return res;\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpxfj_ir1p.rs:15:59\n\
    \   |\n15 |     while let Some(mut i) = lst.iter().cloned().find(|&x| *x > max)\
    \ {\n   |                                                           ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxfj_ir1p.rs:16:20\n   |\n16 |         lst.remove(i);\n\
    \   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         lst.remove(i.try_into().unwrap());\n   |                 \
    \    ++++++++++++++++++++\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpxfj_ir1p.rs:19:59\n   |\n19 |     while let Some(mut i) = lst.iter().cloned().find(|&x|\
    \ *x < min) {\n   |                                                          \
    \ ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxfj_ir1p.rs:20:20\n   |\n\
    20 |         lst.remove(i);\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |         lst.remove(i.try_into().unwrap());\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst.clone();\n    for &i in sorted_list.iter_mut()\
    \ {\n        let mut smallest = i;\n        let mut largest = i;\n        for\
    \ &j in sorted_list.iter() {\n            if *j < smallest {\n               \
    \ smallest = *j;\n            }\n            if *j > largest {\n             \
    \   largest = *j;\n            }\n        }\n        smallest = smallest.max(smallest);\n\
    \        largest = largest.min(largest);\n        *i = smallest;\n        *i =\
    \ largest;\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp71olvvv0.rs:10:9\n   |\n\
    10 |     for &i in sorted_list.iter_mut() {\n   |         ^^    ----------------------\
    \ this expression has type `Option<&mut isize>`\n   |         |\n   |        \
    \ types differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note: expected mutable reference `&mut isize`\n    \
    \                  found reference `&_`\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmp71olvvv0.rs:14:16\n   |\n14 |             if *j\
    \ < smallest {\n   |                ^^\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmp71olvvv0.rs:15:28\n   |\n15 |                 smallest\
    \ = *j;\n   |                            ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp71olvvv0.rs:17:16\n   |\n17 |             if\
    \ *j > largest {\n   |                ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp71olvvv0.rs:18:27\n   |\n18 |               \
    \  largest = *j;\n   |                           ^^\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let len = lst.len();\n\n    for i in 0..len {\n        let\
    \ current = lst.iter().nth(i);\n        let next = lst.iter().nth(len - i);\n\n\
    \        match current {\n            None => {\n                let tmp = next;\n\
    \                next = next.next();\n                lst.insert(len - i, tmp);\n\
    \            }\n            Some(current) => {\n                match next {\n\
    \                    None => {\n                        lst.insert(i, current);\n\
    \                    }\n                    Some(next) => {\n                \
    \        lst.insert(i, current);\n                        lst.insert(len - i -\
    \ 1, next);\n                    }\n                }\n            }\n       \
    \ }\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpaau5ilo0.rs:18:29\n   |\n18 |                 next = next.next();\n\
    \   |                             ^^^^ method not found in `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpaau5ilo0.rs:19:37\n   |\n19 |  \
    \               lst.insert(len - i, tmp);\n   |                              \
    \       ^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaau5ilo0.rs:24:39\n   |\n24 |                         lst.insert(i,\
    \ current);\n   |                                       ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \                       lst.insert(i, *current);\n   |                       \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaau5ilo0.rs:27:39\n\
    \   |\n27 |                         lst.insert(i, current);\n   |            \
    \                           ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n27 |                         lst.insert(i,\
    \ *current);\n   |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaau5ilo0.rs:28:49\n   |\n28 |                         lst.insert(len\
    \ - i - 1, next);\n   |                                                 ^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |                         lst.insert(len - i - 1, *next);\n   |           \
    \                                      +\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = lst[0];\n    let mut j = 0;\n\n    loop {\n  \
    \      if i == lst[j] {\n            i += 1;\n            continue;\n        }\n\
    \n        if i == lst[j] + 1 {\n            i += 1;\n        }\n        \n   \
    \     if j == lst.len() - 1 {\n            return vec![i - 1, i + 1];\n      \
    \  }\n\n        if i == lst[j] + 2 {\n            j += 1;\n        }\n       \
    \ \n        if j == lst.len() - 2 {\n            return vec![i - 1, i + 1, j +\
    \ 1, i + 1, j + 1];\n        }\n\n        return vec![i - 1, i + 1, j + 1, i +\
    \ 1, j + 2];\n    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhtalfle.rs:31:39\n   |\n\
    31 |             return vec![i - 1, i + 1, j + 1, i + 1, j + 1];\n   |       \
    \                                ^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n31 |             return vec![i - 1, i + 1, (j + 1).try_into().unwrap(),\
    \ i + 1, j + 1];\n   |                                       +     +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwhtalfle.rs:34:35\n   |\n34 |\
    \         return vec![i - 1, i + 1, j + 1, i + 1, j + 2];\n   |              \
    \                     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n34 |         return vec![i - 1, i + 1, (j + 1).try_into().unwrap(), i +\
    \ 1, j + 2];\n   |                                   +     +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst\n        .iter()\n        .zip(\n            lst\n   \
    \             .iter()\n                .map(|x| x.clone())\n                .collect::<Vec<_>>(),\n\
    \        )\n        .sort_by(|(&a, &b)| b - a)\n        .map(|x| x.0)\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Zip` in the current\
    \ scope\n  --> /tmp/tmpf8hqa86r.rs:17:10\n   |\n17 |         .sort_by(|(&a, &b)|\
    \ b - a)\n   |          ^^^^^^^ method not found in `Zip<std::slice::Iter<'_,\
    \ isize>, std::vec::IntoIter<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n    }\n\n    let\
    \ mut first_value = lst[0];\n    let mut max_value = first_value;\n    let mut\
    \ min_value = first_value;\n\n    for val in lst.iter().skip(1) {\n        if\
    \ val > max_value {\n            max_value = val;\n        }\n        if val <\
    \ min_value {\n            min_value = val;\n        }\n    }\n\n    vec![min_value,\
    \ max_value, first_value]\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8iw9njmo.rs:18:18\n   |\n\
    18 |         if val > max_value {\n   |                  ^^^^^^^^^\n   |     \
    \             |\n   |                  expected `&isize`, found `isize`\n   |\
    \                  help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iw9njmo.rs:19:25\n   |\n14 |     let mut max_value\
    \ = first_value;\n   |                         ----------- expected due to this\
    \ value\n...\n19 |             max_value = val;\n   |                        \
    \ ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |             max_value = *val;\n   |                     \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8iw9njmo.rs:21:18\n  \
    \ |\n21 |         if val < min_value {\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&isize`, found `isize`\n\
    \   |                  help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iw9njmo.rs:22:25\n   |\n15 |     let mut min_value\
    \ = first_value;\n   |                         ----------- expected due to this\
    \ value\n...\n22 |             min_value = val;\n   |                        \
    \ ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n22 |             min_value = *val;\n   |                     \
    \    +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut rev = lst.into_iter().rev();\n    let mut sorted_list\
    \ = lst.clone();\n    while !rev.next().is_none() {\n        sorted_list.pop_back();\n\
    \        sorted_list.push(rev.next().unwrap());\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop_back` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpyprwk46_.rs:12:21\n   |\n12 |         sorted_list.pop_back();\n\
    \   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut minimum = lst[0];\n\
    \    let mut maximum = lst[0];\n\n    for i in lst.iter().rev() {\n        if\
    \ minimum == i {\n            minimum = maximum;\n            maximum = i;\n \
    \           continue;\n        }\n\n        if minimum > i {\n            minimum\
    \ = i;\n        }\n\n        if maximum < i {\n            maximum = i;\n    \
    \    }\n    }\n\n    for i in lst.iter().rev() {\n        if minimum == i {\n\
    \            minimum = maximum;\n            maximum = i;\n            continue;\n\
    \        }\n\n        if minimum > i {\n            minimum = i;\n        }\n\n\
    \        if maximum < i {\n            maximum = i;\n        }\n    }\n\n    for\
    \ i in lst.iter().rev() {\n        if minimum == i {\n            minimum = maximum;\n\
    \            maximum = i;\n            continue;\n        }\n\n        if minimum\
    \ > i {\n            minimum = i;\n        }\n\n        if maximum < i {\n   \
    \         maximum = i;\n        }\n    }\n\n    for i in lst.iter().rev() {\n\
    \        if minimum == i {\n            minimum = maximum;\n            maximum\
    \ = i;\n            continue;\n        }\n\n        if minimum > i {\n       \
    \     minimum = i;\n        }\n\n        if maximum < i {\n            maximum\
    \ = i;\n        }\n    }\n\n    for i in lst.iter().rev() {\n        if minimum\
    \ == i {\n            minimum = maximum;\n            maximum = i;\n         \
    \   continue;\n        }\n\n        if minimum > i {\n            minimum = i;\n\
    \        }\n\n        if maximum < i {\n            maximum = i;\n        }\n\
    \    }\n\n    for i in lst.iter().rev() {\n        if minimum == i {\n       \
    \     minimum = maximum;\n            maximum = i;\n            continue;\n  \
    \      }\n\n        if minimum > i {\n            minimum = i;\n        }\n\n\
    \        if maximum < i {\n            maximum = i;\n        }\n    }\n\n    for\
    \ i in lst.iter().rev() {\n        if minimum == i {\n            minimum = maximum;\n\
    \            maximum = i;\n            continue;\n        }\n\n        if minimum\
    \ > i {\n            minimum = i;\n        }\n\n        if maximum < i {\n   \
    \         maximum = i;\n        }\n    }\n\n    for i in lst.iter().rev() {\n\
    \        if minimum == i {\n            minimum = maximum;\n            maximum\
    \ = i;\n            continue;\n        }\n\n        if minimum > i {\n       \
    \     minimum = i;\n        }\n\n        if maximum < i {\n            maximum\
    \ = i;\n        }\n    }\n\n    for i in lst.iter().rev() {\n        if minimum\
    \ == i {\n            minimum = maximum;\n            maximum = i;\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp84ewonmp.rs:158:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    141 |     for i in lst.iter().rev() {\n    |                               - unclosed\
    \ delimiter\n142 |         if minimum == i {\n    |                         -\
    \ this delimiter might not be properly closed...\n...\n145 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n158 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp84ewonmp.rs:14:23\n   |\n14 |  \
    \       if minimum == i {\n   |                       ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \ if minimum == *i {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp84ewonmp.rs:16:23\n   |\n11 |     let mut maximum = lst[0];\n\
    \   |                       ------ expected due to this value\n...\n16 |     \
    \        maximum = i;\n   |                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             maximum\
    \ = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp84ewonmp.rs:20:22\n   |\n20 |         if minimum > i {\n   |       \
    \               ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n20 |         if minimum > *i {\n   |                     \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp84ewonmp.rs:21:23\n   |\n\
    10 |     let mut minimum = lst[0];\n   |                       ------ expected\
    \ due to this value\n...\n21 |             minimum = i;\n   |                \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |             minimum = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp84ewonmp.rs:24:22\n   |\n\
    24 |         if maximum < i {\n   |                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |        \
    \ if maxim"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = Vec::new();\n\
    \    let mut min = Vec::new();\n\n    // Find max and min elements and store them\
    \ in vectors\n    for elt in lst {\n        if elt > max.len() {\n           \
    \ max.push(elt);\n        } else {\n            max = max[elt.len()..];\n    \
    \        max = max.into_iter().collect();\n        }\n\n        if elt < min.len()\
    \ {\n            min.push(elt);\n        } else {\n            min = min[elt.len()..];\n\
    \            min = min.into_iter().collect();\n        }\n    }\n\n    // Sort\
    \ them\n    max.sort();\n    min = min.into_iter().collect();\n\n    // Swap them\n\
    \    for (i, elt) in min.iter().zip(max.iter()) {\n        result.push(elt);\n\
    \        result.push(elt);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqa64zpy_.rs:15:18\n   |\n\
    15 |         if elt > max.len() {\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if elt > max.len().try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `len` found for type `isize` in the current scope\n  --> /tmp/tmpqa64zpy_.rs:18:27\n\
    \   |\n18 |             max = max[elt.len()..];\n   |                        \
    \   ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa64zpy_.rs:18:19\n\
    \   |\n10 |     let mut max = Vec::new();\n   |                   ---------- expected\
    \ due to this value\n...\n18 |             max = max[elt.len()..];\n   |     \
    \              ^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                   |\n   |                   expected struct `Vec`, found\
    \ slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n           \
    \    found slice `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa64zpy_.rs:22:18\n\
    \   |\n22 |         if elt < min.len() {\n   |                  ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |         if elt < min.len().try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `len` found for type `isize` in the current scope\n  --> /tmp/tmpqa64zpy_.rs:25:27\n\
    \   |\n25 |             min = min[elt.len()..];\n   |                        \
    \   ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa64zpy_.rs:25:19\n\
    \   |\n11 |     let mut min = Vec::new();\n   |                   ---------- expected\
    \ due to this value\n...\n25 |             min = min[elt.len()..];\n   |     \
    \              ^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                   |\n   |                   expected struct `Vec`, found\
    \ slice"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = lst.clone();\n    for k in 0..sorted.len()\
    \ {\n        let i = sorted[k];\n        for j in k + 1 .. sorted.len() {\n  \
    \          let j = sorted[j];\n            if i > j {\n                sorted.swap(i,\
    \ j);\n            }\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmy_ldbyh.rs:15:29\n   |\n\
    15 |                 sorted.swap(i, j);\n   |                             ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |                 sorted.swap(i.try_into().unwrap(),\
    \ j);\n   |                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmy_ldbyh.rs:15:32\n   |\n15 |              \
    \   sorted.swap(i, j);\n   |                                ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |                 sorted.swap(i,\
    \ j.try_into().unwrap());\n   |                                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut smallest = lst[0];\n  \
    \  for &i in lst {\n        if i < smallest {\n            let mut tmp = i;\n\
    \            smallest = i;\n            i = tmp;\n        }\n    }\n    let mut\
    \ largest = lst[0];\n    for &i in lst {\n        if i > largest {\n         \
    \   let mut tmp = i;\n            largest = i;\n            i = tmp;\n       \
    \ }\n    }\n    res.push(smallest);\n    res.push(largest);\n    res.push(*lst.iter().cloned().skip(2).cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().skip(1).cloned().collect::<Vec<_>>().min());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().max());\n\
    \    res.push(*lst.iter().cloned().cloned().collect::<Vec<_>>().min());\n    res.push(*lst.iter().cloned().cloned().\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpk4oqmzrk.rs:45:13\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n45 |     res.push(*lst.iter().cloned().cloned().\n   |      \
    \       ^ unclosed delimiter\n46 | }\n   | ^ mismatched closing delimiter\n\n\
    error: unexpected token: `)`\n  --> /tmp/tmpk4oqmzrk.rs:46:1\n   |\n46 | }\n \
    \  | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk4oqmzrk.rs:11:9\n   |\n\
    11 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk4oqmzrk.rs:19:9\n   |\n19 |     for &i in lst {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_,\
    \ isize> as Iterator>::Item == &&_`\n    --> /tmp/tmpk4oqmzrk.rs:28:43\n     |\n\
    28   |     res.push(*lst.iter().cloned().skip(2).cloned().collect::<Vec<_>>().max());\n\
    \     |                                           ^^^^^^ expected reference, found\
    \ `isize`\n     |\n     = note: expected reference `&&_`\n                found\
    \ reference `&isize`\n     = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpk4oqmzrk.rs:28:52\n   |\n28 |        res.push(*lst.iter().cloned().skip(2).cloned().collect::<Vec<_>>().max());\n\
    \   |                                                "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    // Sort the list from smallest to largest.\n    lst.sort_by_key(|x|\
    \ x);\n\n    // Swap two smallest values with the two largest values.\n    let\
    \ mut swap = lst.pop();\n    lst.push(*swap);\n\n    lst\n}\n\nfn main() {\n \
    \   let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpu6t2a2xp.rs:14:14\n\
    \   |\n14 |     lst.push(*swap);\n   |              ^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n\n    let mut res = Vec::new();\n    for i in\
    \ lst.rev() {\n        res.push(i);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpvbs65j4o.rs:12:18\n\
    \    |\n12  |       for i in lst.rev() {\n    |                    ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n   \
    \ let mut i = 0;\n    let mut k = lst[0];\n    let mut res = vec![&k];\n\n   \
    \ while i < lst.len() {\n        i += 1;\n        k =\n            lst[i] - k\n\
    \                + if i < lst.len() {\n                    k\n               \
    \ } else {\n                    0\n                };\n\n        res.push(&k);\n\
    \    }\n\n    res.reverse();\n    return res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpefvgpw43.rs:31:12\n   |\n\
    8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n31 |     return res\n   |            ^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut a = lst.clone();\n    for i in 2..a.len() {\n    \
    \    let max = a.iter().max().unwrap();\n        let min = a.iter().min().unwrap();\n\
    \        for j in i..a.len() {\n            if a[j] < min {\n                let\
    \ mut temp = a[j];\n                a[j] = min;\n                a[min] = temp;\n\
    \            }\n            if a[j] > max {\n                let mut temp = a[j];\n\
    \                a[j] = max;\n                a[max] = temp;\n            }\n\
    \        }\n    }\n    a\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpllglm_5y.rs:14:23\n   |\n\
    14 |             if a[j] < min {\n   |                       ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |  \
    \           if a[j] < *min {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpllglm_5y.rs:16:24\n   |\n16 |                 a[j] = min;\n\
    \   |                 ----   ^^^ expected `isize`, found `&isize`\n   |      \
    \           |\n   |                 expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |                 a[j]\
    \ = *min;\n   |                        +\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpllglm_5y.rs:17:17\n   |\n17 |        \
    \         a[min] = temp;\n   |                 ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpllglm_5y.rs:19:23\n\
    \   |\n19 |             if a[j] > max {\n   |                       ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |             if a[j] > *max {\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpllglm_5y.rs:21:24\n   |\n21 |              \
    \   a[j] = max;\n   |                 ----   ^^^ expected `isize`, found `&isize`\n\
    \   |                 |\n   |                 expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |         \
    \        a[j] = *max;\n   |                        +\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpllglm_5y.rs:22:17\n \
    \  |\n22 |                 a[max] = temp;\n   |                 ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n\n    // sort first half\n  \
    \  let mut min_isize = std::i32::MAX;\n    let mut max_isize = std::i32::MIN;\n\
    \    let mut min_idx = 0;\n    let mut max_idx = 0;\n    let mut min_value = std::i32::MAX;\n\
    \    let mut max_value = std::i32::MIN;\n\n    while lst.len() > 0 {\n       \
    \ let isize = lst.len() - 1;\n        let v = lst.pop();\n\n        min_isize\
    \ = min_isize.min(v);\n        min_value = min_value.min(v);\n\n        max_isize\
    \ = max_isize.max(v);\n        max_value = max_value.max(v);\n\n        // swap\
    \ values if min/max values are different\n        if min_isize != max_isize {\n\
    \            if min_isize < max_isize {\n                min_isize = v;\n    \
    \        } else {\n                max_isize = v;\n            }\n        }\n\
    \    }\n\n    while min_value != max_value {\n        let mut min_idx = min_isize.min(max_isize).unwrap();\n\
    \        let mut max_idx = min_isize.max(max_isize).unwrap();\n        let mut\
    \ min_value = min_isize[min_idx].unwrap();\n        let mut max_value = min_isize[max_idx].unwrap();\n\
    \        lst[min_idx] = min_value;\n        lst[max_idx] = max_value;\n    }\n\
    \n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzsx3_fv3.rs:23:35\n   |\n\
    23 |         min_isize = min_isize.min(v);\n   |                             \
    \      ^ expected `i32`, found enum `Option`\n   |\n   = note: expected type `i32`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzsx3_fv3.rs:24:35\n   |\n24 |         min_value = min_value.min(v);\n\
    \   |                                   ^ expected `i32`, found enum `Option`\n\
    \   |\n   = note: expected type `i32`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzsx3_fv3.rs:26:35\n   |\n26 |\
    \         max_isize = max_isize.max(v);\n   |                                \
    \   ^ expected `i32`, found enum `Option`\n   |\n   = note: expected type `i32`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzsx3_fv3.rs:27:35\n   |\n27 |         max_value = max_value.max(v);\n\
    \   |                                   ^ expected `i32`, found enum `Option`\n\
    \   |\n   = note: expected type `i32`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzsx3_fv3.rs:32:29\n   |\n12 |\
    \     let mut min_isize = std::i32::MAX;\n   |                         -------------\
    \ expected due to this value\n...\n32 |                 min_isize = v;\n   | \
    \                            ^ expected `i32`, found enum `Option`\n   |\n   =\
    \ note: expected type `i32`\n              found enum `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzsx3_fv3.rs:34:29\n   |\n13 |     let mut max_isize\
    \ = std::i32::MIN;\n   |                         ------------- expected due to\
    \ this value\n...\n34 |                 max_isize = v;\n   |                 \
    \            ^ expected `i32`, found enum `Option`\n   |\n   = note: expected\
    \ type `i32`\n              found enum `Option<isize>`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `i32` in the current scope\n  --> /tmp/tmpzsx3_fv3.rs:40:52\n\
    \   |\n40 |         let mut min_idx = min_isize.min(max_isize).unwrap();\n   |\
    \                                                    ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut max = lst[0];\n    let mut min_ = lst[0];\n    let\
    \ mut i = 0;\n    let mut j = lst.len() - 1;\n    while i < j {\n        if lst[i]\
    \ > max {\n            max = lst[i];\n        }\n        if lst[j] > max {\n \
    \           max = lst[j];\n        }\n        if lst[i] < min_ {\n           \
    \ min_ = lst[i];\n        }\n        if lst[j] < min_ {\n            min_ = lst[j];\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    let mut lst = vec![];\n\
    \    lst.push(min);\n    lst.push(max);\n    while i <= j {\n        lst.push(min_);\n\
    \        lst.push(max);\n        i += 1;\n        j -= 1;\n    }\n    lst\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmpzxzh3r0r.rs:30:14\n\
    \   |\n30 |     lst.push(min);\n   |              ^^^\n...\n41 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n30 |     lst.push(main);\n   |           \
    \   ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min = isize::MAX;\n\n \
    \   for v in lst {\n        if v < min {\n            min = v;\n        }\n  \
    \  }\n\n    for v in lst {\n        if v > min {\n            push!(res, v);\n\
    \        }\n    }\n\n    for v in lst {\n        if v < min {\n            push!(res,\
    \ v);\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: cannot find macro `push` in this scope\n  --> /tmp/tmpngvs6nd8.rs:20:13\n\
    \   |\n20 |             push!(res, v);\n   |             ^^^^\n\nerror: cannot\
    \ find macro `push` in this scope\n  --> /tmp/tmpngvs6nd8.rs:26:13\n   |\n26 |\
    \             push!(res, v);\n   |             ^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_lst = Vec::new();\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    let mut current_value = std::i32::MAX;\n\
    \    for &v in lst {\n        if current_value > max_val {\n            current_value\
    \ = max_val;\n        }\n        if v > current_value {\n            sorted_lst.push(current_value);\n\
    \            sorted_lst.push(v);\n            current_value = v;\n        } else\
    \ {\n            current_value = v;\n        }\n    }\n    sorted_lst.push(current_value);\n\
    \    sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr0vzmcza.rs:13:9\n   |\n\
    13 |     for &v in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr0vzmcza.rs:26:5\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n26 |     sorted_lst\n   |     ^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<i32>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = lst.len();\n    l.sort_unstable_by_key(|x| {\n\
    \        x - lst[l - lst.len() - 1 - x].min(|x| x).unwrap()\n    });\n    l\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_unstable_by_key` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmppsyajs6r.rs:10:7\n   |\n10 |     l.sort_unstable_by_key(|x|\
    \ {\n   |       ^^^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppsyajs6r.rs:13:5\n   |\n8  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n13 |     l\n   |     ^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v = lst;\n\n    let mut i = 0;\n    let mut j = 0;\n\
    \n    while j < v.len() - 1 {\n        let min: isize = v[j];\n        let max:\
    \ isize = v[j + 1];\n\n        if min >= max {\n            i += 1;\n        }\n\
    \        if i > 0 {\n            let mut tmp: isize = v[i];\n            v[i]\
    \ = v[j];\n            v[j] = tmp;\n        }\n\n        j += 1;\n    }\n\n  \
    \  v\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp10qacrg6.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_lst = vec![];\n    let mut min = lst[0];\n\
    \    for i in lst.iter() {\n        if *i < min {\n            min = i;\n    \
    \    }\n    }\n\n    for i in lst.iter() {\n        if *i < min {\n          \
    \  sorted_lst.push(*i);\n        } else {\n            sorted_lst.push(min);\n\
    \            sorted_lst.push(*i);\n        }\n    }\n\n    sorted_lst\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsre893mp.rs:13:19\n   |\n\
    10 |     let mut min = lst[0];\n   |                   ------ expected due to\
    \ this value\n...\n13 |             min = i;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    13 |             min = *i;\n   |                   +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n\
    \    let mut current = Vec::new();\n    let mut max = lst.iter().max().unwrap();\n\
    \n    for i in lst.iter().rev() {\n        if *i == max {\n            max = i;\n\
    \        }\n        current.push(*i);\n    }\n\n    let mut current = Vec::with_capacity(current.len());\n\
    \n    for i in current.iter_mut() {\n        *i = max;\n    }\n\n    current.reverse();\n\
    \n    current\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ub_oifa.rs:17:18\n   |\n\
    17 |         if *i == max {\n   |                  ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |        \
    \ if *i == *max {\n   |                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3ub_oifa.rs:31:5\n   |\n8  | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n31 |     current\n   |     ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut arr = lst.to_vec();\n\n    // First sort by the smallest\
    \ value\n    arr.sort_unstable();\n\n    // Then sort the rest in descending order\n\
    \    arr.sort_by(|a, b| a.partial_cmp(b).reverse());\n\n    // Return sorted list\n\
    \    arr\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmps16y_u3j.rs:15:41\n   |\n15 |     arr.sort_by(|a,\
    \ b| a.partial_cmp(b).reverse());\n   |                                      \
    \   ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = vec![];\n    let mut min = lst[0];\n    let\
    \ mut max = lst[0];\n    for &x in lst {\n        if min > x {\n            min\
    \ = x;\n        }\n        if max < x {\n            max = x;\n        }\n   \
    \ }\n    for &x in lst {\n        if min > x {\n            sorted.push(x);\n\
    \        }\n        if max < x {\n            sorted.push(min);\n            sorted.push(max);\n\
    \        }\n        if min < x {\n            sorted.push(x);\n        }\n   \
    \     if max > x {\n            sorted.push(min);\n            sorted.push(max);\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52wi9z77.rs:12:9\n   |\n\
    12 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp52wi9z77.rs:20:9\n   |\n20 |     for &x in lst {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_unstable_by(|a, b| {\n        let mut a = a.cmp(&b);\n\
    \        if a != std::cmp::Ordering::Equal {\n            a\n        } else {\n\
    \            b\n        }\n    })\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8hg7wvwx.rs:14:13\n   |\n\
    14 |             b\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8hg7wvwx.rs:9:5\n\
    \   |\n8  |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n9  | /     lst.sort_unstable_by(|a, b| {\n10 | |         let\
    \ mut a = a.cmp(&b);\n11 | |         if a != std::cmp::Ordering::Equal {\n12 |\
    \ |             a\n...  |\n15 | |         }\n16 | |     })\n   | |______^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min_idx = 1;\n    let mut max_idx = lst.len();\n \
    \   while min_idx < max_idx {\n        let swap_idx = min_idx + (max_idx - min_idx)\
    \ / 2;\n        let swap_val = lst[swap_idx];\n\n        // Swap values at min_idx\
    \ and swap_idx.\n        lst[min_idx] = swap_val;\n        lst[swap_idx] = min_idx;\n\
    \n        // Update min_idx and max_idx based on swap_idx.\n        min_idx =\
    \ swap_idx + 1;\n        max_idx = min_idx;\n    }\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxx6mjcae.rs:17:25\n   |\n\
    17 |         lst[swap_idx] = min_idx;\n   |         -------------   ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |         |\n   |         expected due to the type\
    \ of this binding\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_val = *lst.iter().min();\n\
    \    let mut max_val = *lst.iter().max();\n    let mut min_ele = min_val;\n  \
    \  let mut max_ele = max_val;\n\n    for ele in lst {\n        match ele {\n \
    \           ele => res.push(ele),\n            e if ele < min_ele { min_ele =\
    \ ele },\n            e if ele > max_ele { max_ele = ele },\n        }\n    }\n\
    \    res.sort_unstable();\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpepwxz8g_.rs:18:42\n   |\n\
    18 |             e if ele < min_ele { min_ele = ele },\n   |                 \
    \                        -^\n   |                                         |\n\
    \   |                                         help: replace equals symbol with\
    \ a colon: `:`\n\nerror: expected one of `.`, `=>`, `?`, or an operator, found\
    \ `,`\n  --> /tmp/tmpepwxz8g_.rs:18:49\n   |\n18 |             e if ele < min_ele\
    \ { min_ele = ele },\n   |                                                 ^ expected\
    \ one of `.`, `=>`, `?`, or an operator\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpepwxz8g_.rs:10:23\n   |\n10 |     let\
    \ mut min_val = *lst.iter().min();\n   |                       ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpepwxz8g_.rs:11:23\n\
    \   |\n11 |     let mut max_val = *lst.iter().max();\n   |                   \
    \    ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut smallest_element\
    \ = *lst.iter().min();\n    let mut largest_element = *lst.iter().max();\n   \
    \ for element in lst {\n        if element < smallest_element {\n            smallest_element\
    \ = element;\n        }\n        if element > largest_element {\n            largest_element\
    \ = element;\n        }\n    }\n    sorted_list.push(smallest_element);\n    sorted_list.push(largest_element);\n\
    \    sorted_list.sort();\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpfxow_09h.rs:10:32\n\
    \   |\n10 |     let mut smallest_element = *lst.iter().min();\n   |          \
    \                      ^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpfxow_09h.rs:11:31\n   |\n11 |     let\
    \ mut largest_element = *lst.iter().max();\n   |                             \
    \  ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpxy_lz56k.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = lst.clone();\n    let mut minimum = result.iter().cloned().min_by_key(|x|\
    \ x);\n    let mut maximum = result.iter().cloned().max_by_key(|x| x);\n    while\
    \ maximum != minimum {\n        let element = minimum + maximum;\n        minimum\
    \ = result.iter().cloned().min_by_key(|x| if x < element { x } else { None }).unwrap();\n\
    \        maximum = result.iter().cloned().max_by_key(|x| if x > element { x }\
    \ else { None }).unwrap();\n        if maximum == element {\n            result.swap(minimum,\
    \ maximum);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `Option<isize>` to `Option<isize>`\n  --> /tmp/tmpi1kqgayl.rs:13:31\n\
    \   |\n13 |         let element = minimum + maximum;\n   |                   \
    \    ------- ^ ------- Option<isize>\n   |                       |\n   |     \
    \                  Option<isize>\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmpi1kqgayl.rs:14:85\n   |\n14 |         minimum = result.iter().cloned().min_by_key(|x|\
    \ if x < element { x } else { None }).unwrap();\n   |                        \
    \                                                  -          ^^^^ expected `&isize`,\
    \ found enum `Option`\n   |                                                  \
    \                        |\n   |                                             \
    \                             expected because of this\n   |\n   = note: expected\
    \ reference `&isize`\n                   found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi1kqgayl.rs:14:19\n   |\n10 |     let mut minimum\
    \ = result.iter().cloned().min_by_key(|x| x);\n   |                       ----------------------------------------\
    \ expected due to this value\n...\n14 |         minimum = result.iter().cloned().min_by_key(|x|\
    \ if x < element { x } else { None }).unwrap();\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |         minimum = Some(result.iter().cloned().min_by_key(|x| if x\
    \ < element { x } else { None }).unwrap());\n   |                   +++++    \
    \                                                                            \
    \  +\n\nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpi1kqgayl.rs:15:85\n\
    \   |\n15 |         maximum = result.iter().cloned().max_by_key(|x| if x > element\
    \ { x } else { None }).unwrap();\n   |                                       \
    \                                   -          ^^^^ expected `&isize`, found enum\
    \ `Option`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut tmp = lst.clone();\n    let mut result = lst.clone();\n\
    \    for i in 1..tmp.len() {\n        let min_val = tmp[tmp.len() - i];\n    \
    \    let max_val = tmp[tmp.len() - i];\n        for i in 0..i-1 {\n          \
    \  let max_val = tmp[tmp.len() - i];\n            if max_val < min_val {\n   \
    \             result.swap(i, tmp.len() - i);\n                result.swap(result.len()\
    \ - i, result.len() - i - 1);\n                tmp = &result[tmp.len() - i..];\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavq2ek2x.rs:19:23\n   |\n\
    9  |     let mut tmp = lst.clone();\n   |                   ----------- expected\
    \ due to this value\n...\n19 |                 tmp = &result[tmp.len() - i..];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `&[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ reference `&[isize]`\nhelp: try using a conversion method\n   |\n19 |      \
    \           tmp = (&result[tmp.len() - i..]).to_vec();\n   |                 \
    \      +                        ++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = Vec::new();\n    let mut first = lst.min_by_key(|&x|\
    \ x);\n    s.push(first);\n    let mut rest = lst.into_iter().filter(|&x| x !=\
    \ first);\n    while !rest.is_empty() {\n        first = rest.min_by_key(|&x|\
    \ x);\n        s.push(first);\n        rest = rest.filter(|&x| x != first);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpuuomo5fz.rs:10:25\n\
    \    |\n10  |       let mut first = lst.min_by_key(|&x| x);\n    |           \
    \                ^^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ no method named `is_empty` found for struct `Filter` in the current scope\n\
    \  --> /tmp/tmpuuomo5fz.rs:13:17\n   |\n13 |     while !rest.is_empty() {\n  \
    \ |                 ^^^^^^^^ method not found in `Filter<std::vec::IntoIter<isize>,\
    \ [closure@/tmp/tmpuuomo5fz.rs:12:43: 12:58]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuuomo5fz.rs:14:17\n   |\n10 |     let mut first = lst.min_by_key(|&x|\
    \ x);\n   |                     ---------------------- expected due to this value\n\
    ...\n14 |         first = rest.min_by_key(|&x| x);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuuomo5fz.rs:16:16\n   |\n12 |     let mut rest = lst.into_iter().filter(|&x|\
    \ x != first);\n   |                    ---------------------------------------\n\
    \   |                    |                      |\n   |                    | \
    \                     the expected closure\n   |                    |        \
    \              the found closure\n   |                    expected due to this\
    \ value\n...\n16 |         rest = rest.filter(|&x| x != first);\n   |        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::vec::IntoIter`, found\
    \ struct `Filter`\n   |\n   = note: expected struct `Filter<std::vec::IntoIter<_>,\
    \ [closure@/tmp/tmpuuomo5fz.rs:12:43: 12:58]>`\n              found struct `Filter<Filter<std::vec::IntoIter<_>,\
    \ [closure@/tmp/tmpuuomo5fz.rs:12:43: 12:58]>, [closure@/tmp/tmpuuomo5fz.rs:16:28:\
    \ 16:43]>`\n\nerror: aborting due to 4 previou"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut counters = vec![vec![0; lst.len() + 1]; lst.len()\
    \ + 1];\n    let mut max_val = *lst;\n    let mut min_val = *lst;\n\n    for i\
    \ in 0..(lst.len() + 1) {\n        counters[i].push(0);\n    }\n\n    for i in\
    \ 1..lst.len() + 1 {\n        for j in 0..i {\n            let val = *lst;\n \
    \           if val < min_val {\n                min_val = val;\n            }\n\
    \n            if val > max_val {\n                max_val = val;\n           \
    \ }\n\n            counters[i][j] +=1;\n        }\n    }\n\n    for i in 0..(lst.len()\
    \ + 1) {\n        for j in 0..i {\n            lst[i * j + 1] = min_val - counters[i][j]\
    \ * max_val;\n        }\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmp9a5xdlog.rs:10:9\n   |\n10 |     let mut max_val\
    \ = *lst;\n   |         ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n  --> /tmp/tmp9a5xdlog.rs:11:9\n\
    \   |\n11 |     let mut min_val = *lst;\n   |         ^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `[isize]` cannot be known at compilation time\n  -->\
    \ /tmp/tmp9a5xdlog.rs:19:17\n   |\n19 |             let val = *lst;\n   |    \
    \             ^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[isize]`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `[isize]` cannot\
    \ be known at compilation time\n  --> /tmp/tmp9a5xdlog.rs:21:17\n   |\n21 |  \
    \               min_val = val;\n   |                 ^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: the left-hand-side of an assignment must have a statically\
    \ known size\n\nerror[E0277]: the size for values of type `[isize]` cannot be\
    \ known at compilation time\n  --> /tmp/tmp9a5xdlog.rs:25:17\n   |\n25 |     \
    \            max_val = val;\n   |                 ^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: the left-hand-side of an assignment must have a statically\
    \ known size\n\nerror[E0277]: the size for values of "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = lst\n        .iter()\n        .cloned()\n    \
    \    .cloned()\n        .collect::<Vec<_>>();\n    for i in s.len() - 1 {\n  \
    \      if s[i].0 > s[i + 1].0 {\n            let mut tmp = s[i];\n           \
    \ s[i] = s[i + 1];\n            s[i + 1] = tmp;\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpuj3lhi61.rs:12:10\n     |\n12   | \
    \        .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpuj3lhi61.rs:13:10\n\
    \   |\n13 |           .collect::<Vec<_>>();\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Cloned<std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n \
    \          which is required by `Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = lst;\n    new_list.sort();\n    new_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpn9e9mq05.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpdothys0q.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by(|x, y| {\n        match x.cmp(y) {\n         \
    \   -1 => 1,\n            1 => -1,\n            0 => x.cmp(y),\n            _\
    \ => x.cmp(y),\n        }\n    })\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybud08ha.rs:11:13\n   |\n\
    10 |         match x.cmp(y) {\n   |               -------- this expression has\
    \ type `std::cmp::Ordering`\n11 |             -1 => 1,\n   |             ^^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpybud08ha.rs:12:13\n   |\n10 |         match x.cmp(y) {\n   |  \
    \             -------- this expression has type `std::cmp::Ordering`\n11 |   \
    \          -1 => 1,\n12 |             1 => -1,\n   |             ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpybud08ha.rs:13:13\n   |\n10 |         match x.cmp(y) {\n   |       \
    \        -------- this expression has type `std::cmp::Ordering`\n...\n13 |   \
    \          0 => x.cmp(y),\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybud08ha.rs:11:19\n\
    \   |\n11 |             -1 => 1,\n   |                   ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybud08ha.rs:9:5\n\
    \   |\n8  |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n9  | /     lst.sort_by(|x, y| {\n10 | |         match x.cmp(y)\
    \ {\n11 | |             -1 => 1,\n12 | |             1 => -1,\n...  |\n15 | |\
    \         }\n16 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    \n    for v in lst.iter().rev()\
    \ {\n        if rev.len() == 0 {\n            res.push(v);\n        } else {\n\
    \            let last = res.last();\n            let mid = rev.len() as isize\
    \ / (last as usize - v as usize) + 1;\n            res.push(v - mid as isize);\n\
    \            res.push(v + mid as isize);\n        }\n    }\n    \n    res\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `rev` in this scope\n  --> /tmp/tmp20iw5pnd.rs:12:12\n\
    \   |\n12 |         if rev.len() == 0 {\n   |            ^^^ help: a local variable\
    \ with a similar name exists: `res`\n\nerror[E0425]: cannot find value `rev` in\
    \ this scope\n  --> /tmp/tmp20iw5pnd.rs:16:23\n   |\n16 |             let mid\
    \ = rev.len() as isize / (last as usize - v as usize) + 1;\n   |             \
    \          ^^^ help: a local variable with a similar name exists: `res`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp20iw5pnd.rs:17:22\n   |\n17 |             res.push(v\
    \ - mid as isize);\n   |                      ^^^^^^^^^^^^^^^^\n   |         \
    \             |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&(v - mid as isize)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp20iw5pnd.rs:18:22\n   |\n18 |\
    \             res.push(v + mid as isize);\n   |                      ^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&(v + mid\
    \ as isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp20iw5pnd.rs:22:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     res\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror[E0605]: non-primitive cast: `Option<&&isize>` as `usize`\n  --> /tmp/tmp20iw5pnd.rs:16:45\n\
    \   |\n16 |             let mid = rev.len() as isize / (last as usize - v as usize)\
    \ + 1;\n   |                                             ^^^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n\
    \  --> /tmp/tmp20iw5pnd.rs:16:61\n   |\n16 |             let mid = rev.len() as\
    \ isize / (last as usize - v as usize) + 1;\n   |                            \
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst.iter().cloned().collect();\n    list.sort_by(|a,\
    \ b| {\n        if b < a { return Some(b - a); }\n        None\n    });\n    list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp47gm15u4.rs:10:5\n\
    \   |\n9  |     let mut list = lst.iter().cloned().collect();\n   |         --------\
    \ consider giving `list` a type\n10 |     list.sort_by(|a, b| {\n   |     ^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = vec![0; lst.len()];\n    list.push(...lst.clone());\n\
    \    let mut i = 0;\n    let mut j = list.len() - 1;\n    let mut temp = 0;\n\
    \    while i != j {\n        while list[i] < list[j] {\n            i += 1;\n\
    \        }\n        while list[j] > list[i] {\n            j -= 1;\n        }\n\
    \        temp = list[i];\n        list[i] = list[j];\n        list[j] = temp;\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpo8naxbhq.rs:10:15\n   |\n\
    10 |     list.push(...lst.clone());\n   |               ^^^\n   |\nhelp: use `..`\
    \ for an exclusive range\n   |\n10 |     list.push(..lst.clone());\n   |     \
    \          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     list.push(..=lst.clone());\n\
    \   |               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo8naxbhq.rs:10:15\n\
    \   |\n10 |     list.push(...lst.clone());\n   |               ^^^^^^^^^^^^^^\
    \ expected integer, found struct `RangeToInclusive`\n   |\n   = note: expected\
    \ type `{integer}`\n            found struct `RangeToInclusive<Vec<isize>>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = lst;\n    if result.len() > 1 {\n       \
    \ let mut max_idx = result.len() - 1;\n        let mut min_idx = result.len()\
    \ - 1;\n\n        while min_idx > 0 && !result[min_idx].is_max() {\n         \
    \   min_idx--;\n        }\n        while max_idx > 0 && !result[max_idx].is_min()\
    \ {\n            max_idx--;\n        }\n        result[min_idx] = result[max_idx];\n\
    \        for mut idx in range(min_idx + 1, max_idx + 1) {\n            result[idx]\
    \ = result[idx + 1];\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpdtnplt2i.rs:15:22\n\
    \   |\n15 |             min_idx--;\n   |                      ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpdtnplt2i.rs:18:22\n   |\n\
    18 |             max_idx--;\n   |                      ^ expected expression\n\
    \nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpdtnplt2i.rs:21:24\n\
    \   |\n21 |         for mut idx in range(min_idx + 1, max_idx + 1) {\n   |   \
    \                     ^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0599]: no method\
    \ named `is_max` found for type `isize` in the current scope\n  --> /tmp/tmpdtnplt2i.rs:14:47\n\
    \   |\n14 |         while min_idx > 0 && !result[min_idx].is_max() {\n   |   \
    \                                            ^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_min` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpdtnplt2i.rs:17:47\n   |\n17 |         while max_idx > 0\
    \ && !result[max_idx].is_min() {\n   |                                       \
    \        ^^^^^^ method not found in `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.iter().cloned().sort_by(|a, b| {\n        // If list is\
    \ empty or all items are the same, just return 0.\n        if a.is_empty() {\n\
    \            return 0;\n        }\n        if b.is_empty() {\n            return\
    \ 0;\n        }\n        // If a is less than b, swap them.\n        if *a > *b\
    \ {\n            *a.clone() as *mut isize = b.clone() as *mut isize;\n       \
    \ }\n        (*a).cmp(*b).unwrap_or(std::cmp::Ordering::Equal)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmprpj841z7.rs:9:25\n  |\n9 |     lst.iter().cloned().sort_by(|a,\
    \ b| {\n  |                         ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmprpj841z7.rs:19:38\n\
    \   |\n19 |             *a.clone() as *mut isize = b.clone() as *mut isize;\n\
    \   |             ------------------------ ^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0070, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = lst.clone();\n    new_list.remove(0);\n\
    \    new_list.sort();\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpgtzm4n76.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v = Vec::new();\n    let mut last_val = lst[0];\n\
    \    let mut is_sorted = false;\n    for val in lst {\n        if is_sorted {\n\
    \            v.push(*last_val);\n        }\n        if val < last_val {\n    \
    \        v.push(*val);\n        } else {\n            last_val = val;\n      \
    \      is_sorted = true;\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp3tm56wyz.rs:14:20\n\
    \   |\n14 |             v.push(*last_val);\n   |                    ^^^^^^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp3tm56wyz.rs:17:20\n\
    \   |\n17 |             v.push(*val);\n   |                    ^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_by_key(|x| {\n        (*x).min(|y| { *y < y })\n\
    \            .max(|y| { *y > y })\n            .min(|y| { *y < y })\n    })\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdfaxmxda.rs:10:19\n\
    \   |\n10 |         (*x).min(|y| { *y < y })\n   |                   ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdfaxmxda.rs:9:5\n\
    \   |\n8  |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n9  | /     lst.sort_by_key(|x| {\n10 | |         (*x).min(|y|\
    \ { *y < y })\n11 | |             .max(|y| { *y > y })\n12 | |             .min(|y|\
    \ { *y < y })\n13 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_el = lst.iter().min().unwrap();\n\
    \    let mut max_el = lst.iter().max().unwrap();\n    let mut min_el = min_el.clone();\n\
    \    for el in lst {\n        if el > min_el {\n            res.push(min_el);\n\
    \            min_el = el;\n        }\n        if el < max_el {\n            res.push(max_el);\n\
    \            max_el = el;\n        }\n    }\n    res.push(min_el);\n    res.push(max_el);\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpidvvkn0o.rs:18:17\n   |\n\
    18 |         if el < max_el {\n   |                 ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |        \
    \ if el < *max_el {\n   |                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpidvvkn0o.rs:19:22\n   |\n19 |             res.push(max_el);\n \
    \  |                      ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |             res.push(*max_el);\n\
    \   |                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpidvvkn0o.rs:20:22\n\
    \   |\n11 |     let mut max_el = lst.iter().max().unwrap();\n   |            \
    \          ------------------------- expected due to this value\n...\n20 |   \
    \          max_el = el;\n   |                      ^^\n   |                  \
    \    |\n   |                      expected `&isize`, found `isize`\n   |     \
    \                 help: consider borrowing here: `&el`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpidvvkn0o.rs:24:14\n   |\n24 |     res.push(max_el);\n \
    \  |              ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     res.push(*max_el);\n   |          \
    \    +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut min_idx = lst.iter().min_by_key(|&x| x);\n    let\
    \ mut max_idx = lst.iter().max_by_key(|&x| x);\n    let mut min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n\
    \    let mut max_value = lst.iter().nth(max_idx.unwrap()).unwrap();\n\n    loop\
    \ {\n        min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n        max_value\
    \ = lst.iter().nth(max_idx.unwrap()).unwrap();\n\n        if min_value > max_value\
    \ {\n            min_idx = lst.iter().min_by_key(|&x| x);\n            max_idx\
    \ = lst.iter().max_by_key(|&x| x);\n            min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n\
    \            max_value = lst.iter().nth(max_idx.unwrap()).unwrap();\n        }\
    \ else {\n            break;\n        }\n    }\n\n    let mut l = vec![];\n  \
    \  for i in lst {\n        l.push(i);\n    }\n    l.sort_by_key(|&x| x);\n\n \
    \   l\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:11:40\n   |\n\
    11 |     let mut min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n   |\
    \                                        ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:12:40\n\
    \   |\n12 |     let mut max_value = lst.iter().nth(max_idx.unwrap()).unwrap();\n\
    \   |                                        ^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:15:36\n\
    \   |\n15 |         min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n \
    \  |                                    ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:16:36\n\
    \   |\n16 |         max_value = lst.iter().nth(max_idx.unwrap()).unwrap();\n \
    \  |                                    ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:21:40\n\
    \   |\n21 |             min_value = lst.iter().nth(min_idx.unwrap()).unwrap();\n\
    \   |                                        ^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm354levf.rs:22:40\n\
    \   |\n22 |             max_value = lst.iter().nth(max_idx.unwrap()).unwrap();\n\
    \   |                                        ^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut max_item = lst[0];\n    let mut min_item = lst[0];\n\
    \    for i in 1..lst.len() {\n        if max_item > lst[i] {\n            max_item\
    \ = lst[i];\n        }\n        if min_item < lst[i] {\n            min_item =\
    \ lst[i];\n        }\n    }\n\n    let mut lst = vec![];\n    for i in min_item..max_item\
    \ {\n        lst.push(i);\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 4, 2, 3]`', /tmp/tmphme3c5tl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let mut min_value =\
    \ lst[0];\n    let mut max_value = lst[0];\n    for i in lst.iter().rev() {\n\
    \        if i == min_value {\n            sorted_list.push(i);\n        } else\
    \ {\n            if i > max_value {\n                max_value = i;\n        \
    \    }\n        }\n    }\n    for i in sorted_list.iter().rev() {\n        if\
    \ i == max_value {\n            sorted_list.push(i);\n        } else {\n     \
    \       if i < min_value {\n                min_value = i;\n            }\n  \
    \      }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpwkl2w1ex.rs:13:14\n\
    \   |\n13 |         if i == min_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwkl2w1ex.rs:16:20\n   |\n16 |             if i > max_value {\n   | \
    \                   ^^^^^^^^^\n   |                    |\n   |               \
    \     expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkl2w1ex.rs:17:29\n\
    \   |\n11 |     let mut max_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n17 |                 max_value = i;\n   | \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |                 max_value = *i;\n   | \
    \                            +\n\nerror[E0277]: can't compare `&&isize` with `isize`\n\
    \  --> /tmp/tmpwkl2w1ex.rs:22:14\n   |\n22 |         if i == max_value {\n   |\
    \              ^^ no implementation for `&&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwkl2w1ex.rs:25:20\n   |\n25 |             if\
    \ i < min_value {\n   |                    ^^^^^^^^^ expected `&&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkl2w1ex.rs:26:29\n\
    \   |\n10 |     let mut min_value = lst[0];\n   |                         ------\
    \ expected due to this value\n...\n26 |                 min_va"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    // If list is empty, return it as it is.\n    if lst.is_empty()\
    \ {\n        return lst;\n    }\n\n    // Sort and reverse list\n    let mut sorted\
    \ = lst.clone();\n    sorted.sort();\n    sorted.reverse();\n\n    // Return reversed\
    \ list\n    return sorted;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppe6g1kiw.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst2 = lst.clone();\n    let mut min = lst2.iter().min();\n\
    \    let mut max = lst2.iter().max();\n\n    for i in 0..(lst2.len() - 1) {\n\
    \        if lst2[i] > max {\n            max = lst2[i];\n        }\n\n       \
    \ if lst2[i] < min {\n            min = lst2[i];\n        }\n    }\n\n    while\
    \ min < max {\n        let i = lst2.iter().position(|x| x == min).unwrap() as\
    \ usize;\n        lst2.swap(i, lst2.iter().position(|x| x == max).unwrap() as\
    \ usize);\n        max -= 1;\n        min += 1;\n    }\n\n    lst2\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7963m0gx.rs:14:22\n   |\n\
    14 |         if lst2[i] > max {\n   |                      ^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7963m0gx.rs:15:19\n\
    \   |\n11 |     let mut max = lst2.iter().max();\n   |                   -----------------\
    \ expected due to this value\n...\n15 |             max = lst2[i];\n   |     \
    \              ^^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note:\
    \ expected enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7963m0gx.rs:18:22\n   |\n18 |         if lst2[i]\
    \ < min {\n   |                      ^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7963m0gx.rs:19:19\n   |\n10 |\
    \     let mut min = lst2.iter().min();\n   |                   -----------------\
    \ expected due to this value\n...\n19 |             min = lst2[i];\n   |     \
    \              ^^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note:\
    \ expected enum `Option<&isize>`\n              found type `isize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp7963m0gx.rs:24:44\n\
    \   |\n24 |         let i = lst2.iter().position(|x| x == min).unwrap() as usize;\n\
    \   |                                            ^^ no implementation for `&isize\
    \ == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `Option<&isize>`\n  --> /tmp/tmp7963m0gx.rs:25:49\n   |\n25 |         lst2.swap(i,\
    \ lst2.iter().position(|x| x == max).unwrap() as usize);\n   |               \
    \                                  ^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\n  \
    \  for ix in 0..(sorted_list.len() - 1) {\n        let mut tmp = sorted_list[ix];\n\
    \        sorted_list[ix] = sorted_list[ix + 1];\n        sorted_list[ix + 1] =\
    \ tmp;\n    }\n\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpguflr886.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpt5cyxzoj.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted = vec![];\n    let mut max_val = lst[0];\n\
    \    let mut min_val = lst[0];\n    let mut new_list = lst;\n    for val in &new_list\
    \ {\n        if val > max_val {\n            max_val = val;\n        }\n     \
    \   if val < min_val {\n            min_val = val;\n        }\n    }\n    sorted\
    \ = vec![];\n    for val in &new_list {\n        if val > max_val {\n        \
    \    sorted = sorted.push(max_val);\n            max_val = val;\n        }\n \
    \       if val < min_val {\n            sorted = sorted.push(min_val);\n     \
    \       min_val = val;\n        }\n        sorted = sorted.push(val);\n    }\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp01rwt4jk.rs:14:18\n   |\n\
    14 |         if val > max_val {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&isize`, found `isize`\n   |    \
    \              help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp01rwt4jk.rs:15:23\n   |\n10 |     let mut max_val = lst[0];\n\
    \   |                       ------ expected due to this value\n...\n15 |     \
    \        max_val = val;\n   |                       ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \     max_val = *val;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp01rwt4jk.rs:17:18\n   |\n17 |         if val < min_val\
    \ {\n   |                  ^^^^^^^\n   |                  |\n   |            \
    \      expected `&isize`, found `isize`\n   |                  help: consider\
    \ borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01rwt4jk.rs:18:23\n\
    \   |\n11 |     let mut min_val = lst[0];\n   |                       ------ expected\
    \ due to this value\n...\n18 |             min_val = val;\n   |              \
    \         ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             min_val = *val;\n   |                   \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01rwt4jk.rs:23:18\n  \
    \ |\n23 |         if val > max_val {\n   |                  ^^^^^^^\n   |    \
    \              |\n   |                  expected `&isize`, found `isize`\n   |\
    \                  help: consider borrowing here: `&max_val`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp01rwt4jk.rs:24:22\n   |\n9  |     let mut sorted\
    \ = vec![];\n   |                      ------ expected due to this value\n...\n\
    24 |             sorted = sorted.push(max_val);\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp01rwt4jk.rs:25:23\n\
    \   |\n10 |     let mut max_val = lst["
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n\n    for v in lst {\n     \
    \   match v {\n            v when v < result { result.push(v); }\n           \
    \ _ => { result.sort_unstable(); }\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `when`\n  --> /tmp/tmp95o7y78y.rs:13:15\n\
    \   |\n13 |             v when v < result { result.push(v); }\n   |          \
    \     ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpljjkxz_w.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut min_val = lst.iter().min();\n\
    \    let mut max_val = lst.iter().max();\n    let mut max_index = lst.iter().len()\
    \ - 1;\n    while max_index >= 0 {\n        result.push(min_val);\n        result.push(max_val);\n\
    \        max_index -= 1;\n        let mut min_idx = max_index - 1;\n        while\
    \ min_idx >= 0 {\n            if lst[min_idx] > max_val {\n                min_idx\
    \ = max_index - 1;\n            } else {\n                min_idx -= 1;\n    \
    \            break;\n            }\n        }\n        min_val = max_val;\n  \
    \      max_val = lst[min_idx];\n        max_index = min_idx + 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpce5ix5gk.rs:19:31\n   |\n\
    19 |             if lst[min_idx] > max_val {\n   |                           \
    \    ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpce5ix5gk.rs:27:19\n   |\n11 |     let mut max_val = lst.iter().max();\n\
    \   |                       ---------------- expected due to this value\n...\n\
    27 |         max_val = lst[min_idx];\n   |                   ^^^^^^^^^^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpce5ix5gk.rs:30:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<&isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpsy08uke0.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort();\n  |     ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    let mut min_value = lst[0];\n \
    \   for value in lst {\n        if value == min_value {\n            continue;\n\
    \        }\n        let mut next_value = min_value;\n        while next_value\
    \ < value {\n            res[res.len()] = next_value;\n            next_value\
    \ += 1;\n        }\n        min_value = value;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `res` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpn79dt4mr.rs:17:17\n   |\n17 |             res[res.len()]\
    \ = next_value;\n   |             ----^^^^^^^^^-\n   |             |   |\n   |\
    \             |   immutable borrow occurs here\n   |             mutable borrow\
    \ occurs here\n   |             mutable borrow later used here\n   |\nhelp: try\
    \ adding a local storing this...\n  --> /tmp/tmpn79dt4mr.rs:17:17\n   |\n17 |\
    \             res[res.len()] = next_value;\n   |                 ^^^^^^^^^\nhelp:\
    \ ...and then using that local here\n  --> /tmp/tmpn79dt4mr.rs:17:13\n   |\n17\
    \ |             res[res.len()] = next_value;\n   |             ^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![];\n\n    for number in lst {\n\
    \        if sorted_list.len() == 0 {\n            sorted_list.push(number);\n\
    \        }\n        else if number < sorted_list.first() {\n            sorted_list.push(number);\n\
    \        }\n        else {\n            let index = sorted_list.iter().position(|x|\
    \ x == number).unwrap();\n            let number = sorted_list[index];\n     \
    \       sorted_list.push(number);\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7_hotwze.rs:15:26\n   |\n\
    15 |         else if number < sorted_list.first() {\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp7_hotwze.rs:19:59\n   |\n\
    19 |             let index = sorted_list.iter().position(|x| x == number).unwrap();\n\
    \   |                                                           ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst;\n\n    loop {\n        let mut lowest\
    \ = list.iter().min_by_ref();\n        let mut highest = list.iter().max_by_ref();\n\
    \        let mut second_lowest = list.iter().skip(1).min_by_ref();\n        let\
    \ mut second_highest = list.iter().skip(1).max_by_ref();\n\n        // check all\
    \ possible pairs\n        if lowest.unwrap() < second_lowest.unwrap() {\n    \
    \        // swap\n            list.swap(0, list.len() - 1);\n            list.swap(list.len()\
    \ - 1, list.len() - 2);\n        }\n\n        if highest.unwrap() < second_highest.unwrap()\
    \ {\n            // swap\n            list.swap(0, list.len() - 1);\n        \
    \    list.swap(list.len() - 1, list.len() - 2);\n        }\n\n        // break\
    \ if list is already sorted\n        if list.iter().all_eq(&list) {\n        \
    \    break;\n        }\n    }\n\n    list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `min_by_ref` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmplusca2_s.rs:12:38\n   |\n12 |         let\
    \ mut lowest = list.iter().min_by_ref();\n   |                               \
    \       ^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]:\
    \ no method named `max_by_ref` found for struct `std::slice::Iter` in the current\
    \ scope\n  --> /tmp/tmplusca2_s.rs:13:39\n   |\n13 |         let mut highest =\
    \ list.iter().max_by_ref();\n   |                                       ^^^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method\
    \ named `min_by_ref` found for struct `Skip` in the current scope\n  --> /tmp/tmplusca2_s.rs:14:53\n\
    \   |\n14 |         let mut second_lowest = list.iter().skip(1).min_by_ref();\n\
    \   |                                                     ^^^^^^^^^^ method not\
    \ found in `Skip<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `max_by_ref` found for struct `Skip` in the current scope\n  --> /tmp/tmplusca2_s.rs:15:54\n\
    \   |\n15 |         let mut second_highest = list.iter().skip(1).max_by_ref();\n\
    \   |                                                      ^^^^^^^^^^ method not\
    \ found in `Skip<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `all_eq` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmplusca2_s.rs:31:24\n\
    \   |\n31 |         if list.iter().all_eq(&list) {\n   |                     \
    \   ^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    sorted_list_by(&lst).reverse().collect()\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sorted_list_by` in this scope\n -->\
    \ /tmp/tmpijrqapmc.rs:9:5\n  |\n9 |     sorted_list_by(&lst).reverse().collect()\n\
    \  |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut a = lst.to_vec();\n    let mut b = vec![];\n    let\
    \ mut c = vec![];\n    let mut d = vec![];\n    for i in a {\n        if !b.contains(&i)\
    \ {\n            c.push(i);\n        } else {\n            d = b;\n        }\n\
    \    }\n    for i in c {\n        if !d.contains(&i) {\n            b.push(i);\n\
    \        } else {\n            a = d;\n        }\n    }\n    for i in b {\n  \
    \      if !c.contains(&i) {\n            a.push(i);\n        } else {\n      \
    \      d = c;\n        }\n    }\n    for i in a {\n        if !d.contains(&i)\
    \ {\n            b.push(i);\n        } else {\n            a = d;\n        }\n\
    \    }\n    for i in b {\n        if !c.contains(&i) {\n            a.push(i);\n\
    \        } else {\n            d = c;\n        }\n    }\n    for i in a {\n  \
    \      if !d.contains(&i) {\n            b.push(i);\n        } else {\n      \
    \      a = d;\n        }\n    }\n    for i in b {\n        if !c.contains(&i)\
    \ {\n            a.push(i);\n        } else {\n            d = c;\n        }\n\
    \    }\n    for i in a {\n        if !d.contains(&i) {\n            b.push(i);\n\
    \        } else {\n            a = d;\n        }\n    }\n    for i in b {\n  \
    \      if !c.contains(&i) {\n            a.push(i);\n        } else {\n      \
    \      d = c;\n        }\n    }\n    for i in a {\n        if !d.contains(&i)\
    \ {\n            b.push(i);\n        } else {\n            a = d;\n        }\n\
    \    }\n    for i in b {\n        if !c.contains(&i) {\n            a.push(i);\n\
    \        } else {\n            d = c;\n        }\n    }\n    for i in a {\n  \
    \      if !d.contains(&i) {\n            b.push(i);\n        } else {\n      \
    \      a = d;\n        }\n    }\n    for i in b {\n        if !c.contains(&i)\
    \ {\n            a.push(i);\n        } else {\n            d = c;\n        }\n\
    \    }\n    for i in a {\n        if !d.contains(&i) {\n            b.push(i);\n\
    \        } else {\n            a = d;\n        }\n    }\n    for i in b {\n  \
    \      if !c.contains(&i) {\n            a.push(i);\n        } else {\n      \
    \      d = c;\n        }\n    }\n    for i in a {\n        if !d.contains(&i)\
    \ {\n            b.push(i);\n        } else {\n            a = d;\n        }\n\
    \    }\n    for i in b {\n        if !c.contains(&i) {\n            a.push(i);\n\
    \        } else {\n            d = c;\n        }\n    }\n    for i in a {\n  \
    \      if !d.contains(&i) {\n            b.push(i);\n        } else {\n      \
    \      a = d;\n        }\n    }\n    for i in b {\n        if !c.contains(&i)\
    \ {\n            a.push(i);\n        } else {\n            d = c;\n        }\n\
    \    }\n    for i in a {\n        if !d.contains(&i) {\n            b.\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmps824swph.rs:162:3\n\
    \    |\n8   | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    146 |     for i in a {\n    |                - unclosed delimiter\n147 |     \
    \    if !d.contains(&i) {\n    |                            - this delimiter might\
    \ not be properly closed...\n148 |             b.\n149 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n162 | }\n    |   ^\n\nerror: unexpected\
    \ token: `}`\n   --> /tmp/tmps824swph.rs:149:1\n    |\n149 | }\n    | ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmps824swph.rs:148:13\n    |\n147 | /        \
    \ if !d.contains(&i) {\n148 | |             b.\n    | |             ^ expected\
    \ `()`, found struct `Vec`\n149 | | }\n    | |_- expected this to be `()`\n  \
    \  |\n    = note: expected unit type `()`\n                  found struct `Vec<isize>`\n\
    help: you might have meant to return this value\n    |\n148 |             return\
    \ b;.\n    |             ++++++  +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmps824swph.rs:146:5\n\
    \    |\n8   |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    | \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n146 | /     for i in a {\n147 | |         if !d.contains(&i)\
    \ {\n148 | |             b.\n149 | | }\n...   |\n161 | |     assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n162 | | }\n    | |__^ expected struct `Vec`, found `()`\n  \
    \  |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n    }\n\n    let\
    \ mut min = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \n    loop {\n        let mut temp = 0;\n        let mut index = lst.iter().position(|x|\
    \ x == min).unwrap();\n\n        if index != lst.len() - 1 {\n            temp\
    \ = lst.iter()[index + 1].unwrap();\n            lst.iter_mut().remove(*index\
    \ + 1);\n        }\n\n        lst.iter_mut().remove(*index);\n        lst.push(temp);\n\
    \        max = min;\n        index = lst.iter().position(|x| x == max).unwrap();\n\
    \        if index != lst.len() - 1 {\n            temp = lst.iter()[index + 1].unwrap();\n\
    \            lst.iter_mut().remove(*index + 1);\n        }\n\n        lst.iter_mut().remove(*index);\n\
    \        lst.push(temp);\n        min = max;\n    }\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `std::slice::Iter<'_, isize>`\n\
    \  --> /tmp/tmpltw0neu7.rs:21:20\n   |\n21 |             temp = lst.iter()[index\
    \ + 1].unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `remove` found for struct `std::slice::IterMut` in the current\
    \ scope\n  --> /tmp/tmpltw0neu7.rs:22:28\n   |\n22 |             lst.iter_mut().remove(*index\
    \ + 1);\n   |                            ^^^^^^ method not found in `std::slice::IterMut<'_,\
    \ isize>`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpltw0neu7.rs:22:35\n\
    \   |\n22 |             lst.iter_mut().remove(*index + 1);\n   |             \
    \                      ^^^^^^\n\nerror[E0599]: no method named `remove` found\
    \ for struct `std::slice::IterMut` in the current scope\n  --> /tmp/tmpltw0neu7.rs:25:24\n\
    \   |\n25 |         lst.iter_mut().remove(*index);\n   |                     \
    \   ^^^^^^ method not found in `std::slice::IterMut<'_, isize>`\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpltw0neu7.rs:25:31\n   |\n\
    25 |         lst.iter_mut().remove(*index);\n   |                            \
    \   ^^^^^^\n\nerror[E0608]: cannot index into a value of type `std::slice::Iter<'_,\
    \ isize>`\n  --> /tmp/tmpltw0neu7.rs:30:20\n   |\n30 |             temp = lst.iter()[index\
    \ + 1].unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `remove` found for struct `std::slice::IterMut` in the current\
    \ scope\n  --> /tmp/tmpltw0neu7.rs:31:28\n   |\n31 |             lst.iter_mut().remove(*index\
    \ + 1);\n   |                            ^^^^^^ method not found in `std::slice::IterMut<'_,\
    \ isize>`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpltw0neu7.rs:31:35\n\
    \   |\n31 |             lst.iter_mut().remove(*index + 1);\n   |             \
    \                      ^^^^^^\n\nerror[E0599]: no method named `remove` found\
    \ for struct `std::slice::IterMut` in the current scope\n  --> /tmp/tmpltw0neu7.rs:34:24\n\
    \   |\n34 |         lst.iter_mut().remove(*index);\n   |                     \
    \   ^^^^^^ method not found in "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst.to_owned()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpup_jcksz.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = Vec::new();\n\n    // Calculate the\
    \ min and max of the list.\n    let min_value = lst[0];\n    let max_value = lst[0];\n\
    \n    for element in lst.iter() {\n        if element < min_value {\n        \
    \    min_value = element;\n        }\n        if element > max_value {\n     \
    \       max_value = element;\n        }\n    }\n\n    // Insert all values into\
    \ the sorted_list.\n    sorted_list.push(min_value);\n    sorted_list.push(max_value);\n\
    \n    for element in lst.iter() {\n        if element < max_value {\n        \
    \    sorted_list.push(element);\n        }\n    }\n\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:16:22\n   |\n\
    16 |         if element < min_value {\n   |                      ^^^^^^^^^\n \
    \  |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&min_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:17:25\n   |\n12 |\
    \     let min_value = lst[0];\n   |                     ------ expected due to\
    \ this value\n...\n17 |             min_value = element;\n   |               \
    \          ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             min_value = *element;\n   |             \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:19:22\n\
    \   |\n19 |         if element > max_value {\n   |                      ^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&max_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:20:25\n   |\n13 |\
    \     let max_value = lst[0];\n   |                     ------ expected due to\
    \ this value\n...\n20 |             max_value = element;\n   |               \
    \          ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n20 |             max_value = *element;\n   |             \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:29:22\n\
    \   |\n29 |         if element < max_value {\n   |                      ^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&max_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptg3bsncb.rs:30:30\n   |\n30 |\
    \             sorted_list.push(element);\n   |                              ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n30 |             sorted_list.push(*element);\n   |                    \
    \          +\n\nerror: aborting due to 6 previous errors\n\nF"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = vec![];\n    new_list.push(...lst);\n\n\
    \    let min_value = new_list.iter().min().unwrap();\n    let max_value = new_list.iter().max().unwrap();\n\
    \n    for i in 1..(max_value - min_value).max() + 1 {\n        let mut current_min_value\
    \ = min_value;\n        let mut current_max_value = max_value;\n\n        while\
    \ current_min_value == current_max_value {\n            let min_value = current_min_value;\n\
    \            current_min_value = new_list.iter().next().unwrap();\n          \
    \  current_max_value = max_value;\n            current_max_value = new_list.iter().next().unwrap();\n\
    \        }\n\n        let mut current_value = min_value;\n        loop {\n   \
    \         let mut current_list = new_list;\n            let mut new_list = vec![];\n\
    \n            while current_value != current_max_value {\n                current_list.push(*current_value);\n\
    \                new_list.push(*current_value);\n\n                current_value\
    \ += 1;\n            }\n\n            new_list.push(*current_max_value);\n   \
    \         current_list.push(*current_max_value);\n\n            new_list.push(*current_min_value);\n\
    \            current_list.push(*current_min_value);\n\n            while new_list.len()\
    \ >= new_list.iter().min().unwrap() {\n                new_list.pop();\n     \
    \           current_value -= 1;\n            }\n\n            if new_list.len()\
    \ >= new_list.iter().max().unwrap() {\n                break;\n            }\n\
    \        }\n\n        new_list = new_list.into_iter().cloned().collect();\n  \
    \  }\n\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmp15jp56ik.rs:10:19\n   |\n\
    10 |     new_list.push(...lst);\n   |                   ^^^\n   |\nhelp: use `..`\
    \ for an exclusive range\n   |\n10 |     new_list.push(..lst);\n   |         \
    \          ~~\nhelp: or `..=` for an inclusive range\n   |\n10 |     new_list.push(..=lst);\n\
    \   |                   ~~~\n\nerror[E0277]: the trait bound `RangeToInclusive<Vec<isize>>:\
    \ Ord` is not satisfied\n    --> /tmp/tmp15jp56ik.rs:12:37\n     |\n12   |   \
    \  let min_value = new_list.iter().min().unwrap();\n     |                   \
    \                  ^^^ the trait `Ord` is not implemented for `RangeToInclusive<Vec<isize>>`\n\
    \     |\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&RangeToInclusive<Vec<isize>>`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `RangeToInclusive<Vec<isize>>: Ord` is not satisfied\n\
    \    --> /tmp/tmp15jp56ik.rs:13:37\n     |\n13   |     let max_value = new_list.iter().max().unwrap();\n\
    \     |                                     ^^^ the trait `Ord` is not implemented\
    \ for `RangeToInclusive<Vec<isize>>`\n     |\n     = note: required because of\
    \ the requirements on the impl of `Ord` for `&RangeToInclusive<Vec<isize>>`\n\
    note: required by a bound in `std::iter::Iterator::max`\n\nerror[E0369]: cannot\
    \ subtract `&RangeToInclusive<Vec<isize>>` from `&RangeToInclusive<Vec<isize>>`\n\
    \  --> /tmp/tmp15jp56ik.rs:15:28\n   |\n15 |     for i in 1..(max_value - min_value).max()\
    \ + 1 {\n   |                  --------- ^ --------- &RangeToInclusive<Vec<isize>>\n\
    \   |                  |\n   |                  &RangeToInclusive<Vec<isize>>\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&RangeToInclusive<Vec<isize>>`\n\
    \  --> /tmp/tmp15jp56ik.rs:35:17\n   |\n35 |                 current_value +=\
    \ 1;\n   |                 -------------^^^^^\n   |                 |\n   |  \
    \               cannot use `+=` on type `&RangeToInclusive<Vec<isize>>`\n\nerror[E0277]:\
    \ the trait bound `RangeToInclusive<Vec<isize>>: Ord` is not satisfied\n    -->\
    \ /tmp/tmp15jp"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_lst = lst;\n    let mut current_min: isize\
    \ = 0;\n    while sorted_lst.len() > 1 {\n        let min_value = sorted_lst.iter().min().unwrap();\n\
    \        let max_value = sorted_lst.iter().max().unwrap();\n        let new_lst\
    \ = sorted_lst.drain(..=min_value);\n        new_lst.extend(sorted_lst.drain(min_value..=max_value));\n\
    \        sorted_lst = new_lst;\n        current_min = min_value;\n    }\n    sorted_lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `RangeToInclusive<&isize>: RangeBounds<usize>`\
    \ is not satisfied\n    --> /tmp/tmph0a5cxyo.rs:14:40\n     |\n14   |        \
    \ let new_lst = sorted_lst.drain(..=min_value);\n     |                      \
    \            ----- ^^^^^^^^^^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `RangeToInclusive<&isize>`\n     |                                  |\n\
    \     |                                  required by a bound introduced by this\
    \ call\n     |\n     = help: the following other types implement trait `RangeBounds<T>`:\n\
    \               RangeToInclusive<&T>\n               RangeToInclusive<T>\nnote:\
    \ required by a bound in `Vec::<T, A>::drain`\n\nerror[E0599]: no method named\
    \ `extend` found for struct `std::vec::Drain` in the current scope\n  --> /tmp/tmph0a5cxyo.rs:15:17\n\
    \   |\n15 |         new_lst.extend(sorted_lst.drain(min_value..=max_value));\n\
    \   |                 ^^^^^^ method not found in `std::vec::Drain<'_, isize>`\n\
    \nerror[E0277]: the trait bound `RangeInclusive<&isize>: RangeBounds<usize>` is\
    \ not satisfied\n    --> /tmp/tmph0a5cxyo.rs:15:41\n     |\n15   |         new_lst.extend(sorted_lst.drain(min_value..=max_value));\n\
    \     |                                   ----- ^^^^^^^^^^^^^^^^^^^^^ the trait\
    \ `RangeBounds<usize>` is not implemented for `RangeInclusive<&isize>`\n     |\
    \                                   |\n     |                                \
    \   required by a bound introduced by this call\n     |\n     = help: the following\
    \ other types implement trait `RangeBounds<T>`:\n               RangeInclusive<&T>\n\
    \               RangeInclusive<T>\nnote: required by a bound in `Vec::<T, A>::drain`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph0a5cxyo.rs:16:22\n   |\n9  |\
    \     let mut sorted_lst = lst;\n   |                          --- expected due\
    \ to this value\n...\n16 |         sorted_lst = new_lst;\n   |               \
    \       ^^^^^^^ expected struct `Vec`, found struct `std::vec::Drain`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `std::vec::Drain<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort();\n    lst.to_owned()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmppy1gamc1.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.pop();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpbvux_fhr.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    if lst.len() == 0 {\n        return Vec::new();\n    }\n \
    \   let mut it = lst.iter().enumerate().rev();\n    let (mut i, mut j) = it.next();\n\
    \    let mut k = it.next();\n    let mut tmp = vec![k.unwrap(), i.unwrap()].iter().cloned().collect::<Vec<(Vec<isize>,\
    \ Vec<isize>)>>();\n\n    let mut tmp = tmp.iter_mut().cloned().collect::<Vec<(Vec<isize>,\
    \ Vec<isize>)>>();\n    let mut res = Vec::new();\n    loop {\n        if *i.unwrap().0\
    \ * -1 < *j.unwrap().0 {\n            res.push(*i.unwrap().0);\n            i\
    \ = i.next();\n            if i == nil {\n                break;\n           \
    \ }\n        } else {\n            res.push(*j.unwrap().0);\n            j = j.next();\n\
    \            if j == nil {\n                break;\n            }\n        }\n\
    \        tmp.push((i.unwrap().0, j.unwrap().0));\n        i = k.next();\n    \
    \    j = k.next();\n        tmp = tmp.iter_mut().cloned().collect::<Vec<(Vec<isize>,\
    \ Vec<isize>)>>();\n    }\n\n    res.sort_unstable();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `nil` in this scope\n  --> /tmp/tmpc7neipm9.rs:23:21\n\
    \   |\n23 |             if i == nil {\n   |                     ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `nil` in this scope\n  -->\
    \ /tmp/tmpc7neipm9.rs:29:21\n   |\n29 |             if j == nil {\n   |      \
    \               ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc7neipm9.rs:13:9\n   |\n13 |     let (mut i, mut j) = it.next();\n\
    \   |         ^^^^^^^^^^^^^^   --------- this expression has type `Option<(usize,\
    \ &isize)>`\n   |         |\n   |         expected enum `Option`, found tuple\n\
    \   |\n   = note: expected enum `Option<(usize, &isize)>`\n             found\
    \ tuple `(_, _)`\n\nerror[E0277]: a value of type `Vec<(Vec<isize>, Vec<isize>)>`\
    \ cannot be built from an iterator over elements of type `(usize, &isize)`\n \
    \   --> /tmp/tmpc7neipm9.rs:15:64\n     |\n15   |     let mut tmp = vec![k.unwrap(),\
    \ i.unwrap()].iter().cloned().collect::<Vec<(Vec<isize>, Vec<isize>)>>();\n  \
    \   |                                                                ^^^^^^^ value\
    \ of type `Vec<(Vec<isize>, Vec<isize>)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(usize, &isize)>` is\
    \ not implemented for `Vec<(Vec<isize>, Vec<isize>)>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0271]: type mismatch resolving `<std::slice::IterMut<'_,\
    \ (Vec<isize>, Vec<isize>)> as Iterator>::Item == &_`\n    --> /tmp/tmpc7neipm9.rs:17:34\n\
    \     |\n17   |     let mut tmp = tmp.iter_mut().cloned().collect::<Vec<(Vec<isize>,\
    \ Vec<isize>)>>();\n     |                                  ^^^^^^ types differ\
    \ in mutability\n     |\n     = note:      expected reference `&_`\n         \
    \    found mutable reference `&mut (Vec<isize>, Vec<isize>)`\nnote: required by\
    \ a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::slice::IterMut<'_, (Vec<isize>, Vec<isize>)>>`, but its trait bounds\
    \ were not satisfied\n   -->"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    lst.sort_unstable();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmp9_5udf1f.rs:9:5\n  |\n8 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n  |                      --- help: consider changing this to\
    \ be mutable: `mut lst`\n9 |     lst.sort_unstable();\n  |     ^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = lst;\n    let mut min = result.iter().min();\n\
    \    let mut max = result.iter().max();\n    let mut min_idx = result.iter().position(|&x|\
    \ x == min);\n    let mut max_idx = result.iter().position(|&x| x == max);\n \
    \   loop {\n        // if min==max, then max is new min, min is new max,\n   \
    \     // and we need to swap min and max and repeat.\n        if min == max {\n\
    \            min = result.swap(0, min_idx);\n            max = result.swap(1,\
    \ max_idx);\n            min = result.swap(0, min_idx);\n            max = result.swap(1,\
    \ max_idx);\n            min.clone(),\n            max.clone(),\n            min_idx,\n\
    \            max_idx,\n            true,\n            true\n        } else {\n\
    \            min_idx = max_idx;\n            min.clone(),\n            max.clone(),\n\
    \            min_idx,\n            max_idx,\n            false,\n            false\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpg1rtq1hv.rs:22:24\n   |\n22 |             min.clone(),\n   |  \
    \                      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n  --> /tmp/tmpg1rtq1hv.rs:30:24\n\
    \   |\n30 |             min.clone(),\n   |                        ^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg1rtq1hv.rs:12:56\n   |\n12 |     let mut min_idx = result.iter().position(|&x|\
    \ x == min);\n   |                                                        ^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg1rtq1hv.rs:13:56\n   |\n13 |     let mut max_idx = result.iter().position(|&x|\
    \ x == max);\n   |                                                        ^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg1rtq1hv.rs:18:34\n   |\n18 |             min = result.swap(0,\
    \ min_idx);\n   |                                  ^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg1rtq1hv.rs:18:19\n\
    \   |\n10 |     let mut min = result.iter().min();\n   |                   -------------------\
    \ expected due to this value\n...\n18 |             min = result.swap(0, min_idx);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `()`\n   |\n   = note:   expected enum `Option<&isize>`\n           found unit\
    \ type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg1rtq1hv.rs:19:34\n\
    \   |\n19 |             max = result.swap(1, max_idx);\n   |                 \
    \                 ^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<usize>`\n\nerror[E0308]:\
    \ mismat"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_list = vec![lst[0]];\n    for el in lst {\n\
    \        if sorted_list.iter().all(|&x| x < el) {\n            sorted_list.push(el);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp18t1p7yr.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = lst;\n    let mut min_value = list.clone();\n\
    \    list.sort_by(|a, b| a.cmp(b));\n    list.sort_by(|a, b| b.cmp(a));\n    for\
    \ i in 0..list.len() {\n        min_value[i] = list[i];\n    }\n    min_value\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpko35j2a5.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of integers, return list in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\n/// strange_sort_list([]) == []\nfn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    for i in lst.iter() {\n       \
    \ res.push(i);\n    }\n    for e in res.iter().rev() {\n        res.push(e - 1);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `{integer}` from `&&isize`\n  --> /tmp/tmp9ifzra2l.rs:14:20\n\
    \   |\n14 |         res.push(e - 1);\n   |                  - ^ - {integer}\n\
    \   |                  |\n   |                  &&isize\n   |\nhelp: `-` can be\
    \ used on `isize`, you can dereference `e`\n   |\n14 |         res.push(*e - 1);\n\
    \   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ifzra2l.rs:16:5\n\
    \   |\n8  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n16 |     res\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
