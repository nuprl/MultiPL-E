name: HumanEval_18_how_many_times
language: rust
prompt: "/// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n/// >>> how_many_times('aaa',\
  \ 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n/// 3\nfn how_many_times(string:\
  \ String, substring: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
  \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
  ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
  ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
  ), String::from(\"john\")), 1);\n}\n"
completions: ["    string.chars()\n        .zip(string.chars().skip(string.len()))\n\
    \        .filter(|&(c1, _)| c1 == substring)\n        .count();", '    string.chars().zip(substring.chars()).filter(|(a,
    b)| a == b).count() + 1', "    let mut counter = 0;\n    for s in string.chars()\
    \ {\n        let found = substring.contains(&s);\n        if found {\n       \
    \     counter += 1;\n        }\n    }\n    counter", '    string.chars().filter(|c|
    substring.contains(&c)).count()', "    string.chars()\n        .enumerate()\n\
    \        .filter(|(_, c)| c.contains(substring))\n        .count()", "    // This\
    \ code uses `memchr` which is not available on all platforms, but we can work\
    \ around that.\n    let mut string_bytes = string.as_bytes();\n    let mut substring_len\
    \ = substring.len();\n    let mut i = 0;\n    while i < substring_len && i < string_bytes.len()\
    \ {\n        if substring_len == 0 {\n            return i;\n        }\n     \
    \   if string_bytes[i] == substring_len {\n            substring_len -= 1;\n \
    \           i += 1;\n        } else if string_bytes[i] == 0 {\n            i +=\
    \ 1;\n        } else {\n            substring_len -= 1;\n            i += 1;\n\
    \        }\n    }\n    0", "    let mut count = String::new();\n    let mut s\
    \ = String::from(string);\n    let mut sub = String::from(substring);\n\n    while\
    \ !s.is_empty() {\n        let index = sub.find(s);\n        if index != Some(sub.length())\
    \ {\n            count += 1;\n            s = String::from_utf8(s.split_off(index).collect());\n\
    \        }\n        else {\n            return count;\n        }\n    }\n\n  \
    \  count", '    string.char_indices().map(|i| (substring, i)).count(|&(sub, i),
    _| sub == substring)', "    let mut count = 0; // count how many substrings match\n\
    \    let mut last_end = 0; // last substring end\n    for index in string.char_indices().rev()\
    \ {\n        let start = index.0;\n        let end = index.1;\n        if last_end\
    \ < start {\n            break // nothing matched\n        }\n        if last_end\
    \ >= end {\n            break // reached end of string\n        }\n        let\
    \ index = string.char_offset(start); // start of substring match\n        if string[index..].contains(&substring)\
    \ {\n            count += 1;\n        }\n        last_end = end;\n    }\n    count",
  "    let mut count = 0;\n    for index in string.char_indices() {\n        if let\
    \ Some(index) = substring.find(string.chars()[index]) {\n            count +=\
    \ 1;\n        }\n    }\n    count", "    // Start with 0, because substring starts\
    \ with substring\n    let mut cnt = 0;\n    let mut last = 0;\n    let mut i =\
    \ string.find(&substring);\n    while i != String::npos {\n        if i == last\
    \ {\n            cnt += 1;\n            last = i + 1;\n        } else {\n    \
    \        cnt = 0;\n        }\n        i = string.find(&substring, last);\n   \
    \ }\n    cnt", '    string.chars().filter(|c| *c == substring).count()', '    string.chars().filter(|c|
    substring.contains(c)).count() + 1', "    let mut cnt = 0;\n    let mut last =\
    \ 0;\n    for c in string.chars() {\n        if c.to_ascii_lowercase().contains(substring)\
    \ {\n            cnt += 1;\n        }\n        if substring[last..].to_ascii_lowercase().contains(c)\
    \ {\n            cnt += 1;\n        }\n        last = c.len_utf8();\n    }\n \
    \   cnt", "    let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len()\
    \ {\n        if string.starts_with(substring, pos) {\n            count += 1;\n\
    \        }\n        pos += 1;\n    }\n    count", "    let mut counter = 0;\n\
    \    for ch in string.chars() {\n        if ch.contains(&substring) {\n      \
    \      counter += 1;\n        }\n    }\n    counter", '    string.chars().zip(substring.chars()).filter(|(a,
    b)| a == b).count()', "    if string.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut i = 1;\n    let mut pos = 0;\n    let mut found = false;\n    loop\
    \ {\n        found = pos == string.len() || string.chars().any(|c| c == string[pos]);\n\
    \        if found {\n            return i;\n        }\n        i += 1;\n     \
    \   pos += 1;\n    }", "    let mut count = Vec::new();\n    for _i in 0..string.len()\
    \ {\n        for _j in string.chars().skip_while(|&&c| c != substring[..]) {\n\
    \            count.push(0);\n        }\n        let start = _i;\n        let end\
    \ = string.len() - substring.length();\n        let start = if start < 0 { 0 }\
    \ else { start };\n        let end = if end < 0 { 0 } else { end };\n        for\
    \ _i in start..end {\n            let mut pos = _i;\n            let c = string.chars().skip_while(|&&c|\
    \ c != substring[..]).take(substring.length());\n            pos += c.len();\n\
    \            let found = !count.contains(&pos);\n            count.push(found\
    \ as isize);\n        }\n    }\n    count.iter().max().unwrap()", "    string.iter().filter_map(|c|\
    \ {\n        let index = string.find(substring);\n        Some(index as isize)\n\
    \    }).count()", '    string.chars().take_while(|c| c.unwrap() == substring).count()
    + 1', "    let mut count = 0;\n    let mut index = string.find(substring);\n \
    \   while index != String::npos {\n        count = count + 1;\n        index =\
    \ string.find(substring, index + 1);\n    }\n    count", "    if string.len()\
    \ < substring.len() {\n        return 0;\n    }\n\n    let mut count = 0;\n  \
    \  let mut start_index = 0;\n    let mut end_index = string.len() - substring.len();\n\
    \    let mut found = false;\n    while !found {\n        while start_index < end_index\
    \ {\n            if string.chars()[start_index] == substring.chars()[start_index]\
    \ {\n                start_index += 1;\n                count += 1;\n        \
    \    } else {\n                break;\n            }\n        }\n\n        if\
    \ start_index >= end_index {\n            found = true;\n        } else {\n  \
    \          end_index -= 1;\n        }\n    }\n\n    count", "    string.chars()\n\
    \        .zip(substring.chars())\n        .map(|(char1, char2)| (char1 as u8 ==\
    \ char2 as u8) as isize)\n        .sum()", "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter(|(a, b)| a == b)\n        .count() + 1", '    string.count(substring)',
  "    let mut count = 0;\n    let mut last_substring_pos = 0;\n    while let Some(pos)\
    \ = string.find(substring, last_substring_pos) {\n        last_substring_pos =\
    \ pos + 1;\n        count += 1;\n    }\n    count", "    let mut substr_len =\
    \ substring.len();\n    let mut count = 0;\n    let mut pos = 0;\n    while pos\
    \ < string.len() {\n        let mut found = string[pos].find(&substring[..substr_len]);\n\
    \        count = if found != String::npos {\n            found + substr_len\n\
    \        } else {\n            count\n        };\n        pos = pos + 1;\n   \
    \ }\n    count", "    string.chars()\n        .filter(|c| substring.contains(&c.to_string()))\n\
    \        .count()", "    let mut counter = 0;\n    let mut pos = 0;\n    for c\
    \ in string.chars() {\n        if pos == 0 && c.is_ascii() {\n            pos\
    \ = string.find(substring, pos);\n            continue;\n        }\n        if\
    \ pos == 0 {\n            pos = string.find(substring, pos + 1);\n           \
    \ continue;\n        }\n        if pos == string.len() - 1 {\n            pos\
    \ = string.find(substring, 0);\n            continue;\n        }\n        let\
    \ mut i = 0;\n        for b in &string[pos - 1..pos] {\n            if i == 0\
    \ && b.is_ascii() {\n                i = 1;\n                continue;\n     \
    \       }\n            if i == 1 && b.is_ascii() {\n                i = 2;\n \
    \               continue;\n            }\n            if i == 2 && b.is_ascii()\
    \ {\n                i = 3;\n                continue;\n            }\n      \
    \      break;\n        }\n        counter += i;\n        pos += i;\n    }\n  \
    \  counter", "    if string.is_empty() || substring.is_empty() {\n        return\
    \ 0;\n    }\n    let mut result = 1;\n    let mut string_ptr = string.as_bytes();\n\
    \    let mut substring_ptr = substring.as_bytes();\n    let len = min(string_ptr.len(),\
    \ substring_ptr.len());\n    for _ in 0..len {\n        if string_ptr[string_ptr.len()\
    \ - substring_ptr.len()..string_ptr.len()].iter()\n            .zip(substring_ptr.iter())\n\
    \            .any(|e| e[0] == e[1])\n        {\n            result *= 2;\n   \
    \     }\n        result *= 2;\n        string_ptr = string_ptr.offset(1);\n  \
    \      substring_ptr = substring_ptr.offset(1);\n    }\n    result * 2", "   \
    \ string\n        .chars()\n        .zip(substring.chars())\n        .filter(|(a,\
    \ b)| a == b)\n        .count();", "    if string.contains(&substring) {\n   \
    \     string.count(substring)\n    } else {\n        0\n    }", '    string.chars().filter(|c|
    *c == *substring).count() + 1', "    let mut substr_len = substring.length();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < string.length() &&\
    \ count < substr_len {\n        if string[i] == substring[0] {\n            i\
    \ += 1;\n            count += 1;\n            if i == string.length() || string[i]\
    \ != substring[1] {\n                return count;\n            }\n          \
    \  while i + 1 < string.length() && count < substr_len {\n                if string[i\
    \ + 1] == substring[0] {\n                    i += 2;\n                    count\
    \ += 1;\n                    if i == string.length() || string[i] != substring[1]\
    \ {\n                        return count;\n                    }\n          \
    \      } else {\n                    i += 1;\n                }\n            }\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count", "    let\
    \ mut counter = 0;\n    for (i, c) in string.chars().enumerate() {\n        if\
    \ c == substring {\n            counter += 1;\n            if i >= string.len()\
    \ - substring.len() {\n                break;\n            }\n            if i\
    \ >= string.len() - substring.len() - 1 && string.chars()[i + substring.len()..].all(|c|\
    \ c != c) {\n                break;\n            }\n        }\n    }\n    counter",
  "    string.chars()\n        .zip(substring.chars())\n        .filter(|(a, b)| {\n\
    \            b.cmp(a) == Ordering::Less\n        })\n        .fold(0, |acc, (a,\
    \ b)| acc + (b == a ? 1 : 0))", "    let mut count = 0;\n    let mut idx = string.find(substring);\n\
    \    while idx != std::str::npos {\n        count += 1;\n        idx = string.find(substring,\
    \ idx + 1);\n    }\n    count", "    if string.find(substring).is_none() {\n \
    \       return 0;\n    }\n\n    let mut i = 0;\n    for pos in string.find(substring)\
    \ {\n        if pos == 0 {\n            continue;\n        }\n\n        if string.chars().skip(pos).take(substring).count()\
    \ > 1 {\n            i += 1;\n        }\n    }\n\n    i + 1", "    string\n  \
    \      .chars()\n        .zip(string.chars())\n        .filter(|(a, b)| a == b)\n\
    \        .filter(|(a, b)| a.to_ascii_lowercase().contains(substring))\n      \
    \  .count()", "    // O(n)\n    let mut count = 0; // This is an extra level of\
    \ indirection that is unnecessary but saves ~80% of run-time when profiling\n\
    \    for ch in string.chars() {\n        if ch == substring {\n            count\
    \ += 1;\n        }\n        if ch.is_ascii_uppercase() {\n            count +=\
    \ 1;\n        }\n        if ch.is_ascii_lowercase() {\n            count += 1;\n\
    \        }\n        if ch.is_digit() {\n            count += 1;\n        }\n \
    \       if ch.is_punctuation() {\n            count += 1;\n        }\n       \
    \ if ch.is_whitespace() {\n            count += 1;\n        }\n    }\n    count",
  '    string.chars().filter(|c| c == substring).count() + how_many_times(substring,
    substring)', "    string.chars()\n        .zip(substring.chars())\n        .filter(|(sub_char,\
    \ sub_len)| sub_char == sub_len)\n        .count()", "    if string.contains(&substring)\
    \ {\n        string.count(substring)\n    } else {\n        string.length()\n\
    \    }", "    let mut len = 0;\n    let mut pos = 0;\n    let mut i = 0;\n   \
    \ while i < string.len() {\n        pos = string.find(substring, pos);\n     \
    \   if pos < i {\n            len += 1;\n        } else {\n            len +=\
    \ pos - i;\n        }\n        i += 1;\n    }\n    len", "    if string.len()\
    \ == 0 {\n        return 0\n    }\n    if substring.len() == 0 {\n        return\
    \ 1\n    }\n    \n    let mut current_offset = 0;\n    let mut sub_offset = 0;\n\
    \    \n    while current_offset < string.len() {\n        let mut match = false;\n\
    \        for c in string.chars() {\n            if c == 'a' {\n              \
    \  current_offset += 1;\n                sub_offset = current_offset;\n      \
    \          match = true;\n                break;\n            }\n        }\n \
    \       \n        if match {\n            if string.chars().position(|c| c ==\
    \ substring[sub_offset]).is_some() {\n                return string.chars().position(|c|\
    \ c == substring[sub_offset]).unwrap() + 1;\n            }\n        }\n      \
    \  \n        current_offset += 1;\n    }\n    \n    0", "    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < string.len() && j < substring.len() {\n   \
    \     if string[i] == substring[j] {\n            i += 1;\n            j += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    j", "    // Check\
    \ substring against both strings at the same time, then do an overlaps check between\
    \ them.\n    // This way the result is the same as simply counting the number\
    \ of occurrences of substring in string\n    string.chars().zip(string.chars()).count(|(start,\
    \ end), &_| {\n        start >= substring.len() || end >= substring.len() || substring[start..end]\
    \ == &substring[start..end]\n    })", "    let mut counter: isize = 0;\n    let\
    \ mut start = 0;\n    let mut end = string.len();\n    let mut found = false;\n\
    \    while start < end {\n        if found {\n            break;\n        }\n\
    \        if string.to_lowercase()[start] == substring.to_lowercase()[start as\
    \ usize] {\n            counter += 1;\n            start += 1;\n            found\
    \ = true;\n        } else if string.to_lowercase()[end as usize] == substring.to_lowercase()[end\
    \ as usize] {\n            counter += 1;\n            end -= 1;\n        } else\
    \ {\n            found = false;\n        }\n    }\n    counter", "    let mut\
    \ counter = 0\n\n    for c in string.chars() {\n        counter += !string.chars().any(|&c|\
    \ c == c);\n        counter += !substring.chars().any(|&c| c == c);\n    }\n\n\
    \    counter", '    string.chars().filter(|c| *c == substring).count() + 1', '    string.chars().filter(|c|
    *c == substring).count()', "    // TODO: Fix this so it doesnt have to copy the\
    \ string\n    let mut found_at = -1;\n    for (i, c) in string.chars().enumerate()\
    \ {\n        if c == 'a' {\n            if found_at == -1 || i - (found_at + 1)\
    \ <= substring.len() {\n                found_at = i;\n            }\n       \
    \ }\n    }\n    if found_at == -1 {\n        return 0\n    }\n    substring.chars().filter(|c|\
    \ *c == 'a').count() - found_at", "    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if substring.contains(&c) {\n            count += 1;\n        }\n\
    \    }\n    count", "    if !string.contains(substring) {\n        return 0;\n\
    \    }\n    if let index = string.find(substring, 0) {\n        if index + substring.length()\
    \ == string.length() {\n            return 1;\n        }\n        return 2;\n\
    \    }\n    0;", '    string.chars().filter(|&c| c == substring).count()', " \
    \   // TODO: Optimize algorithm\n\n    // Calculate total overlap with substring\n\
    \    let mut substring = substring.to_lowercase();\n    let mut total_overlap\
    \ = 0;\n    for (index, character) in string.chars().enumerate() {\n        if\
    \ character == substring {\n            total_overlap += 1;\n            if total_overlap\
    \ > substring.length {\n                return total_overlap;\n            }\n\
    \        } else {\n            total_overlap = 0;\n        }\n    }\n\n    //\
    \ If we reach the end of the string, return substring's length\n    if string[string.len()...]\
    \ == substring {\n        return substring.length;\n    }\n\n    // If substring\
    \ doesn't exist at all, return original string\n    substring.length", "    //\
    \ If substring does not occur in string, return 0\n    string.count(substring).map(|c|\
    \ c as isize)\n        .unwrap_or(0)", '    string.find(substring).map(|i| string.as_bytes()[i..].iter().filter(|c|
    c == c).count() + 1)', "    let mut counter = 0\n\n    for _ in string.chars()\
    \ {\n        if let Some(pos) = string.find(substring) {\n            counter\
    \ += 1;\n            string = string.replace(pos, substring.len(), \"\").to_string();\n\
    \        }\n    }\n\n    counter", "    string.chars().enumerate()\n        .filter(|(_,\
    \ c)| c == substring[0])\n        .count()", '    substring.chars().filter(|c|
    string.contains(&c)).count()', "    string.chars()\n        .filter(|c| c.contains(&substring))\n\
    \        .count() as isize", "    if string.len() < substring.len() {\n      \
    \  return 0;\n    }\n    let mut start = 0;\n    while start < string.len() &&\
    \ substring[start..].contains(&string[start..]) {\n        start += 1;\n    }\n\
    \    start", "    string.chars()\n        .zip(substring.chars())\n        .filter(|(a,\
    \ b)| a == b)\n        .fold(0, |acc, &(a, b)| acc + 1)", "    if string.len()\
    \ == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i <= string.len() && j <= substring.len() {\n \
    \       if string[i] != substring[j] {\n            i += 1;\n            j = 0;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    return if substring[j..].len()\
    \ == 0 {\n        0\n    } else {\n        i + 1\n    };", "    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < string.len() && j < substring.len() {\n   \
    \     if string[i] == substring[j] {\n            i += 1;\n            j += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    i + (j - 1)", '    string.chars().filter(|c|
    c != substring[0] && c != substring[1]).count() as isize', '    string.chars().count(|c|
    string.chars().any(|c| c == c))', "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter(|(char, substring)| char == substring)\n        .count()", " \
    \   let mut count = HashMap::new();\n    for pos in string.char_indices() {\n\
    \        let pos = pos.0 as usize;\n        let len = substring.length();\n  \
    \      if len > 0 && substring[0..len].contains(&string[pos]) {\n            count\
    \ += 1;\n        }\n    }\n    count.len()", "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter(|(first, second)| first == second)\n        .count()", "    string.char_indices()\n\
    \        .filter(|(i, char)| substring.contains(char))\n        .count()", " \
    \   let mut cnt = 0;\n    for i in string.rindex() {\n        if string.contains(&substring)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt", "    let mut cnt = 0;\n\
    \    for substr in string.split() {\n        if substr == substring {\n      \
    \      cnt += 1;\n        }\n    }\n    cnt", "    let mut n = 0;\n    for c in\
    \ string.chars() {\n        if c == substring {\n            n += 1;\n       \
    \ }\n        if c.is_ascii_alphanumeric() {\n            n += 1;\n        }\n\
    \    }\n    n", "    string.chars()\n        .zip(substring.chars())\n       \
    \ .filter(|(a, b)| (a == b) || (a < b) || (a > b))\n        .count()", "    string.chars().zip(substring.chars())\n\
    \        .filter(|(c1, c2)| c1 == c2)\n        .filter(|(c1, c2)| c1 < c2)\n \
    \       .count();", '    string.chars().filter(|c| c == substring).count() + 1',
  "    let mut count = 0;\n    let mut index_to_search = 0;\n    while index_to_search\
    \ < string.len() {\n        let index_to_start = index_to_search;\n        let\
    \ index_to_end = string.find(substring, index_to_search);\n        if index_to_end\
    \ == -1 {\n            count = count + 1;\n            index_to_search = index_to_start;\n\
    \        } else {\n            count = count + index_to_end - index_to_start;\n\
    \            index_to_search = index_to_end;\n        }\n    }\n    count", " \
    \   let mut count = 0;\n    for s in string.iter() {\n        if s.contains(substring)\
    \ {\n            count += 1;\n        }\n    }\n    count", '    string.chars().filter(|c|
    c == substring).count() + how_many_times_without_overlap(string, substring)',
  '    string.chars().count(|c| string.contains(substring))', "    if string.find(substring)\
    \ == String::npos {\n        return 0;\n    }\n    let mut count = 0;\n    let\
    \ mut pos = 0;\n    let mut last_pos = 0;\n    while pos < string.len() {\n  \
    \      if string.find(substring, pos) != String::npos {\n            count = count\
    \ + 1;\n            last_pos = pos;\n        }\n        pos = pos + 1;\n    }\n\
    \    count", '    string.chars().filter(|c| c == substring).count() + 1', '    string.chars().count(|c|
    *c == substring)', "    string.chars()\n        .position(|c| string.find(substring)\
    \ == Some(c.to_ascii_lowercase()))\n        .count()", '    string.chars().zip(substring.chars()).filter(|&(ref
    a, ref b)| a == b).count', "    string.chars().zip(substring.chars())\n      \
    \  .filter(|(a, b)| a == b)\n        .count();", "    string\n        .chars()\n\
    \        .filter(|c| *c == substring.as_bytes())\n        .count() - 1", '    string.chars().filter(|c|
    substring.contains(c)).count()', "    let mut cnt = 0;\n    let start_idx = string.find(substring);\n\
    \    while let Some(end_idx) = string.find(substring, start_idx + 1) {\n     \
    \   cnt += 1;\n        start_idx = end_idx;\n    }\n    cnt", "    let mut position\
    \ = 0;\n    while position < string.len() {\n        if string.starts_with(substring,\
    \ position) {\n            return 1;\n        }\n        position += 1;\n    }\n\
    \    0", "    string.chars()\n        .zip(substring.chars())\n        .filter(|(a,\
    \ b)| a == b)\n        .count()", '    substring.chars().fold(0, |acc, c| acc
    + string.count(c))', '    string.chars().filter(|c| c == substring).count() +
    how_many_times(substring, string.chars().filter(|c| c != substring).last())',
  '    string.chars().filter(|c| c == substring).count()', "    let mut count = std::cmp::min::min(string.chars().count(|c|\
    \ *c == substring), string.len());\n    if string.find(substring) != string.find(string.rsub(substring).unwrap())\
    \ { // If substring is contained in another substring\n        count = count +\
    \ 1;\n    }\n    count", "    if string.is_empty() {\n        return 0;\n    }\n\
    \    if substring.is_empty() {\n        return 1;\n    }\n\n    match find_index(&string,\
    \ &substring) {\n        Some(index) => index + how_many_times(&string[index..],\
    \ &substring),\n        None => 0,\n    }", "    string.chars()\n        .filter(|c|\
    \ c == substring)\n        .count()", "    let mut i = 0;\n    string.char_indices()\n\
    \        .filter(|&(x, y)| x == substring[0] && y != substring[0])\n        .for_each(|&(x,\
    \ y)| i += 1);\n    i", "    let mut position = 0;\n\n    while position < string.len()\
    \ {\n        match string.find(substring, position) {\n            Some(index)\
    \ => {\n                position += index;\n            }\n            None =>\
    \ return 0,\n        }\n        position += 1;\n    }\n\n    string.len()", " \
    \   let mut count = 0\n    let mut index = string.find(substring)\n    while index\
    \ >= 0 {\n        count = count + 1;\n        index = string.find(substring, index\
    \ + 1)\n    }\n    count", "    let mut counter = 0;\n    for (index, char) in\
    \ string.chars().enumerate() {\n        if char == substring {\n            counter\
    \ += 1;\n            if index != string.chars().last().unwrap() {\n          \
    \      if char == string.chars()[index + 1].unwrap() {\n                    counter\
    \ += 1;\n                }\n            }\n        }\n    }\n    counter", " \
    \   string.chars().filter_map(|c| {\n        if c.to_ascii_lowercase() == substring.to_ascii_lowercase()\
    \ {\n            Some(c)\n        } else {\n            None\n        }\n    }).count()\
    \ + 1", '    substring.chars().zip(string.chars()).filter(|(a, b)| a == b).count();',
  "    let mut count = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    return count;", '    string.chars().filter(|c|
    c == substring).count() as isize', "    string\n        .chars()\n        .filter_map(|c|\
    \ {\n            if let Some(i) = get_index(substring, c) {\n                Some(i)\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .fold(0, |a, b| {\n            if a > b {\n                a\n           \
    \ } else {\n                b\n            }\n        })", "    let mut counter\
    \ = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n        if string[pos]\
    \ == substring {\n            counter += 1;\n        }\n        pos += 1;\n  \
    \  }\n    counter", "    string.char_indices()\n        .filter(|&(_, index)|\
    \ string.chars().any(|c| c == c))\n        .filter(|&(_, index)| string.chars().any(|c|\
    \ c == c))\n        .filter(|&(_, index)| string.chars().contains(&substring[..]))\n\
    \        .count()", "    let len = string.len();\n    let substring = substring.to_string();\n\
    \    let mut pos = 0;\n    let mut count = 0;\n    while pos < len {\n       \
    \ if string[pos] == substring[0] {\n            count += 1;\n            pos +=\
    \ 1;\n        }\n        if string[pos] == substring[1] {\n            count +=\
    \ 1;\n            pos += 1;\n        }\n        if string[pos] == substring[2]\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[3] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[4] {\n            count += 1;\n         \
    \   pos += 1;\n        }\n        if string[pos] == substring[5] {\n         \
    \   count += 1;\n            pos += 1;\n        }\n        if string[pos] == substring[6]\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[7] {\n            count += 1;\n            pos += 1;\n        }\n\
    \        if string[pos] == substring[8] {\n            count += 1;\n         \
    \   pos += 1;\n        }\n        if string[pos] == substring[9] {\n         \
    \   count += 1;\n            pos += 1;\n        }\n        if string[pos] == substring[10]\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[11] {\n            count += 1;\n            pos += 1;\n       \
    \ }\n        if string[pos] == substring[12] {\n            count += 1;\n    \
    \        pos += 1;\n        }\n        if string[pos] == substring[13] {\n   \
    \         count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[14] {\n            count += 1;\n            pos += 1;\n       \
    \ }\n        if string[pos] == substring[15] {\n            count += 1;\n    \
    \        pos += 1;\n        }\n        if string[pos] == substring[16] {\n   \
    \         count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[17] {\n            count += 1;\n            pos += 1;\n       \
    \ }\n        if string[pos] == substring[18] {\n            count += 1;\n    \
    \        pos += 1;\n        }\n        if string[pos] == substring[19] {\n   \
    \         count += 1;\n            pos += 1;\n        }\n        if string[pos]\
    \ == substring[20] {\n            count += 1;\n            pos += 1;\n       \
    \ }\n        if string[pos] == substring[21] {\n            count += 1;\n    \
    \        pos += 1;\n        }\n        if string[pos] == substring[22] {", " \
    \   // The algorithm works fine only when substring is smaller than string.\n\
    \    // When substring is longer than string, all possible substrings have to\
    \ be checked\n    // to ensure that the substrings do not overlap.\n    if substring.length\
    \ < string.length {\n        return 0.into();\n    }\n    // Keep a count of the\
    \ number of occurrences.\n    let mut count = 0usize;\n\n    // Iterate from beginning\
    \ to end. Add 1 to count for each time the substring occurs.\n    for i in 0..substring.length\
    \ {\n        if string.contains(&substring[..i]) {\n            count += 1;\n\
    \        }\n    }\n    count", "    if substring.is_empty() {\n        return\
    \ 0;\n    }\n    let mut iter_string = string.char_indices();\n    let mut iter\
    \ = substring.char_indices();\n    loop {\n        if iter_string.next().is_none()\
    \ {\n            break;\n        }\n        if iter.next().is_none() {\n     \
    \       continue;\n        }\n        if iter_string.next().unwrap().0 == iter.next().unwrap().0\
    \ {\n            iter.next()\n                .map(|c| match c {\n           \
    \         None => true,\n                    Some(c) => c == iter.next().unwrap().0\n\
    \                })\n                .count()\n        } else {\n            iter.next()\n\
    \                .map(|c| match c {\n                    None => false,\n    \
    \                Some(c) => c == iter.next().unwrap().0\n                })\n\
    \                .count()\n        }\n    }", '    string.chars().count(|x| x
    == substring)', "    string\n        .split_ascii_lowercase()\n        .rfind(substring.to_ascii_lowercase())\n\
    \        .unwrap_or(0)", "    // Find start position\n    let start = string.find(substring).unwrap();\n\
    \n    // Find end position\n    let end = string.rfind(substring).unwrap();\n\n\
    \    // Return how many times substring occurs\n    (end - start).abs() as isize",
  '    string.chars().position(|c| c == substring).map(|i| i + substring.length()).sum()',
  "    string\n        .chars()\n        .zip(substring.chars())\n        .filter(|(a,\
    \ b)| a == b)\n        .count() as isize", "    // Find how many times `substring`\
    \ is in `string`\n    string\n        .chars()\n        .filter(|c| c.contains(&substring))\n\
    \        .count()", "    // Calculate the offset of the given substring in the\
    \ string\n    let substring_index_offset = (string.len() - substring.len()) as\
    \ isize;\n\n    // If the substring is found at the start or end of the string,\
    \ return 0\n    if substring_index_offset < 0 {\n        return 0;\n    }\n\n\
    \    // Otherwise, return the number of times the substring can be found in the\
    \ original string\n    if substring_index_offset == 0 {\n        return string.chars().filter(|c|\
    \ c == substring).count() + 1;\n    }\n\n    // Otherwise, find the index of the\
    \ first character of the substring in the string\n    let substring_index_start\
    \ = string.chars().position(|c| c == substring).unwrap();\n\n    // Return the\
    \ number of times the substring can be found in the original string\n    return\
    \ substring_index_offset - substring_index_start + substring.chars().count() +\
    \ 1;", "    let mut pos = 0;\n    let mut count = usize::MAX;\n    while pos <\
    \ string.len() {\n        let end = string.find(substring, pos);\n        if end\
    \ != String::npos { // Found the substring\n            count = count + 1;\n \
    \           pos = end + 1;\n        } else { // No more occurrences, return count\n\
    \            return count;\n        }\n    }\n    // Didn't find substring, return\
    \ 0\n    count", '    string.count(substring)', "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter_map(|pair| {\n            if let Some(c1) = pair.0.contains(pair.0)\
    \ {\n                Some(substring\n                    .chars()\n          \
    \          .skip_while(|&c| c1 == c)\n                    .count()\n         \
    \       )\n            } else {\n                None\n            }\n       \
    \ })\n        .fold(0, |acc, x| {\n            acc + x\n        })", "    let\
    \ mut count = 0; // how many times substring occurs\n\n    // get index\n    let\
    \ mut index = string.find(substring);\n\n    // skip first occurrence\n    if\
    \ index != None {\n        index = skip_substring(&string, &substring, index);\n\
    \    }\n\n    loop {\n        // skip next occurrences\n        index = skip_substring(&string,\
    \ &substring, index);\n\n        // skip cases when substring appears consecutively\n\
    \        if index != None {\n            if string.chars().any(|c| c == index\
    \ + 1) {\n                count++;\n            }\n        }\n        else {\n\
    \            break;\n        }\n    }\n\n    count", "    string.chars().fold(0,\
    \ |acc, c| {\n        if string.contains(substring.as_bytes()) {\n           \
    \ acc + 1;\n        }\n        acc\n    })", '    string.chars().count((substring.chars().collect::<String>())).min(string.length())',
  "    let mut count = 0;\n    for (i, elem) in string.chars().zip(substring.chars()).skip(1).take(string.len()\
    \ - substring.len()).enumerate() {\n        if elem == substring {\n         \
    \   count = 1 + i;\n        }\n    }\n    return count;", "    let mut count =\
    \ 0;\n    let mut i = string.find(|&b| b == substring);\n    while i != String::npos\
    \ && i < string.len() {\n        if string[i] == substring {\n            count\
    \ += 1;\n        }\n        i += 1;\n    }\n    count", "    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| (a == b) || (a == 'a'\
    \ && b == 'a'))\n        .count()", "    let mut i = 0;\n    while i < string.len()\
    \ && i < string.len().saturating_sub(1) && string[i] == substring[0] {\n     \
    \   i += 1;\n    }\n    i", '    substring.chars().filter(|c| string.contains(c)).count()',
  "    let mut counter = 0;\n    let mut substring_iter = string.char_indices()\n\
    \        .filter(|&i| i.0..=< substring.length())\n        .map(|i| i.0)\n   \
    \     .collect::<Vec<usize>>();\n    substring_iter.sort();\n    for i in substring_iter\
    \ {\n        if string.chars().any(|&c| i == c) {\n            counter += 1;\n\
    \        }\n    }\n    counter", "    string.char_indices()\n        .filter_map(|x|\
    \ x.contains(substring))\n        .count() as isize", "    string\n        .chars()\n\
    \        .filter(|c| *c == substring)\n        .count() + 1", '    string.chars().filter(|c|
    *c == substring).count()', "    let mut current_start = 0;\n    let mut count\
    \ = 0;\n    while current_start < string.len() {\n        if string.chars().position(|c|\
    \ c == substring[current_start]).is_some() {\n            count += 1;\n      \
    \  }\n        current_start += 1;\n    }\n    count", "    let mut index = 0;\n\
    \    let mut count = 0;\n    while index < string.len() {\n        let index =\
    \ string.find(substring, index);\n        if index == None {\n            break;\n\
    \        }\n        index += 1;\n        count += 1;\n    }\n    count", "   \
    \ string.chars()\n        .zip(substring.chars())\n        .filter(|&(a, b)| a\
    \ == b)\n        .count()", "    // Using `std::mem::transmute` here because String::index\n\
    \    // doesn't seem to work on Rust < 1.48.\n    let index = string.find(substring).map(|i|\
    \ i as usize).unwrap_or(0);\n    string.chars().take(index).count() + 1", "  \
    \  string.char_indices()\n        .filter_map(|(i, _)| {\n            if substring.contains(&string[i])\
    \ {\n                Some(i + 1)\n            } else {\n                None\n\
    \            }\n        })\n        .count()", '    string.chars().filter(|c|
    c != substring[0]).count() + string.chars().filter(|c| c == substring[0]).count()',
  "    string.char_indices()\n        .filter_map(|(index, c)| {\n            c.is_ascii_case()\
    \ || c.is_ascii_uppercase_ascii() || c.is_ascii_lowercase()\n        })\n    \
    \    .count(|&(index, c)| c == substring)", "    let mut count = 0;\n    let mut\
    \ index = 0;\n    while index < string.len() {\n        let index = string.find(substring,\
    \ index);\n        if index == String::npos { break; }\n        count += 1;\n\
    \        index = index + 1;\n    }\n    count", "    let mut count = substr_counts(string);\n\
    \    count.into_iter().filter(|&(_, count)| substring.find(&_).is_some()).count()",
  "    let mut count = 1;\n\n    for i in string.chars() {\n        if i >= substring.chars()\
    \ {\n            count += 1;\n        }\n        if string.contains(&substring)\
    \ {\n            count += 1;\n        }\n        if string.contains(&substring[..i])\
    \ {\n            count += 1;\n        }\n    }\n\n    count", "    let mut count\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let j = string.find(substring,\
    \ i);\n        if j == String::npos {\n            break;\n        }\n       \
    \ i += j;\n        count += 1;\n    }\n    count", "    string.chars()\n     \
    \   .zip(substring.chars())\n        .filter(|&(_, s)| s == s)\n        .count()",
  "    let len = string.len() as isize;\n    let sub_len = substring.len() as isize;\n\
    \n    if len < sub_len {\n        return 0;\n    }\n\n    let mut count = 0;\n\
    \n    let mut start = 0;\n    let mut end = 0;\n    while start < len {\n    \
    \    end = string.find(substring, start);\n\n        if end == -1 {\n        \
    \    return 0;\n        }\n\n        count += 1;\n        start = end + 1;\n \
    \   }\n\n    return count;", "    if string.contains(substring) {\n        return\
    \ string.count(substring).unwrap();\n    }\n    let mut found = 0;\n    for (index,\
    \ c) in string.char_indices().enumerate() {\n        if let Some(i) = get_string_offset(substring,\
    \ c) {\n            if i == index {\n                found += 1;\n           \
    \ }\n        }\n    }\n    found", "    let mut i = 0usize;\n    let mut j = 0usize;\n\
    \    let mut found = false;\n    while !found && i < string.len() {\n        if\
    \ string.len() - j > substring.length {\n            j += substring.length();\n\
    \            continue;\n        }\n        if string.as_str()[..j] == substring.as_str()\
    \ {\n            i += 1;\n            j += substring.length();\n            found\
    \ = true;\n        } else {\n            j += 1;\n        }\n    }\n    i + (j\
    \ - i);", "    string.char_indices()\n        .filter_map(|x| x.find(|c| c.is_ascii()))\n\
    \        .filter(|x| x.is_some())\n        .filter(|x| x.0 != x.1)\n        .filter(|(_,\
    \ count)| count > 0)\n        .count()", '    string.count(&substring).map(|n|
    n * substring.length())', "    if string.is_empty() {\n        return 0;\n   \
    \ }\n    \n    let mut count = 0;\n    for i in 0..string.len() {\n        if\
    \ string.chars().any(|c| c == i) {\n            count += 1;\n        }\n     \
    \   if substring.chars().any(|c| c == i) {\n            count += 1;\n        }\n\
    \    }\n    \n    return count;", "    let mut result = 0;\n\n    let mut strings\
    \ = string.chars();\n    let mut substrings = substring.chars();\n\n    while\
    \ let Some(mut s) = strings.next() {\n        while let Some(mut t) = substrings.next()\
    \ {\n            if s == t {\n                result += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n    }\n\n    result", '    string.chars().filter(|c|
    c == substring).count() + 1', '    string.chars().filter(|c| c == substring).count()
    + 1', "    // Use rfind() rather than find() since find() does not return usize\n\
    \    string.rfind(substring).map(|pos| pos as usize).count()", "    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a == b)\n        .count()",
  "    // Start with the initial substring length so no overlapping matches.\n   \
    \ let mut pos = 0;\n\n    // We loop through the string as many times as we can\
    \ to find all overlapping matches.\n    while pos < string.len() {\n        let\
    \ mut found = false;\n        let mut start_pos = pos;\n        let mut end_pos\
    \ = pos;\n\n        // Keep going as long as the start position is before the\
    \ end position\n        while start_pos < end_pos && string.chars().skip(start_pos).find(|c|\
    \ *c == substring[start_pos]) {\n            start_pos += 1;\n        }\n\n  \
    \      // The start position should be before the end position\n        assert_eq!(start_pos,\
    \ end_pos);\n\n        // Keep going as long as the end position is after the\
    \ start position\n        while end_pos < start_pos && string.chars().skip(end_pos).find(|c|\
    \ *c == substring[end_pos]) {\n            end_pos += 1;\n        }\n\n      \
    \  // We should now have found a match for the substring on the string.\n    \
    \    if start_pos == end_pos {\n            // The string matches the substring\
    \ exactly.\n            if start_pos < string.len() {\n                // We need\
    \ to skip over any overlapping matches on the substring.\n                while\
    \ start_pos < end_pos && string.chars().skip(start_pos).find(|c| *c == substring[start_pos])\
    \ {\n                    start_pos += 1;\n                }\n            }\n \
    \           found = true;\n        }\n        pos += end_pos - start_pos + 1;\n\
    \    }\n\n    // We don't need to worry about the initial substring since we already\
    \ have found one.\n    !found && pos", "    let mut idx: usize = 0;\n    loop\
    \ {\n        idx += string.find(substring, idx).unwrap_or(1);\n        if idx\
    \ == string.len() {\n            break;\n        }\n        if idx == string.len()\
    \ - substring.len() {\n            break;\n        }\n        if string[idx..idx+substring.len()].iter().all(|&c|\
    \ *c != string[idx+substring.len()]) {\n            break;\n        }\n    }\n\
    \    idx", '    substring.chars().filter(|c| string.contains(c)).count()', '    string.len()
    + substring.len() + 1 // to include overlaping cases', "    string.len() + substring.len()\n\
    \        .rposition(|&b| b == substring)\n        .expect(\"Substring is not in\
    \ string\")\n        .count() + 1", '    string.chars().count(|c| c.contains(&substring))',
  "    string\n        .chars()\n        .zip(substring.chars())\n        .filter(|(char,\
    \ substring)| char == substring)\n        .count();", "    let mut found_count\
    \ = 0 as isize;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            found_count += 1;\n        }\n    }\n    found_count", "    string.chars()\n\
    \        .zip(substring.chars())\n        .filter(|(a, b)| a != b)\n        .count()\
    \ + how_many_times(substring, &string[..])", "    string.char_indices()\n    \
    \    .filter_map(|index| {\n            let mut it = index.to_ascii_lowercase();\n\
    \            it.extend(substring);\n            Some(it)\n        })\n       \
    \ .count()", "    if string.len() < substring.len() {\n        return 0;\n   \
    \ }\n\n    let mut so_far = 0;\n    let mut pos = 0;\n\n    while so_far < string.len()\
    \ {\n        if string.starts_with(substring, pos, so_far) {\n            so_far\
    \ += substring.len();\n            pos += substring.len();\n        } else {\n\
    \            so_far += 1;\n            pos += 1;\n        }\n    }\n\n    so_far",
  "    let mut count = 1; // counting overlapping occurrences\n    let mut i = 0;\n\
    \    while i < string.len() {\n        i += match string[i + substring.len()..].contains(&substring)\
    \ {\n            true => substring.len(),\n            false => 1,\n        };\n\
    \        count += 1;\n    }\n    count", '    string.chars().filter(|c| c == substring).count()',
  "    string.chars()\n        .zip(string.chars())\n        .filter(|(c1, c2)| c1\
    \ == c2)\n        .filter(|(c1, c2)| c1 == c2 && c1 == substring[0])\n       \
    \ .count() as isize", "    let mut position = 0usize;\n\n    while position <\
    \ string.len() {\n        let found = string.find(substring, position);\n    \
    \    if found == std::string::npos {\n            return 0;\n        }\n\n   \
    \     if found > position {\n            return found - position + 1;\n      \
    \  }\n\n        position = found + 1;\n    }\n\n    0", '    string.chars().zip(substring.chars()).count(|&(a,
    b)| a == b)', "    string.char_indices()\n        .filter(|(&a, &b)| a == b)\n\
    \        .count()", '    string.chars().zip(substring.chars()).filter(|(&a, &b)|
    a == b).count()', '    string.chars().zip(substring.chars()).filter(|(a, b)| a
    == b).count() + 1', "    string.char_indices()\n        .filter_map(|i| if i.0\
    \ == substring.len() {\n            None\n        } else {\n            Some((*i).1.iter().count(|j|\
    \ j == substring.len()))\n        })\n        .count()", "    let mut count =\
    \ 0; // keep track of how many times substring occurs\n    let len = string.len();\n\
    \    for pos in 0..len {\n        if string.eq(substring, pos) {\n           \
    \ count += 1;\n        }\n    }\n    return count;", '    string.chars().filter(|c|
    c == substring).count()', "    let mut counter = 0;\n    string\n        .split_whitespace()\n\
    \        .into_iter()\n        .map(|x| match x {\n            x if x == substring\
    \ => counter = counter + 1;\n            _ => (),\n        })\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .fold(0, |acc, x| acc + x);\n    counter", "    let\
    \ mut pos = 0;\n    let mut i = 0;\n    while pos < string.len() {\n        i\
    \ = string.find(substring, pos);\n        if i == -1 {\n            break;\n \
    \       }\n        pos += i + 1;\n    }\n    i + 1", "    let mut counter = 0;\n\
    \    let mut index = 0;\n\n    while index < string.len() {\n        let index\
    \ = string.find(substring, index);\n\n        if index == String::npos { break;\
    \ }\n        index = index + substring.len();\n        counter += 1;\n    }\n\n\
    \    counter", "    string.chars()\n        .zip(substring.chars())\n        .filter(|(a,\
    \ b)| a == b)\n        .count()", "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter(|&[start, end]| start <= end)\n        .count();", "    string.char_indices()\n\
    \        .filter_map(|i| i.find(substring, ::std::cmp::Ordering::Equal))\n   \
    \     .count()", "    let mut count = 0\n    for (i, c) in string.chars().zip(substring.chars()).filter(|&&(_,\
    \ c2)| c.eq(c2)).enumerate() {\n        if i >= substring.len() {\n          \
    \  break\n        }\n        count += (i == 0) ? 0 : 1;\n    }\n    count", " \
    \   string\n        .split_last_mut()\n        .find(|x| x == substring)\n   \
    \     .map(|i| i + substring.length())\n        .unwrap_or_else(|| 0)", "    let\
    \ mut i = 0; // current position\n    for ch in string.chars() {\n        if substring\
    \ == ch {\n            i += 1;\n        } else if i >= substring.length() - 1\
    \ {\n            break;\n        }\n\n        i += 1;\n    }\n\n    i", "    let\
    \ mut index = 0;\n    let mut match_count = 0;\n    while index <= string.len()\
    \ {\n        if string.contains(substring, index) {\n            match_count +=\
    \ 1;\n        }\n        index += 1;\n    }\n    match_count", "    let mut cnt\
    \ = 0;\n    string\n        .chars()\n        .filter(|c| c == substring)\n  \
    \      .filter(|c| c != '\\0')\n        .for_each(|c| {\n            cnt += 1;\n\
    \            if cnt > 1 {\n                cnt -= 1;\n            }\n        });\n\
    \    cnt", '    string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()',
  "    let substring: Vec<Char> = string.chars().collect();\n    string.chars().filter(|c|\
    \ *c != *substring).count() - 1", "    string.chars()\n        .zip(substring.chars())\n\
    \        .filter(|c| c.0 == c.1)\n        .count()", '    string.chars().take_while(|c|
    c == substring).count() + 1', "    let mut found = 0;\n    for c in string.chars()\
    \ {\n        if substring.contains(c) {\n            found += 1;\n        }\n\
    \    }\n    found", "    let mut count: usize = 0;\n    for ch in string.chars()\
    \ {\n        if string.contains(ch) && substring.contains(ch) {\n            count\
    \ += 1;\n        }\n    }\n    count", "    let mut counter = 0;\n    let mut\
    \ position = 0;\n    while counter < string.len() && position != string.len()\
    \ {\n        if string[position..].find(substring) != Some(position..) {\n   \
    \         break;\n        }\n        position += 1;\n        counter += 1;\n \
    \   }\n    counter", "    let mut s = string;\n    loop {\n        if s.contains(substring)\
    \ {\n            return 1 + s.find(substring).unwrap();\n        }\n        s\
    \ = &s[..s.len()-1];\n    }"]
stop_tokens:
- "\n}"
