name: HumanEval_20_find_closest_elements
language: rust
results:
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_val = numbers[0];\n    let mut closest_dist\
    \ = std::f64::MAX;\n\n    for &number in &numbers[1..] {\n        let dist = number.abs()\
    \ - closest_val.abs();\n        if dist < closest_dist {\n            closest_dist\
    \ = dist;\n            closest_val = number;\n        }\n    }\n\n    (closest_val,\
    \ closest_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.2, 0.20000000000000018)`,\n right: `(3.9, 4.0)`', /tmp/tmpxjr1kl5r.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_difference = std::f64::MAX;\n    let mut\
    \ largest_difference = std::f64::MIN;\n    for (index, &number) in numbers.iter().enumerate()\
    \ {\n        let difference = number - numbers[index];\n        if smallest_difference\
    \ > difference {\n            smallest_difference = difference;\n        }\n \
    \       if largest_difference < difference {\n            largest_difference =\
    \ difference;\n        }\n    }\n    (numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == smallest_difference).unwrap().1],\n     numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == largest_difference).unwrap().1])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&f64` with `f64`\n  --> /tmp/tmpg96kibp4.rs:19:57\n\
    \   |\n19 |     (numbers[numbers.iter().enumerate().find(|(_, v)| v == smallest_difference).unwrap().1],\n\
    \   |                                                         ^^ no implementation\
    \ for `&&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n\
    \  --> /tmp/tmpg96kibp4.rs:19:6\n   |\n19 |     (numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == smallest_difference).unwrap().1],\n   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]:\
    \ can't compare `&&f64` with `f64`\n  --> /tmp/tmpg96kibp4.rs:20:57\n   |\n20\
    \ |      numbers[numbers.iter().enumerate().find(|(_, v)| v == largest_difference).unwrap().1])\n\
    \   |                                                         ^^ no implementation\
    \ for `&&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n\
    \  --> /tmp/tmpg96kibp4.rs:20:6\n   |\n20 |      numbers[numbers.iter().enumerate().find(|(_,\
    \ v)| v == largest_difference).unwrap().1])\n   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort_by(|a, b| a.abs() as i64);\n\n    let mut\
    \ smallest = numbers[0];\n    let mut largest = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] - smallest > largest - numbers[i] {\n            smallest\
    \ = numbers[i];\n        } else {\n            largest = numbers[i];\n       \
    \ }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi_wdk_aa.rs:8:28\n  |\n8 |\
    \     numbers.sort_by(|a, b| a.abs() as i64);\n  |                           \
    \ ^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `i64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return numbers[0], numbers[0];\n\
    \    }\n\n    // sort numbers in reverse order\n    numbers.sort_unstable_by_key(|num|\
    \ num.clone());\n\n    // find two closest numbers\n    let mut lower = numbers[0]\
    \ as f64;\n    let mut upper = numbers[0] as f64;\n    for num in numbers.iter_mut()\
    \ {\n        if num > upper {\n            upper = num;\n        }\n\n       \
    \ if num < lower {\n            lower = num;\n        }\n    }\n\n    return (lower,\
    \ upper);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \ --> /tmp/tmpd3t_aitq.rs:9:26\n  |\n9 |         return numbers[0], numbers[0];\n\
    \  |                          ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpd3t_aitq.rs:13:34\n\
    \     |\n13   |     numbers.sort_unstable_by_key(|num| num.clone());\n     | \
    \            -------------------- ^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |             |\n     |             required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `Ord`:\n               i128\n               i16\n               i32\n      \
    \         i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::sort_unstable_by_key`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3t_aitq.rs:19:18\n\
    \   |\n19 |         if num > upper {\n   |                  ^^^^^\n   |      \
    \            |\n   |                  expected `&mut f64`, found `f64`\n   | \
    \                 help: consider mutably borrowing here: `&mut upper`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd3t_aitq.rs:20:21\n   |\n17 |     let mut upper\
    \ = numbers[0] as f64;\n   |                     ----------------- expected due\
    \ to this value\n...\n20 |             upper = num;\n   |                    \
    \ ^^^ expected `f64`, found `&mut f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n20 |             upper = *num;\n   |                     +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd3t_aitq.rs:23:18\n   |\n23 |  \
    \       if num < lower {\n   |                  ^^^^^\n   |                  |\n\
    \   |                  expected `&mut f64`, found `f64`\n   |                \
    \  help: consider mutably borrowing here: `&mut lower`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd3t_aitq.rs:24:21\n   |\n16 |     let mut lower = numbers[0]\
    \ as f64;\n   |                     ----------------- expected due to this value\n\
    ...\n24 |        "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0.0, 0.0);\n \
    \   }\n\n    let mut min1 = numbers[0].min(numbers[1]);\n    let mut min2 = numbers[0].min(numbers[1]);\n\
    \n    for i in 0..numbers.len() - 1 {\n        let mut min3 = numbers[i].min(numbers[i\
    \ + 1]);\n        let mut min4 = numbers[i].min(numbers[i + 1]);\n\n        if\
    \ min1 < min2 {\n            min1 = min3;\n        } else {\n            min2\
    \ = min4;\n        }\n    }\n\n    (min1, min2)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.2, 4.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp55i6odfe.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut min_val\
    \ = numbers[0];\n\n    for (i, v) in numbers.iter().enumerate() {\n        let\
    \ dist = std::f64::abs(v - min_val);\n        if dist < min_dist {\n         \
    \   min_dist = dist;\n            min_val = v;\n        }\n    }\n\n    (min_val,\
    \ min_dist)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpkfspv04g.rs:12:30\n\
    \   |\n12 |         let dist = std::f64::abs(v - min_val);\n   |             \
    \                 ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkfspv04g.rs:15:23\n   |\n9  |     let mut min_val = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n15 | \
    \            min_val = v;\n   |                       ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   min_val = *v;\n   |                       +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for n in numbers {\n        if n < smallest {\n            smallest = n;\n\
    \        }\n        if n > largest {\n            largest = n;\n        }\n  \
    \  }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp0wf3zxes.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min1: f64;\n    let mut min2: f64;\n    let mut\
    \ min: Vec<f64> = Vec::new();\n    let mut max: Vec<f64> = Vec::new();\n\n   \
    \ for i in numbers.iter() {\n        let mut index = Vec::new();\n        let\
    \ mut min_diff = ::std::f64::MAX;\n\n        for j in 0..(numbers.len() - 1) {\n\
    \            if numbers[j] > i {\n                break;\n            }\n\n  \
    \          let diff = (numbers[j] - i).abs();\n            if diff < min_diff\
    \ {\n                min_diff = diff;\n                index = (j + 0, j + 1);\n\
    \            }\n        }\n\n        if index != (Vec::new(), Vec::new()) {\n\
    \            min1 = numbers[index[0]];\n            min2 = numbers[index[1]];\n\
    \            min.push(min1);\n            max.push(min2);\n        } else {\n\
    \            min1 = i;\n            min2.push(min1);\n            min.push(min2);\n\
    \        }\n    }\n\n    (min.iter().min_by_key(|x| x).unwrap(), max.iter().min_by_key(|x|\
    \ x).unwrap())\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr9ou0z4l.rs:18:29\n   |\n\
    18 |             if numbers[j] > i {\n   |                             ^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18\
    \ |             if numbers[j] > *i {\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr9ou0z4l.rs:25:25\n   |\n14 |         let mut\
    \ index = Vec::new();\n   |                         ---------- expected due to\
    \ this value\n...\n25 |                 index = (j + 0, j + 1);\n   |        \
    \                 ^^^^^^^^^^^^^^ expected struct `Vec`, found tuple\n   |\n  \
    \ = note: expected struct `Vec<_>`\n               found tuple `(usize, usize)`\n\
    \nerror[E0277]: can't compare `Vec<_>` with `(Vec<_>, Vec<_>)`\n  --> /tmp/tmpr9ou0z4l.rs:29:18\n\
    \   |\n29 |         if index != (Vec::new(), Vec::new()) {\n   |             \
    \     ^^ no implementation for `Vec<_> == (Vec<_>, Vec<_>)`\n   |\n   = help:\
    \ the trait `PartialEq<(Vec<_>, Vec<_>)>` is not implemented for `Vec<_>`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr9ou0z4l.rs:35:20\n   |\n8  |     let mut min1: f64;\n   |         \
    \          --- expected due to this type\n...\n35 |             min1 = i;\n  \
    \ |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             min1 = *i;\n   |                    +\n\n\
    error[E0599]: no method named `push` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpr9ou0z4l.rs:36:18\n   |\n36 |             min2.push(min1);\n  \
    \ |                  ^^^^ method not found in `f64`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr9ou0z4l.rs:41:28\n     |\n\
    41   |     (min.iter().min_by_key(|x| x).unwrap(), max.it"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut min_distance\
    \ = Vec::new();\n    for i in 0..numbers.len() {\n        let mut max_distance\
    \ = f64::MAX;\n        let mut max_distance = Vec::new();\n        let mut min_distance\
    \ = Vec::new();\n        // iterate through all the elements and find the max\
    \ and min distance\n        for j in 0..numbers.len() {\n            let distance\
    \ = numbers[i] - numbers[j];\n            if distance > max_distance {\n     \
    \           max_distance = distance;\n            } else if distance < min_distance\
    \ {\n                min_distance = distance;\n            }\n        }\n    \
    \    min_distance.push(min_distance);\n        min_distance.push(max_distance);\n\
    \    }\n    min_distance.sort_unstable();\n    (min_distance[0], min_distance[1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzo4vkv7.rs:17:27\n   |\n\
    17 |             if distance > max_distance {\n   |                          \
    \ ^^^^^^^^^^^^ expected `f64`, found struct `Vec`\n   |\n   = note: expected type\
    \ `f64`\n            found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyzo4vkv7.rs:18:32\n   |\n12 |         let mut max_distance = Vec::new();\n\
    \   |                                ---------- expected due to this value\n...\n\
    18 |                 max_distance = distance;\n   |                          \
    \      ^^^^^^^^ expected struct `Vec`, found `f64`\n   |\n   = note: expected\
    \ struct `Vec<_>`\n                found type `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyzo4vkv7.rs:19:34\n   |\n19 |             } else if distance\
    \ < min_distance {\n   |                                  ^^^^^^^^^^^^ expected\
    \ `f64`, found struct `Vec`\n   |\n   = note: expected type `f64`\n          \
    \  found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzo4vkv7.rs:20:32\n\
    \   |\n13 |         let mut min_distance = Vec::new();\n   |                 \
    \               ---------- expected due to this value\n...\n20 |             \
    \    min_distance = distance;\n   |                                ^^^^^^^^ expected\
    \ struct `Vec`, found `f64`\n   |\n   = note: expected struct `Vec<_>`\n     \
    \           found type `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzo4vkv7.rs:23:27\n\
    \   |\n23 |         min_distance.push(min_distance);\n   |                   \
    \        ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |\
    \                           |\n   |                           cyclic type of infinite\
    \ size\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyzo4vkv7.rs:26:18\n\
    \     |\n26   |     min_distance.sort_unstable();\n     |                  ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \      "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\
    \n    for &n in numbers {\n        min = std::min(n,\n                      min);\n\
    \        max = std::max(n,\n                      max);\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n  --> /tmp/tmppxszrmu5.rs:12:20\n\
    \   |\n12 |         min = std::min(n,\n   |                    ^^^ not found in\
    \ `std`\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\nhelp: if you import `min`, refer to it directly\n   |\n12 -         min\
    \ = std::min(n,\n12 +         min = min(n,\n   | \n\nerror[E0425]: cannot find\
    \ function `max` in crate `std`\n  --> /tmp/tmppxszrmu5.rs:14:20\n   |\n14 | \
    \        max = std::max(n,\n   |                    ^^^ not found in `std`\n \
    \  |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\nhelp: if you import `max`, refer to it directly\n   |\n14 -         max\
    \ = std::max(n,\n14 +         max = max(n,\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppxszrmu5.rs:11:9\n   |\n11 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = std::f64::MAX;\n\n    for (i, number) in numbers.iter().enumerate() {\n  \
    \      if number < min_number {\n            min_number = number;\n          \
    \  min_distance = i;\n        }\n    }\n\n    let mut max_number = numbers[min_distance];\n\
    \    let mut max_distance = min_distance;\n\n    for number in numbers.iter().skip(min_distance\
    \ + 1) {\n        if number > max_number {\n            max_number = number;\n\
    \            max_distance = i;\n        }\n    }\n\n    (min_number, max_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp973oru2w.rs:24:28\n\
    \   |\n24 |             max_distance = i;\n   |                            ^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp973oru2w.rs:12:21\n\
    \   |\n12 |         if number < min_number {\n   |                     ^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&min_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp973oru2w.rs:13:26\n   |\n9  |     let mut min_number\
    \ = std::f64::MAX;\n   |                          ------------- expected due to\
    \ this value\n...\n13 |             min_number = number;\n   |               \
    \           ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             min_number = *number;\n   |             \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp973oru2w.rs:14:28\n\
    \   |\n8  |     let mut min_distance = std::f64::MAX;\n   |                  \
    \          ------------- expected due to this value\n...\n14 |             min_distance\
    \ = i;\n   |                            ^ expected `f64`, found `usize`\n   |\n\
    help: you can cast a `usize` to an `f64`, producing the floating point representation\
    \ of the integer, rounded if necessary\n   |\n14 |             min_distance =\
    \ i as f64;\n   |                              ++++++\n\nerror[E0277]: the type\
    \ `[f64]` cannot be indexed by `f64`\n  --> /tmp/tmp973oru2w.rs:18:26\n   |\n\
    18 |     let mut max_number = numbers[min_distance];\n   |                   \
    \       ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `f64`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<f64>` for `Vec<f64>`\n\
    \nerror[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmp973oru2w.rs:21:52\n\
    \   |\n21 |     for number in numbers.iter().skip(min_distance + 1) {\n   |  \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = std::f64::MAX;\n    let mut largest\
    \ = -std::f64::MAX;\n    for n in numbers {\n        let n = *n;\n        if n\
    \ < smallest {\n            smallest = n;\n        }\n        if n > largest {\n\
    \            largest = n;\n        }\n    }\n    (smallest, largest)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpbbjl09a_.rs:11:17\n\
    \   |\n11 |         let n = *n;\n   |                 ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest: Vec<f64> = Vec::new();\n    let mut largest:\
    \ Vec<f64> = Vec::new();\n\n    for number in numbers {\n        if number < numbers[0]\
    \ {\n            smallest.push(number);\n        } else {\n            largest.push(number);\n\
    \        }\n    }\n\n    (smallest[0], largest[0])\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp69kt5pmy.rs:12:21\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n11  |     for number in numbers\
    \ {\n    |                   ------- `numbers` moved due to this implicit call\
    \ to `.into_iter()`\n12  |         if number < numbers[0] {\n    |           \
    \          ^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n11  |     for number in &numbers {\n    |               \
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_difference = numbers[0];\n    let mut\
    \ smallest_number = numbers[0];\n    let mut largest_difference = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for i in 1..numbers.len() {\n \
    \       let difference = numbers[i] - numbers[i - 1];\n        if difference <\
    \ smallest_difference {\n            smallest_difference = difference;\n     \
    \       smallest_number = numbers[i];\n        }\n        if difference > largest_difference\
    \ {\n            largest_difference = difference;\n            largest_number\
    \ = numbers[i];\n        }\n    }\n    (smallest_number, largest_number)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(2.2, 3.9)`,\n right: `(3.9, 4.0)`', /tmp/tmpkd8oponh.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let min = numbers[0].cloned();\n    let max = numbers[0].cloned();\n\
    \    for &x in numbers {\n        let delta = x - min;\n        if delta < 0 {\n\
    \            min = x;\n        } else {\n            max = x;\n        }\n   \
    \ }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n --> /tmp/tmpv4xfev57.rs:8:26\n\
    \  |\n8 |     let min = numbers[0].cloned();\n  |                          ^^^^^^\
    \ `f64` is not an iterator\n  |\n  = note: the following trait bounds were not\
    \ satisfied:\n          `f64: Iterator`\n          which is required by `&mut\
    \ f64: Iterator`\n\nerror[E0599]: `f64` is not an iterator\n --> /tmp/tmpv4xfev57.rs:9:26\n\
    \  |\n9 |     let max = numbers[0].cloned();\n  |                          ^^^^^^\
    \ `f64` is not an iterator\n  |\n  = note: the following trait bounds were not\
    \ satisfied:\n          `f64: Iterator`\n          which is required by `&mut\
    \ f64: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4xfev57.rs:10:9\n\
    \   |\n10 |     for &x in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpv4xfev57.rs:12:18\n   |\n\
    12 |         if delta < 0 {\n   |                  ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if delta < 0.0 {\n   | \
    \                    ++\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for &n in numbers {\n        if min > n {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfrkcrl73.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (0.0, numbers[0])\n   \
    \ } else {\n        let mut smallest_diff: f64 = numbers[0] as f64;\n        let\
    \ mut second_closest: f64 = numbers[1] as f64;\n        for n in numbers[2..]\
    \ {\n            let new_diff = smallest_diff - n;\n            if new_diff <\
    \ 0 {\n                smallest_diff = -new_diff;\n                second_closest\
    \ = n;\n            } else {\n                smallest_diff = new_diff;\n    \
    \        }\n        }\n        (second_closest, smallest_diff)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpa3ks7hm5.rs:13:18\n   |\n13 |         for n in numbers[2..]\
    \ {\n   |                  ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n13 |         for n in &numbers[2..]\
    \ {\n   |                  +\n13 |         for n in &mut numbers[2..] {\n   |\
    \                  ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpa3ks7hm5.rs:13:18\n\
    \   |\n13 |         for n in numbers[2..] {\n   |                  ^^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[f64]: IntoIterator` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing\
    \ here\n   |\n13 |         for n in &numbers[2..] {\n   |                  +\n\
    13 |         for n in &mut numbers[2..] {\n   |                  ++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut minimum = numbers[0];\n    let mut maximum = numbers[0];\n\
    \n    for n in numbers {\n        if n < minimum {\n            minimum = n;\n\
    \        }\n        if n > maximum {\n            maximum = n;\n        }\n  \
    \  }\n\n    (minimum, maximum)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpjj5z6v5z.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_element = numbers[0];\n    let mut furthest_element\
    \ = numbers[0];\n\n    for &x in numbers {\n        if f64::abs(x - closest_element)\
    \ < f64::abs(x - furthest_element) {\n            closest_element = x\n      \
    \  } else {\n            furthest_element = x\n        }\n    }\n\n    (closest_element,\
    \ furthest_element)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasin_j29.rs:11:9\n   |\n\
    11 |     for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0, numbers[0]);\n\
    \    }\n    let mut min_dist = ::std::f64::MAX;\n    let mut best_value = numbers[0];\n\
    \    let mut best_idx = 1;\n    for i in 2..=numbers.len() {\n        let dist\
    \ = ::std::f64::MAX;\n        for (j, value) in numbers.iter().enumerate() {\n\
    \            if i == j {\n                continue;\n            }\n         \
    \   let dist = dist::abs(value - numbers[j]);\n            if dist < min_dist\
    \ {\n                min_dist = dist;\n                best_value = value;\n \
    \               best_idx = j;\n            }\n        }\n        (best_value,\
    \ best_idx)\n    }\n    (best_value, best_idx)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `dist`\n\
    \  --> /tmp/tmpimj9qy92.rs:20:24\n   |\n20 |             let dist = dist::abs(value\
    \ - numbers[j]);\n   |                        ^^^^ use of undeclared crate or\
    \ module `dist`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpimj9qy92.rs:9:17\n\
    \  |\n9 |         return (0, numbers[0]);\n  |                 ^\n  |        \
    \         |\n  |                 expected `f64`, found integer\n  |          \
    \       help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpimj9qy92.rs:23:30\n   |\n12 |     let mut best_value = numbers[0];\n\
    \   |                          ---------- expected due to this value\n...\n23\
    \ |                 best_value = value;\n   |                              ^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |                 best_value = *value;\n   |                       \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpimj9qy92.rs:27:9\n\
    \   |\n27 |         (best_value, best_idx)\n   |         ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found tuple\n   |\n   = note: expected unit type `()`\n     \
    \             found tuple `(f64, usize)`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpimj9qy92.rs:29:18\n   |\n29 |     (best_value, best_idx)\n   | \
    \                 ^^^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can\
    \ cast a `usize` to an `f64`, producing the floating point representation of the\
    \ integer, rounded if necessary\n   |\n29 |     (best_value, best_idx as f64)\n\
    \   |                           ++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut current = numbers[0];\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n    for n in numbers.iter().skip(1) {\n  \
    \      current = n;\n        if current < smallest {\n            smallest = current;\n\
    \        }\n        if current > largest {\n            largest = current;\n \
    \       }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0urydsh.rs:12:19\n   |\n\
    8  |     let mut current = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n12 |         current = n;\n   |           \
    \        ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n12 |         current = *n;\n   |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\
    \n    for &num in numbers {\n        if num < min {\n            min = num;\n\
    \        }\n        if num > max {\n            max = num;\n        }\n    }\n\
    \n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmnem16s.rs:11:9\n   |\n\
    11 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut lowest = numbers[0].0 * numbers[0];\n    let mut\
    \ highest = numbers[0].0 * numbers[0];\n    for number in numbers.iter() {\n \
    \       if number > highest {\n            highest = number;\n        }\n    \
    \    if number < lowest {\n            lowest = number;\n        }\n    }\n  \
    \  (lowest, highest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0610]: `f64` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmpv60pq17w.rs:8:33\n  |\n8 |     let mut lowest = numbers[0].0 * numbers[0];\n\
    \  |                                 ^\n\nerror[E0610]: `f64` is a primitive type\
    \ and therefore doesn't have fields\n --> /tmp/tmpv60pq17w.rs:9:34\n  |\n9 | \
    \    let mut highest = numbers[0].0 * numbers[0];\n  |                       \
    \           ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv60pq17w.rs:18:6\n\
    \   |\n18 |     (lowest, highest)\n   |      ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |     (*lowest, highest)\n\
    \   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv60pq17w.rs:18:14\n\
    \   |\n18 |     (lowest, highest)\n   |              ^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |     (lowest,\
    \ *highest)\n   |              +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut best = Vec::new();\n    best = numbers.iter().fold(best.clone(),\
    \ |mut b, x| {\n        if b < x {\n            b = x;\n        }\n        b\n\
    \    });\n    best = numbers.iter().fold(best.clone(), |mut b, x| {\n        if\
    \ b > x {\n            b = x;\n        }\n        b\n    });\n    (best.0, best.1)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd4zqmbtl.rs:10:16\n   |\n\
    10 |         if b < x {\n   |                ^ expected struct `Vec`, found `&f64`\n\
    \   |\n   = note: expected struct `Vec<_>`\n           found reference `&f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd4zqmbtl.rs:11:17\n   |\n9  |\
    \     best = numbers.iter().fold(best.clone(), |mut b, x| {\n   |            \
    \                                       - expected due to this parameter type\n\
    10 |         if b < x {\n11 |             b = x;\n   |                 ^ expected\
    \ struct `Vec`, found `&f64`\n   |\n   = note: expected struct `Vec<_>`\n    \
    \       found reference `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4zqmbtl.rs:16:16\n\
    \   |\n16 |         if b > x {\n   |                ^ expected struct `Vec`, found\
    \ `&f64`\n   |\n   = note: expected struct `Vec<_>`\n           found reference\
    \ `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4zqmbtl.rs:17:17\n\
    \   |\n15 |     best = numbers.iter().fold(best.clone(), |mut b, x| {\n   |  \
    \                                                 - expected due to this parameter\
    \ type\n16 |         if b > x {\n17 |             b = x;\n   |               \
    \  ^ expected struct `Vec`, found `&f64`\n   |\n   = note: expected struct `Vec<_>`\n\
    \           found reference `&f64`\n\nerror[E0609]: no field `0` on type `Vec<_>`\n\
    \  --> /tmp/tmpd4zqmbtl.rs:21:11\n   |\n21 |     (best.0, best.1)\n   |      \
    \     ^ unknown field\n\nerror[E0609]: no field `1` on type `Vec<_>`\n  --> /tmp/tmpd4zqmbtl.rs:21:19\n\
    \   |\n21 |     (best.0, best.1)\n   |                   ^ unknown field\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = numbers[0];\n    let mut min_element\
    \ = numbers[0];\n    let mut min_distance = numbers[0]\n        .sqrt()\n    \
    \    .floor()\n        .unwrap();\n    let mut max_element = numbers[0];\n   \
    \ let mut max_distance = numbers[0]\n        .sqrt()\n        .floor()\n     \
    \   .unwrap();\n\n    for n in numbers {\n        if n != min_element {\n    \
    \        let distance = n.sqrt() - min_distance;\n            if distance < min_distance\
    \ {\n                min_distance = distance;\n                min_element = n;\n\
    \            }\n        }\n    }\n    for n in numbers {\n        if n != max_element\
    \ {\n            let distance = n.sqrt() - max_distance;\n            if distance\
    \ > max_distance {\n                max_distance = distance;\n               \
    \ max_element = n;\n            }\n        }\n    }\n    (min_element, max_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3_10au54.rs:13:10\n   |\n13 |         .unwrap();\n   |\
    \          ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp3_10au54.rs:18:10\n\
    \   |\n18 |         .unwrap();\n   |          ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut diff\
    \ = max - min;\n    if diff < .01 * min {\n        (min, max)\n    } else {\n\
    \        let mut midx = (min + max) / 2;\n        let midy = (min + max) / 2;\n\
    \        for n in numbers {\n            if n < midx {\n                midx =\
    \ n;\n            }\n            if n > midy {\n                midy = n;\n  \
    \          }\n        }\n        (midx, midy)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: float literals must have an integer part\n  --> /tmp/tmpzzbtbu38.rs:19:15\n\
    \   |\n19 |     if diff < .01 * min {\n   |               ^^^ help: must have\
    \ an integer part: `0.01`\n\nerror[E0277]: cannot divide `f64` by `{integer}`\n\
    \  --> /tmp/tmpzzbtbu38.rs:22:36\n   |\n22 |         let mut midx = (min + max)\
    \ / 2;\n   |                                    ^ no implementation for `f64 /\
    \ {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not implemented for\
    \ `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n  \
    \           <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n      \
    \       <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n        \
    \     <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n            \
    \ <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n22 |         let mut midx = (min + max) / 2.0;\n   |           \
    \                            ++\n\nerror[E0277]: cannot divide `f64` by `{integer}`\n\
    \  --> /tmp/tmpzzbtbu38.rs:23:32\n   |\n23 |         let midy = (min + max) /\
    \ 2;\n   |                                ^ no implementation for `f64 / {integer}`\n\
    \   |\n   = help: the trait `Div<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Div<Rhs>`:\n            \
    \ <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n23 |         let\
    \ midy = (min + max) / 2.0;\n   |                                   ++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort();\n    let mut smallest_number = numbers[0];\n\
    \    let mut greatest_number = numbers[0];\n\n    for i in 1 .. numbers.len()\
    \ {\n        if numbers[i] < smallest_number {\n            smallest_number =\
    \ numbers[i];\n        }\n        if numbers[i] > greatest_number {\n        \
    \    greatest_number = numbers[i];\n        }\n    }\n\n    (smallest_number,\
    \ greatest_number)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmph8ngap0g.rs:8:13\n\
    \    |\n8   |     numbers.sort();\n    |             ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    match numbers[..] {\n        vec![number, number] => {\n\
    \            if number - numbers[2] < number - numbers[3] {\n                (numbers[2],\
    \ numbers[3])\n            } else {\n                (numbers[3], numbers[2])\n\
    \            }\n        }\n        vec![number, number, number] => {\n       \
    \     if number - numbers[1] < number - numbers[3] {\n                (numbers[1],\
    \ numbers[3])\n            } else {\n                (numbers[3], numbers[1])\n\
    \            }\n        }\n        vec![number, number, number, number] => {\n\
    \            if number - numbers[2] < number - numbers[1] {\n                (numbers[2],\
    \ numbers[1])\n            } else {\n                (numbers[1], numbers[2])\n\
    \            }\n        }\n        vec![number, number, number, number, number]\
    \ => {\n            if number - numbers[3] < number - numbers[2] {\n         \
    \       (numbers[3], numbers[2])\n            } else {\n                (numbers[2],\
    \ numbers[3])\n            }\n        }\n        vec![number, number, number,\
    \ number, number, number] => {\n            if number - numbers[4] < number -\
    \ numbers[3] {\n                (numbers[4], numbers[3])\n            } else {\n\
    \                (numbers[3], numbers[4])\n            }\n        }\n        vec![number,\
    \ number, number, number, number, number, number] => {\n            if number\
    \ - numbers[5] < number - numbers[4] {\n                (numbers[5], numbers[4])\n\
    \            } else {\n                (numbers[4], numbers[5])\n            }\n\
    \        }\n        vec![number, number, number, number, number, number, number,\
    \ number] => {\n            if number - numbers[6] < number - numbers[5] {\n \
    \               (numbers[6], numbers[5])\n            } else {\n             \
    \   (numbers[5], numbers[6])\n            }\n        }\n        vec![number, number,\
    \ number, number, number, number, number, number, number] => {\n            if\
    \ number - numbers[7] < number - numbers[6] {\n                (numbers[7], numbers[6])\n\
    \            } else {\n                (numbers[6], numbers[7])\n            }\n\
    \        }\n        _ => {\n            (numbers[3], numbers[3])\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `number` in this scope\n --> /tmp/tmpdlpielue.rs:9:14\n\
    \  |\n9 |         vec![number, number] => {\n  |              ^^^^^^ help: a local\
    \ variable with a similar name exists: `numbers`\n\nerror[E0425]: cannot find\
    \ value `number` in this scope\n --> /tmp/tmpdlpielue.rs:9:22\n  |\n9 |      \
    \   vec![number, number] => {\n  |                      ^^^^^^ help: a local variable\
    \ with a similar name exists: `numbers`\n\nerror[E0425]: cannot find value `number`\
    \ in this scope\n  --> /tmp/tmpdlpielue.rs:10:16\n   |\n10 |             if number\
    \ - numbers[2] < number - numbers[3] {\n   |                ^^^^^^ help: a local\
    \ variable with a similar name exists: `numbers`\n\nerror[E0425]: cannot find\
    \ value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:10:38\n   |\n10 |  \
    \           if number - numbers[2] < number - numbers[3] {\n   |             \
    \                         ^^^^^^ help: a local variable with a similar name exists:\
    \ `numbers`\n\nerror[E0425]: cannot find value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:16:14\n\
    \   |\n16 |         vec![number, number, number] => {\n   |              ^^^^^^\
    \ help: a local variable with a similar name exists: `numbers`\n\nerror[E0425]:\
    \ cannot find value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:16:22\n\
    \   |\n16 |         vec![number, number, number] => {\n   |                  \
    \    ^^^^^^ help: a local variable with a similar name exists: `numbers`\n\nerror[E0425]:\
    \ cannot find value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:16:30\n\
    \   |\n16 |         vec![number, number, number] => {\n   |                  \
    \            ^^^^^^ help: a local variable with a similar name exists: `numbers`\n\
    \nerror[E0425]: cannot find value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:17:16\n\
    \   |\n17 |             if number - numbers[1] < number - numbers[3] {\n   | \
    \               ^^^^^^ help: a local variable with a similar name exists: `numbers`\n\
    \nerror[E0425]: cannot find value `number` in this scope\n  --> /tmp/tmpdlpielue.rs:17:38\n\
    \   |\n17 |             if number - numbers[1] < number - numbers[3] {"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let numbers = numbers[..2];\n    let mut min_dist = std::f64::MAX;\n\
    \    let mut min_element;\n    for i in 0..numbers.len() {\n        let current_dist\
    \ = f64::abs(numbers[i] - numbers[i - 1]);\n        if current_dist < min_dist\
    \ {\n            min_dist = current_dist;\n            min_element = i;\n    \
    \    }\n    }\n    (numbers[min_element as usize], numbers[min_element + 1] as\
    \ f64)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n --> /tmp/tmped7qfyde.rs:8:9\n  |\n8 |     let numbers = numbers[..2];\n\
    \  |         ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help:\
    \ the trait `Sized` is not implemented for `[f64]`\n  = note: all local variables\
    \ must have a statically known size\n  = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n  |\n8 |     let numbers =\
    \ &numbers[..2];\n  |                   +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut small = numbers[0];\n    let mut large = numbers[0];\n\
    \    for (i, num) in numbers.iter().enumerate() {\n        if num < small {\n\
    \            small = num;\n        }\n        if num > large {\n            large\
    \ = num;\n        }\n    }\n\n    small, large\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpvh0kdoio.rs:19:10\n   |\n19 |     small, large\n  \
    \ |          ^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvh0kdoio.rs:11:18\n   |\n11 |         if num < small {\n   |  \
    \                ^^^^^\n   |                  |\n   |                  expected\
    \ `&f64`, found `f64`\n   |                  help: consider borrowing here: `&small`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvh0kdoio.rs:12:21\n   |\n8  |\
    \     let mut small = numbers[0];\n   |                     ---------- expected\
    \ due to this value\n...\n12 |             small = num;\n   |                \
    \     ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n12 |             small = *num;\n   |                     +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvh0kdoio.rs:14:18\n   |\n14 |  \
    \       if num > large {\n   |                  ^^^^^\n   |                  |\n\
    \   |                  expected `&f64`, found `f64`\n   |                  help:\
    \ consider borrowing here: `&large`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvh0kdoio.rs:15:21\n\
    \   |\n9  |     let mut large = numbers[0];\n   |                     ----------\
    \ expected due to this value\n...\n15 |             large = num;\n   |       \
    \              ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             large = *num;\n   |                     +\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort_unstable_by_key(|n| n.abs());\n    let mut\
    \ lower = numbers[..2].iter().min().unwrap();\n    let mut upper = numbers[2..4].iter().max().unwrap();\n\
    \    lower.min(upper)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4k18jr7x.rs:8:34\n\
    \     |\n8    |     numbers.sort_unstable_by_key(|n| n.abs());\n     |       \
    \      -------------------- ^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |             |\n     |             required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `Ord`:\n               i128\n               i16\n               i32\n      \
    \         i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::sort_unstable_by_key`\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp4k18jr7x.rs:9:41\n     |\n9    |     let mut lower\
    \ = numbers[..2].iter().min().unwrap();\n     |                              \
    \           ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4k18jr7x.rs:10:42\n\
    \     |\n10   |     let mut upper = numbers[2..4].iter().max().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4k18jr7x.rs:11:15\n   |\n11 |\
    \     lower.min(upper"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n\n    let mut min_diff = numbers[0] - numbers[1];\n    let mut min_diff\
    \ = numbers[0] - numbers[1];\n    let mut min_diff = numbers[0] - numbers[1];\n\
    \n    let mut min_pos = 0;\n    let mut min_pos = 0;\n\n    let mut min_pos =\
    \ 1;\n    let mut min_pos = 1;\n\n    for i in 2..numbers.len() {\n        let\
    \ diff = numbers[i] - numbers[i - 1];\n\n        if diff < min_diff {\n      \
    \      min_diff = diff;\n            min_pos = i - 1;\n        }\n\n        if\
    \ diff < min_diff {\n            min_diff = diff;\n            min_pos = i - 1;\n\
    \        }\n    }\n\n    (numbers[min_pos], numbers[min_pos])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpxigm_tdk.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort();\n    let mut min = numbers[0];\n    let\
    \ mut max = numbers[0];\n    for n in numbers.iter() {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmp51afrlss.rs:8:13\n\
    \    |\n8   |     numbers.sort();\n    |             ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51afrlss.rs:12:16\n\
    \   |\n12 |         if n < min {\n   |                ^^^\n   |              \
    \  |\n   |                expected `&f64`, found `f64`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51afrlss.rs:13:19\n\
    \   |\n9  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n13 |             min = n;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *n;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp51afrlss.rs:15:16\n   |\n15 |         if n > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp51afrlss.rs:16:19\n   |\n10 |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n16 |             max = n;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   max = *n;\n   |                   +\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut biggest = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i];\n        }\n        if numbers[i] > biggest {\n \
    \           biggest = numbers[i];\n        }\n    }\n    (smallest, biggest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpptvejt8p.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest: Option<f64> = None;\n    let mut largest:\
    \ Option<f64> = None;\n    for n in numbers {\n        let diff = n - numbers.iter().skip(1).fold(f64::max,\
    \ |max, &x| max);\n        if smallest == None || (diff < smallest.unwrap()) {\n\
    \            smallest = Some(diff);\n        }\n        if largest == None ||\
    \ (diff > largest.unwrap()) {\n            largest = Some(diff);\n        }\n\
    \    }\n    (smallest.unwrap(), largest.unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `fn(f64, f64) -> f64 {core::f64::<impl f64>::max}`\
    \ from `f64`\n  --> /tmp/tmpifn9v1_o.rs:11:22\n   |\n11 |         let diff = n\
    \ - numbers.iter().skip(1).fold(f64::max, |max, &x| max);\n   |              \
    \        ^ no implementation for `f64 - fn(f64, f64) -> f64 {core::f64::<impl\
    \ f64>::max}`\n   |\n   = help: the trait `Sub<fn(f64, f64) -> f64 {core::f64::<impl\
    \ f64>::max}>` is not implemented for `f64`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0].clone(); // the number with minimal\
    \ absolute value\n    let mut max = numbers[0].clone(); // the number with maximal\
    \ absolute value\n    for (idx, number) in\n        numbers.iter().enumerate()\
    \ { // iterate over numbers\n            if *number < min { min = *number; }\n\
    \            if *number > max { max = *number; }\n        }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpro4hnamt.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = (numbers[0] as f64).min(numbers[1] as\
    \ f64);\n    let mut largest = (numbers[0] as f64).max(numbers[1] as f64);\n\n\
    \    for n in numbers[2..].iter() {\n        let diff = (n - smallest).abs();\n\
    \        if diff < smallest {\n            smallest = n;\n        }\n        if\
    \ diff > largest {\n            largest = n;\n        }\n    }\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpghfqnglz.rs:14:24\n   |\n\
    8  |     let mut smallest = (numbers[0] as f64).min(numbers[1] as f64);\n   |\
    \                        ------------------------------------------ expected due\
    \ to this value\n...\n14 |             smallest = n;\n   |                   \
    \     ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |             smallest = *n;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpghfqnglz.rs:17:23\n   |\n9  |     let mut largest\
    \ = (numbers[0] as f64).max(numbers[1] as f64);\n   |                       ------------------------------------------\
    \ expected due to this value\n...\n17 |             largest = n;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             largest = *n;\n   |                     \
    \  +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff: f64 = numbers[0];\n    let mut min_number:\
    \ f64 = numbers[0];\n\n    for (i, &number) in numbers.iter().enumerate() {\n\
    \        let diff = number.abs() - min_diff.abs();\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_number = number;\n        }\n\
    \    }\n    min_number, min_diff\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpwcv72oue.rs:18:15\n   |\n18 |     min_number, min_diff\n\
    \   |               ^ expected one of 8 possible tokens\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    let mut min_idx = numbers[0];\n    let mut max_idx = numbers[0];\n\n    for\
    \ n in numbers.iter() {\n        if n < min_val {\n            min_val = n;\n\
    \            min_idx = n;\n        } else if n > max_val {\n            max_val\
    \ = n;\n            max_idx = n;\n        }\n    }\n\n    (min_val, max_idx)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi5345m79.rs:14:16\n   |\n\
    14 |         if n < min_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&f64`, found `f64`\n   |                help:\
    \ consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi5345m79.rs:15:23\n   |\n8  |     let mut min_val = numbers[0];\n  \
    \ |                       ---------- expected due to this value\n...\n15 |   \
    \          min_val = n;\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             min_val\
    \ = *n;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi5345m79.rs:16:23\n   |\n10 |     let mut min_idx = numbers[0];\n  \
    \ |                       ---------- expected due to this value\n...\n16 |   \
    \          min_idx = n;\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             min_idx\
    \ = *n;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi5345m79.rs:17:23\n   |\n17 |         } else if n > max_val {\n   |\
    \                       ^^^^^^^\n   |                       |\n   |          \
    \             expected `&f64`, found `f64`\n   |                       help: consider\
    \ borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi5345m79.rs:18:23\n\
    \   |\n9  |     let mut max_val = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n18 |             max_val = n;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |             max_val = *n;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi5345m79.rs:19:23\n   |\n\
    11 |     let mut max_idx = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n19 |             max_idx = n;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n19 |             max_idx = *n;\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\
    \    for &i in numbers {\n        let delta = i - min;\n        if delta < 0 {\n\
    \            max = i;\n        } else {\n            min = i;\n        }\n   \
    \ }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbvgyek_c.rs:10:9\n   |\n\
    10 |     for &i in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbvgyek_c.rs:19:6\n   |\n19 |     (min, max)\n\
    \   |      ^^^ expected `f64`, found `i32`\n   |\nhelp: you can convert an `i32`\
    \ to an `f64`, producing the floating point representation of the integer\n  \
    \ |\n19 |     (min.into(), max)\n   |         +++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbvgyek_c.rs:19:11\n   |\n19 |     (min, max)\n   |    \
    \       ^^^ expected `f64`, found `i32`\n   |\nhelp: you can convert an `i32`\
    \ to an `f64`, producing the floating point representation of the integer\n  \
    \ |\n19 |     (min, max.into())\n   |              +++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut max_number = 0.0f64;\n    let mut min_number =\
    \ 0.0f64;\n    let mut min_distance = std::f64::MAX;\n    for (index, number)\
    \ in numbers.iter().enumerate() {\n        let distance = std::f64::MAX;\n   \
    \     for element in &numbers[index..] {\n            let distance = match element\
    \ - number {\n                n if n < min_number => std::f64::MAX,\n        \
    \        n if n > max_number => std::f64::MAX,\n                n => std::f64::MAX,\n\
    \            };\n            if distance < distance {\n                min_number\
    \ = number;\n                min_distance = distance;\n            }\n       \
    \ }\n        max_number = number;\n    }\n    (min_number, max_number)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9fqrk3qc.rs:20:30\n   |\n\
    9  |     let mut min_number = 0.0f64;\n   |                          ------ expected\
    \ due to this value\n...\n20 |                 min_number = number;\n   |    \
    \                          ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |                 min_number = *number;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9fqrk3qc.rs:24:22\n   |\n8  |     let mut max_number = 0.0f64;\n   |\
    \                          ------ expected due to this value\n...\n24 |      \
    \   max_number = number;\n   |                      ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |         max_number\
    \ = *number;\n   |                      +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Convert to a map and sort by the distance to the second\
    \ element\n    let mut sorted_map = numbers;\n    sorted_map.sort_by_key(|x| x.abs());\n\
    \n    // Return the second\n    (sorted_map[1], sorted_map.last())\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpuurza9ic.rs:10:28\n\
    \    |\n10  |     sorted_map.sort_by_key(|x| x.abs());\n    |                -----------\
    \ ^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n    |            \
    \    |\n    |                required by a bound introduced by this call\n   \
    \ |\n    = help: the following other types implement trait `Ord`:\n          \
    \    i128\n              i16\n              i32\n              i64\n         \
    \     i8\n              isize\n              u128\n              u16\n       \
    \     and 4 others\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuurza9ic.rs:13:21\n   |\n13 |\
    \     (sorted_map[1], sorted_map.last())\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n\
    \              found enum `Option<&f64>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min: f64 = numbers[0] as f64;\n    let mut max:\
    \ f64 = numbers[0] as f64;\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        let delta = number.abs() as f64;\n        if delta < min {\n    \
    \        min = delta;\n        }\n        if delta > max {\n            max =\
    \ delta;\n        }\n    }\n\n    let mut i = 0;\n    let mut j = numbers.len();\n\
    \    while i <= j {\n        let mut delta = numbers[i - 1].abs() as f64;\n  \
    \      if delta < numbers[i].abs() {\n            delta = numbers[i].abs() as\
    \ f64;\n        }\n        if delta < min {\n            min = delta;\n      \
    \  }\n        if delta > max {\n            max = delta;\n        }\n        let\
    \ mut swap = numbers[i - 1];\n        numbers[i - 1] = numbers[i];\n        numbers[i]\
    \ = swap;\n        i += 1;\n        j -= 1;\n    }\n    (min, max)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpkczc5aw1.rs:10:10\n   |\n\
    10 |     for (i, number) in numbers.iter().enumerate() {\n   |          ^ help:\
    \ if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmpkczc5aw1.rs:33:13\n   |\n33 |         let mut swap\
    \ = numbers[i - 1];\n   |             ----^^^^\n   |             |\n   |     \
    \        help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by\
    \ default\n\nerror[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpkczc5aw1.rs:34:9\n   |\n7  | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                          ------- help: consider\
    \ changing this to be mutable: `mut numbers`\n...\n34 |         numbers[i - 1]\
    \ = numbers[i];\n   |         ^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `numbers` as mutable, as it is not declared as mutable\n  -->\
    \ /tmp/tmpkczc5aw1.rs:35:9\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n   |                          ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n35 |         numbers[i] = swap;\n  \
    \ |         ^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous\
    \ errors; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_val = f64::MAX;\n    let mut max_val = f64::MIN;\n\
    \n    for number in numbers {\n        if number < min_val {\n            min_val\
    \ = number;\n        }\n\n        if number > max_val {\n            max_val =\
    \ number;\n        }\n    }\n\n    (min_val, max_val)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpiks8l4hj.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut lowest_element = numbers.iter().min().unwrap();\n\
    \    let mut second_lowest_element = numbers.iter().min().unwrap();\n    let mut\
    \ closest_elements = Vec::new();\n\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        if number == lowest_element {\n            closest_elements.push(number);\n\
    \        }\n        if number == second_lowest_element {\n            closest_elements.push(number);\n\
    \        }\n        if index < numbers.len() - 1 {\n            if number > lowest_element\
    \ {\n                second_lowest_element = number;\n            }\n        \
    \    if number < second_lowest_element {\n                lowest_element = number;\n\
    \            }\n        }\n    }\n    (lowest_element, second_lowest_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpef48nter.rs:8:45\n\
    \     |\n8    |     let mut lowest_element = numbers.iter().min().unwrap();\n\
    \     |                                             ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmpef48nter.rs:9:52\n     |\n9    |     let mut\
    \ second_lowest_element = numbers.iter().min().unwrap();\n     |             \
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpef48nter.rs:28:6\n   |\n28 | \
    \    (lowest_element, second_lowest_element)\n   |      ^^^^^^^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n28\
    \ |     (*lowest_element, second_lowest_element)\n   |      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpef48nter.rs:28:22\n   |\n28 |     (lowest_element,\
    \ second_lowest_element)\n   |                      ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n28\
    \ |     (lowest_element, *second_lowest_element)\n   |                      +\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information abo"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    match numbers.len() {\n        0 => return(f64::INFINITY,\
    \ f64::INFINITY),\n        _ => {\n            let mut lowest = numbers[0];\n\
    \            let mut highest = numbers[0];\n            for n in numbers {\n \
    \               if n < lowest {\n                    lowest = n;\n           \
    \     } else if n > highest {\n                    highest = n;\n            \
    \    }\n            }\n            (lowest, highest)\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpn38a0t4d.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n\n    let mut lowest = numbers[0];\n    let mut highest = numbers[0];\n\
    \    let mut current_index = 0;\n    let mut current_delta = 0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let number = numbers[i];\n        let delta\
    \ = number - lowest;\n        if current_delta == 0 || delta < current_delta {\n\
    \            lowest = number;\n            current_index = i;\n            current_delta\
    \ = delta;\n        }\n        let delta = number - highest;\n        if delta\
    \ > current_delta {\n            highest = number;\n            current_index\
    \ = i;\n            current_delta = delta;\n        }\n    }\n\n    (lowest, highest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp245ijy4r.rs:19:42\n   |\n\
    19 |         if current_delta == 0 || delta < current_delta {\n   |          \
    \                                ^^^^^^^^^^^^^ expected `f64`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp245ijy4r.rs:22:29\n   |\n15 |\
    \     let mut current_delta = 0;\n   |                             - expected\
    \ due to this value\n...\n22 |             current_delta = delta;\n   |      \
    \                       ^^^^^ expected integer, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp245ijy4r.rs:25:20\n   |\n25 |         if delta > current_delta\
    \ {\n   |                    ^^^^^^^^^^^^^ expected `f64`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp245ijy4r.rs:28:29\n   |\n15 |     let mut current_delta\
    \ = 0;\n   |                             - expected due to this value\n...\n28\
    \ |             current_delta = delta;\n   |                             ^^^^^\
    \ expected integer, found `f64`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut min1 = numbers[0];\n        let mut min2 = numbers[1];\n\
    \n        for n in numbers.iter().skip(2) {\n            let mut diff = f64::MAX;\n\
    \            for m in numbers.iter().skip(2) {\n                diff = f64::min(diff,\
    \ f64::abs(n - m));\n            }\n            min1 = min(min1, diff);\n    \
    \        min2 = min(min2, diff);\n        }\n        (min1, min2)\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpmsp5twkx.rs:19:20\n\
    \   |\n19 |             min1 = min(min1, diff);\n   |                    ^^^\n\
    ...\n26 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n19 |        \
    \     min1 = main(min1, diff);\n   |                    ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find\
    \ function `min` in this scope\n  --> /tmp/tmpmsp5twkx.rs:20:20\n   |\n20 |  \
    \           min2 = min(min2, diff);\n   |                    ^^^\n...\n26 | fn\
    \ main() {\n   | --------- similarly named function `main` defined here\n   |\n\
    help: a function with a similar name exists\n   |\n20 |             min2 = main(min2,\
    \ diff);\n   |                    ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_dist = std::f64::MAX;\n    let mut closest_to_smallest\
    \ = std::f64::MAX;\n    for &n in numbers {\n        let dist = n - closest_to_smallest;\n\
    \        if dist < smallest_dist {\n            smallest_dist = dist;\n      \
    \      closest_to_smallest = n;\n        }\n    }\n    (closest_to_smallest, smallest_dist)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpogrexi0o.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n\n    // Convert to a sorted\
    \ vector so we don't have to check all the numbers every time.\n    let mut sorted_numbers\
    \ = numbers.iter().cloned().collect::<Vec<_>>().sort();\n\n    let min_diff =\
    \ sorted_numbers[0] - sorted_numbers[1];\n    let mut smallest = sorted_numbers[1];\n\
    \    let mut largest = sorted_numbers[0];\n\n    for number in sorted_numbers.iter().skip(1).rev()\
    \ {\n        if number - largest < smallest - number {\n            smallest =\
    \ number;\n        }\n\n        if largest - number < smallest - number {\n  \
    \          largest = number;\n        }\n    }\n\n    (smallest, largest)\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpj2d0xzlb.rs:11:74\n\
    \    |\n11  |     let mut sorted_numbers = numbers.iter().cloned().collect::<Vec<_>>().sort();\n\
    \    |                                                                       \
    \   ^^^^ the trait `Ord` is not implemented for `f64`\n    |\n    = help: the\
    \ following other types implement trait `Ord`:\n              i128\n         \
    \     i16\n              i32\n              i64\n              i8\n          \
    \    isize\n              u128\n              u16\n            and 4 others\n\
    note: required by a bound in `slice::<impl [T]>::sort`\n\nerror[E0608]: cannot\
    \ index into a value of type `()`\n  --> /tmp/tmpj2d0xzlb.rs:13:20\n   |\n13 |\
    \     let min_diff = sorted_numbers[0] - sorted_numbers[1];\n   |            \
    \        ^^^^^^^^^^^^^^^^^ help: to access tuple elements, use: `sorted_numbers.0`\n\
    \nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpj2d0xzlb.rs:13:40\n\
    \   |\n13 |     let min_diff = sorted_numbers[0] - sorted_numbers[1];\n   |  \
    \                                      ^^^^^^^^^^^^^^^^^ help: to access tuple\
    \ elements, use: `sorted_numbers.1`\n\nerror[E0608]: cannot index into a value\
    \ of type `()`\n  --> /tmp/tmpj2d0xzlb.rs:14:24\n   |\n14 |     let mut smallest\
    \ = sorted_numbers[1];\n   |                        ^^^^^^^^^^^^^^^^^ help: to\
    \ access tuple elements, use: `sorted_numbers.1`\n\nerror[E0608]: cannot index\
    \ into a value of type `()`\n  --> /tmp/tmpj2d0xzlb.rs:15:23\n   |\n15 |     let\
    \ mut largest = sorted_numbers[0];\n   |                       ^^^^^^^^^^^^^^^^^\
    \ help: to access tuple elements, use: `sorted_numbers.0`\n\nerror[E0599]: no\
    \ method named `iter` found for unit type `()` in the current scope\n  --> /tmp/tmpj2d0xzlb.rs:17:34\n\
    \   |\n17 |     for number in sorted_numbers.iter().skip(1).rev() {\n   |    \
    \                              ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n\n    let mut smallest_diff:\
    \ f64 = numbers[0].abs();\n    let mut largest_diff: f64 = numbers[0].abs();\n\
    \n    let mut smallest: f64 = numbers[0];\n    let mut largest: f64 = numbers[0];\n\
    \n    for x in numbers {\n        smallest_diff = if x < smallest {\n        \
    \    smallest\n        } else {\n            smallest_diff\n        };\n\n   \
    \     largest_diff = if x > largest {\n            largest_diff\n        } else\
    \ {\n            largest_diff\n        };\n\n        smallest = if x < smallest\
    \ {\n            x\n        } else {\n            smallest\n        };\n\n   \
    \     largest = if x > largest {\n            x\n        } else {\n          \
    \  largest\n        };\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmplhumpe9g.rs:47:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers[2..].iter().zip(numbers[0..].iter()).enumerate().min(|a,\
    \ b| {\n        (a.1 - b.1).abs()\n    })\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpczw27f09.rs:8:62\n\
    \     |\n8    |     numbers[2..].iter().zip(numbers[0..].iter()).enumerate().min(|a,\
    \ b| {\n     |                                                              ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n     =\
    \ note: 2 redundant requirements hidden\n     = note: required because of the\
    \ requirements on the impl of `Ord` for `(usize, (&f64, &f64))`\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmpczw27f09.rs:8:62\n\
    \     |\n8    |       numbers[2..].iter().zip(numbers[0..].iter()).enumerate().min(|a,\
    \ b| {\n     |  ______________________________________________________________^^^_-\n\
    \     | |                                                              |\n   \
    \  | |                                                              expected 0\
    \ arguments\n9    | |         (a.1 - b.1).abs()\n10   | |     })\n     | |_____-\
    \ supplied 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpczw27f09.rs:8:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n8  | /     numbers[2..].iter().zip(numbers[0..].iter()).enumerate().min(|a,\
    \ b| {\n9  | |         (a.1 - b.1).abs()\n10 | |     })\n   | |______^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(f64, f64)`\n \
    \              found enum `Option<(usize, (&f64, &f64))>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0308.\nFor more information ab"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[0])\n\
    \    } else {\n        let mut min_distance = numbers[0];\n        let mut min_value\
    \ = numbers[0];\n        let mut max_value = numbers[0];\n\n        for n in numbers\
    \ {\n            let distance = std::f64::abs(n - min_value);\n            if\
    \ distance < min_distance {\n                min_distance = distance;\n      \
    \          min_value = n;\n            } else {\n                max_value = n;\n\
    \            }\n        }\n\n        (min_value, max_value)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpfmkzlqxi.rs:16:38\n\
    \   |\n16 |             let distance = std::f64::abs(n - min_value);\n   |   \
    \                                   ^^^ not found in `std::f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0]\n    let mut max = numbers[0]\n\
    \    for n in numbers {\n        if n < min {\n            min = n\n        }\n\
    \        if n > max {\n            max = n\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpeg9utub_.rs:8:29\n\
    \  |\n8 |     let mut min = numbers[0]\n  |                             ^ help:\
    \ add `;` here\n9 |     let mut max = numbers[0]\n  |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpeg9utub_.rs:9:29\n \
    \  |\n9  |     let mut max = numbers[0]\n   |                             ^ help:\
    \ add `;` here\n10 |     for n in numbers {\n   |     --- unexpected token\n\n\
    error: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = 1.0;\n    let mut min_element =\
    \ numbers[0];\n    let mut max_element = numbers[0];\n    for i in numbers.iter()\
    \ {\n        let distance = std::f64::abs(i - min_element);\n        if distance\
    \ < min_distance {\n            min_distance = distance;\n            min_element\
    \ = i;\n        }\n        if i > max_element {\n            max_element = i;\n\
    \        }\n    }\n    (min_element, max_element)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpf8tq8d_h.rs:12:34\n\
    \   |\n12 |         let distance = std::f64::abs(i - min_element);\n   |     \
    \                             ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf8tq8d_h.rs:15:27\n   |\n9  |     let mut min_element =\
    \ numbers[0];\n   |                           ---------- expected due to this\
    \ value\n...\n15 |             min_element = i;\n   |                        \
    \   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n15 |             min_element = *i;\n   |                           +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf8tq8d_h.rs:17:16\n   |\n17 |  \
    \       if i > max_element {\n   |                ^^^^^^^^^^^\n   |          \
    \      |\n   |                expected `&f64`, found `f64`\n   |             \
    \   help: consider borrowing here: `&max_element`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf8tq8d_h.rs:18:27\n   |\n10 |     let mut max_element =\
    \ numbers[0];\n   |                           ---------- expected due to this\
    \ value\n...\n18 |             max_element = i;\n   |                        \
    \   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |             max_element = *i;\n   |                           +\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.size() > 2);\n    let mut min_diff = f64::MAX;\n\
    \    let mut min_diff = numbers[0] - numbers[1];\n    let mut min_element1 = numbers[0];\n\
    \    let mut min_element2 = numbers[0];\n    let mut min_elements = Vec::new();\n\
    \    for num in numbers.iter().skip(1) {\n        let diff = num - min_element1;\n\
    \        if diff < min_diff {\n            min_diff = diff;\n            min_element1\
    \ = num;\n        }\n        let diff = num - min_element2;\n        if diff <\
    \ min_diff {\n            min_diff = diff;\n            min_element2 = num;\n\
    \        }\n    }\n    min_elements.push(min_element1);\n    min_elements.push(min_element2);\n\
    \    min_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmpulfgu277.rs:8:21\n  |\n8 |     assert!(numbers.size()\
    \ > 2);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpulfgu277.rs:18:28\n\
    \   |\n11 |     let mut min_element1 = numbers[0];\n   |                     \
    \       ---------- expected due to this value\n...\n18 |             min_element1\
    \ = num;\n   |                            ^^^ expected `f64`, found `&f64`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n18 |             min_element1\
    \ = *num;\n   |                            +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpulfgu277.rs:23:28\n   |\n12 |     let mut min_element2 = numbers[0];\n\
    \   |                            ---------- expected due to this value\n...\n\
    23 |             min_element2 = num;\n   |                            ^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n23\
    \ |             min_element2 = *num;\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpulfgu277.rs:28:5\n   |\n7  | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \    ---------- expected `(f64, f64)` because of return type\n...\n28 |     min_elements\n\
    \   |     ^^^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected\
    \ tuple `(f64, f64)`\n             found struct `Vec<f64>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_one = numbers[0];\n    let mut closest_two\
    \ = numbers[0];\n\n    for i in 1..numbers.len() {\n        let two = numbers[i];\n\
    \n        if two > closest_two {\n            closest_two = two;\n        }\n\n\
    \        if closest_two < two {\n            closest_one = two;\n        }\n\n\
    \        if closest_one < two {\n            closest_two = two;\n        }\n \
    \   }\n\n    (closest_one, closest_two)\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpa30xbs6c.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        let a = numbers[i];\n        if a <\
    \ min {\n            min = a;\n        }\n        if a > max {\n            max\
    \ = a;\n        }\n    }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpv643gmr8.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = std::f64::MAX;\n    let mut largest\
    \ = std::f64::MIN;\n\n    for n in numbers {\n        let delta = n.abs() - smallest;\n\
    \        if delta < smallest {\n            smallest = delta;\n        }\n\n \
    \       if delta > largest {\n            largest = delta;\n        }\n    }\n\
    \n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(-1.7976931348623157e308, 1.7976931348623157e308)`,\n right: `(3.9, 4.0)`',\
    \ /tmp/tmpctfr1xn_.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_val = (numbers[0], numbers[0]);\n    let\
    \ mut closest_distance = std::f64::MAX;\n    for val in numbers.iter().rev() {\n\
    \        let distance = val - closest_val.0;\n        if distance < closest_distance\
    \ {\n            closest_distance = distance;\n            closest_val = val;\n\
    \        }\n    }\n    closest_val\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpygezl04b.rs:14:27\n   |\n\
    8  |     let mut closest_val = (numbers[0], numbers[0]);\n   |               \
    \            ------------------------ expected due to this value\n...\n14 |  \
    \           closest_val = val;\n   |                           ^^^ expected tuple,\
    \ found `&f64`\n   |\n   = note:  expected tuple `(f64, f64)`\n           found\
    \ reference `&f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers.iter().min_by_key(|x| x.abs());\n\
    \    let mut max = numbers.iter().max_by_key(|x| x.abs());\n\n    while let Some(i)\
    \ = (min + max).iter().min() {\n        if numbers.iter().any(|x| x.abs() == i)\
    \ {\n            return (i, i);\n        }\n\n        if numbers.iter().any(|x|\
    \ x.abs() == max) {\n            max = (*max).max();\n        } else {\n     \
    \       min = (*min).min();\n        }\n    }\n\n    (max, min)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpn6qx0nni.rs:8:45\n\
    \     |\n8    |     let mut min = numbers.iter().min_by_key(|x| x.abs());\n  \
    \   |                                  ---------- ^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                  |\n  \
    \   |                                  required by a bound introduced by this\
    \ call\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::min_by_key`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpn6qx0nni.rs:9:45\n\
    \     |\n9    |     let mut max = numbers.iter().max_by_key(|x| x.abs());\n  \
    \   |                                  ---------- ^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                  |\n  \
    \   |                                  required by a bound introduced by this\
    \ call\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::max_by_key`\n\
    \nerror[E0369]: cannot add `Option<&f64>` to `Option<&f64>`\n  --> /tmp/tmpn6qx0nni.rs:11:30\n\
    \   |\n11 |     while let Some(i) = (min + max).iter().min() {\n   |         \
    \                 --- ^ --- Option<&f64>\n   |                          |\n  \
    \ |                          Option<&f64>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn6qx0nni.rs:16:46\n   |\n16 |         if numbers.iter().any(|x|\
    \ x.abs() == max) {\n   |                                              ^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<&f64>`\n\nerror[E0614]: type `Option<&f64>` cannot be\
    \ dereferenc"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest = numbers[0];\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n    let mut smallest_index = vec![];\n   \
    \ let mut largest_index = vec![];\n    for i in numbers.iter() {\n        let\
    \ dist = i - closest;\n        if dist < smallest {\n            smallest = dist;\n\
    \            smallest_index.push(i);\n        }\n        if dist > largest {\n\
    \            largest = dist;\n            largest_index.push(i);\n        }\n\
    \    }\n\n    // Make sure that the smallest and largest are both in the list\n\
    \    let mut smallest_i = vec![];\n    let mut largest_i = vec![];\n    for num\
    \ in smallest_index {\n        smallest_i.push(num);\n    }\n    for num in largest_index\
    \ {\n        largest_i.push(num);\n    }\n\n    smallest_i.reverse();\n    largest_i.reverse();\n\
    \n    (closest, smallest_i.last())\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz_8z5scj.rs:38:15\n   |\n\
    38 |     (closest, smallest_i.last())\n   |               ^^^^^^^^^^^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<&&f64>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[0])\n\
    \    } else {\n        let mut smallest = numbers[0];\n        let mut largest\
    \ = numbers[0];\n        for i in 1..numbers.len() {\n            let mut this:\
    \ Vec<_> = numbers[i as usize].iter().cloned().collect();\n            if this.len()\
    \ < 2 {\n                this.push(numbers[i]);\n            }\n            this[0]\
    \ = this[0] / this[1];\n            let this1 = this.len() as f64;\n         \
    \   if this1 > smallest {\n                smallest = this1;\n            }\n\
    \            if this1 < largest {\n                largest = this1;\n        \
    \    }\n        }\n        (smallest, largest)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpkakbd_nr.rs:14:56\n   |\n14 |             let mut this:\
    \ Vec<_> = numbers[i as usize].iter().cloned().collect();\n   |              \
    \                                          ^^^^ method not found in `f64`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance: f64 = numbers.iter().min().unwrap();\n\
    \    let mut second_closest: Option<f64> = None;\n    let mut third_closest: Option<f64>\
    \ = None;\n    let mut fourth_closest: Option<f64> = None;\n    let mut fifth_closest:\
    \ Option<f64> = None;\n    for number in numbers.iter() {\n        if min_distance\
    \ == number {\n            if second_closest == None || number < second_closest.unwrap()\
    \ {\n                second_closest = Some(number);\n            }\n        }\
    \ else {\n            if third_closest == None || number < third_closest.unwrap()\
    \ {\n                third_closest = Some(number);\n            }\n          \
    \  if fourth_closest == None || number < fourth_closest.unwrap() {\n         \
    \       fourth_closest = Some(number);\n            }\n            if fifth_closest\
    \ == None || number < fifth_closest.unwrap() {\n                fifth_closest\
    \ = Some(number);\n            }\n        }\n        min_distance = number;\n\
    \    }\n\n    (second_closest, third_closest)\n        .collect::<(Option<f64>,\
    \ Option<f64>)>()\n        .try_fold(first_closest: None, second_closest: Some,\
    \ third_closest: Some, fourth_closest: Some, fifth_closest: Some)\n        .unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `first_closest` in this scope\n  --> /tmp/tmpuuv2dvy0.rs:34:19\n\
    \   |\n34 |         .try_fold(first_closest: None, second_closest: Some, third_closest:\
    \ Some, fourth_closest: Some, fifth_closest: Some)\n   |                   ^^^^^^^^^^^^^\
    \ expecting a type here because of type ascription\n\nerror[E0573]: expected type,\
    \ found variant `None`\n  --> /tmp/tmpuuv2dvy0.rs:34:34\n   |\n34 |         .try_fold(first_closest:\
    \ None, second_closest: Some, third_closest: Some, fourth_closest: Some, fifth_closest:\
    \ Some)\n   |                                  ^^^^\n   |                    \
    \              |\n   |                                  expecting a type here\
    \ because of type ascription\n   |                                  help: try\
    \ using the variant's enum: `std::option::Option`\n\nerror[E0573]: expected type,\
    \ found variant `Some`\n  --> /tmp/tmpuuv2dvy0.rs:34:56\n   |\n34 |         .try_fold(first_closest:\
    \ None, second_closest: Some, third_closest: Some, fourth_closest: Some, fifth_closest:\
    \ Some)\n   |                                                        ^^^^\n  \
    \ |                                                        |\n   |           \
    \                                             expecting a type here because of\
    \ type ascription\n   |                                                      \
    \  help: try using the variant's enum: `std::option::Option`\n\nerror[E0573]:\
    \ expected type, found variant `Some`\n  --> /tmp/tmpuuv2dvy0.rs:34:77\n   |\n\
    34 |         .try_fold(first_closest: None, second_closest: Some, third_closest:\
    \ Some, fourth_closest: Some, fifth_closest: Some)\n   |                     \
    \                                                        ^^^^\n   |          \
    \                                                                   |\n   |  \
    \                                                                           expecting\
    \ a type here because of type ascription\n   |                               \
    \                                              help: try using the variant's enum:\
    \ `std::option::Option`\n\nerror[E0573]: expect"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n    }\n\
    \n    let mut current_min = numbers[0];\n    let mut current_max = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        if current_min > numbers[i] {\n   \
    \         current_min = numbers[i];\n        }\n        if current_max < numbers[i]\
    \ {\n            current_max = numbers[i];\n        }\n    }\n\n    (current_min,\
    \ current_max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp279fyvaf.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = f64::MAX;\n    let mut max = f64::MIN;\n\
    \    for num in numbers.iter() {\n        let delta = num - min;\n        if delta\
    \ < 0.0 {\n            min = num;\n        } else {\n            max = num;\n\
    \        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9j8o10of.rs:13:19\n   |\n\
    8  |     let mut min = f64::MAX;\n   |                   -------- expected due\
    \ to this value\n...\n13 |             min = num;\n   |                   ^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *num;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9j8o10of.rs:15:19\n   |\n9  |     let mut max\
    \ = f64::MIN;\n   |                   -------- expected due to this value\n...\n\
    15 |             max = num;\n   |                   ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   max = *num;\n   |                   +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    debug_assert!(numbers.len() >= 2);\n    let mut min_a =\
    \ numbers.iter().min().unwrap();\n    let mut max_a = numbers.iter().max().unwrap();\n\
    \    let mut min_b = numbers.iter().min_by_key(|n| n as f64).unwrap();\n    let\
    \ mut max_b = numbers.iter().max_by_key(|n| n as f64).unwrap();\n    while min_a\
    \ == min_b {\n        min_b = numbers.iter().min_by_key(|n| n as f64).unwrap();\n\
    \    }\n    while max_a == max_b {\n        max_b = numbers.iter().max_by_key(|n|\
    \ n as f64).unwrap();\n    }\n    (min_a, max_a), (min_b, max_b)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpqri1v95r.rs:19:19\n   |\n19 |     (min_a, max_a), (min_b, max_b)\n\
    \   |                   ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqri1v95r.rs:9:36\n\
    \     |\n9    |     let mut min_a = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqri1v95r.rs:10:36\n\
    \     |\n10   |     let mut max_a = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqri1v95r.rs:11:47\n\
    \     |\n11   |     let mut min_b = numbers.iter().min_by_key(|n| n as f64).unwrap();\n\
    \     |                                    ---------- ^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |                                    |\n\
    \     |                                    required by a bound introduced by this\
    \ call\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n        "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = numbers[0] - numbers[1];\n    let mut\
    \ min_element = numbers[1];\n    for &n in &numbers[2..] {\n        let d = n\
    \ - min_element;\n        if d < min_diff {\n            min_diff = d\n      \
    \  } else {\n            min_element = n;\n        }\n    }\n    (min_element,\
    \ min_diff)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, -2.8)`,\n right: `(3.9, 4.0)`', /tmp/tmpl62sru1v.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for &n in numbers {\n        if n == largest {\n            largest = n;\n\
    \        } else if n == smallest {\n            smallest = n;\n        } else\
    \ {\n            if n > largest {\n                largest = n;\n            }\
    \ else if n < smallest {\n                smallest = n;\n            }\n     \
    \   }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_18nh1j.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n\n    let mut closest = (numbers[0], numbers[0]);\n    let mut smallest_diff\
    \ = numbers[1];\n    let mut largest_diff = numbers[1];\n\n    for num in numbers[2..]\
    \ {\n        let diff = (num - closest.0).abs();\n\n        if diff < smallest_diff\
    \ {\n            smallest_diff = diff;\n            closest = (num, num);\n  \
    \      }\n        if diff > largest_diff {\n            largest_diff = diff;\n\
    \            closest = (num, num);\n        }\n    }\n\n    (closest, smallest_diff)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpw66p4noi.rs:16:16\n   |\n16 |     for num in numbers[2..]\
    \ {\n   |                ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n16 |     for num in &numbers[2..]\
    \ {\n   |                +\n16 |     for num in &mut numbers[2..] {\n   |    \
    \            ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpw66p4noi.rs:16:16\n\
    \   |\n16 |     for num in numbers[2..] {\n   |                ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n16 |     for num in &numbers[2..] {\n   |                +\n16 |     for\
    \ num in &mut numbers[2..] {\n   |                ++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw66p4noi.rs:29:6\n   |\n29 |     (closest, smallest_diff)\n\
    \   |      ^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected type\
    \ `f64`\n             found tuple `(f64, f64)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_distance = numbers[0];\n    let mut largest_distance\
    \ = numbers[0];\n    for &number in numbers {\n        smallest_distance = std::fmin(smallest_distance,\
    \ number);\n        largest_distance = std::fmax(largest_distance, number);\n\
    \    }\n    (smallest_distance, largest_distance)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fmin` in crate `std`\n  --> /tmp/tmp8aa4ze_b.rs:11:34\n\
    \   |\n11 |         smallest_distance = std::fmin(smallest_distance, number);\n\
    \   |                                  ^^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `fmax` in crate `std`\n  --> /tmp/tmp8aa4ze_b.rs:12:33\n\
    \   |\n12 |         largest_distance = std::fmax(largest_distance, number);\n\
    \   |                                 ^^^^ not found in `std`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8aa4ze_b.rs:10:9\n   |\n10 |     for &number\
    \ in numbers {\n   |         ^^^^^^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    match numbers.len() {\n        2 => numbers.iter().min(|a,\
    \ b| b - a).unwrap(),\n        _ => panic!(\"Too many input arguments. Must be\
    \ at least 2.\"),\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqi_8uxun.rs:9:29\n\
    \     |\n9    |         2 => numbers.iter().min(|a, b| b - a).unwrap(),\n    \
    \ |                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpqi_8uxun.rs:9:29\n     |\n9    |         2 => numbers.iter().min(|a,\
    \ b| b - a).unwrap(),\n     |                             ^^^ ------------ supplied\
    \ 1 argument\n     |                             |\n     |                   \
    \          expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpqi_8uxun.rs:9:14\n  |\n7 | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n  |                                             \
    \   ---------- expected `(f64, f64)` because of return type\n8 |     match numbers.len()\
    \ {\n9 |         2 => numbers.iter().min(|a, b| b - a).unwrap(),\n  |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `&f64`\n\
    \  |\n  = note:  expected tuple `(f64, f64)`\n          found reference `&f64`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0].abs();\n    let mut largest\
    \ = numbers[0].abs();\n    let mut index = 0;\n    for number in numbers {\n \
    \       let difference = number.abs() - smallest;\n        if smallest < number\
    \ && difference < largest {\n            smallest = number;\n            largest\
    \ = difference;\n        }\n        index += 1\n    }\n    (numbers[index - 1],\
    \ numbers[index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpivaw_a37.rs:19:6\n\
    \    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  \
    \  |                          ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n11  |     for number in numbers\
    \ {\n    |                   ------- `numbers` moved due to this implicit call\
    \ to `.into_iter()`\n...\n19  |     (numbers[index - 1], numbers[index])\n   \
    \ |      ^^^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter()\n        .enumerate()\n        .filter_map(|(index,\
    \ number)| {\n            if index == 0 {\n                Some(number as f64)\n\
    \            } else {\n                let prev = (numbers[index - 1] as f64).abs();\n\
    \                Some((prev + (number as f64).abs()) as f64)\n            }\n\
    \        })\n        .min_by(|a, b| a.cmp(b))\n        .expect(\"find_closest_elements\
    \ should never fail\")\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `cmp` exists for reference `&f64`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpoilxwa3e.rs:18:26\n   |\n18 |     \
    \    .min_by(|a, b| a.cmp(b))\n   |                          ^^^\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `f64: Ord`\n    \
    \       which is required by `&f64: Ord`\n           `&f64: Iterator`\n      \
    \     which is required by `&mut &f64: Iterator`\n           `f64: Iterator`\n\
    \           which is required by `&mut f64: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoilxwa3e.rs:8:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n8  | /     numbers.iter()\n\
    9  | |         .enumerate()\n10 | |         .filter_map(|(index, number)| {\n\
    11 | |             if index == 0 {\n...  |\n18 | |         .min_by(|a, b| a.cmp(b))\n\
    19 | |         .expect(\"find_closest_elements should never fail\")\n   | |__________________________________________________________^\
    \ expected tuple, found `f64`\n   |\n   = note: expected tuple `(f64, f64)`\n\
    \               found type `f64`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n\
    \  --> /tmp/tmpoilxwa3e.rs:12:22\n   |\n12 |                 Some(number as f64)\n\
    \   |                      ------^^^^^^^\n   |                      |\n   |  \
    \                    cannot cast `&f64` as `f64`\n   |                      help:\
    \ dereference the expression: `*number`\n\nerror[E0606]: casting `&f64` as `f64`\
    \ is invalid\n  --> /tmp/tmpoilxwa3e.rs:15:30\n   |\n15 |                 Some((prev\
    \ + (number as f64).abs()) as f64)\n   |                              ^------^^^^^^^^\n\
    \   |                              ||\n   |                              |help:\
    \ dereference the expression: `*number`\n   |                              cannot\
    \ cast `&f64` as `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0, 0);\n    }\n\
    \    let mut min_index = 0;\n    let mut max_index = 1;\n\n    let mut min_distance\
    \ = numbers[0] as f64;\n    let mut max_distance = numbers[0] as f64;\n    for\
    \ &n in numbers[1..] {\n        let distance = match n.cmp(&min_distance) {\n\
    \            Ordering::Greater => numbers[0] as f64,\n            Ordering::Less\
    \ => n as f64,\n            Ordering::Equal => min_distance,\n        };\n   \
    \     if distance < min_distance {\n            min_distance = distance;\n   \
    \         min_index = 0;\n        }\n        if distance > max_distance {\n  \
    \          max_distance = distance;\n            max_index = 1;\n        }\n \
    \   }\n    (min_distance, max_distance)\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp7kz8zt51.rs:18:13\n   |\n18 |             Ordering::Greater => numbers[0]\
    \ as f64,\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp7kz8zt51.rs:19:13\n\
    \   |\n19 |             Ordering::Less => n as f64,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmp7kz8zt51.rs:20:13\n   |\n20 |    \
    \         Ordering::Equal => min_distance,\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7kz8zt51.rs:9:17\n\
    \  |\n9 |         return (0, 0);\n  |                 ^\n  |                 |\n\
    \  |                 expected `f64`, found integer\n  |                 help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7kz8zt51.rs:9:20\n\
    \  |\n9 |         return (0, 0);\n  |                    ^\n  |              \
    \      |\n  |                    expected `f64`, found integer\n  |          \
    \          help: use a float literal: `0.0`\n\nerror[E0277]: the size for values\
    \ of type `[f64]` cannot be known at compilation time\n  --> /tmp/tmp7kz8zt51.rs:16:15\n\
    \   |\n16 |     for &n in numbers[1..] {\n   |               ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n16 |     for &n in &numbers[1..] {\n   |               +\n16 |     for &n\
    \ in &mut numbers[1..] {\n   |               ++++\n\nerror[E0277]: `[f64]` is\
    \ not an iterator\n  --> /tmp/tmp7kz8zt51.rs:16:15\n   |\n16 |     for &n in numbers[1..]\
    \ {\n   |               ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhel"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smaller = numbers[0];\n    let mut larger = numbers[0];\n\
    \n    for i in numbers.iter().rev() {\n        if smaller < i {\n            smaller\
    \ = i;\n        }\n        if larger > i {\n            larger = i;\n        }\n\
    \    }\n\n    (smaller, larger)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8w5rfolo.rs:12:22\n   |\n\
    12 |         if smaller < i {\n   |                      ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |         if\
    \ smaller < *i {\n   |                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8w5rfolo.rs:13:23\n   |\n8  |     let mut smaller = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n13 | \
    \            smaller = i;\n   |                       ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |          \
    \   smaller = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8w5rfolo.rs:15:21\n   |\n15 |         if larger > i {\n   |   \
    \                  ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |         if larger > *i {\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8w5rfolo.rs:16:22\n   |\n9  |\
    \     let mut larger = numbers[0];\n   |                      ---------- expected\
    \ due to this value\n...\n16 |             larger = i;\n   |                 \
    \     ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             larger = *i;\n   |                      +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_value = numbers[0] as f64;\n    let mut max_value\
    \ = numbers[0] as f64;\n\n    for &n in numbers {\n        if n < min_value {\n\
    \            min_value = n as f64;\n        }\n        if n > max_value {\n  \
    \          max_value = n as f64;\n        }\n    }\n\n    return (min_value, max_value);\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnve4d0jc.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_element = numbers[0];\n    let mut max_element\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        if numbers[i] > max_element\
    \ {\n            max_element = numbers[i];\n        }\n        if numbers[i] <\
    \ min_element {\n            min_element = numbers[i];\n        }\n    }\n   \
    \ (min_element, max_element)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpb2ds9htl.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers\n        .iter()\n        .enumerate()\n      \
    \  .min_by(|(i, _)| {\n            if i > 0 && f64::abs(numbers[i] - numbers[i\
    \ - 1]) < f64::abs(numbers[i] - numbers[i]) {\n                numbers[i], numbers[i\
    \ - 1]\n            } else {\n                numbers[i], numbers[i]\n       \
    \     }\n        })\n        .unwrap_or((numbers[0], numbers[0]))\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpfan2wp07.rs:13:27\n   |\n13 |                 numbers[i], numbers[i\
    \ - 1]\n   |                           ^ expected one of `.`, `;`, `?`, `}`, or\
    \ an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found\
    \ `,`\n  --> /tmp/tmpfan2wp07.rs:15:27\n   |\n15 |                 numbers[i],\
    \ numbers[i]\n   |                           ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0593]: closure is expected to take 2 distinct\
    \ arguments, but it takes a single 2-tuple as argument\n  --> /tmp/tmpfan2wp07.rs:11:10\n\
    \   |\n11 |         .min_by(|(i, _)| {\n   |          ^^^^^^ -------- takes a\
    \ single 2-tuple as argument\n   |          |\n   |          expected closure\
    \ that takes 2 distinct arguments\n   |\nhelp: change the closure to take multiple\
    \ arguments instead of a single tuple\n   |\n11 |         .min_by(|i, _| {\n \
    \  |                 ~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfan2wp07.rs:18:21\n\
    \   |\n18 |         .unwrap_or((numbers[0], numbers[0]))\n   |               \
    \      ^^^^^^^^^^ expected `usize`, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfan2wp07.rs:18:33\n   |\n18 |         .unwrap_or((numbers[0], numbers[0]))\n\
    \   |                                 ^^^^^^^^^^\n   |                       \
    \          |\n   |                                 expected `&f64`, found `f64`\n\
    \   |                                 help: consider borrowing here: `&numbers[0]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfan2wp07.rs:8:5\n   |\n7  |  \
    \ fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |          \
    \                                        ---------- expected `(f64, f64)` because\
    \ of return type\n8  | /     numbers\n9  | |         .iter()\n10 | |         .enumerate()\n\
    11 | |         .min_by(|(i, _)| {\n...  |\n17 | |         })\n18 | |         .unwrap_or((numbers[0],\
    \ numbers[0]))\n   | |____________________________________________^ expected `f64`,\
    \ found `usize`\n   |\n   = note: expected tuple `(f64, f64)`\n              found"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_d = std::f64::MAX;\n    let mut min_i = -1;\n\
    \    for i in 0..numbers.len() {\n        let d = std::f64::f64::from(numbers[i]\
    \ - numbers[min_i]);\n        if d < min_d {\n            min_d = d;\n       \
    \     min_i = i;\n        }\n    }\n    (numbers[min_i], numbers[min_i + 1])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: could not find `f64` in `f64`\n  --> /tmp/tmpk833hqat.rs:11:27\n\
    \   |\n11 |         let d = std::f64::f64::from(numbers[i] - numbers[min_i]);\n\
    \   |                           ^^^ not found in `std::f64`\n   |\nhelp: consider\
    \ importing this builtin type\n   |\n1  | use std::primitive::f64;\n   |\nhelp:\
    \ if you import `f64`, refer to it directly\n   |\n11 -         let d = std::f64::f64::from(numbers[i]\
    \ - numbers[min_i]);\n11 +         let d = f64::from(numbers[i] - numbers[min_i]);\n\
    \   | \n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpk833hqat.rs:9:21\n\
    \  |\n9 |     let mut min_i = -1;\n  |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_value = numbers[0].clone() + 1.0; // to avoid\
    \ a divide by zero error\n    let mut max_value = numbers[0].clone() - 1.0; //\
    \ to avoid a divide by zero error\n    for i in numbers.iter_mut() {\n       \
    \ *i = *i / max_value.clone(); // dividing each element by max_value\n       \
    \ if *i < min_value {\n            min_value = *i;\n        }\n    }\n    for\
    \ i in numbers.iter_mut() {\n        *i = *i / min_value.clone(); // dividing\
    \ each element by min_value\n        if *i > max_value {\n            max_value\
    \ = *i;\n        }\n    }\n    (min_value, max_value)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpaub7ssks.rs:10:14\n   |\n7  | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                          ------- help: consider\
    \ changing this to be mutable: `mut numbers`\n...\n10 |     for i in numbers.iter_mut()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `numbers` as mutable, as it is not declared as mutable\n  -->\
    \ /tmp/tmpaub7ssks.rs:16:14\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n   |                          ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n16 |     for i in numbers.iter_mut()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0].clone() as f64;\n    let\
    \ mut largest = numbers[0].clone() as f64;\n    for n in numbers {\n        if\
    \ n.abs() < smallest.abs() {\n            smallest = n.clone();\n        }\n \
    \       if n.abs() > largest.abs() {\n            largest = n.clone();\n     \
    \   }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpqv15jcff.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Find two numbers that minimally increase the distance\
    \ to eachother\n    let mut min_dist = std::f64::INFINITY;\n    let mut min_i\
    \ = -1;\n    for i in 0..numbers.len() {\n        let dist = numbers[i] - numbers[min_i];\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_i\
    \ = i;\n        }\n    }\n    (numbers[min_i], numbers[min_i + 1])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpuwa9u6hw.rs:10:21\n\
    \   |\n10 |     let mut min_i = -1;\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if smallest > i {\n            smallest\
    \ = i;\n        }\n        if largest < i {\n            largest = i;\n      \
    \  }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1a_eberu.rs:11:23\n   |\n\
    11 |         if smallest > i {\n   |                       ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |         if\
    \ smallest > *i {\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1a_eberu.rs:12:24\n   |\n8  |     let mut smallest = numbers[0];\n\
    \   |                        ---------- expected due to this value\n...\n12 |\
    \             smallest = i;\n   |                        ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |          \
    \   smallest = *i;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1a_eberu.rs:14:22\n   |\n14 |         if largest < i {\n\
    \   |                      ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |         if largest < *i {\n   |       \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1a_eberu.rs:15:23\n\
    \   |\n9  |     let mut largest = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n15 |             largest = i;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             largest = *i;\n   |                     \
    \  +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_distance = FLT_MAX;\n    let mut largest_distance\
    \ = -FLT_MAX;\n    for number in numbers {\n        let distance = number.abs();\n\
    \        if distance < smallest_distance {\n            smallest_distance = distance;\n\
    \        }\n        if distance > largest_distance {\n            largest_distance\
    \ = distance;\n        }\n    }\n    if smallest_distance == largest_distance\
    \ {\n        smallest_distance\n    } else {\n        (smallest_distance, largest_distance)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FLT_MAX` in this scope\n --> /tmp/tmpp07vtbhc.rs:8:33\n\
    \  |\n8 |     let mut smallest_distance = FLT_MAX;\n  |                      \
    \           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `FLT_MAX` in this scope\n --> /tmp/tmpp07vtbhc.rs:9:33\n  |\n9 |     let mut\
    \ largest_distance = -FLT_MAX;\n  |                                 ^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp07vtbhc.rs:20:9\n\
    \   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |\
    \                                                ---------- expected `(f64, f64)`\
    \ because of return type\n...\n20 |         smallest_distance\n   |         ^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `f64`\n   |\n   = note: expected tuple `(f64, f64)`\n\
    \               found type `f64`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for number in numbers.iter().rev() {\n        if number < smallest {\n  \
    \          smallest = number;\n        }\n        if number > largest {\n    \
    \        largest = number;\n        }\n    }\n    (smallest, largest)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphdo9jl5k.rs:11:21\n   |\n\
    11 |         if number < smallest {\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphdo9jl5k.rs:12:24\n   |\n8  |     let mut smallest\
    \ = numbers[0];\n   |                        ---------- expected due to this value\n\
    ...\n12 |             smallest = number;\n   |                        ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12\
    \ |             smallest = *number;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphdo9jl5k.rs:14:21\n   |\n14 |         if number\
    \ > largest {\n   |                     ^^^^^^^\n   |                     |\n\
    \   |                     expected `&f64`, found `f64`\n   |                 \
    \    help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphdo9jl5k.rs:15:23\n   |\n9  |     let mut largest = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n15 | \
    \            largest = number;\n   |                       ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |    \
    \         largest = *number;\n   |                       +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0].0; //smallest\n    let mut\
    \ largest = numbers[0].0; //largest\n\n    for number in numbers {\n        if\
    \ number < smallest {\n            smallest = number;\n        }\n        if number\
    \ > largest {\n            largest = number;\n        }\n    }\n\n    smallest,\
    \ largest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpi7clwq6s.rs:20:13\n   |\n20 |     smallest, largest\n\
    \   |             ^ expected one of 8 possible tokens\n\nerror[E0610]: `f64` is\
    \ a primitive type and therefore doesn't have fields\n --> /tmp/tmpi7clwq6s.rs:8:35\n\
    \  |\n8 |     let mut smallest = numbers[0].0; //smallest\n  |               \
    \                    ^\n\nerror[E0610]: `f64` is a primitive type and therefore\
    \ doesn't have fields\n --> /tmp/tmpi7clwq6s.rs:9:34\n  |\n9 |     let mut largest\
    \ = numbers[0].0; //largest\n  |                                  ^\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0, numbers.last().unwrap());\n\
    \    }\n\n    let mut smallest = numbers[0].min(numbers[1]);\n    let mut largest\
    \ = numbers[0].max(numbers[1]);\n\n    for &n in numbers[2..] {\n        let tmp\
    \ = n.min(smallest);\n        if tmp < smallest {\n            smallest = tmp;\n\
    \        }\n\n        if tmp > largest {\n            largest = tmp;\n       \
    \ }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppma0tfgp.rs:9:17\n  |\n9 |\
    \         return (0, numbers.last().unwrap());\n  |                 ^\n  |   \
    \              |\n  |                 expected `f64`, found integer\n  |     \
    \            help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmppma0tfgp.rs:9:20\n  |\n9 |         return (0, numbers.last().unwrap());\n\
    \  |                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \  |\nhelp: consider dereferencing the borrow\n  |\n9 |         return (0, *numbers.last().unwrap());\n\
    \  |                    +\n\nerror[E0277]: the size for values of type `[f64]`\
    \ cannot be known at compilation time\n  --> /tmp/tmppma0tfgp.rs:15:15\n   |\n\
    15 |     for &n in numbers[2..] {\n   |               ^^^^^^^^^^^^ expected an\
    \ implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n15 |     for &n in &numbers[2..] {\n   |               +\n15 |     for &n\
    \ in &mut numbers[2..] {\n   |               ++++\n\nerror[E0277]: `[f64]` is\
    \ not an iterator\n  --> /tmp/tmppma0tfgp.rs:15:15\n   |\n15 |     for &n in numbers[2..]\
    \ {\n   |               ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n15 |     for &n in &numbers[2..]\
    \ {\n   |               +\n15 |     for &n in &mut numbers[2..] {\n   |      \
    \         ++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest = numbers[0];\n    let mut second_closest\
    \ = numbers[0];\n\n    for &n in numbers {\n        if n > closest {\n       \
    \     second_closest = closest;\n            closest = n;\n        } else if n\
    \ < closest {\n            second_closest = 1;\n            closest = n;\n   \
    \     } else {\n            second_closest = 1;\n        }\n    }\n\n    (closest,\
    \ second_closest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz1rbgo3n.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz1rbgo3n.rs:16:30\n   |\n9  |     let mut second_closest\
    \ = numbers[0];\n   |                              ---------- expected due to\
    \ this value\n...\n16 |             second_closest = 1;\n   |                \
    \              ^\n   |                              |\n   |                  \
    \            expected `f64`, found integer\n   |                             \
    \ help: use a float literal: `1.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz1rbgo3n.rs:19:30\n\
    \   |\n9  |     let mut second_closest = numbers[0];\n   |                   \
    \           ---------- expected due to this value\n...\n19 |             second_closest\
    \ = 1;\n   |                              ^\n   |                            \
    \  |\n   |                              expected `f64`, found integer\n   |  \
    \                            help: use a float literal: `1.0`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for &n in numbers {\n        let curr_min = min;\n        let curr_max =\
    \ max;\n\n        if n < curr_min {\n            min = n;\n        }\n       \
    \ if n > curr_max {\n            max = n;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplkyuy3jy.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.is_empty() {\n        (0.0, 0.0)\n    }\n  \
    \  let mut min_val: f64 = numbers[0];\n    let mut max_val: f64 = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if i < min_val {\n            min_val\
    \ = i;\n        }\n        if i > max_val {\n            max_val = i;\n      \
    \  }\n    }\n    (min_val, max_val)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfwcz0z_3.rs:9:9\n   |\n8\
    \  | /     if numbers.is_empty() {\n9  | |         (0.0, 0.0)\n   | |        \
    \ ^^^^^^^^^^ expected `()`, found tuple\n10 | |     }\n   | |_____- expected this\
    \ to be `()`\n   |\n   = note: expected unit type `()`\n                  found\
    \ tuple `({float}, {float})`\nhelp: you might have meant to return this value\n\
    \   |\n9  |         return (0.0, 0.0);\n   |         ++++++           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfwcz0z_3.rs:14:16\n   |\n14 |         if i <\
    \ min_val {\n   |                ^^^^^^^\n   |                |\n   |        \
    \        expected `&f64`, found `f64`\n   |                help: consider borrowing\
    \ here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfwcz0z_3.rs:15:23\n\
    \   |\n11 |     let mut min_val: f64 = numbers[0];\n   |                     \
    \ --- expected due to this type\n...\n15 |             min_val = i;\n   |    \
    \                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             min_val = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfwcz0z_3.rs:17:16\n   |\n\
    17 |         if i > max_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&f64`, found `f64`\n   |                help:\
    \ consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfwcz0z_3.rs:18:23\n   |\n12 |     let mut max_val: f64 = numbers[0];\n\
    \   |                      --- expected due to this type\n...\n18 |          \
    \   max_val = i;\n   |                       ^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |             max_val\
    \ = *i;\n   |                       +\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min: f64 = numbers.iter().min().unwrap();\n   \
    \ let mut max: f64 = numbers.iter().max().unwrap();\n    let mut smallest = min;\n\
    \    let mut largest = max;\n    let mut index: usize = 0;\n    while index <\
    \ numbers.len() {\n        if numbers[index] < smallest {\n            smallest\
    \ = numbers[index];\n            index += 1;\n        } else if numbers[index]\
    \ > largest {\n            largest = numbers[index];\n            index += 1;\n\
    \        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp7zlx8vqe.rs:8:39\n\
    \     |\n8    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp7zlx8vqe.rs:8:24\n  |\n8 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n8 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp7zlx8vqe.rs:9:39\n     |\n9    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp7zlx8vqe.rs:9:24\n  |\n9 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     let\
    \ mut max: f64 = *num"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut lower = numbers[0];\n    let mut higher = numbers[0];\n\
    \    for (number, index) in numbers.iter().enumerate() {\n        if number <\
    \ lower {\n            lower = number;\n        }\n        if number > higher\
    \ {\n            higher = number;\n        }\n    }\n\n    let mut i = 1;\n  \
    \  let mut closest = lower as f64;\n    let mut closest = higher as f64;\n   \
    \ while i < numbers.len() {\n        let mut curr = numbers[i];\n        let mut\
    \ j = i;\n        while j < numbers.len() {\n            let mut delta = curr\
    \ - numbers[j];\n            if delta < closest {\n                closest = delta;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n\n   \
    \ (lower, closest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2fymkx6_.rs:11:21\n   |\n\
    11 |         if number < lower {\n   |                     ^^^^^ expected `usize`,\
    \ found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2fymkx6_.rs:12:21\n\
    \   |\n8  |     let mut lower = numbers[0];\n   |                     ----------\
    \ expected due to this value\n...\n12 |             lower = number;\n   |    \
    \                 ^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can cast\
    \ a `usize` to an `f64`, producing the floating point representation of the integer,\
    \ rounded if necessary\n   |\n12 |             lower = number as f64;\n   |  \
    \                          ++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2fymkx6_.rs:14:21\n\
    \   |\n14 |         if number > higher {\n   |                     ^^^^^^ expected\
    \ `usize`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2fymkx6_.rs:15:22\n\
    \   |\n9  |     let mut higher = numbers[0];\n   |                      ----------\
    \ expected due to this value\n...\n15 |             higher = number;\n   |   \
    \                   ^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can\
    \ cast a `usize` to an `f64`, producing the floating point representation of the\
    \ integer, rounded if necessary\n   |\n15 |             higher = number as f64;\n\
    \   |                             ++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers\n        .iter()\n        .enumerate()\n      \
    \  .min_by_key(|(_, i)| numbers[i] - numbers[i - 1]);\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[f64]` cannot be indexed by `&&f64`\n  --> /tmp/tmpmqf7n_o1.rs:11:30\n\
    \   |\n11 |         .min_by_key(|(_, i)| numbers[i] - numbers[i - 1]);\n   | \
    \                             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented\
    \ for `&&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&&f64>`\
    \ for `Vec<f64>`\n\nerror[E0369]: cannot subtract `{integer}` from `&&f64`\n \
    \ --> /tmp/tmpmqf7n_o1.rs:11:53\n   |\n11 |         .min_by_key(|(_, i)| numbers[i]\
    \ - numbers[i - 1]);\n   |                                                   -\
    \ ^ - {integer}\n   |                                                   |\n  \
    \ |                                                   &&f64\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpmqf7n_o1.rs:7:48\n  |\n7 | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n  |    ---------------------                    \
    \   ^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note:  expected\
    \ tuple `(f64, f64)`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0.0, 0.0);\n \
    \   }\n\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for &num in\
    \ numbers {\n        if *num < min_val {\n            min_val = *num;\n      \
    \  }\n        if *num > max_val {\n            max_val = *num;\n        }\n  \
    \  }\n\n    for &num in numbers {\n        if *num < min_val {\n            min_val\
    \ = *num;\n        }\n        if *num > max_val {\n            max_val = *num;\n\
    \        }\n    }\n\n    let mut min_diff = std::f64::MAX;\n    let mut max_diff\
    \ = std::f64::MIN;\n    let mut min_diff = std::f64::MAX;\n    let mut max_diff\
    \ = std::f64::MIN;\n    let mut min_diff = std::f64::MAX;\n    let mut max_diff\
    \ = std::f64::MIN;\n    for &num in numbers {\n        if *num < min_val {\n \
    \           min_val = *num;\n        }\n        if *num > max_val {\n        \
    \    max_val = *num;\n        }\n    }\n\n    for &num in numbers {\n        if\
    \ *num < min_val {\n            min_diff = std::f64::MAX;\n        }\n       \
    \ if *num > max_val {\n            max_diff = std::f64::MIN;\n        }\n    \
    \    if *num < min_diff {\n            min_diff = *num;\n        }\n        if\
    \ *num > max_diff {\n            max_diff = *num;\n        }\n    }\n\n    if\
    \ max_diff < min_diff {\n        return (min_val, max_val);\n    }\n\n    return\
    \ (min_diff, max_diff);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xyxydom.rs:22:9\n   |\n\
    22 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3xyxydom.rs:31:9\n   |\n31 |     for &num in\
    \ numbers {\n   |         ^^^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `num`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3xyxydom.rs:46:9\n   |\n46 |     for &num in numbers {\n   |  \
    \       ^^^^    ------- this expression has type `Option<f64>`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `num`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3xyxydom.rs:55:9\n\
    \   |\n55 |     for &num in numbers {\n   |         ^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest = numbers[0];\n    let mut closest = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] - closest < closest -\
    \ numbers[i] {\n            closest = numbers[i];\n        }\n    }\n    (numbers[0],\
    \ closest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpsgbp28hs.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut a = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut b = numbers.iter().cloned().collect::<Vec<_>>();\n    let mut closest\
    \ = vec![];\n    let mut smallest = vec![];\n    let mut largest = vec![];\n \
    \   let mut a0 = a[0];\n    let mut b0 = b[0];\n    let mut c_mut_a = a.clone();\n\
    \    let mut c_mut_b = b.clone();\n    let mut c_mut_c_mut_a = c_mut_a.clone();\n\
    \    let mut c_mut_c_mut_b = c_mut_b.clone();\n    for i in 0..a.len() {\n   \
    \     for j in 0..b.len() {\n            let diff = a[i] - b[j];\n           \
    \ if diff <= 0.0 {\n                continue;\n            }\n            let\
    \ mut smallest_j = smallest[j].iter().cloned().collect::<Vec<_>>();\n        \
    \    let mut largest_j = largest[j].iter().cloned().collect::<Vec<_>>();\n   \
    \         if diff < smallest[j].len() {\n                smallest[j] = vec![c_mut_a[i]];\n\
    \            } else {\n                smallest[j].push(c_mut_a[i]);\n       \
    \     }\n            if diff > largest[j].len() {\n                largest[j]\
    \ = vec![c_mut_b[i]];\n            } else {\n                largest[j].push(c_mut_b[i]);\n\
    \            }\n            if diff <= 0.0 {\n                continue;\n    \
    \        }\n            smallest_j.iter().cloned().cloned().sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(c_mut_b[j]);\n            largest_j.iter().cloned().cloned().sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(c_mut_a[j]);\n        }\n    }\n    smallest.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(largest.last().cloned());\n    largest.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(smallest.last().cloned());\n    let mut ret1\
    \ = smallest.iter().cloned().cloned().take(1).unwrap().clone();\n    let mut ret2\
    \ = largest.iter().cloned().cloned().take(1).unwrap().clone();\n    ret1.sort_unstable_by_key(|x|\
    \ x).cloned().take(1).unwrap().push(ret2.last().cloned());\n    ret2.\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9_0zx9cz.rs:50:1\n   |\n50\
    \ | }\n   | ^\n\nerror[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp9_0zx9cz.rs:25:34\n\
    \   |\n11 |     let mut smallest = vec![];\n   |         ------------ consider\
    \ giving `smallest` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n25 |             let mut smallest_j = smallest[j].iter().cloned().collect::<Vec<_>>();\n\
    \   |                                  ^^^^^^^^^^^ cannot infer type\n   |\n \
    \  = note: type must be known at this point\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.is_empty() {\n        return (0., 0.);\n   \
    \ }\n    let mut best = Vec::new();\n    let mut best = Vec::new();\n    let mut\
    \ best = Vec::new();\n    let mut best = Vec::new();\n    let mut best = Vec::new();\n\
    \    let mut best = Vec::new();\n    for n in numbers {\n        let mut best1\
    \ = 0.;\n        let mut best2 = 0.;\n        let mut best3 = 0.;\n        let\
    \ mut best4 = 0.;\n        for n in numbers {\n            match n {\n       \
    \         n if n == n => { best1 = best; best2 = best; best3 = best; best4 = best;\
    \ },\n                n if n < n => { best1 = best; best2 = best; },\n       \
    \         n if n > n => { best1 = best; best2 = best; },\n                _ =>\
    \ { }\n            }\n        }\n        best = if best1 < best2 && best3 < best4\
    \ { (best1, best3) } else if best2 < best1 && best3 < best4 { (best2, best3) }\
    \ else { if best1 < best2 && best2 < best4 { (best1, best2) } else { if best1\
    \ < best2 && best3 < best4 { (best1, best3) } else { if best2 < best1 && best3\
    \ < best4 { (best2, best3) } } };\n    }\n    (best.0, best.1)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptw373pax.rs:42:3\n\
    \   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n30 |         best = if best1 < best2 && best3 < best4 { (best1, best3) }\
    \ else if best2 < best1 && best3 < best4 { (best2, best3) } else { if b...\n \
    \  |                                                                         \
    \                                                           - this delimiter might\
    \ not be properly closed...\n31 |     }\n   |     - ...as it matches this but\
    \ it has different indentation\n...\n42 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptw373pax.rs:24:42\n   |\n18 |         let mut best1 = 0.;\n\
    \   |                         -- expected due to this value\n...\n24 |       \
    \          n if n == n => { best1 = best; best2 = best; best3 = best; best4 =\
    \ best; },\n   |                                          ^^^^ expected floating-point\
    \ number, found struct `Vec`\n   |\n   = note: expected type `{float}`\n     \
    \       found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptw373pax.rs:24:56\n\
    \   |\n19 |         let mut best2 = 0.;\n   |                         -- expected\
    \ due to this value\n...\n24 |                 n if n == n => { best1 = best;\
    \ best2 = best; best3 = best; best4 = best; },\n   |                         \
    \                               ^^^^ expected floating-point number, found struct\
    \ `Vec`\n   |\n   = note: expected type `{float}`\n            found struct `Vec<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptw373pax.rs:24:70\n   |\n20 |\
    \         let mut best3 = 0.;\n   |                         -- expected due to\
    \ this value\n...\n24 |                 n if n == n => { best1 = best; best2 =\
    \ best; best3 = best; best4 = best; },\n   |                                 \
    \                                     ^^^^ expected floating-point number, found\
    \ struct `Vec`\n   |\n   = note: expected type `{float}`\n            found struct\
    \ `Vec<_>`\n\nerror[E0308]: mismatched t"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = f64::MAX;\n    let mut max = f64::MIN;\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp_tpb0xm1.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for i in numbers.iter().rev() {\n        if i < min {\n            min =\
    \ i;\n        }\n\n        if i > max {\n            max = i;\n        }\n   \
    \ }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph2cql824.rs:12:16\n   |\n\
    12 |         if i < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph2cql824.rs:13:19\n\
    \   |\n8  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n13 |             min = i;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph2cql824.rs:16:16\n   |\n16 |         if i > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph2cql824.rs:17:19\n   |\n9  |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n17 |             max = i;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |          \
    \   max = *i;\n   |                   +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0] as f64;\n    let mut biggest\
    \ = numbers[0] as f64;\n    for &n in numbers {\n        if n >= smallest {\n\
    \            smallest = n;\n        } else if n < smallest {\n            smallest\
    \ = n;\n        }\n        if n <= biggest {\n            biggest = n;\n     \
    \   } else if n > biggest {\n            biggest = n;\n        }\n    }\n    (smallest,\
    \ biggest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdl4_vu0k.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut lowest_found = (numbers[0], numbers[0]);\n\n  \
    \  for i in 1..numbers.len() {\n        let (current, minimum) = lowest_found;\n\
    \        let difference = numbers[i] - current;\n        if difference < minimum\
    \ {\n            lowest_found = (numbers[i], numbers[i]);\n        }\n    }\n\
    \    lowest_found\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp4stfwp_2.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i];\n        }\n        if numbers[i] < smallest {\n \
    \           smallest = numbers[i];\n        }\n    }\n\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpfrfmau2v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = numbers[0].abs();\n    let mut min_number\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        let distance = numbers[i].abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = numbers[i];\n        }\n    }\n    (min_number, min_distance)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpsc22j96a.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Sort numbers so we can find the closest one first\n\
    \    let sorted_numbers = numbers.iter().sorted();\n    // If the first number\
    \ is 0 then there is no number\n    if sorted_numbers.first() == f64::from(0.0)\n\
    \        || (sorted_numbers.last() == f64::from(0.0)\n            && numbers.len()\
    \ > 1)\n    {\n        return (sorted_numbers.last().unwrap(), sorted_numbers.last().unwrap());\n\
    \    }\n    // If the first and last numbers are the same, return the middle number\n\
    \    if sorted_numbers.first() == sorted_numbers.last() {\n        return (sorted_numbers.last(),\
    \ sorted_numbers.last().unwrap());\n    }\n    let first_number = sorted_numbers.first().unwrap();\n\
    \    let last_number = sorted_numbers.last().unwrap();\n    let mut result = vec![(first_number,\
    \ first_number)];\n    for (i, number) in sorted_numbers.iter().skip(1) {\n  \
    \      let current_number = number;\n        let distance = if i == 0 {\n    \
    \        first_number - current_number\n        } else {\n            last_number\
    \ - current_number\n        };\n        let closest_number = if distance < 0 {\n\
    \            result[result.len() - 1].1.unwrap() + distance\n        } else {\n\
    \            result[result.len() - 1].0.unwrap() + distance\n        };\n    \
    \    // Update the result vector\n        result.push((current_number, closest_number));\n\
    \    }\n    // If there are any remaining numbers, return the nearest to them\
    \ in order\n    if let Some(number) = sorted_numbers.last() {\n        result.push((number,\
    \ number));\n    }\n    // Return the results\n    result.into_iter().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpzfujqpxb.rs:9:41\n  |\n9 |     let sorted_numbers\
    \ = numbers.iter().sorted();\n  |                                         ^^^^^^\
    \ method not found in `std::slice::Iter<'_, f64>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for &n in &numbers[1..] {\n        if n < smallest {\n            smallest\
    \ = n;\n        }\n\n        if n > largest {\n            largest = n;\n    \
    \    }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp6pskabau.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_value = numbers[0].min();\n    let mut max_value\
    \ = numbers[0].max();\n\n    for number in numbers.iter().rev() {\n        if\
    \ number < min_value {\n            min_value = number;\n        }\n        if\
    \ number > max_value {\n            max_value = number;\n        }\n    }\n\n\
    \    let min_distance = min_value - max_value;\n    let mut min_value = min_value\
    \ + min_distance;\n    let mut max_value = max_value - min_distance;\n    min_value\
    \ = min_value..max_value;\n\n    (min_value, max_value)\n}\n\nfn main() {\n  \
    \  let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp613r0cmp.rs:8:36\n    |\n8   |     let mut min_value = numbers[0].min();\n\
    \    |                                    ^^^- supplied 0 arguments\n    |   \
    \                                 |\n    |                                   \
    \ expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp613r0cmp.rs:9:36\n\
    \    |\n9   |     let mut max_value = numbers[0].max();\n    |               \
    \                     ^^^- supplied 0 arguments\n    |                       \
    \             |\n    |                                    expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp613r0cmp.rs:12:21\n   |\n12 |         if number < min_value {\n\
    \   |                     ^^^^^^^^^\n   |                     |\n   |        \
    \             expected `&f64`, found `f64`\n   |                     help: consider\
    \ borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp613r0cmp.rs:13:25\n\
    \   |\n8  |     let mut min_value = numbers[0].min();\n   |                  \
    \       ---------------- expected due to this value\n...\n13 |             min_value\
    \ = number;\n   |                         ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |             min_value\
    \ = *number;\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp613r0cmp.rs:15:21\n   |\n15 |         if number > max_value {\n\
    \   |                     ^^^^^^^^^\n   |                     |\n   |        \
    \             expected `&f64`, found `f64`\n   |                     help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp613r0cmp.rs:16:25\n\
    \   |\n9  |     let mut max_value = numbers[0].max();\n   |                  \
    \       ---------------- expected due to this value\n...\n16 |             max_value\
    \ = number;\n   |                         ^^^^^^ expected `f64`, found `&f64`\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let min_diff = numbers.iter().min().unwrap();\n    let\
    \ max_diff = numbers.iter().max().unwrap();\n    if min_diff == max_diff {\n \
    \       return (min_diff, min_diff);\n    }\n    let mut min_closest = max_diff;\n\
    \    let mut max_closest = min_diff;\n    let mut min_idx = 0;\n    let mut max_idx\
    \ = numbers.len() - 1;\n    while min_idx < max_idx {\n        let diff = (min_closest\
    \ + max_closest) / 2; // make sure diff is even\n        let closest = match numbers[min_idx..max_idx].iter().cloned().min_max_element::<f64>()\n\
    \            .map(|v| (v - diff).abs()).min_max_element::<f64>()\n        {\n\
    \            Some((a, b)) if a < b => (a, b)\n            Some((a, b)) if a >\
    \ b => (b, a)\n            Some((a, b)) => return (a, b)\n            None =>\
    \ return (min_diff, max_diff)\n        };\n        if closest < min_closest {\n\
    \            min_closest = closest;\n            min_idx = min_idx + 1;\n    \
    \    } else if closest > max_closest {\n            max_closest = closest;\n \
    \           max_idx = max_idx - 1;\n        }\n    }\n    (min_diff, max_diff)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `Some`\n\
    \  --> /tmp/tmpfm1lyd9y.rs:23:13\n   |\n22 |             Some((a, b)) if a < b\
    \ => (a, b)\n   |                                   --       - expected one of\
    \ `,`, `.`, `?`, `}`, or an operator\n   |                                   |\n\
    \   |                                   while parsing the `match` arm starting\
    \ here\n23 |             Some((a, b)) if a > b => (b, a)\n   |             ^^^^\
    \ unexpected token\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmpfm1lyd9y.rs:8:35\n     |\n8    |     let min_diff = numbers.iter().min().unwrap();\n\
    \     |                                   ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpfm1lyd9y.rs:9:35\n\
    \     |\n9    |     let max_diff = numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfm1lyd9y.rs:11:17\n   |\n11 |\
    \         return (min_diff, min_diff);\n   |                 ^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11\
    \ |         return (*min_diff, min_diff);\n   |                 +\n\nerror[E0308]:\
    \ mismatch"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter()\n        .enumerate()\n        .filter_map(|(idx,\
    \ num)| {\n            if idx > 0 {\n                Some((\n                \
    \    num - numbers[idx - 1].unwrap(),\n                    numbers[idx].unwrap(),\n\
    \                ))\n            } else {\n                Some((\n          \
    \          num - numbers[numbers.len() - 1].unwrap(),\n                    numbers[0].unwrap(),\n\
    \                ))\n            }\n        })\n        .nth(1)\n        .unwrap_or((numbers[0],\
    \ numbers[1]))\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp2cds_xvh.rs:13:44\n   |\n13 |                     num -\
    \ numbers[idx - 1].unwrap(),\n   |                                           \
    \ ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2cds_xvh.rs:14:34\n   |\n\
    14 |                     numbers[idx].unwrap(),\n   |                        \
    \          ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp2cds_xvh.rs:18:54\n\
    \   |\n18 |                     num - numbers[numbers.len() - 1].unwrap(),\n \
    \  |                                                      ^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `unwrap` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2cds_xvh.rs:19:32\n   |\n19 |                 \
    \    numbers[0].unwrap(),\n   |                                ^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n\n    let mut min = 0.0;\n\
    \    let mut max = numbers[0];\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        if number < min {\n            min = number;\n        }\n       \
    \ if number > max {\n            max = number;\n        }\n    }\n\n    let mut\
    \ min_index = 0;\n    let mut max_index = numbers[0] as usize;\n\n    for (index,\
    \ number) in numbers.iter().enumerate() {\n        if number < min {\n       \
    \     min = number;\n            min_index = index;\n        }\n        if number\
    \ > max {\n            max = number;\n            max_index = index;\n       \
    \ }\n    }\n\n    (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpztxyyigb.rs:13:21\n   |\n\
    13 |         if number < min {\n   |                     ^^^\n   |           \
    \          |\n   |                     expected `&f64`, found floating-point number\n\
    \   |                     help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpztxyyigb.rs:14:19\n   |\n10 |     let mut min\
    \ = 0.0;\n   |                   --- expected due to this value\n...\n14 |   \
    \          min = number;\n   |                   ^^^^^^ expected floating-point\
    \ number, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |             min = *number;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpztxyyigb.rs:16:21\n   |\n16 |         if number > max {\n\
    \   |                     ^^^\n   |                     |\n   |              \
    \       expected `&f64`, found `f64`\n   |                     help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpztxyyigb.rs:17:19\n\
    \   |\n11 |     let mut max = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n17 |             max = number;\n   |               \
    \    ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n17 |             max = *number;\n   |                   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpztxyyigb.rs:25:21\n   |\n25 |  \
    \       if number < min {\n   |                     ^^^\n   |                \
    \     |\n   |                     expected `&f64`, found floating-point number\n\
    \   |                     help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpztxyyigb.rs:26:19\n   |\n10 |     let mut min\
    \ = 0.0;\n   |                   --- expected due to this value\n...\n26 |   \
    \          min = number;\n   |                   ^^^^^^ expected floating-point\
    \ number, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    26 |             min = *number;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpztxyyigb.rs:29:21\n   |\n29 |         if number > ma"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        // too few numbers, nothing\
    \ to do\n        return (0.0,0.0);\n    }\n    let mut smallest_value = numbers[0];\n\
    \    let mut largest_value = numbers[0];\n\n    for num in numbers.iter().skip(1)\
    \ {\n        if num > largest_value {\n            largest_value = num;\n    \
    \    }\n\n        if num < smallest_value {\n            smallest_value = num;\n\
    \        }\n    }\n\n    (smallest_value, largest_value)\n}\n\nfn main() {\n \
    \   let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv4xtk_m5.rs:16:18\n   |\n\
    16 |         if num > largest_value {\n   |                  ^^^^^^^^^^^^^\n \
    \  |                  |\n   |                  expected `&f64`, found `f64`\n\
    \   |                  help: consider borrowing here: `&largest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4xtk_m5.rs:17:29\n   |\n13 |     let mut largest_value\
    \ = numbers[0];\n   |                             ---------- expected due to this\
    \ value\n...\n17 |             largest_value = num;\n   |                    \
    \         ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             largest_value = *num;\n   |             \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4xtk_m5.rs:20:18\n\
    \   |\n20 |         if num < smallest_value {\n   |                  ^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&f64`, found `f64`\n\
    \   |                  help: consider borrowing here: `&smallest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4xtk_m5.rs:21:30\n   |\n12 |     let mut smallest_value\
    \ = numbers[0];\n   |                              ---------- expected due to\
    \ this value\n...\n21 |             smallest_value = num;\n   |              \
    \                ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |             smallest_value = *num;\n   |            \
    \                  +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = numbers[0].0; // initialize min\
    \ distance to first number in list\n    let mut max_distance = numbers[0].0;\n\
    \n    // iterate through numbers to find min and max distance\n    for number\
    \ in numbers {\n        let distance = if number < min_distance {\n          \
    \  min_distance\n        } else {\n            max_distance\n        };\n\n  \
    \      // update min and max distance\n        if distance < min_distance {\n\
    \            min_distance = number;\n        }\n        if distance > max_distance\
    \ {\n            max_distance = number;\n        }\n    }\n\n    // return min\
    \ and max distances in order\n    (min_distance, max_distance)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0610]: `f64` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmp0vm9gvvy.rs:8:39\n  |\n8 |     let mut min_distance = numbers[0].0;\
    \ // initialize min distance to first number in list\n  |                    \
    \                   ^\n\nerror[E0610]: `f64` is a primitive type and therefore\
    \ doesn't have fields\n --> /tmp/tmp0vm9gvvy.rs:9:39\n  |\n9 |     let mut max_distance\
    \ = numbers[0].0;\n  |                                       ^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // TODO: this could be made more efficient by sorting the\
    \ list first and going through the list once\n    let mut min1 = numbers[0]\n\
    \    let mut min2 = numbers[0]\n    for i in 1..numbers.len() {\n        let dist\
    \ = &numbers[i] - &numbers[i - 1];\n        if dist < min1 {\n            min1\
    \ = dist;\n        }\n        if dist < min2 {\n            min2 = dist;\n   \
    \     }\n    }\n    (min1, min2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_40d_bqm.rs:9:30\n\
    \   |\n9  |     let mut min1 = numbers[0]\n   |                              ^\
    \ help: add `;` here\n10 |     let mut min2 = numbers[0]\n   |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_40d_bqm.rs:10:30\n\
    \   |\n10 |     let mut min2 = numbers[0]\n   |                              ^\
    \ help: add `;` here\n11 |     for i in 1..numbers.len() {\n   |     --- unexpected\
    \ token\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    let mut index = 0;\n    let mut result = (numbers[0], numbers[0]);\n   \
    \ while index < numbers.len() {\n        let current = numbers[index];\n     \
    \   if current < result.0 {\n            result = (numbers[index], numbers[index]);\n\
    \        } else if current > result.0 {\n            result = (numbers[index],\
    \ result);\n        }\n\n        index = index + 1;\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsgxgoo_5.rs:17:39\n   |\n\
    17 |             result = (numbers[index], result);\n   |                    \
    \                   ^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected\
    \ type `f64`\n             found tuple `(f64, f64)`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Find closest number in the array and return it in the\
    \ array\n    let mut smaller = numbers[0];\n    let mut larger = numbers[0];\n\
    \    for i in numbers {\n        if i < smaller { smaller = i }\n        else\
    \ if i > larger { larger = i }\n    }\n    (smaller, larger)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmph3t7monm.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = f64::MAX;\n    let mut largest = -smallest;\n\
    \    let mut mid = numbers.len() / 2;\n\n    for n in numbers {\n        if n\
    \ < smallest {\n            smallest = n;\n        }\n        if n > largest {\n\
    \            largest = n;\n        }\n        if n == smallest {\n           \
    \ mid = numbers.len() / 2;\n        }\n    }\n\n    (smallest, largest)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "warning: variable `mid` is assigned to, but never used\n  --> /tmp/tmp72ppepvw.rs:10:13\n\
    \   |\n10 |     let mut mid = numbers.len() / 2;\n   |             ^^^\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_mid` instead\n\nwarning: value assigned to `mid` is never read\n  --> /tmp/tmp72ppepvw.rs:20:13\n\
    \   |\n20 |             mid = numbers.len() / 2;\n   |             ^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0382]: borrow of moved value: `numbers`\n\
    \   --> /tmp/tmp72ppepvw.rs:20:19\n    |\n7   | fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    |                          ------- move occurs\
    \ because `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n\
    ...\n12  |     for n in numbers {\n    |              ------- `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n...\n20  |             mid = numbers.len()\
    \ / 2;\n    |                   ^^^^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n12  |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n    }\n\
    \n    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n    for\
    \ &x in &numbers[1..] {\n        if x < largest {\n            largest = x;\n\
    \        } else if x > smallest {\n            smallest = x;\n        }\n    }\n\
    \    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpvq4m4a32.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for num in numbers {\n        if num < smallest {\n            smallest =\
    \ num;\n        }\n        if num > largest {\n            largest = num;\n  \
    \      }\n    }\n    smallest, largest\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpbst8a0so.rs:18:13\n   |\n18 |     smallest, largest\n\
    \   |             ^ expected one of 8 possible tokens\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut best = vec![numbers[0] - 1, numbers[0] - 1];\n\
    \    let mut closest = numbers[0];\n    let mut worst = numbers[0];\n    for &n\
    \ in numbers {\n        if n > best {\n            best = n;\n        }\n    \
    \    if n < worst {\n            worst = n;\n        }\n    }\n    let mut min_difference\
    \ = best.min(&worst) - 1;\n    for i in numbers.iter().rev() {\n        let difference\
    \ = i + 1;\n        if difference > min_difference {\n            min_difference\
    \ = difference;\n            closest = i;\n        }\n    }\n    (closest, min_difference)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n --> /tmp/tmpbllhw6b0.rs:8:36\n\
    \  |\n8 |     let mut best = vec![numbers[0] - 1, numbers[0] - 1];\n  |      \
    \                              ^ no implementation for `f64 - {integer}`\n  |\n\
    \  = help: the trait `Sub<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n            <&'a f32\
    \ as Sub<f32>>\n            <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n\
    \            <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n      \
    \      <&'a i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a\
    \ isize as Sub<isize>>\n          and 48 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     let mut best = vec![numbers[0]\
    \ - 1.0, numbers[0] - 1];\n  |                                       ++\n\nerror[E0277]:\
    \ cannot subtract `{integer}` from `f64`\n --> /tmp/tmpbllhw6b0.rs:8:52\n  |\n\
    8 |     let mut best = vec![numbers[0] - 1, numbers[0] - 1];\n  |            \
    \                                        ^ no implementation for `f64 - {integer}`\n\
    \  |\n  = help: the trait `Sub<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n            <&'a f32\
    \ as Sub<f32>>\n            <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n\
    \            <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n      \
    \      <&'a i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a\
    \ isize as Sub<isize>>\n          and 48 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     let mut best = vec![numbers[0]\
    \ - 1, numbers[0] - 1.0];\n  |                                               \
    \        ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbllhw6b0.rs:11:9\n\
    \   |\n11 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n    let mut index = 0;\n    let mut best_distance = numbers[0] - numbers[1];\n\
    \    let mut best_index = index;\n    while index < numbers.len() {\n        if\
    \ numbers[index] - best_distance < best_distance {\n            best_distance\
    \ = numbers[index] - best_distance;\n            best_index = index;\n       \
    \ }\n        index += 1;\n    }\n    (numbers[best_index], numbers[best_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpe1xwdsjo.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut min_diff = numbers[0] - numbers[1];\n        let\
    \ mut min_diff = numbers[1] - numbers[0];\n\n        let mut first_number = numbers[0];\n\
    \        let mut second_number = numbers[1];\n\n        for n in numbers[2..]\
    \ {\n            let diff = n - first_number;\n            if diff < min_diff\
    \ {\n                min_diff = diff;\n                first_number = n;\n   \
    \         } else if diff == min_diff {\n                second_number = n;\n \
    \           }\n        }\n        (first_number, second_number)\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpa20g1azj.rs:17:18\n   |\n17 |         for n in numbers[2..]\
    \ {\n   |                  ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n17 |         for n in &numbers[2..]\
    \ {\n   |                  +\n17 |         for n in &mut numbers[2..] {\n   |\
    \                  ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpa20g1azj.rs:17:18\n\
    \   |\n17 |         for n in numbers[2..] {\n   |                  ^^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[f64]: IntoIterator` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing\
    \ here\n   |\n17 |         for n in &numbers[2..] {\n   |                  +\n\
    17 |         for n in &mut numbers[2..] {\n   |                  ++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for &n in numbers {\n        if n < smallest {\n            smallest = n;\n\
    \        }\n        if n > largest {\n            largest = n;\n        }\n  \
    \  }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_3cnj1m.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0].clone(); let mut largest\
    \ = numbers[0].clone();\n\n    for &x in numbers {\n        if x < smallest {\n\
    \            smallest = x;\n        }\n        if x > largest {\n            largest\
    \ = x;\n        }\n    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpln4_t4_j.rs:10:9\n   |\n\
    10 |     for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (f64::NAN, f64::NAN);\n\
    \    }\n    let mut index = 0;\n    let mut min = numbers[index];\n    let mut\
    \ max = numbers[index];\n    for (i, n) in numbers.iter().enumerate() {\n    \
    \    if n == min {\n            index = i;\n            min = n;\n        }\n\
    \        if n == max {\n            index = i;\n            max = n;\n       \
    \ }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgaw2695_.rs:17:19\n   |\n\
    12 |     let mut min = numbers[index];\n   |                   --------------\
    \ expected due to this value\n...\n17 |             min = n;\n   |           \
    \        ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n17 |             min = *n;\n   |                   +\n\nerror[E0277]:\
    \ can't compare `&f64` with `f64`\n  --> /tmp/tmpgaw2695_.rs:15:14\n   |\n15 |\
    \         if n == min {\n   |              ^^ no implementation for `&f64 == f64`\n\
    \   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgaw2695_.rs:21:19\n\
    \   |\n13 |     let mut max = numbers[index];\n   |                   --------------\
    \ expected due to this value\n...\n21 |             max = n;\n   |           \
    \        ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n21 |             max = *n;\n   |                   +\n\nerror[E0277]:\
    \ can't compare `&f64` with `f64`\n  --> /tmp/tmpgaw2695_.rs:19:14\n   |\n19 |\
    \         if n == max {\n   |              ^^ no implementation for `&f64 == f64`\n\
    \   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter().cloned().zip(numbers)\n        .enumerate()\n\
    \        .filter_map(|(i, number)| {\n            if i == 0 {\n              \
    \  Some((number, number))\n            } else {\n                let distance\
    \ = std::f64::distance(number, numbers[i - 1]);\n                if distance <\
    \ number {\n                    Some((number, numbers[i - 1]))\n             \
    \   } else {\n                    None\n                }\n            }\n   \
    \     })\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `distance` in module `std::f64`\n  -->\
    \ /tmp/tmpqpfcui3t.rs:14:42\n   |\n14 |                 let distance = std::f64::distance(number,\
    \ numbers[i - 1]);\n   |                                          ^^^^^^^^ not\
    \ found in `std::f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqpfcui3t.rs:16:35\n\
    \   |\n16 |                     Some((number, numbers[i - 1]))\n   |         \
    \                          ^^^^^^^^^^^^^^ expected tuple, found `f64`\n   |\n\
    \   = note: expected tuple `(f64, f64)`\n               found type `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqpfcui3t.rs:8:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n8  | /     numbers.iter().cloned().zip(numbers)\n\
    9  | |         .enumerate()\n10 | |         .filter_map(|(i, number)| {\n11 |\
    \ |             if i == 0 {\n...  |\n21 | |         })\n22 | |         .collect::<Vec<_>>()\n\
    \   | |____________________________^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected tuple `(f64, f64)`\n             found struct `Vec<((f64,\
    \ f64), (f64, f64))>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = Vec::new();\n    min_dist.push((numbers[0],\
    \ numbers[0]));\n    for &n in numbers {\n        let d = n - min_dist[0][1];\n\
    \        min_dist.push((n, min_dist[0][1] + d));\n    }\n    min_dist.iter().fold(\n\
    \        (0, 0.0),\n        |(min_dist1, min_dist2), &(v, w)) => (\n         \
    \       min_dist1.1.min(|&(_, d)| d < w ? d : w),\n                min_dist2.1.max(|&(_,\
    \ d)| d > w ? d : w)\n            )\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `:` or `|`, found `)`\n  --> /tmp/tmp5xum84vn.rs:16:41\n\
    \   |\n16 |         |(min_dist1, min_dist2), &(v, w)) => (\n   |             \
    \                            ^ expected one of `:` or `|`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5xum84vn.rs:10:9\n   |\n10 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror[E0608]: cannot index into a value of\
    \ type `(f64, f64)`\n  --> /tmp/tmp5xum84vn.rs:11:21\n   |\n11 |         let d\
    \ = n - min_dist[0][1];\n   |                     ^^^^^^^^^^^^^^ help: to access\
    \ tuple elements, use: `min_dist[0].1`\n\nerror[E0608]: cannot index into a value\
    \ of type `(f64, f64)`\n  --> /tmp/tmp5xum84vn.rs:12:27\n   |\n12 |         min_dist.push((n,\
    \ min_dist[0][1] + d));\n   |                           ^^^^^^^^^^^^^^ help: to\
    \ access tuple elements, use: `min_dist[0].1`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for number in numbers.iter() {\n        if number < smallest {\n       \
    \     smallest = number;\n        }\n\n        if number > largest {\n       \
    \     largest = number;\n        }\n    }\n\n    (smallest, largest)\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxg4zikx7.rs:12:21\n   |\n\
    12 |         if number < smallest {\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxg4zikx7.rs:13:24\n   |\n8  |     let mut smallest\
    \ = numbers[0];\n   |                        ---------- expected due to this value\n\
    ...\n13 |             smallest = number;\n   |                        ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13\
    \ |             smallest = *number;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxg4zikx7.rs:16:21\n   |\n16 |         if number\
    \ > largest {\n   |                     ^^^^^^^\n   |                     |\n\
    \   |                     expected `&f64`, found `f64`\n   |                 \
    \    help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxg4zikx7.rs:17:23\n   |\n9  |     let mut largest = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n17 | \
    \            largest = number;\n   |                       ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |    \
    \         largest = *number;\n   |                       +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers.iter().min().unwrap();\n   \
    \ let mut largest = numbers.iter().max().unwrap();\n    let mut i = 0;\n    for\
    \ (index, x) in numbers.iter().enumerate() {\n        if index == i {\n      \
    \      continue;\n        }\n        if x < smallest {\n            smallest =\
    \ x;\n            i = index;\n        }\n        if x > largest {\n          \
    \  largest = x;\n            i = index;\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzip4df5f.rs:8:39\n\
    \     |\n8    |     let mut smallest = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzip4df5f.rs:9:38\n\
    \     |\n9    |     let mut largest = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzip4df5f.rs:24:6\n   |\n24 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `f64`, found `&f64`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n24 |     (*smallest, largest)\n\
    \   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzip4df5f.rs:24:16\n\
    \   |\n24 |     (smallest, largest)\n   |                ^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |    \
    \ (smallest, *largest)\n   |                +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0..numbers.len()).fold(0.0,\
    \ |acc, i| {\n            return if acc < numbers[0] {\n                numbers[0]\n\
    \            } else if acc > numbers[0] {\n                numbers[1]\n      \
    \      } else if numbers[0] < numbers[1] {\n                numbers[0]\n     \
    \       } else {\n                numbers[1]\n            }\n        })\n    }\n\
    \    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len() {\n   \
    \     if result[0] < numbers[i] {\n            result.swap(0, i);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkodxv_0f.rs:9:40\n  |\n9 |\
    \         return (0..numbers.len()).fold(0.0, |acc, i| {\n  |                \
    \                        ^^^ expected tuple, found floating-point number\n  |\n\
    \  = note: expected tuple `(f64, f64)`\n              found type `{float}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkodxv_0f.rs:10:29\n   |\n10 |  \
    \           return if acc < numbers[0] {\n   |                             ^^^^^^^^^^\
    \ expected tuple, found `f64`\n   |\n   = note: expected tuple `(f64, f64)`\n\
    \               found type `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkodxv_0f.rs:11:17\n\
    \   |\n11 |                 numbers[0]\n   |                 ^^^^^^^^^^ expected\
    \ tuple, found `f64`\n   |\n   = note: expected tuple `(f64, f64)`\n         \
    \      found type `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkodxv_0f.rs:12:29\n\
    \   |\n12 |             } else if acc > numbers[0] {\n   |                   \
    \          ^^^^^^^^^^ expected tuple, found `f64`\n   |\n   = note: expected tuple\
    \ `(f64, f64)`\n               found type `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkodxv_0f.rs:13:17\n   |\n13 |                 numbers[1]\n   |\
    \                 ^^^^^^^^^^ expected tuple, found `f64`\n   |\n   = note: expected\
    \ tuple `(f64, f64)`\n               found type `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkodxv_0f.rs:15:17\n   |\n15 |                 numbers[0]\n\
    \   |                 ^^^^^^^^^^ expected tuple, found `f64`\n   |\n   = note:\
    \ expected tuple `(f64, f64)`\n               found type `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkodxv_0f.rs:17:17\n   |\n17 |              \
    \   numbers[1]\n   |                 ^^^^^^^^^^ expected tuple, found `f64`\n\
    \   |\n   = note: expected tuple `(f64, f64)`\n               found type `f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkodxv_0f.rs:27:5\n   |\n7  | fn\
    \ find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |             \
    \                                   ---------- expected `(f64, f64)` because of\
    \ return type\n...\n27 |     result\n   |     ^^^^^^ expec"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Find the first element from the left side that is larger\
    \ than the last\n    let mut leftmost_element = numbers[0];\n\n    // Find the\
    \ first element from the right side that is smaller than the last\n    let mut\
    \ rightmost_element = numbers[0];\n\n    for n in numbers {\n        if n <= leftmost_element\
    \ {\n            leftmost_element = pq(n)?;\n        } else {\n            rightmost_element\
    \ = pq(n)?;\n        }\n    }\n\n    // Return the smallest element to the right\
    \ of our last element and the biggest to the left\n    (rightmost_element, leftmost_element)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pq` in this scope\n  --> /tmp/tmp4df1gpig.rs:16:32\n\
    \   |\n16 |             leftmost_element = pq(n)?;\n   |                     \
    \           ^^ not found in this scope\n\nerror[E0425]: cannot find function `pq`\
    \ in this scope\n  --> /tmp/tmp4df1gpig.rs:18:33\n   |\n18 |             rightmost_element\
    \ = pq(n)?;\n   |                                 ^^ not found in this scope\n\
    \nerror[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmp4df1gpig.rs:16:37\n\
    \   |\n7  | / fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n8 \
    \ | |     // Find the first element from the left side that is larger than the\
    \ last\n9  | |     let mut leftmost_element = numbers[0];\n10 | |\n...  |\n16\
    \ | |             leftmost_element = pq(n)?;\n   | |                         \
    \            ^ cannot use the `?` operator in a function that returns `(f64, f64)`\n\
    ...  |\n23 | |     (rightmost_element, leftmost_element)\n24 | | }\n   | |_- this\
    \ function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<_>` is not implemented for `(f64, f64)`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmp4df1gpig.rs:18:38\n\
    \   |\n7  | / fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n8 \
    \ | |     // Find the first element from the left side that is larger than the\
    \ last\n9  | |     let mut leftmost_element = numbers[0];\n10 | |\n...  |\n18\
    \ | |             rightmost_element = pq(n)?;\n   | |                        \
    \              ^ cannot use the `?` operator in a function that returns `(f64,\
    \ f64)`\n...  |\n23 | |     (rightmost_element, leftmost_element)\n24 | | }\n\
    \   | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<_>` is not implemented for `(f64, f64)`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        let current = numbers[i];\n        if\
    \ current > largest {\n            largest = current;\n        }\n        if current\
    \ < smallest {\n            smallest = current;\n        }\n    }\n    smallest,\
    \ largest\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmp68u0l_sq.rs:19:13\n   |\n19 |     smallest, largest\n\
    \   |             ^ expected one of 8 possible tokens\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        smallest = numbers[i] as f64;\n    \
    \    largest = numbers[i] as f64;\n        for j in i..numbers.len() {\n     \
    \       let dist = numbers[j] as f64 - smallest as f64;\n            if dist <\
    \ 0 {\n                smallest = numbers[j];\n            } else {\n        \
    \        largest = numbers[j];\n            }\n        }\n    }\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp052oxyb7.rs:15:23\n   |\n\
    15 |             if dist < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `f64`, found integer\n   |\
    \                       help: use a float literal: `0.0`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for i in numbers.iter().rev() {\n        if *i < min {\n            min\
    \ = *i;\n        }\n        if *i > max {\n            max = *i;\n        }\n\
    \    }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp8bgwq7jx.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_val = numbers[0]\n    let mut max_val = numbers[0]\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] > max_val {\n        \
    \    max_val = numbers[i]\n        }\n        if numbers[i] < min_val {\n    \
    \        min_val = numbers[i]\n        }\n    }\n    (min_val, max_val)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpk628lgrp.rs:8:33\n\
    \  |\n8 |     let mut min_val = numbers[0]\n  |                              \
    \   ^ help: add `;` here\n9 |     let mut max_val = numbers[0]\n  |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk628lgrp.rs:9:33\n\
    \   |\n9  |     let mut max_val = numbers[0]\n   |                           \
    \      ^ help: add `;` here\n10 |     for i in 1..numbers.len() {\n   |     ---\
    \ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ i = 0;\n    for &n in numbers {\n        if n == min {\n            i += 1;\n\
    \            continue;\n        }\n        if n == max {\n            return (&numbers[i],\
    \ &numbers[i + 1]);\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6kb4kdsx.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6kb4kdsx.rs:19:9\n   |\n19 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6kb4kdsx.rs:25:21\n   |\n25 |             return (&numbers[i], &numbers[i\
    \ + 1]);\n   |                     ^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider removing the borrow\n   |\n25 -             return (&numbers[i],\
    \ &numbers[i + 1]);\n25 +             return (numbers[i], &numbers[i + 1]);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6kb4kdsx.rs:25:34\n  \
    \ |\n25 |             return (&numbers[i], &numbers[i + 1]);\n   |           \
    \                       ^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n25 -             return (&numbers[i], &numbers[i\
    \ + 1]);\n25 +             return (&numbers[i], numbers[i + 1]);\n   | \n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut smallest = numbers[0];\n        let mut largest\
    \ = numbers[0];\n\n        for &n in numbers {\n            if smallest > n {\n\
    \                smallest = n;\n            }\n            if largest < n {\n\
    \                largest = n;\n            }\n        }\n\n        (smallest,\
    \ largest)\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmporqx8vfw.rs:14:13\n   |\n\
    14 |         for &n in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `n`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut min_element\
    \ = numbers[0];\n    let mut min_element_index = numbers[0];\n    let mut max_element\
    \ = numbers[0];\n    let mut max_element_index = numbers[0];\n    for i in 0..numbers.len()\
    \ {\n        let dist = numbers[i] - min_element;\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_element = numbers[i];\n   \
    \         min_element_index = i;\n        }\n        let dist = numbers[i] - max_element;\n\
    \        if dist > max_dist {\n            max_dist = dist;\n            max_element\
    \ = numbers[i];\n            max_element_index = i;\n        }\n    }\n    (min_element,\
    \ min_element_index), (max_element, max_element_index)\n}\n\nfn main() {\n   \
    \ let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmp3n5p3cfs.rs:27:37\n   |\n27 |     (min_element, min_element_index),\
    \ (max_element, max_element_index)\n   |                                     ^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]: cannot find\
    \ value `max_dist` in this scope\n  --> /tmp/tmp3n5p3cfs.rs:21:19\n   |\n21 |\
    \         if dist > max_dist {\n   |                   ^^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_dist`\n\nerror[E0425]: cannot find\
    \ value `max_dist` in this scope\n  --> /tmp/tmp3n5p3cfs.rs:22:13\n   |\n22 |\
    \             max_dist = dist;\n   |             ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `min_dist`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3n5p3cfs.rs:18:33\n   |\n10 |     let mut min_element_index = numbers[0];\n\
    \   |                                 ---------- expected due to this value\n\
    ...\n18 |             min_element_index = i;\n   |                           \
    \      ^ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to\
    \ an `f64`, producing the floating point representation of the integer, rounded\
    \ if necessary\n   |\n18 |             min_element_index = i as f64;\n   |   \
    \                                ++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3n5p3cfs.rs:24:33\n   |\n12 |     let mut max_element_index = numbers[0];\n\
    \   |                                 ---------- expected due to this value\n\
    ...\n24 |             max_element_index = i;\n   |                           \
    \      ^ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to\
    \ an `f64`, producing the floating point representation of the integer, rounded\
    \ if necessary\n   |\n24 |             max_element_index = i as f64;\n   |   \
    \                                ++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0]\n    let mut max = numbers[0]\n\
    \    for &n in numbers {\n        if n > min {\n            max = n;\n       \
    \ } else if n < max {\n            min = n;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpx2xfvp5k.rs:8:29\n\
    \  |\n8 |     let mut min = numbers[0]\n  |                             ^ help:\
    \ add `;` here\n9 |     let mut max = numbers[0]\n  |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpx2xfvp5k.rs:9:29\n \
    \  |\n9  |     let mut max = numbers[0]\n   |                             ^ help:\
    \ add `;` here\n10 |     for &n in numbers {\n   |     --- unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx2xfvp5k.rs:10:9\n   |\n10 |   \
    \  for &n in numbers {\n   |         ^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for i in 1..numbers.len() {\n \
    \       if numbers[i] > largest_number {\n            largest_number = numbers[i];\n\
    \        }\n        if numbers[i] < smallest_number {\n            smallest_number\
    \ = numbers[i];\n        }\n    }\n    (smallest_number, largest_number)\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmphmxuu_lq.rs:8:13\n\
    \    |\n8   |     numbers.sort();\n    |             ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.length >= 2);\n    let mut closest = numbers[0];\n\
    \    let mut farthest = numbers[0];\n    for n in numbers.iter().skip(1) {\n \
    \       let d = n.f64() - closest.f64();\n        if d < closest {\n         \
    \   closest = n;\n        }\n        if d > farthest {\n            farthest =\
    \ n;\n        }\n    }\n    (closest, farthest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<f64>`\n --> /tmp/tmpfuwdmilb.rs:8:21\n\
    \  |\n8 |     assert!(numbers.length >= 2);\n  |                     ^^^^^^ unknown\
    \ field\n\nerror[E0599]: no method named `f64` found for reference `&f64` in the\
    \ current scope\n  --> /tmp/tmpfuwdmilb.rs:12:19\n   |\n12 |         let d = n.f64()\
    \ - closest.f64();\n   |                   ^^^ method not found in `&f64`\n\n\
    error[E0599]: no method named `f64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpfuwdmilb.rs:12:35\n   |\n12 |         let d = n.f64() - closest.f64();\n\
    \   |                                   ^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfuwdmilb.rs:14:23\n   |\n9  |     let mut closest\
    \ = numbers[0];\n   |                       ---------- expected due to this value\n\
    ...\n14 |             closest = n;\n   |                       ^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |    \
    \         closest = *n;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfuwdmilb.rs:17:24\n   |\n10 |     let mut farthest = numbers[0];\n\
    \   |                        ---------- expected due to this value\n...\n17 |\
    \             farthest = n;\n   |                        ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |          \
    \   farthest = *n;\n   |                        +\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    debug_assert_eq!(numbers.len(), 2);\n\n    let min_ind\
    \ = 0..numbers[0].cmp(&numbers[1]);\n    let min_ind = min_ind.iter().cloned().collect();\n\
    \n    let max_ind = numbers[0].cmp(&numbers[1]);\n    let max_ind = max_ind.iter().cloned().collect();\n\
    \n    (min_ind[0], min_ind[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n  --> /tmp/tmpe_cduiaa.rs:10:33\n\
    \   |\n10 |     let min_ind = 0..numbers[0].cmp(&numbers[1]);\n   |          \
    \                       ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `std::ops::Range` in the current scope\n  --> /tmp/tmpe_cduiaa.rs:11:27\n\
    \   |\n11 |     let min_ind = min_ind.iter().cloned().collect();\n   |       \
    \                    ^^^^ method not found in `std::ops::Range<{integer}>`\n\n\
    error[E0599]: `f64` is not an iterator\n  --> /tmp/tmpe_cduiaa.rs:13:30\n   |\n\
    13 |     let max_ind = numbers[0].cmp(&numbers[1]);\n   |                    \
    \          ^^^ `f64` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `f64: Iterator`\n           which is\
    \ required by `&mut f64: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_square = std::f64::MAX;\n    let mut closest_value\
    \ = 0.0;\n    let mut closest_index = 0;\n\n    for i in 0..numbers.len() {\n\
    \        if numbers[i] < closest_value {\n            closest_value = numbers[i];\n\
    \            closest_index = i;\n        }\n\n        if smallest_square > numbers[i]\
    \ * numbers[i] {\n            smallest_square = numbers[i] * numbers[i];\n   \
    \     }\n    }\n\n    (closest_value, closest_index)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3j245gtc.rs:23:21\n   |\n\
    23 |     (closest_value, closest_index)\n   |                     ^^^^^^^^^^^^^\
    \ expected `f64`, found `usize`\n   |\nhelp: you can cast a `usize` to an `f64`,\
    \ producing the floating point representation of the integer, rounded if necessary\n\
    \   |\n23 |     (closest_value, closest_index as f64)\n   |                  \
    \                 ++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut index = 0;\n\n    while index < numbers.len() {\n\
    \        let new_value = numbers[index] + 1.0;\n        let mut new_value = std::f64::MAX;\n\
    \        let mut index = index + 1;\n\n        while index < numbers.len() {\n\
    \            if new_value < numbers[index] {\n                new_value = numbers[index];\n\
    \            }\n            index = index + 1;\n        }\n        (numbers[index\
    \ & 1], new_value)\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7z85qx1o.rs:21:9\n   |\n\
    10 | /     while index < numbers.len() {\n11 | |         let new_value = numbers[index]\
    \ + 1.0;\n12 | |         let mut new_value = std::f64::MAX;\n13 | |         let\
    \ mut index = index + 1;\n...  |\n21 | |         (numbers[index & 1], new_value)\n\
    \   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found tuple\n22\
    \ | |     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                  found tuple `(f64, f64)`\nhelp: you might\
    \ have meant to return this value\n   |\n21 |         return (numbers[index &\
    \ 1], new_value);\n   |         ++++++                                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7z85qx1o.rs:10:5\n   |\n7  |   fn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n   |                                            \
    \      ---------- expected `(f64, f64)` because of return type\n...\n10 | /  \
    \   while index < numbers.len() {\n11 | |         let new_value = numbers[index]\
    \ + 1.0;\n12 | |         let mut new_value = std::f64::MAX;\n13 | |         let\
    \ mut index = index + 1;\n...  |\n21 | |         (numbers[index & 1], new_value)\n\
    22 | |     }\n   | |_____^ expected tuple, found `()`\n   |\n   = note:  expected\
    \ tuple `(f64, f64)`\n           found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.windows(2).min_by_key(|&(mut a, _)| a).enumerate()\n\
    \        .find(|(_, mut b)| b == numbers.last())\n        .expect(\"two numbers\
    \ are too close\")\n        .1\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9zjiprwx.rs:8:37\n  |\n8 |\
    \     numbers.windows(2).min_by_key(|&(mut a, _)| a).enumerate()\n  |        \
    \                             ^^^^^^^^^-\n  |                                \
    \     |        |\n  |                                     |        expected due\
    \ to this\n  |                                     expected slice `[f64]`, found\
    \ tuple\n  |\n  = note: expected slice `[f64]`\n             found tuple `(_,\
    \ _)`\n\nerror[E0599]: `Option<&[f64]>` is not an iterator\n   --> /tmp/tmp9zjiprwx.rs:8:52\n\
    \    |\n8   |       numbers.windows(2).min_by_key(|&(mut a, _)| a).enumerate()\n\
    \    |                                                      ^^^^^^^^^ `Option<&[f64]>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&[f64]>: Iterator`\n            which is required by `&mut\
    \ Option<&[f64]>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (0.0, 0.0)\n    }\n   \
    \ else {\n        let mut smallest_number = numbers[0];\n        let mut largest_number\
    \ = numbers[0];\n        for number in numbers {\n            if number < smallest_number\
    \ {\n                smallest_number = number;\n            }\n            if\
    \ number > largest_number {\n                largest_number = number;\n      \
    \      }\n        }\n        (smallest_number, largest_number)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp219uu3xv.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n\n    let mut closest_1 = numbers[0];\n    let mut closest_2 = numbers[0];\n\
    \    let mut index = 1;\n\n    while index < numbers.len() {\n        if f64::from(closest_1)\
    \ < f64::from(numbers[index]) {\n            closest_1 = numbers[index];\n   \
    \     }\n\n        if f64::from(closest_2) < f64::from(numbers[index]) {\n   \
    \         closest_2 = numbers[index];\n        }\n\n        index += 1\n    }\n\
    \n    (closest_1, closest_2)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp7b_g53i6.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0].abs();\n    let mut max = numbers[0].abs();\n\
    \n    for &n in numbers {\n        if n < min {\n            min = n;\n      \
    \  }\n        if n > max {\n            max = n;\n        }\n    }\n    if min\
    \ > max {\n        (max, min)\n    } else {\n        (min, max)\n    }\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvc0oo62h.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_dist = std::f64::MAX;\n    let mut second_smallest_dist\
    \ = std::f64::MAX;\n\n    for num in numbers {\n        let distance = num.abs()\
    \ - (numbers.iter().skip(1).take(1).sum().unwrap());\n        if distance < &mut\
    \ smallest_dist {\n            smallest_dist = distance;\n        }\n        if\
    \ distance < &mut second_smallest_dist {\n            second_smallest_dist = distance;\n\
    \        }\n    }\n    (numbers[numbers.iter().skip(1).take(1).sum().unwrap()],\
    \ numbers[second_smallest_dist])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpf1x_7c1r.rs:12:68\n\
    \   |\n12 |         let distance = num.abs() - (numbers.iter().skip(1).take(1).sum().unwrap());\n\
    \   |                                                                    ^^^ cannot\
    \ infer type for type parameter `S` declared on the associated function `sum`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n12 |         let distance = num.abs()\
    \ - (numbers.iter().skip(1).take(1).sum::<S>().unwrap());\n   |              \
    \                                                         +++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf1x_7c1r.rs:13:23\n   |\n13 |         if distance\
    \ < &mut smallest_dist {\n   |                       ^^^^^^^^^^^^^^^^^^ expected\
    \ `f64`, found `&mut f64`\n   |\nhelp: consider removing the borrow\n   |\n13\
    \ -         if distance < &mut smallest_dist {\n13 +         if distance < smallest_dist\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf1x_7c1r.rs:16:23\n\
    \   |\n16 |         if distance < &mut second_smallest_dist {\n   |          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&mut f64`\n   |\n\
    help: consider removing the borrow\n   |\n16 -         if distance < &mut second_smallest_dist\
    \ {\n16 +         if distance < second_smallest_dist {\n   | \n\nerror[E0277]:\
    \ the type `[f64]` cannot be indexed by `f64`\n  --> /tmp/tmpf1x_7c1r.rs:20:62\n\
    \   |\n20 |     (numbers[numbers.iter().skip(1).take(1).sum().unwrap()], numbers[second_smallest_dist])\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[f64]>` is not implemented for `f64`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<f64>` for `Vec<f64>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0282,\
    \ E0308.\nFor more information about an error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_diff;\n    let mut closest_i = 0;\n  \
    \  for &n in &numbers {\n        let diff_i = n.abs() - &numbers[closest_i].abs();\n\
    \        if diff_i < smallest_diff {\n            smallest_diff = diff_i;\n  \
    \          closest_i = *numbers.iter().position(|n| *n >= *n).unwrap();\n    \
    \    }\n    }\n    (&numbers[closest_i], &numbers[closest_i + 1])\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpc73sc9wz.rs:14:25\n\
    \   |\n14 |             closest_i = *numbers.iter().position(|n| *n >= *n).unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc73sc9wz.rs:17:6\n   |\n17 | \
    \    (&numbers[closest_i], &numbers[closest_i + 1])\n   |      ^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider removing the borrow\n   |\n\
    17 -     (&numbers[closest_i], &numbers[closest_i + 1])\n17 +     (numbers[closest_i],\
    \ &numbers[closest_i + 1])\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc73sc9wz.rs:17:27\n\
    \   |\n17 |     (&numbers[closest_i], &numbers[closest_i + 1])\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\n\
    help: consider removing the borrow\n   |\n17 -     (&numbers[closest_i], &numbers[closest_i\
    \ + 1])\n17 +     (&numbers[closest_i], numbers[closest_i + 1])\n   | \n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_index = -1;\n    let mut largest_index\
    \ = -1;\n\n    for &num in numbers {\n        let index = numbers.iter().position(|x|\
    \ x.abs() < num).unwrap();\n        if index > smallest_index {\n            smallest_index\
    \ = index;\n        }\n\n        if index > largest_index {\n            largest_index\
    \ = index;\n        }\n    }\n\n    (numbers[smallest_index], numbers[largest_index])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbkz0gmft.rs:11:9\n   |\n\
    11 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpbkz0gmft.rs:8:30\n\
    \  |\n8 |     let mut smallest_index = -1;\n  |                              ^^\
    \ the trait `Neg` is not implemented for `usize`\n  |\n  = help: the following\
    \ other types implement trait `Neg`:\n            &f32\n            &f64\n   \
    \         &i128\n            &i16\n            &i32\n            &i64\n      \
    \      &i8\n            &isize\n          and 8 others\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n --> /tmp/tmpbkz0gmft.rs:9:29\n  |\n9 |\
    \     let mut largest_index = -1;\n  |                             ^^ the trait\
    \ `Neg` is not implemented for `usize`\n  |\n  = help: the following other types\
    \ implement trait `Neg`:\n            &f32\n            &f64\n            &i128\n\
    \            &i16\n            &i32\n            &i64\n            &i8\n     \
    \       &isize\n          and 8 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort();\n\
    \    let first_elem = sorted_numbers[0];\n    let mut closest_elem = sorted_numbers[0];\n\
    \    let mut current_min_val = first_elem;\n    let mut current_max_val = first_elem;\n\
    \    for i in sorted_numbers.iter_mut().skip(1) {\n        if *i < current_min_val\
    \ {\n            current_min_val = *i;\n            closest_elem = i;\n      \
    \  }\n        if *i > current_max_val {\n            current_max_val = *i;\n \
    \       }\n    }\n    (current_min_val, closest_elem)\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpjli204_n.rs:9:20\n\
    \    |\n9   |     sorted_numbers.sort();\n    |                    ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjli204_n.rs:17:28\n\
    \   |\n11 |     let mut closest_elem = sorted_numbers[0];\n   |              \
    \              ----------------- expected due to this value\n...\n17 |       \
    \      closest_elem = i;\n   |                            ^ expected `f64`, found\
    \ `&mut f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |      \
    \       closest_elem = *i;\n   |                            +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min: f64 = numbers[0];\n    let mut max: f64 =\
    \ numbers[0];\n\n    for (index, number) in numbers.iter().enumerate() {\n   \
    \     if number < min {\n            min = number;\n        }\n        if number\
    \ > max {\n            max = number;\n        }\n    }\n\n    // The min and max\
    \ are now the closest elements.\n    let mut smallest_index = index;\n    let\
    \ mut biggest_index = index;\n\n    for &index in numbers.iter().rev() {\n   \
    \     let number = numbers[index];\n        if number < min {\n            min\
    \ = number;\n            smallest_index = index;\n        }\n        if number\
    \ > max {\n            max = number;\n            biggest_index = index;\n   \
    \     }\n    }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `index` in this scope\n  --> /tmp/tmpqjrvyh0o.rs:21:30\n\
    \   |\n21 |     let mut smallest_index = index;\n   |                        \
    \      ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `index`\
    \ in this scope\n  --> /tmp/tmpqjrvyh0o.rs:22:29\n   |\n22 |     let mut biggest_index\
    \ = index;\n   |                             ^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqjrvyh0o.rs:12:21\n   |\n12 |  \
    \       if number < min {\n   |                     ^^^\n   |                \
    \     |\n   |                     expected `&f64`, found `f64`\n   |         \
    \            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqjrvyh0o.rs:13:19\n   |\n8  |     let mut min: f64 = numbers[0];\n\
    \   |                  --- expected due to this type\n...\n13 |             min\
    \ = number;\n   |                   ^^^^^^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n13 |             min = *number;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqjrvyh0o.rs:15:21\n\
    \   |\n15 |         if number > max {\n   |                     ^^^\n   |    \
    \                 |\n   |                     expected `&f64`, found `f64`\n \
    \  |                     help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqjrvyh0o.rs:16:19\n   |\n9  |     let mut max:\
    \ f64 = numbers[0];\n   |                  --- expected due to this type\n...\n\
    16 |             max = number;\n   |                   ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |    \
    \         max = *number;\n   |                   +\n\nerror[E0277]: the type `[f64]`\
    \ cannot be indexed by `f64`\n  --> /tmp/tmpqjrvyh0o.rs:25:22\n   |\n25 |    \
    \     let number = numbers[index];\n   |                      ^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[f64]>` is not implemented for `f64`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: r"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0])\n\
    \    }\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for n in numbers {\n        if n <= smallest {\n            smallest = n;\n\
    \        }\n        if n >= largest {\n            largest = n;\n        }\n \
    \   }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmptp2hmemh.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Find smallest and largest\n    let smallest = numbers.iter().min_by_key(|num|\
    \ num);\n    let largest = numbers.iter().max_by_key(|num| num);\n\n    // If\
    \ smallest == largest we still have two numbers to return so the second value\
    \ isn't needed\n    if smallest == largest {\n        return smallest, smallest;\n\
    \    }\n\n    // Calculate delta\n    let mut delta: f64;\n    delta = largest\
    \ - smallest;\n\n    // Calculate the first value\n    let first_value = smallest\
    \ + delta;\n\n    // Calculate the second value by finding the closest value to\
    \ the first one\n    let second_value = numbers.iter().find(|num| num == first_value).unwrap();\n\
    \    (first_value, second_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpxtcmkzty.rs:14:24\n   |\n14 |         return smallest,\
    \ smallest;\n   |                        ^ expected one of 8 possible tokens\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxtcmkzty.rs:9:46\n\
    \     |\n9    |     let smallest = numbers.iter().min_by_key(|num| num);\n   \
    \  |                                   ---------- ^^^^^^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |                                   |\n    \
    \ |                                   required by a bound introduced by this call\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\n     = note: 1 redundant requirement hidden\n\
    \     = note: required because of the requirements on the impl of `Ord` for `&&f64`\n\
    note: required by a bound in `std::iter::Iterator::min_by_key`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxtcmkzty.rs:10:45\n\
    \     |\n10   |     let largest = numbers.iter().max_by_key(|num| num);\n    \
    \ |                                  ---------- ^^^^^^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |                                  |\n     |   \
    \                               required by a bound introduced by this call\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\n     = note: 1 redundant requirement hidden\n\
    \     = note: required because of the requirements on the impl of `Ord` for `&&f64`\n\
    note: required by a bound in `std::iter::Iterato"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ num)| {\n            if i < 2 {\n                Some(num)\n            } else\
    \ {\n                let (min_val, max_val) = numbers.iter().min_max();\n    \
    \            Some((num - min_val).abs(), max_val.abs())\n            }\n     \
    \   })\n        .min()\n        .last()\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `min_max` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpixrftv_5.rs:14:57\n   |\n14 |          \
    \       let (min_val, max_val) = numbers.iter().min_max();\n   |             \
    \                                            ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ f64>`\n\nerror[E0061]: this enum variant takes 1 argument but 2 arguments were\
    \ supplied\n  --> /tmp/tmpixrftv_5.rs:15:17\n   |\n15 |                 Some((num\
    \ - min_val).abs(), max_val.abs())\n   |                 ^^^^ ---------------------\
    \  ------------- supplied 2 arguments\n   |                 |\n   |          \
    \       expected 1 argument\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmpixrftv_5.rs:18:10\n     |\n18   |         .min()\n\
    \     |          ^^^ the trait `Ord` is not implemented for `f64`\n     |\n  \
    \   = help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0599]:\
    \ the method `last` exists for enum `Option<&f64>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpixrftv_5.rs:19:10\n    |\n19  |           .last()\n\
    \    |            ^^^^ method cannot be called on `Option<&f64>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&f64>: Iterator`\n            which is required by `&mut\
    \ Option<&f64>: Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let min_element = numbers.iter().min();\n    let max_element\
    \ = numbers.iter().max();\n\n    (min_element, max_element)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr3l3glb5.rs:8:38\n\
    \     |\n8    |     let min_element = numbers.iter().min();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr3l3glb5.rs:9:38\n\
    \     |\n9    |     let max_element = numbers.iter().max();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3l3glb5.rs:11:6\n   |\n11 | \
    \    (min_element, max_element)\n   |      ^^^^^^^^^^^ expected `f64`, found enum\
    \ `Option`\n   |\n   = note: expected type `f64`\n              found enum `Option<&f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3l3glb5.rs:11:19\n   |\n11 |\
    \     (min_element, max_element)\n   |                   ^^^^^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<&f64>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut lowest_difference = numbers[0] - numbers[1];\n\
    \    let mut best_val = numbers[0];\n    for &n in numbers[1..] {\n        let\
    \ difference = n - best_val;\n        if difference < lowest_difference {\n  \
    \          lowest_difference = difference;\n            best_val = n;\n      \
    \  }\n    }\n    (best_val, lowest_difference)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmp55p5smlc.rs:10:15\n   |\n10 |     for &n in numbers[1..]\
    \ {\n   |               ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n10 |     for &n in &numbers[1..]\
    \ {\n   |               +\n10 |     for &n in &mut numbers[1..] {\n   |      \
    \         ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmp55p5smlc.rs:10:15\n\
    \   |\n10 |     for &n in numbers[1..] {\n   |               ^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n \
    \  |\n10 |     for &n in &numbers[1..] {\n   |               +\n10 |     for &n\
    \ in &mut numbers[1..] {\n   |               ++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers[0..numbers.len().min(2)].iter().cloned().min().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8m6ew9x2.rs:8:54\n\
    \     |\n8    |     numbers[0..numbers.len().min(2)].iter().cloned().min().unwrap()\n\
    \     |                                                      ^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp8m6ew9x2.rs:8:5\n  |\n7 | fn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n  |                                                ----------\
    \ expected `(f64, f64)` because of return type\n8 |     numbers[0..numbers.len().min(2)].iter().cloned().min().unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found `f64`\n  |\n  = note: expected tuple `(f64, f64)`\n           \
    \   found type `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let min_val = numbers.iter().min();\n    let max_val =\
    \ numbers.iter().max();\n\n    // get the index of the two elements that are closest\
    \ to eachother\n    let mut min_val_ix: usize = 0;\n    let mut max_val_ix: usize\
    \ = 0;\n    for i in numbers.iter().cloned().skip(1) {\n        // check if the\
    \ ith number is closer to the minimum than the minimum so far\n        let closest_val\
    \ = min(i, min_val);\n        let current_val_ix = min_val_ix;\n        if closest_val\
    \ == current_val_ix {\n            // if this element has already been found,\
    \ then just use the smallest index to search for the second element\n        \
    \    min_val_ix = i;\n        }\n        else {\n            // if this element\
    \ has not already been found then set the new minimum index to the current index\
    \ and the second\n            // index to the smallest index to search for elements\
    \ with the current value\n            min_val_ix = current_val_ix;\n         \
    \   max_val_ix = i;\n        }\n    }\n\n    // return the two closest values\
    \ to the minimum value\n    (numbers[min_val_ix], numbers[max_val_ix])\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp4g5_c5fg.rs:16:27\n\
    \   |\n16 |         let closest_val = min(i, min_val);\n   |                 \
    \          ^^^\n...\n34 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    16 |         let closest_val = main(i, min_val);\n   |                       \
    \    ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4g5_c5fg.rs:8:34\n\
    \     |\n8    |     let min_val = numbers.iter().min();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4g5_c5fg.rs:9:34\n\
    \     |\n9    |     let max_val = numbers.iter().max();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4g5_c5fg.rs:20:26\n   |\n12 |\
    \     let mut min_val_ix: usize = 0;\n   |                         ----- expected\
    \ due to this type\n...\n20 |             min_val_ix = i;\n   |              \
    \            ^ expected `usize`, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4g5_c5fg.rs:26:26\n "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] - numbers[i - 1] > 0.0\
    \ {\n            if numbers[i - 1] > numbers[i] {\n                max = numbers[i\
    \ - 1];\n            } else {\n                min = numbers[i];\n           \
    \ }\n        } else {\n            if numbers[i - 1] < numbers[i] {\n        \
    \        min = numbers[i - 1];\n            } else {\n                max = numbers[i];\n\
    \            }\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpjxkvdux2.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort_unstable_by_key(|x| x.abs());\n    (numbers[0],\
    \ numbers[1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo06s7jlq.rs:8:34\n\
    \     |\n8    |     numbers.sort_unstable_by_key(|x| x.abs());\n     |       \
    \      -------------------- ^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |             |\n     |             required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `Ord`:\n               i128\n               i16\n               i32\n      \
    \         i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::sort_unstable_by_key`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min: f64 = numbers.iter().min().unwrap();\n   \
    \ let mut max: f64 = numbers.iter().max().unwrap();\n\n    for number in numbers.iter().skip(2)\
    \ {\n        if number < min {\n            min = number;\n        }\n       \
    \ if number > max {\n            max = number;\n        }\n    }\n\n    (min,\
    \ max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphq7ym75a.rs:8:39\n\
    \     |\n8    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmphq7ym75a.rs:8:24\n  |\n8 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n8 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmphq7ym75a.rs:9:39\n     |\n9    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmphq7ym75a.rs:9:24\n  |\n9 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     let\
    \ mut max: f64 = *num"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_distance = std::f64::MAX;\n    let mut\
    \ second_smallest_distance = std::f64::MAX;\n\n    for number in numbers {\n \
    \       let distance = numbers.iter().position(|x| x < number).unwrap_or(numbers.len());\n\
    \        if smallest_distance > number {\n            smallest_distance = number;\n\
    \        }\n        if second_smallest_distance > number {\n            second_smallest_distance\
    \ = number;\n        }\n    }\n\n    (smallest_distance, second_smallest_distance)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuy6bkfhk.rs:12:56\n   |\n\
    12 |         let distance = numbers.iter().position(|x| x < number).unwrap_or(numbers.len());\n\
    \   |                                                        ^^^^^^\n   |    \
    \                                                    |\n   |                 \
    \                                       expected `&f64`, found `f64`\n   |   \
    \                                                     help: consider borrowing\
    \ here: `&number`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., numbers[0]);\n\
    \    }\n\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    let\
    \ mut min_index = -1;\n    let mut max_index = -1;\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < min {\n            min = numbers[i];\n          \
    \  min_index = i;\n        }\n        if numbers[i] > max {\n            max =\
    \ numbers[i];\n            max_index = i;\n        }\n    }\n\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpj6i826ua.rs:14:25\n\
    \   |\n14 |     let mut min_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpj6i826ua.rs:15:25\n   |\n15 | \
    \    let mut max_index = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n\
    \    }\n    let mut min_distance = numbers[0];\n    let mut min_number = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        let distance = numbers[i] - numbers[i\
    \ - 1];\n        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = numbers[i - 1];\n        }\n    }\n    (min_number,\
    \ min_distance)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, -2.8)`,\n right: `(3.9, 4.0)`', /tmp/tmpw3ilpqk0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \n    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n        if n > max_val {\n            max_val = n;\n        }\n  \
    \  }\n\n    (min_val, max_val)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpi0al4y4i.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest: Vec<_> = Vec::new();\n    let mut largest:\
    \ Vec<_> = Vec::new();\n\n    for i in numbers.iter() {\n        if i == numbers.last().unwrap()\
    \ {\n            smallest.push(i);\n            largest.push(i);\n        } else\
    \ {\n            let mut smallest_index = -1;\n            let mut largest_index\
    \ = -1;\n\n            for j in smallest.iter() {\n                if i.abs()\
    \ < j.abs() {\n                    smallest_index = j;\n                }\n  \
    \          }\n\n            for j in largest.iter() {\n                if i.abs()\
    \ < j.abs() {\n                    largest_index = j;\n                }\n   \
    \         }\n\n            if smallest_index == -1 && largest_index == -1 {\n\
    \                smallest.push(i);\n                largest.push(i);\n       \
    \     } else if largest_index == -1 {\n                smallest.push(smallest[smallest.len()\
    \ - 1]);\n                smallest.push(i);\n            } else if smallest_index\
    \ == -1 {\n                largest.push(largest[largest.len() - 1]);\n       \
    \         largest.push(i);\n            } else {\n                if i == smallest[smallest_index]\
    \ {\n                    smallest.push(smallest[smallest_index]);\n          \
    \      } else {\n                    largest.push(largest[largest_index]);\n \
    \               }\n            }\n        }\n    }\n\n    (smallest[smallest.len()\
    \ - 1], largest[largest.len() - 1]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9x0tyqf.rs:21:38\n   |\n\
    16 |             let mut smallest_index = -1;\n   |                          \
    \            -- expected due to this value\n...\n21 |                     smallest_index\
    \ = j;\n   |                                      ^ expected integer, found `&&f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc9x0tyqf.rs:27:37\n   |\n17 |\
    \             let mut largest_index = -1;\n   |                              \
    \       -- expected due to this value\n...\n27 |                     largest_index\
    \ = j;\n   |                                     ^ expected integer, found `&&f64`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpc9x0tyqf.rs:16:38\n\
    \   |\n16 |             let mut smallest_index = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpc9x0tyqf.rs:31:34\n\
    \   |\n31 |             if smallest_index == -1 && largest_index == -1 {\n   |\
    \                                  ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpc9x0tyqf.rs:37:41\n   |\n37 |             } else if smallest_index\
    \ == -1 {\n   |                                         ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 "
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smaller = numbers[0];\n    let mut larger = numbers[0];\n\
    \    for &x in &numbers {\n        if x < smaller { smaller = x; }\n        if\
    \ x > larger { larger = x; }\n    }\n    (smaller, larger)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp8zl20ysn.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers {\n        if i < smallest {\n            smallest = i;\n\
    \        }\n        if i > largest {\n            largest = i;\n        }\n  \
    \  }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpd6vaokdp.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    use std::f64;\n    let mut min = f64::MAX;\n    let mut\
    \ max = f64::MIN;\n\n    for &n in numbers {\n        if n <= min {\n        \
    \    min = n;\n        }\n\n        if n > max {\n            max = n;\n     \
    \   }\n    }\n\n    (min, max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5atak7g.rs:12:9\n   |\n\
    12 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_value = numbers[0];\n    let mut max_value\
    \ = numbers[0];\n\n    for value in numbers {\n        min_value = std::cmp::min(min_value,\
    \ value);\n        max_value = std::cmp::max(max_value, value);\n    }\n\n   \
    \ (min_value, max_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpg2pcmtdp.rs:12:21\n\
    \     |\n12   |         min_value = std::cmp::min(min_value, value);\n     | \
    \                    ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpg2pcmtdp.rs:13:21\n\
    \     |\n13   |         max_value = std::cmp::max(max_value, value);\n     | \
    \                    ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut minimum = numbers[0] as f64;\n    let mut maximum\
    \ = numbers[0] as f64;\n    for &n in numbers {\n        let difference = n -\
    \ minimum;\n        if difference < 0 {\n            minimum = n;\n        } else\
    \ if difference > 0 {\n            maximum = n;\n        } else {\n          \
    \  minimum = n;\n            maximum = n;\n        }\n    }\n    (minimum, maximum)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzzc8wjrn.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpzzc8wjrn.rs:12:23\n   |\n\
    12 |         if difference < 0 {\n   |                       ^ no implementation\
    \ for `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if difference < 0.0 {\n\
    \   |                          ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzc8wjrn.rs:14:32\n\
    \   |\n14 |         } else if difference > 0 {\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `f64`, found integer\n   |                                help:\
    \ use a float literal: `0.0`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.get(0).is_finite());\n    assert!(numbers.get(1).is_finite());\n\
    \n    // Find two closest elements\n    let mut smallest = f64::MAX;\n    let\
    \ mut largest = numbers.get(0);\n    for &n in numbers.iter().skip(1) {\n    \
    \    let d = n.abs() - smallest;\n        if d < 0.0 {\n            smallest =\
    \ n;\n        } else {\n            largest = n;\n        }\n    }\n\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_finite` found for enum `Option` in the\
    \ current scope\n --> /tmp/tmp35gwko34.rs:8:28\n  |\n8 |     assert!(numbers.get(0).is_finite());\n\
    \  |                            ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_none`\n\nerror[E0599]: no method named `is_finite`\
    \ found for enum `Option` in the current scope\n --> /tmp/tmp35gwko34.rs:9:28\n\
    \  |\n9 |     assert!(numbers.get(1).is_finite());\n  |                      \
    \      ^^^^^^^^^ help: there is an associated function with a similar name: `is_none`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp35gwko34.rs:19:23\n   |\n13 |\
    \     let mut largest = numbers.get(0);\n   |                       --------------\
    \ expected due to this value\n...\n19 |             largest = n;\n   |       \
    \                ^ expected enum `Option`, found `f64`\n   |\n   = note: expected\
    \ enum `Option<&f64>`\n              found type `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp35gwko34.rs:23:16\n   |\n23 |     (smallest, largest)\n\
    \   |                ^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note:\
    \ expected type `f64`\n              found enum `Option<&f64>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut largest = numbers.iter().max().unwrap();\n    let\
    \ mut smallest = numbers.iter().min().unwrap();\n\n    for number in numbers {\n\
    \        if number > largest {\n            largest = number;\n        }\n   \
    \     if number < smallest {\n            smallest = number;\n        }\n    }\n\
    \n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzar85kty.rs:8:38\n\
    \     |\n8    |     let mut largest = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzar85kty.rs:9:39\n\
    \     |\n9    |     let mut smallest = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzar85kty.rs:12:21\n   |\n12 |\
    \         if number > largest {\n   |                     ^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |    \
    \     if number > *largest {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzar85kty.rs:13:23\n   |\n8  |     let mut largest = numbers.iter().max().unwrap();\n\
    \   |                       ----------------------------- expected due to this\
    \ value\n...\n13 |             largest = number;\n   |                       ^^^^^^\n\
    \   |                       |\n   |                       expected `&f64`, found\
    \ `f64`\n   |                       help: consider borrowing here: `&number`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzar85"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_d = std::f64::MAX;\n    let mut min_d = numbers[0];\n\
    \    let mut min_d_idx = 1;\n    let mut min_d_idx = 1;\n    for &d in numbers\
    \ {\n        if d < min_d {\n            min_d = d;\n            min_d_idx = min_d_idx;\n\
    \        }\n        if d == min_d {\n            min_d_idx += 1;\n        }\n\
    \    }\n    (min_d, min_d_idx)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz85e6pru.rs:12:9\n   |\n\
    12 |     for &d in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `d`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz85e6pru.rs:21:13\n   |\n21 |     (min_d, min_d_idx)\n\
    \   |             ^^^^^^^^^ expected `f64`, found integer\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    (min, max)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0cm6i6e.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_numbers = numbers;\n    closest_numbers.sort();\n\
    \    closest_numbers.shrink_to_fit();\n\n    (closest_numbers[1], closest_numbers[0])\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpzljmt6px.rs:9:21\n\
    \    |\n9   |     closest_numbers.sort();\n    |                     ^^^^ the\
    \ trait `Ord` is not implemented for `f64`\n    |\n    = help: the following other\
    \ types implement trait `Ord`:\n              i128\n              i16\n      \
    \        i32\n              i64\n              i8\n              isize\n     \
    \         u128\n              u16\n            and 4 others\nnote: required by\
    \ a bound in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0].clone() as f64;\n    let\
    \ mut biggest = numbers[0].clone() as f64;\n\n    for number in numbers.iter().rev()\
    \ {\n        if number < smallest {\n            smallest = number;\n        }\n\
    \        if number > biggest {\n            biggest = number;\n        }\n   \
    \ }\n\n    (smallest, biggest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3dsco7z_.rs:12:21\n   |\n\
    12 |         if number < smallest {\n   |                     ^^^^^^^^\n   | \
    \                    |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&smallest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3dsco7z_.rs:13:24\n   |\n8  |     let mut smallest\
    \ = numbers[0].clone() as f64;\n   |                        -------------------------\
    \ expected due to this value\n...\n13 |             smallest = number;\n   | \
    \                       ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n13 |             smallest = *number;\n   | \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3dsco7z_.rs:15:21\n\
    \   |\n15 |         if number > biggest {\n   |                     ^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&biggest`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3dsco7z_.rs:16:23\n   |\n9  |     let mut biggest\
    \ = numbers[0].clone() as f64;\n   |                       -------------------------\
    \ expected due to this value\n...\n16 |             biggest = number;\n   |  \
    \                     ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |             biggest = *number;\n   |  \
    \                     +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_difference = numbers.iter().cloned().min_by(|a,\
    \ b| a.abs() < b.abs()).unwrap();\n    let mut closest_number: Vec<f64> = vec![];\n\
    \    let mut larger_number: Vec<f64> = vec![];\n\n    for i in numbers {\n   \
    \     let difference = i.abs() - smallest_difference.abs();\n        if difference\
    \ < smallest_difference.abs() {\n            closest_number.push(i);\n       \
    \ } else {\n            larger_number.push(i);\n        }\n        smallest_difference\
    \ = difference;\n    }\n    (smallest_difference, closest_number, larger_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy6rb0gas.rs:8:73\n  |\n8 |\
    \     let mut smallest_difference = numbers.iter().cloned().min_by(|a, b| a.abs()\
    \ < b.abs()).unwrap();\n  |                                                  \
    \                       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy6rb0gas.rs:21:27\n\
    \   |\n21 |     (smallest_difference, closest_number, larger_number)\n   |   \
    \                        ^^^^^^^^^^^^^^ expected `f64`, found struct `Vec`\n \
    \  |\n   = note: expected type `f64`\n            found struct `Vec<f64>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy6rb0gas.rs:21:5\n   |\n7  | fn\
    \ find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |             \
    \                                   ---------- expected `(f64, f64)` because of\
    \ return type\n...\n21 |     (smallest_difference, closest_number, larger_number)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected a tuple\
    \ with 2 elements, found one with 3 elements\n   |\n   = note: expected tuple\
    \ `(f64, f64)`\n              found tuple `(f64, f64, Vec<f64>)`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter()\n        .zip(numbers.iter().cloned())\n\
    \        .map(|(a, b)| (*a - *b).abs())\n        .sorted()\n        .take(2)\n\
    \        .expect(\"there should be exactly two numbers\")\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpq6_06v_o.rs:10:29\n\
    \   |\n10 |         .map(|(a, b)| (*a - *b).abs())\n   |                     \
    \        ^^\n\nerror[E0599]: no method named `sorted` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpq6_06v_o.rs:11:10\n   |\n11 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Map<Zip<std::slice::Iter<'_, f64>,\
    \ Cloned<std::slice::Iter<'_, f64>>>, [closure@/tmp/tmpq6_06v_o.rs:10:14: 10:38]>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = 1.0;\n    let mut closest_element\
    \ = (numbers[0], numbers[1]);\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        let distance = f64::abs (number - closest_element[1]);\n        if\
    \ distance < min_distance {\n            min_distance = distance;\n          \
    \  closest_element = (number, numbers[index]);\n        }\n    }\n    closest_element\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `(f64, f64)`\n  --> /tmp/tmpoklxhijo.rs:11:43\n\
    \   |\n11 |         let distance = f64::abs (number - closest_element[1]);\n \
    \  |                                           ^^^^^^^^^^^^^^^^^^ help: to access\
    \ tuple elements, use: `closest_element.1`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoklxhijo.rs:14:32\n   |\n14 |             closest_element = (number,\
    \ numbers[index]);\n   |                                ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |    \
    \         closest_element = (*number, numbers[index]);\n   |                 \
    \               +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = 1.0;\n    let mut min_number = numbers[0];\n\
    \    let mut max_number = numbers[0];\n\n    for number in numbers.iter() {\n\
    \        let dist = abs(number - min_number);\n\n        if dist < min_dist {\n\
    \            min_number = number;\n            min_dist = dist;\n        }\n\n\
    \        if dist > max_dist {\n            max_number = number;\n            max_dist\
    \ = dist;\n        }\n    }\n\n    (min_number, max_number)\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpllux1b1g.rs:13:20\n\
    \   |\n13 |         let dist = abs(number - min_number);\n   |               \
    \     ^^^ not found in this scope\n\nerror[E0425]: cannot find value `max_dist`\
    \ in this scope\n  --> /tmp/tmpllux1b1g.rs:20:19\n   |\n20 |         if dist >\
    \ max_dist {\n   |                   ^^^^^^^^ help: a local variable with a similar\
    \ name exists: `min_dist`\n\nerror[E0425]: cannot find value `max_dist` in this\
    \ scope\n  --> /tmp/tmpllux1b1g.rs:22:13\n   |\n22 |             max_dist = dist;\n\
    \   |             ^^^^^^^^ help: a local variable with a similar name exists:\
    \ `min_dist`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpllux1b1g.rs:16:26\n\
    \   |\n9  |     let mut min_number = numbers[0];\n   |                       \
    \   ---------- expected due to this value\n...\n16 |             min_number =\
    \ number;\n   |                          ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             min_number\
    \ = *number;\n   |                          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllux1b1g.rs:21:26\n   |\n10 |     let mut max_number = numbers[0];\n\
    \   |                          ---------- expected due to this value\n...\n21\
    \ |             max_number = number;\n   |                          ^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n21\
    \ |             max_number = *number;\n   |                          +\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0., 0.);\n    }\n\
    \n    let mut min_distance = numbers.iter().map(|x| f64::max(x, f64::EPSILON)).fold(f64::EPSILON,\
    \ |a, b| a.saturating_sub(b));\n    let mut max_distance = (numbers[0], numbers[0]);\n\
    \    for i in numbers[1..].iter() {\n        let distance = numbers.iter().map(|x|\
    \ x.abs()).fold(f64::EPSILON, |a, b| a.saturating_sub(b));\n        if distance\
    \ < min_distance {\n            min_distance = distance;\n            max_distance\
    \ = (numbers[i], numbers[i]);\n        } else if distance == min_distance {\n\
    \            if max_distance.0 >= i {\n                max_distance = (numbers[i],\
    \ numbers[i]);\n            }\n        }\n    }\n    (min_distance, max_distance)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfj7fpqe.rs:12:60\n   |\n\
    12 |     let mut min_distance = numbers.iter().map(|x| f64::max(x, f64::EPSILON)).fold(f64::EPSILON,\
    \ |a, b| a.saturating_sub(b));\n   |                                         \
    \                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n12 |     let mut min_distance = numbers.iter().map(|x| f64::max(*x,\
    \ f64::EPSILON)).fold(f64::EPSILON, |a, b| a.saturating_sub(b));\n   |       \
    \                                                     +\n\nerror[E0599]: no method\
    \ named `saturating_sub` found for type `f64` in the current scope\n  --> /tmp/tmpdfj7fpqe.rs:12:106\n\
    \   |\n12 |     let mut min_distance = numbers.iter().map(|x| f64::max(x, f64::EPSILON)).fold(f64::EPSILON,\
    \ |a, b| a.saturating_sub(b));\n   |                                         \
    \                                                                 ^^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `saturating_sub`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpdfj7fpqe.rs:15:84\n\
    \   |\n15 |         let distance = numbers.iter().map(|x| x.abs()).fold(f64::EPSILON,\
    \ |a, b| a.saturating_sub(b));\n   |                                         \
    \                                           ^^^^^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpdfj7fpqe.rs:18:29\n\
    \   |\n18 |             max_distance = (numbers[i], numbers[i]);\n   |       \
    \                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented\
    \ for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&f64>`\
    \ for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n\
    \  --> /tmp/tmpdfj7fpqe.rs:18:41\n   |\n18 |             max_distance = (numbers[i],\
    \ numbers[i]);\n   |                                         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    let mut smallest_index = -1;\n    let mut largest_index = -1;\n\n    for\
    \ i in numbers.iter().rev() {\n        smallest = i;\n        if i < (&numbers[0]).cloned()\
    \ {\n            smallest_index = numbers.len() - 1;\n        }\n\n        if\
    \ i > (&numbers[0]).cloned() {\n            largest_index = 0;\n        }\n\n\
    \        if smallest_index == -1 && largest_index == -1 {\n            break;\n\
    \        }\n\n        if smallest < numbers[0] {\n            smallest = numbers[0];\n\
    \            smallest_index = numbers.len() - 1;\n        }\n\n        if largest\
    \ < numbers[0] {\n            largest = numbers[0];\n            largest_index\
    \ = 0;\n        }\n\n        if smallest > largest {\n            break;\n   \
    \     }\n\n        if smallest_index == -1 && largest_index == -1 {\n        \
    \    break;\n        }\n\n        let tmp = &numbers[smallest_index];\n      \
    \  let tmp_diff = tmp - &numbers[0];\n        let tmp_length = numbers.size();\n\
    \n        if largest < tmp {\n            if tmp_length < largest_index {\n  \
    \              largest_index = tmp_length;\n            }\n            let tmp_diff\
    \ = tmp - &numbers[largest_index];\n            let tmp_length = numbers.size();\n\
    \            largest = tmp;\n            if tmp_diff > largest {\n           \
    \     largest = &numbers[largest_index];\n                largest_index = numbers.len()\
    \ - 1;\n            }\n        }\n\n        if smallest > tmp {\n            if\
    \ tmp_length < smallest_index {\n                smallest_index = tmp_length;\n\
    \            }\n            let tmp_diff = tmp - &numbers[smallest_index];\n \
    \           let tmp_length = numbers.size();\n            smallest = tmp;\n  \
    \          if tmp_diff < smallest {\n                smallest = &numbers[smallest_index];\n\
    \                smallest_index = numbers.len() - 1;\n            }\n        }\n\
    \    }\n\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpltr46xpy.rs:14:20\n   |\n\
    8  |     let mut smallest = numbers[0];\n   |                        ----------\
    \ expected due to this value\n...\n14 |         smallest = i;\n   |          \
    \          ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |         smallest = *i;\n   |                    +\n\n\
    error[E0599]: `&f64` is not an iterator\n  --> /tmp/tmpltr46xpy.rs:15:30\n   |\n\
    15 |         if i < (&numbers[0]).cloned() {\n   |                           \
    \   ^^^^^^ `&f64` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `&f64: Iterator`\n           which is required\
    \ by `&mut &f64: Iterator`\n           `f64: Iterator`\n           which is required\
    \ by `&mut f64: Iterator`\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpltr46xpy.rs:10:30\n   |\n10 |     let mut smallest_index\
    \ = -1;\n   |                              ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: `&f64` is not an iterator\n  --> /tmp/tmpltr46xpy.rs:19:30\n\
    \   |\n19 |         if i > (&numbers[0]).cloned() {\n   |                    \
    \          ^^^^^^ `&f64` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `&f64: Iterator`\n           which is\
    \ required by `&mut &f64: Iterator`\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpltr46xpy.rs:23:30\n   |\n23 |         if\
    \ smallest_index == -1 && largest_index == -1 {\n   |                        \
    \      ^^\n   |                              |\n   |                         \
    \     cannot apply unary operator `-`\n   |                              help:\
    \ you may have meant the maximum value of `usize`: `usize::M"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut i = 0;\n    let mut j = 0;\n    let mut min = numbers[0];\
    \ // first element of array must be the minimum\n    let mut max = numbers[0];\
    \ // second element of array must be the maximum\n    let mut mid = numbers[0];\
    \ // mid point of array must be the first element of the array\n    while i <\
    \ numbers.len() && j < numbers.len() {\n        if numbers[i].abs() < numbers[j].abs()\
    \ {\n            min = numbers[i];\n            j = j + 1;\n        } else {\n\
    \            max = numbers[j];\n            i = i + 1;\n        }\n    }\n   \
    \ if j > 0 {\n        mid = min + (max - min) / 2;\n    } else {\n        mid\
    \ = min;\n    }\n    (min, mid)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmpor44h4b7.rs:23:33\n\
    \   |\n23 |         mid = min + (max - min) / 2;\n   |                       \
    \          ^ no implementation for `f64 / {integer}`\n   |\n   = help: the trait\
    \ `Div<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n23 |         mid = min + (max - min)\
    \ / 2.0;\n   |                                    ++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.iter().cloned().windows(2).flat_map(|numbers|\n\
    \        (numbers[0].abs() as i64, numbers[1].abs() as i64).min(|a, b| a.abs()\
    \ < b.abs())\n    )\n    .collect()\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmp9ywi98np.rs:8:29\n  |\n8 |     numbers.iter().cloned().windows(2).flat_map(|numbers|\n\
    \  |                             ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ f64>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if *i < smallest {\n           \
    \ smallest = *i;\n        }\n        if *i > largest {\n            largest =\
    \ *i;\n        }\n    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpnjavw96b.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    numbers.sort_unstable();\n    let smallest = numbers[0];\n\
    \    let largest = numbers[0];\n    for element in &numbers {\n        if element\
    \ < smallest {\n            smallest = element;\n        }\n        if element\
    \ > largest {\n            largest = element;\n        }\n    }\n    (smallest,\
    \ largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpl2dnmvro.rs:8:13\n\
    \     |\n8    |     numbers.sort_unstable();\n     |             ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl2dnmvro.rs:12:22\n   |\n12 |         if element < smallest\
    \ {\n   |                      ^^^^^^^^\n   |                      |\n   |   \
    \                   expected `&f64`, found `f64`\n   |                      help:\
    \ consider borrowing here: `&smallest`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl2dnmvro.rs:13:24\n   |\n9  |     let smallest = numbers[0];\n   | \
    \                   ---------- expected due to this value\n...\n13 |         \
    \    smallest = element;\n   |                        ^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |    \
    \         smallest = *element;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl2dnmvro.rs:15:22\n   |\n15 |         if element\
    \ > largest {\n   |                      ^^^^^^^\n   |                      |\n\
    \   |                      expected `&f64`, found `f64`\n   |                \
    \      help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl2dnmvro.rs:16:23\n   |\n10 |     let largest = numbers[0];\n \
    \  |                   ---------- expected due to this value\n...\n16 |      \
    \       largest = element;\n   |                       ^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |    \
    \         largest = *element;\n   |                       +\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min: f64 = numbers[0];\n    let mut max: f64 =\
    \ numbers[0];\n    for number in numbers.iter() {\n        if number < min {\n\
    \            min = number;\n        }\n        if number > max {\n           \
    \ max = number;\n        }\n    }\n    (min, max)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfcxipm87.rs:11:21\n   |\n\
    11 |         if number < min {\n   |                     ^^^\n   |           \
    \          |\n   |                     expected `&f64`, found `f64`\n   |    \
    \                 help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfcxipm87.rs:12:19\n   |\n8  |     let mut min: f64 = numbers[0];\n\
    \   |                  --- expected due to this type\n...\n12 |             min\
    \ = number;\n   |                   ^^^^^^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n12 |             min = *number;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcxipm87.rs:14:21\n\
    \   |\n14 |         if number > max {\n   |                     ^^^\n   |    \
    \                 |\n   |                     expected `&f64`, found `f64`\n \
    \  |                     help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcxipm87.rs:15:19\n   |\n9  |     let mut max:\
    \ f64 = numbers[0];\n   |                  --- expected due to this type\n...\n\
    15 |             max = number;\n   |                   ^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |    \
    \         max = *number;\n   |                   +\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut smallest: f64 = numbers[0];\n        let mut largest_minus_smallest:\
    \ f64 = numbers[1];\n        for n in numbers[2..] {\n            let midpoint\
    \ = (n + smallest) as f64 / 2.0;\n            smallest = midpoint if midpoint\
    \ < smallest { smallest = midpoint };\n            largest_minus_smallest = midpoint\
    \ if midpoint > largest_minus_smallest { largest_minus_smallest = midpoint };\n\
    \        }\n        (smallest, largest_minus_smallest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpmtjisf0w.rs:15:33\n   |\n15 |            \
    \ smallest = midpoint if midpoint < smallest { smallest = midpoint };\n   |  \
    \                               ^^ expected one of 8 possible tokens\n\nerror[E0277]:\
    \ the size for values of type `[f64]` cannot be known at compilation time\n  -->\
    \ /tmp/tmpmtjisf0w.rs:13:18\n   |\n13 |         for n in numbers[2..] {\n   |\
    \                  ^^^^^^^^^^^^ expected an implementor of trait `IntoIterator`\n\
    \   |\n   = note: the trait bound `[f64]: IntoIterator` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `[f64]`\nhelp: consider borrowing here\n   |\n13 |         for n in &numbers[2..]\
    \ {\n   |                  +\n13 |         for n in &mut numbers[2..] {\n   |\
    \                  ++++\n\nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpmtjisf0w.rs:13:18\n\
    \   |\n13 |         for n in numbers[2..] {\n   |                  ^^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[f64]: IntoIterator` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `[f64]`\nhelp: consider borrowing\
    \ here\n   |\n13 |         for n in &numbers[2..] {\n   |                  +\n\
    13 |         for n in &mut numbers[2..] {\n   |                  ++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Find the two smallest numbers and make sure they are\
    \ in order\n    let mut smallest_num = numbers[0];\n    let mut other_num = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] < smallest_num {\n  \
    \          smallest_num = numbers[i];\n        }\n        if numbers[i] > other_num\
    \ {\n            other_num = numbers[i];\n        }\n    }\n    // Return the\
    \ smallest and other number in order\n    (smallest_num, other_num)\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmp326m9e8g.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    if numbers.len() < 2 {\n        return (0.0, 0.0);\n  \
    \  }\n\n    let mut smallest = numbers[0].clone();\n    let mut largest = numbers[0].clone();\n\
    \    for (i, _) in numbers.iter().enumerate() {\n        if largest < numbers[i]\
    \ {\n            largest = numbers[i].clone();\n        }\n        if smallest\
    \ > numbers[i] {\n            smallest = numbers[i].clone();\n        }\n    }\n\
    \n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpca2fc6v6.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_number = numbers[0];\n    let mut largest_number\
    \ = numbers[0];\n    for i in numbers {\n        if i < smallest_number {\n  \
    \          smallest_number = i;\n        }\n        if i > largest_number {\n\
    \            largest_number = i;\n        }\n    }\n    (smallest_number, largest_number)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpg1kf3cue.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n    for i in 1..numbers.len() {\n        if\
    \ numbers[i] > largest {\n            largest = numbers[i];\n        }\n     \
    \   if numbers[i] < smallest {\n            smallest = numbers[i];\n        }\n\
    \    }\n    (smallest, largest)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 5.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpcji55nqv.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_dist = FLT_MAX;\n    let mut min_index = 0;\n\
    \    for (index, &value) in numbers.iter().enumerate() {\n        let dist = value\
    \ - min_dist;\n        if dist < min_dist {\n            min_dist = dist;\n  \
    \          min_index = index;\n        }\n    }\n    (numbers[min_index], numbers[min_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FLT_MAX` in this scope\n --> /tmp/tmpyszn8ke4.rs:8:24\n\
    \  |\n8 |     let mut min_dist = FLT_MAX;\n  |                        ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut current_min = std::f64::MAX;\n    let mut current_max\
    \ = std::f64::MIN;\n\n    for number in numbers.iter() {\n        if number >\
    \ current_max {\n            current_max = number;\n        }\n        if number\
    \ < current_min {\n            current_min = number;\n        }\n    }\n\n   \
    \ (current_min, current_max)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5iopqgqg.rs:12:21\n   |\n\
    12 |         if number > current_max {\n   |                     ^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&current_max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5iopqgqg.rs:13:27\n   |\n9  |     let mut current_max\
    \ = std::f64::MIN;\n   |                           ------------- expected due\
    \ to this value\n...\n13 |             current_max = number;\n   |           \
    \                ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             current_max = *number;\n   |            \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5iopqgqg.rs:15:21\n\
    \   |\n15 |         if number < current_min {\n   |                     ^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&current_min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5iopqgqg.rs:16:27\n   |\n8  |     let mut current_min\
    \ = std::f64::MAX;\n   |                           ------------- expected due\
    \ to this value\n...\n16 |             current_min = number;\n   |           \
    \                ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             current_min = *number;\n   |            \
    \               +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smaller: f64 = numbers[0];\n    let mut larger:\
    \ f64 = numbers[0];\n    for &n in numbers {\n        if n < smaller { smaller\
    \ = n; }\n        if n > larger { larger = n; }\n    }\n    (smaller, larger)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpesdatffu.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    assert!(numbers.len() >= 2);\n    let mut min_value = numbers[0];\n\
    \    let mut min_diff = f64::MAX;\n\n    for n in numbers.iter().skip(1) {\n \
    \       let diff = n - min_value;\n\n        if diff < min_diff {\n          \
    \  min_value = n;\n            min_diff = diff;\n        }\n    }\n\n    return\
    \ (min_value, min_diff);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb08m2zu4.rs:16:25\n   |\n\
    9  |     let mut min_value = numbers[0];\n   |                         ----------\
    \ expected due to this value\n...\n16 |             min_value = n;\n   |     \
    \                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             min_value = *n;\n   |                   \
    \      +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // Make sure we have at least two elements.\n    if numbers.len()\
    \ < 2 {\n        return (numbers[0], numbers[0]);\n    }\n    // Sort them by\
    \ distance.\n    numbers.sort_by_key(|number| number.to_f64());\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n    for &n in numbers {\n\
    \        if n < smallest {\n            smallest = n;\n        }\n        if n\
    \ > largest {\n            largest = n;\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for reference `&f64` in the\
    \ current scope\n  --> /tmp/tmpaknebgga.rs:13:41\n   |\n13 |     numbers.sort_by_key(|number|\
    \ number.to_f64());\n   |                                         ^^^^^^ method\
    \ not found in `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaknebgga.rs:16:9\n\
    \   |\n16 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest_diff = F64::MIN;\n    let mut smaller_number\
    \ = numbers[0];\n    for number in &numbers[1..] {\n        let diff = abs(number\
    \ - smaller_number);\n        if diff < smallest_diff {\n            smallest_diff\
    \ = diff;\n            smaller_number = number;\n        }\n    }\n    (smaller_number,\
    \ smallest_diff)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `F64`\n --> /tmp/tmp8dpkzr0m.rs:8:29\n\
    \  |\n8 |     let mut smallest_diff = F64::MIN;\n  |                         \
    \    ^^^ use of undeclared type `F64`\n\nerror[E0425]: cannot find function `abs`\
    \ in this scope\n  --> /tmp/tmp8dpkzr0m.rs:11:20\n   |\n11 |         let diff\
    \ = abs(number - smaller_number);\n   |                    ^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8dpkzr0m.rs:14:30\n \
    \  |\n9  |     let mut smaller_number = numbers[0];\n   |                    \
    \          ---------- expected due to this value\n...\n14 |             smaller_number\
    \ = number;\n   |                              ^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             smaller_number\
    \ = *number;\n   |                              +\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
