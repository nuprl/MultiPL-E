name: HumanEval_24_largest_divisor
language: rust
prompt: "/// For a given number n, find the largest number that divides n evenly,\
  \ smaller than n\n/// >>> largest_divisor(15)\n/// 5\nfn largest_divisor(n: isize)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3),\
  \ 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n   \
  \ assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"
completions: ["    let mut max_div = 0;\n    let mut max_div_divisor = 0;\n    let\
    \ mut max_div_divisor_squared = 0;\n\n    for i in 1..=n {\n        let mut divisor\
    \ = 1;\n        let mut divisor_squared = 1;\n        for j in 0..=i {\n     \
    \       if i % j == 0 {\n                divisor += 1;\n                divisor_squared\
    \ += j;\n                if divisor_squared > max_div_divisor {\n            \
    \        max_div_divisor = divisor_squared;\n                    max_div_divisor_squared\
    \ = divisor;\n                }\n            }\n        }\n        if divisor\
    \ > max_div {\n            max_div = divisor;\n        }\n    }\n\n    if max_div_divisor\
    \ == max_div {\n        max_div_divisor_squared\n    } else {\n        max_div_divisor\n\
    \    }", '    (n as isize) / isize_factors(n).iter().max().unwrap()', "    let\
    \ mut max: isize = 1;\n    let mut i = 1; // starting from 2, since 1 is evenly\
    \ divisible by 2\n    while i <= n {\n        if n % i == 0 {\n            max\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    max", " \
    \   let mut i: isize = 1;\n    let mut n: isize = n;\n\n    while i * i < n {\n\
    \        i += 1;\n    }\n\n    for j in 1..i {\n        if n % j == 0 {\n    \
    \        n = n / j;\n        }\n    }\n    n", "    let mut res = 1;\n    while\
    \ (res <= n) {\n        res = (res + n) / 2;\n    }\n    res", "    debug_assert!(n\
    \ % 2 == 0);\n\n    // find the smallest divisor of n that is evenly divisible\
    \ by 2\n    for i in 2..((n / 2) + 1) as usize {\n        if n % i == 0 {\n  \
    \          return i;\n        }\n    }\n\n    n", "    if n < 10 {\n        return\
    \ 1;\n    }\n    let mut largest_divisor: isize = 1;\n    let mut square: isize\
    \ = n;\n    while square >= 2 {\n        square = square / 2;\n        largest_divisor\
    \ = largest_divisor + 1;\n    }\n    largest_divisor", "    let mut i = n;\n \
    \   let mut largest_divisor = 1;\n    while i * largest_divisor <= n {\n     \
    \   largest_divisor += 1;\n        i -= 1;\n    }\n    i", "    let mut i: isize\
    \ = 1;\n    let mut m = 1;\n    while i <= n {\n        if n % i == 0 {\n    \
    \        m = i;\n        }\n        i += 1;\n    }\n    m", "    (1..=n).reverse().fold(1,\
    \ |acc, &x| {\n        acc.checked_add(&x).ok()\n    });", '    n.checked_div(2).unwrap()',
  "    // Start with a non-negative number as the largest divisor\n    let mut largest_divisor\
    \ = n as isize;\n    let mut num_divisors: isize = 0;\n    // Loop while num_divisors\
    \ < n\n    while num_divisors <= n {\n        // Find the divisor of the form\
    \ n * (n/num_divisors)\n        let divisor = n / num_divisors;\n        // If\
    \ the divisor is greater than n, then the smallest divisor of n is\n        //\
    \ the divisor, otherwise its greater than the largest divisor\n        if divisor\
    \ > n {\n            largest_divisor = divisor;\n        } else {\n          \
    \  largest_divisor = n;\n            break;\n        }\n        // Add 1 to the\
    \ number of divisors\n        num_divisors += 1;\n    }\n    largest_divisor",
  "    let mut largest_divisor = 0;\n    let mut current_number = 1;\n\n    // loops\
    \ until current_number is larger than n\n    loop {\n        if n % current_number\
    \ == 0 {\n            largest_divisor = current_number;\n        }\n        current_number\
    \ += 1;\n        if current_number > n {\n            break;\n        }\n    }\n\
    \n    return largest_divisor;", "    fn gcd(a: isize, b: isize) -> isize {\n \
    \       if b == 0 {\n            return a\n        }\n        gcd(b, a % b)\n\
    \    }\n\n    if n <= 1 {\n        return n\n    }\n\n    let mut cur = 0 as isize;\n\
    \    let mut min_div = 1;\n    let mut max_div = n as isize;\n\n    for x in 1..n\
    \ / 2 {\n        let div = gcd(x, n);\n\n        if x < n / div {\n          \
    \  min_div = x;\n            max_div = div;\n        }\n    }\n\n    if n / max_div\
    \ > max_div {\n        max_div = n / max_div;\n    }\n\n    while max_div > 1\
    \ {\n        let div = max_div;\n\n        for _ in 0..div {\n            if n\
    \ % div == 0 {\n                break;\n            }\n\n            div -= 1;\n\
    \        }\n\n        if div > min_div {\n            break;\n        }\n\n  \
    \      max_div -= 1;\n    }\n\n    max_div", "    let mut num: isize = 1; // The\
    \ largest integer smaller than n\n    while num * num <= n {\n        num += 1;\
    \ // Number that divides n evenly\n    }\n    num", "    let mut m = n;\n    let\
    \ mut l = n;\n    for _ in 0..10 {\n        let mut m = m - 1;\n        for _\
    \ in 0..m {\n            if n % m == 0 {\n                l = l;\n           \
    \ } else {\n                break;\n            }\n        }\n    }\n    l", " \
    \   if n < 2 {\n        return 1;\n    }\n    let mut i = 0;\n    let mut j =\
    \ n;\n    let mut largest_divisor: isize = 0;\n    let mut num_divs: isize = 0;\n\
    \    while i < j {\n        if j % i == 0 {\n            i += 1;\n           \
    \ num_divs += 1;\n        } else {\n            i += 1;\n            if num_divs\
    \ > largest_divisor {\n                largest_divisor = num_divs;\n         \
    \   }\n            num_divs = 0;\n        }\n    }\n    largest_divisor", '    (**n).min(|a,
    b| a % b == 0)', "    debug_assert!(n >= 1);\n    debug_assert!((n & (n - 1))\
    \ == 0);\n    let mut n1 = n / 2;\n    while n1 % 2 != 0 {\n        n1 /= 2;\n\
    \    }\n    while n != n1 {\n        n = n1;\n        n1 = n / 2;\n    }\n   \
    \ n", "    let mut max_divisor = n;\n\n    while max_divisor * max_divisor <=\
    \ n {\n        max_divisor += 1;\n    }\n\n    max_divisor", '    (1..=n).filter(|&d|
    n % d == 0).max().unwrap()', "    (0..n).fold(0, |acc, n|\n        if n % acc\
    \ == 0 {\n            acc\n        } else {\n            acc\n        }\n    )",
  "    debug_assert!(n % 2 == 0);\n\n    let mut max = (n - 1) / 2;\n    while max\
    \ % 2 == 0 {\n        max /= 2;\n    }\n\n    max", "    (1..n).max_by_key(|i|\
    \ {\n        i / i\n    })", "    let mut highest: isize = 0;\n    let mut divisor:\
    \ isize = 0;\n\n    for i in 1..n {\n        if n % i == 0 {\n            highest\
    \ = i;\n            divisor = i;\n        } else {\n            divisor *= i;\n\
    \        }\n    }\n\n    highest", "    loop {\n        if n % 2 == 0 {\n    \
    \        n /= 2;\n        } else {\n            break;\n        }\n    }\n   \
    \ n", "    let mut m = n;\n    let mut factor = 1;\n    while m % factor == 0\
    \ {\n        m = m / factor;\n        factor *= 2;\n    }\n    m", "    // Compute\
    \ the first few powers of 2\n    let mut power_twos = vec![1usize; (1 << 1)..\
    \ ];\n    // For each power of two, find all divisors less than that power of\
    \ two\n    // We use some algebraic tricks to make this fast, by computing all\
    \ divisors up to sqrt(n)\n    // Then we simply take the largest.\n    for power_two\
    \ in power_twos.iter_mut() {\n        // Keep track of divisors less than the\
    \ given power of two\n        let mut divisors = vec![0; n];\n        // Do this\
    \ in reverse to compute the divisors up to sqrt(n)\n        for divisor in divisors.iter_mut().rev()\
    \ {\n            if divisor > (1 << power_two) - 1 {\n                continue;\n\
    \            }\n            // If this divisor divides n evenly, then\n      \
    \      // the remaining divisors divide n evenly\n            if n % divisor ==\
    \ 0 {\n                // Then we add it to the vector of divisors less than\n\
    \                // this power of two\n                divisors.push(divisor);\n\
    \                break;\n            }\n        }\n        // Keep track of the\
    \ largest divisor less than this power of two\n        if divisors.len() > 0 {\n\
    \            *power_two = divisors.iter().max().unwrap();\n        } else {\n\
    \            *power_two = 1 << power_two;\n        }\n    }\n\n    // Return the\
    \ largest number that divides n evenly, smaller than n\n    *power_twos\n    \
    \    .iter()\n        .filter_map(|power_two| {\n            if *power_two < (1\
    \ << n) - 1 {\n                Some(power_two)\n            } else {\n       \
    \         None\n            }\n        })\n        .max()\n        .unwrap()",
  '    (1..=n).filter(|&x| n%x == 0).max()', "    let mut max_divisor: isize = 0;\n\
    \    let mut max_divisor_num: isize = 0;\n    for divisor in 1..=n {\n       \
    \ if n%divisor == 0 {\n            if divisor > max_divisor {\n              \
    \  max_divisor = divisor;\n                max_divisor_num = 1;\n            }\n\
    \            elsif divisor == max_divisor {\n                max_divisor_num +=\
    \ 1;\n            }\n        }\n    }\n    max_divisor", "    let mut largest\
    \ = isize::MAX;\n\n    for i in 1 .. n {\n        if n % i == 0 {\n          \
    \  let mut j = i;\n            while j > 0 && n % j == 0 {\n                j\
    \ -= 1;\n            }\n            if j > 0 {\n                largest = i;\n\
    \            }\n        }\n    }\n\n    largest", "    for i in 1..=n / 2 {\n\
    \        if n % i == 0 {\n            return i;\n        }\n    }\n    n", " \
    \   use std::cmp::Ordering;\n\n    let mut i: isize = 1;\n    let mut largest:\
    \ isize = 1;\n\n    for i in 1..n {\n        if n % i == 0 {\n            largest\
    \ = i;\n            if largest > n {\n                break;\n            }\n\
    \        } else {\n            i = i + 1;\n        }\n    }\n\n    largest", " \
    \   let mut nmax = n;\n    loop {\n        if n % 2 == 0 {\n            n = n\
    \ / 2;\n        } else {\n            n /= 2;\n            nmax = n as isize;\n\
    \        }\n        if n == 1 {\n            break;\n        }\n    }\n    nmax",
  "    if n % 2 == 0 {\n        n / 2\n    } else {\n        largest_divisor(n - 1)\
    \ / 2\n    }", "    if n < 2 {\n        return n\n    }\n    let mut largest =\
    \ &n;\n    let mut max_divisor = 1;\n    for i in 1..=n {\n        if n % i ==\
    \ 0 {\n            if max < i {\n                largest = &i;\n            }\n\
    \            max_divisor = i;\n        }\n    }\n    largest", "    let mut max_divisor\
    \ = 1;\n\n    for divisor in 2..=n/2 {\n        if n % divisor == 0 {\n      \
    \      max_divisor = divisor;\n        }\n    }\n\n    if max_divisor <= n {\n\
    \        max_divisor\n    } else {\n        n\n    }", "    (1..=n).max()\n  \
    \      .map(|d| n % d)\n        .unwrap_or(n)", "    let mut res = n; // Initialize\
    \ result with n\n    let mut mod_mod_div = 1;\n    let mut remainder = n % 2;\
    \ // Initializing remainder with n's modulo value\n    while remainder != 0 {\n\
    \        remainder /= 2; // Initializing remainder with n's divided by 2\n   \
    \     mod_mod_div += 1;\n    }\n    while mod_mod_div != 0 {\n        if res %\
    \ mod_mod_div == 0 {\n            res = (res % mod_mod_div) / mod_mod_div;\n \
    \       } else {\n            mod_mod_div -= 1;\n        }\n    }\n    if res\
    \ > n { res } else { res }", "    let mut largest = n as isize;\n    let mut max_divisor\
    \ = 0;\n    for i in 1..(n/2) {\n        if n%i == 0 {\n            largest =\
    \ i;\n            max_divisor = i;\n        }\n    }\n    for i in max_divisor+1..(n/2)\
    \ {\n        if n%i == 0 {\n            largest = i;\n        }\n    }\n    largest",
  "    // Find the highest divisor, by dividing n by all primes up to 10\n    // >>>\
    \ largest_divisor(15)\n    // 7\n    let mut primes = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19];\n    for &prime in &primes {\n        let divisor = n / prime;\n  \
    \      if divisor == 0 {\n            return prime;\n        }\n    }\n    panic!(\"\
    largest_divisor failed to find the largest divisor\");", "    if n == 1 {\n  \
    \      return 1;\n    }\n    let mut largest_divisor = 1isize;\n    let mut next_divisor\
    \ = 1isize;\n    while next_divisor <= n {\n        if n % next_divisor == 0 {\n\
    \            largest_divisor = next_divisor;\n        }\n        next_divisor\
    \ *= 2;\n    }\n    largest_divisor", "    let mut largest: isize = 1;\n    let\
    \ mut n_div = &n;\n    while *n_div > 1 {\n        n_div = &(*n_div).sqrt();\n\
    \        largest = if largest < n_div { *n_div }\n        else {\n           \
    \ largest\n        };\n    }\n    largest", "    let mut divisor = 2;\n    let\
    \ mut result = 1;\n    while divisor < n {\n        if n % divisor == 0 {\n  \
    \          result += divisor;\n        }\n        divisor += 2;\n    }\n    result",
  "    if n < 3 {\n        return 1;\n    }\n\n    let mut n = n as usize;\n    let\
    \ mut max_divisor = 1;\n\n    for d in divisors(n) {\n        if n % d == 0 {\n\
    \            if d > max_divisor {\n                max_divisor = d;\n        \
    \    }\n        }\n    }\n    max_divisor", "    debug_assert!(n > 1);\n    let\
    \ mut result = 1;\n    for i in 1..n {\n        if n % i == 0 {\n            if\
    \ result > i {\n                result = i;\n            }\n        }\n    }\n\
    \    result", '    (1..=n).rfold(i, |x, y| if x % y == 0 { y } else { *i })',
  "    let mut max_divisor: isize = 1;\n    let mut max_divisor2: isize = 1;\n\n \
    \   for divisor in 2..n {\n        if n % divisor == 0 {\n            if divisor\
    \ > max_divisor {\n                max_divisor = divisor;\n            }\n   \
    \         if divisor > max_divisor2 {\n                max_divisor2 = divisor;\n\
    \            }\n        }\n    }\n\n    if max_divisor > max_divisor2 {\n    \
    \    max_divisor\n    } else {\n        max_divisor2\n    }", "    let mut v:\
    \ Vec<isize> = vec![0isize; 10];\n\n    for i in v.iter() {\n        if n % i\
    \ == 0 {\n            return i;\n        }\n    }\n\n    return v;", "    match\
    \ n {\n        1 => 1,\n        n if n % 2 == 0 => n,\n        n => n,\n    }",
  "    let mut largest = n;\n    while n > 0 {\n        if n % 2 == 0 {\n        \
    \    n /= 2;\n        } else {\n            largest = n;\n            break;\n\
    \        }\n    }\n    largest", "    (1..=n).max_by_key(|i| {\n        i % 2\
    \ == 0 && i / 2 % n == 0\n    }).unwrap()", "    let mut largest = 0;\n    let\
    \ mut divisor = 1;\n    while divisor < n {\n        if n % divisor == 0 {\n \
    \           divisor *= 2;\n            largest = divisor;\n        }\n       \
    \ divisor += 1;\n    }\n    largest", "    use std::cmp::Ordering;\n    (n + (n\
    \ - 1) / 2)\n        .try_into()\n        .unwrap()\n        .pow(2)\n       \
    \ .partial_cmp(&n)\n        .unwrap()\n        .partial_cmp(&n / 2)\n        .unwrap()\n\
    \        .partial_cmp(&(n / 4))\n        .unwrap()\n        .partial_cmp(&(n /\
    \ 6))\n        .unwrap()\n        .partial_cmp(&(n / 8))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 10))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 12))\n        .unwrap()\n        .partial_cmp(&(n / 14))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 16))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 18))\n        .unwrap()\n        .partial_cmp(&(n / 20))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 22))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 24))\n        .unwrap()\n        .partial_cmp(&(n / 26))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 28))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 30))\n        .unwrap()\n        .partial_cmp(&(n / 32))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 34))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 36))\n        .unwrap()\n        .partial_cmp(&(n / 38))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 40))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 42))\n        .unwrap()\n        .partial_cmp(&(n / 44))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 46))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 48))\n        .unwrap()\n        .partial_cmp(&(n / 50))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 52))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 54))\n        .unwrap()\n        .partial_cmp(&(n / 56))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 58))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 60))\n        .unwrap()\n        .partial_cmp(&(n / 62))\n        .unwrap()\n\
    \        .partial_cmp(&(n / 64))\n        .unwrap()\n        .partial_cmp(&(n\
    \ / 66))\n        .unwrap()\n        .partial_cmp(&(n / 68))\n        .unwrap()\n\
    \        .partial_cmp(&(", "    let mut largest_divisor = 1;\n    let mut max_divisor\
    \ = 1;\n\n    for d in 1..n {\n        if d % largest_divisor == 0 {\n       \
    \     max_divisor = d;\n        } else {\n            if largest_divisor == n\
    \ {\n                return max_divisor;\n            }\n            largest_divisor\
    \ = d;\n        }\n    }\n    max_divisor", "    let mut max_divisor = n / 2;\n\
    \    while max_divisor % 2 == 0 {\n        max_divisor /= 2;\n    }\n    max_divisor",
  "    n / isize::from(2..=n)\n        .iter()\n        .max() // Find the max\n \
    \       .unwrap_or(-1) // If that's not possible (n is 0, -1, or something else)\
    \ return the max", "    let mut largest_divisor: isize = 0;\n    let mut largest_divisor_size:\
    \ isize = n;\n    let mut largest_divisor_factor: isize = 1;\n\n    for divisor\
    \ in &[1..] {\n        let mut divisor_size: isize = 0;\n\n        while divisor_size\
    \ < largest_divisor_size {\n            divisor_size += divisor * largest_divisor_factor;\n\
    \            largest_divisor_factor += 2;\n        }\n\n        if divisor_size\
    \ < largest_divisor_size {\n            largest_divisor_factor = divisor_size;\n\
    \            largest_divisor_size = divisor;\n        }\n    }\n\n    largest_divisor",
  "    if n % 2 == 0 {\n        return n;\n    }\n    for i in 2..(n/2) {\n      \
    \  if n % i == 0 {\n            return i;\n        }\n    }\n    return n;", " \
    \   let mut result = n;\n    while result % 2 != 0 && result % 3 != 0 && result\
    \ % 5 != 0 {\n        result = result / 2;\n    }\n    result", '    (n + (n -
    1) / 2) / (n - 1)', "    let mut max_divisor = 1;\n    let mut max_divisor_remainder\
    \ = n;\n    while max_divisor_remainder % 2 == 0 {\n        max_divisor_remainder\
    \ /= 2;\n        max_divisor += 1;\n    }\n    max_divisor", "    match n % 2\
    \ {\n        0 => 1,\n        1 => n,\n        _ => n,\n    }", "    let mut largest_divisor:\
    \ isize = 1;\n\n    for i in 2..=n {\n        if n % i == 0 {\n            if\
    \ largest_divisor == 1 {\n                largest_divisor = i;\n            }\
    \ else {\n                largest_divisor = if largest_divisor < i { largest_divisor\
    \ } else { i };\n            }\n        }\n    }\n\n    largest_divisor", '    (n
    - 1) / 2 + 1', '    n.checked_sub(1).checked_mul( isize::from(2).sqrt()).unwrap().unwrap()',
  "    let mut max_divisor = n as isize;\n    for i in 1..=max_divisor {\n       \
    \ if n % i == 0 {\n            max_divisor = i;\n        }\n    }\n    max_divisor",
  "    let mut largest_divisor = n;\n    let mut smallest_divisor = n - 1;\n    let\
    \ mut greatest_divisor = n - 1;\n\n    while smallest_divisor >= 0 {\n       \
    \ if n % smallest_divisor == 0 {\n            greatest_divisor = smallest_divisor;\n\
    \            smallest_divisor -= 1;\n        }\n        else {\n            smallest_divisor\
    \ -= 1;\n        }\n    }\n\n    largest_divisor", "    // n is guaranteed to\
    \ be positive\n    // since it is guaranteed to be even\n    // since it is guaranteed\
    \ to be less than or equal to sqrt(n) (i.e., sqrt(n) divides n)\n    // since\
    \ n is guaranteed to be even, n divides evenly into sqrt(n) evenly (since sqrt(n)\
    \ divides n)\n    match n % _ {\n        0 => 0,\n        x | x == 0 => x,\n \
    \       _ => (n / x)\n    }", "    let mut factor = 1;\n    loop {\n        factor\
    \ *= n;\n        if factor <= n {\n            return factor;\n        }\n   \
    \ }", "    let mut n: isize = n;\n    let mut max_divisor = 0;\n    while n >\
    \ 1 {\n        max_divisor = n / 2;\n        n = max_divisor;\n    }\n    max_divisor",
  "    if n < 0 {\n        return 0;\n    }\n\n    let mut ni = n;\n    let mut d\
    \ = 0;\n    while ni / d < ni {\n        d = d << 1;\n    }\n    d = d + 1;\n\
    \    while ni % d == 0 {\n        d = d << 1;\n    }\n    d", "    let mut i =\
    \ 1;\n    while i <= n {\n        if n % i == 0 {\n            return i;\n   \
    \     }\n        i += 1;\n    }\n    n", "    let mut primes = vec![n];\n    let\
    \ mut max = 0;\n    for _ in 0..=n {\n        let mut max_divisor = 1;\n     \
    \   for _ in 0..=n {\n            if primes.len() > 0 {\n                let prime\
    \ = primes.pop();\n                if prime > 1 {\n                    let mut\
    \ divisor = 1;\n                    for p in &prime {\n                      \
    \  if !primes.contains(&p) { divisor *= p };\n                    }\n        \
    \            if divisor > max_divisor { max_divisor = divisor };\n           \
    \     }\n            }\n        }\n        primes.push(max_divisor);\n       \
    \ max = max > max_divisor ? max : max_divisor;\n    }\n    max", "    let mut\
    \ max_divisor = u64::max_value();\n    for i in 0..n {\n        if n % i == 0\
    \ {\n            if !max_divisor.checked_add(i).is_ok() {\n                max_divisor\
    \ = i;\n            }\n        }\n    }\n    match max_divisor {\n        0 =>\
    \ panic!(\"n must be positive\"),\n        n => n,\n    }", "    let mut max_divisor:\
    \ isize = n;\n    let mut factor: isize = 1;\n    while n % factor == 0 {\n  \
    \      factor *= 2;\n        max_divisor = max_divisor / factor;\n    }\n    max_divisor",
  "    let mut max = 0;\n    let mut div = 1;\n    while div <= n {\n        if n\
    \ % div == 0 {\n            max = div;\n            div += 1;\n        }\n   \
    \     div += 1;\n    }\n    max", "    (1..=n)\n        .iter()\n        .filter_map(|factor|\
    \ {\n            if !(n % factor) {\n                Some(factor)\n          \
    \  } else {\n                None\n            }\n        })\n        .max()\n\
    \        .unwrap_or(1)", "    if n <= 1 {\n        return n;\n    }\n    let mut\
    \ max_div = 1;\n    let mut max_divs = vec![];\n    for div in n.iter().rev()\
    \ {\n        if div % 2 != 0 {\n            continue;\n        }\n        if div\
    \ > max_div {\n            max_div = div;\n        }\n    }\n    max_divs.push(max_div);\n\
    \    for i in (1..=max_div).rev() {\n        if max_divs[i] * 2 > n {\n      \
    \      return max_divs[i];\n        }\n    }\n    max_div", "    loop {\n    \
    \    n /= 2\n        if n % 2 == 0 {\n            return n\n        }\n    }",
  '    (1..=n).filter(_ % 2 == 0).max()', "    let mut largest = n;\n    let mut next_divisor\
    \ = 1;\n    while largest%next_divisor != 0 {\n        largest += next_divisor;\n\
    \        next_divisor *= 2;\n    }\n    largest", '    (1..=n).map(|x| x / n).max()',
  '    (1..=n).find_max()', "    let mut largest = if n % 2 == 0 { n / 2 } else {\
    \ (n / 2) + 1 };\n    for i in 2..largest.min(largest) {\n        if n % i ==\
    \ 0 {\n            largest = i;\n        }\n    }\n    largest", "    let mut\
    \ largest: isize = 1;\n    let mut current_divisor: isize = 2;\n    while current_divisor\
    \ <= n {\n        if n % current_divisor == 0 {\n            largest = current_divisor;\n\
    \        }\n        current_divisor += 1;\n    }\n    largest", "    let mut largest_divisor\
    \ = 1;\n    let mut smallest_divisor = n;\n    for d in 2..=smallest_divisor {\n\
    \        if n % d == 0 {\n            largest_divisor = d;\n            if d <\
    \ smallest_divisor {\n                smallest_divisor = d;\n            }\n \
    \       }\n    }\n    largest_divisor", "    let mut ns: Vec<isize> = vec![n];\n\
    \    for d in 1..=n%ns {\n        if ns/d > n {\n            return ns/d;\n  \
    \      }\n        ns.push(d / n);\n    }\n    ns[1..].iter().max().unwrap()",
  "    debug_assert!(n%2 == 0);\n    let mut max_divisor = 2;\n    for divisor in\
    \ 2..n {\n        if n%divisor == 0 {\n            n = n / divisor;\n        \
    \    max_divisor = divisor;\n        }\n    }\n    n", '    largest_divisor_iter(n).max()',
  "    let mut max_div = 1;\n    let mut max_num = n;\n    while max_num > 2 {\n \
    \       max_num = max_num / 2;\n        max_div += 1;\n    }\n    max_div", " \
    \   let mut max_divisor: usize = 1;\n    let mut min_divisor = 1;\n    for divisor\
    \ in 1..=n {\n        if n % divisor == 0 {\n            if divisor > max_divisor\
    \ {\n                max_divisor = divisor;\n            }\n            if divisor\
    \ < min_divisor {\n                min_divisor = divisor;\n            }\n   \
    \     }\n    }\n\n    // return the biggest divisor\n    match max_divisor {\n\
    \        1 => min_divisor,\n        _ => max_divisor\n    }", "    if n == 1 {\
    \ return 1; }\n    if n % 2 == 0 { return 2; }\n    let mut max_divider = 2;\n\
    \    let mut max_divisor = 1;\n    while max_divider < n {\n        max_divisor\
    \ *= max_divider;\n        max_divider += 1;\n    }\n    max_divisor", "    let\
    \ mut res = isize::MAX;\n    let mut rem = n;\n\n    while rem != 0 {\n      \
    \  if rem % 2 == 0 {\n            res -= 1;\n            rem /= 2;\n        }\
    \ else {\n            rem /= 2;\n        }\n    }\n\n    res", "    n.checked_div(n\
    \ as usize)\n        .unwrap()\n        .checked_mul(n as usize).unwrap()\n  \
    \      .checked_div(n as usize).unwrap()\n        .unwrap_or(1)", "    let mut\
    \ m = n;\n    for _ in 0..n {\n        if n % m == 0 {\n            m = m / 2;\n\
    \        } else {\n            break;\n        }\n    }\n    m", "    let mut\
    \ n = n as isize;\n    while n % 2 == 0 {\n        n /= 2;\n    }\n    while n\
    \ % 3 == 0 {\n        n /= 3;\n    }\n    if n != 1 {\n        n\n    } else {\n\
    \        std::i64::MAX as isize\n    }", "    while n % 2 == 0 {\n        n /=\
    \ 2;\n    }\n    while n % 3 == 0 {\n        n /= 3;\n    }\n    n", "    // Base\
    \ Case\n    if n < 2 { 1 }\n\n    // Middle Case\n    let mut divisor = 1; //\
    \ Initialize dividend\n    let mut num_divisors = 1;\n    for d in 2..=n {\n \
    \       if n % d == 0 {\n            divisor = d;\n            num_divisors +=\
    \ 1;\n        }\n    }\n\n    if num_divisors == 1 {\n        return divisor;\n\
    \    }\n\n    // Handle the case of multiple divisors\n    let mut largest_divisor\
    \ = divisor;\n    let mut largest_divisors = num_divisors;\n    for d in divisor..=n\
    \ {\n        if n % d == 0 {\n            let remainder = n % d;\n           \
    \ if remainder == 0 {\n                largest_divisor = d;\n                largest_divisors\
    \ = num_divisors + 1;\n            }\n        }\n    }\n\n    if largest_divisors\
    \ > largest_divisor {\n        largest_divisor\n    } else {\n        largest_divisors\n\
    \    }", "    let mut res = n;\n\n    while res >= 2 {\n        res -= 2;\n  \
    \  }\n\n    res", "    // Compute the largest divisor less than n\n    // The\
    \ smallest divisor less than n will be evenly divisible by n\n    loop {\n   \
    \     if n % 2 == 0 {\n            n /= 2;\n        }\n        else {\n      \
    \      n = n - 1;\n        }\n        if n == 0 || n % 2 == 0 {\n            return\
    \ n;\n        }\n    }", '    n.checked_div(2).unwrap()', '    (1..=n).fold(n,
    |a, b| if a % b == 0 { a } else { b })', "    // Sieve of Eratosthenes\n    let\
    \ mut primes = vec![n];\n\n    for p in 2..=n {\n        if p > n {\n        \
    \    break;\n        }\n        for j in 2..p * p {\n            if j % p == 0\
    \ {\n                primes.push(j);\n            }\n        }\n    }\n\n    let\
    \ mut max_divisor = 0;\n\n    for prime in &primes[..] {\n        for divisor\
    \ in 2..=n {\n            if divisor % prime == 0 {\n                let divisor\
    \ = divisor * divisor;\n\n                if divisor > max_divisor {\n       \
    \             max_divisor = divisor;\n                }\n            }\n     \
    \   }\n    }\n\n    max_divisor", "    let mut i = 1;\n    let mut m = 0;\n  \
    \  while i * i <= n {\n        if n % i == 0 {\n            m = i;\n        }\n\
    \        i += 1;\n    }\n    i", "    let mut s = n;\n    s.checked_sub(1).unwrap();\n\
    \    loop {\n        s = s.checked_sub(2).unwrap();\n        if s % 2 == 0 {\n\
    \            return s;\n        }\n    }", "    let mut i: isize = n;\n    let\
    \ mut j: isize = n;\n    let mut k: isize = n;\n    while i < j {\n        loop\
    \ {\n            if i % k == 0 {\n                i += 1;\n                if\
    \ i == n {\n                    break;\n                }\n                k +=\
    \ 1;\n            } else {\n                j += 1;\n                if j == n\
    \ {\n                    break;\n                }\n                k -= 1;\n\
    \            }\n        }\n    }\n    j", "    let mut n = 1u64;\n    loop {\n\
    \        match n % n {\n            0 => return n,\n            _ => n += 1,\n\
    \        }\n    }", "    let mut max_divisor = 1;\n    let mut max_divisors =\
    \ Vec::new();\n    while n % max_divisor != 0 {\n        max_divisor = max_divisor\
    \ + 1;\n    }\n    max_divisors.push(max_divisor);\n    let mut max_divisor_index\
    \ = 0;\n    for (i, max_divisor) in max_divisors.into_iter().enumerate() {\n \
    \       if n % max_divisor == 0 {\n            max_divisor_index = i;\n      \
    \  }\n    }\n    max_divisor_index", "    let mut max_divisor = n;\n    let mut\
    \ divisor = 1;\n\n    while divisor < max_divisor {\n        if n % divisor ==\
    \ 0 {\n            max_divisor = divisor;\n        }\n        divisor += 1;\n\
    \    }\n    max_divisor", "    debug_assert!(n % 2 == 0);\n    let mut max_divisor\
    \ = 1;\n    let mut max_divisor_square = max_divisor * max_divisor;\n    let mut\
    \ i = 0;\n    while i < n {\n        if n % max_divisor == 0 {\n            max_divisor_square\
    \ = max_divisor * max_divisor;\n            if max_divisor > n {\n           \
    \     break;\n            }\n            max_divisor = max_divisor + 1;\n    \
    \    }\n        i += 1;\n    }\n    max_divisor_square", "    for i in 1..n {\n\
    \        if n % i == 0 {\n            return i;\n        }\n    }\n\n    n", " \
    \   if n <= 0 {\n        1\n    }\n    let mut max_divisor = 1;\n    let mut last_divisor\
    \ = 2;\n    while last_divisor < n {\n        let divisor = last_divisor + 1;\n\
    \        if n % divisor == 0 {\n            max_divisor = divisor;\n        }\n\
    \        last_divisor = divisor;\n    }\n    max_divisor", "    debug_assert!(n\
    \ % 2 == 0);\n    let mut i = 1isize;\n    while i <= n / 2 {\n        if n %\
    \ i == 0 {\n            return i;\n        }\n        i += 1;\n    }\n    n",
  "    let mut n = n;\n    let mut m = 0;\n\n    while n > 2 {\n        n /= 2;\n\
    \        m += 1;\n    }\n    if m > n {\n        return n;\n    }\n    return\
    \ m;", '    (1..n).max_by(|&i| i).unwrap()', "    let mut max_divisor = 1;\n \
    \   let mut max_num = n;\n    let mut max_power = 1;\n    while max_num > 1 {\n\
    \        max_power = (max_num as ipow) / 2;\n        if max_power % 2 == 0 {\n\
    \            max_num = max_power as usize;\n        } else {\n            max_divisor\
    \ = max_power;\n        }\n    }\n    if max_num > n {\n        max_num = n\n\
    \    }\n    if max_num > 1 {\n        max_num *= 2;\n    }\n    if max_power ==\
    \ 2 {\n        max_num\n    } else {\n        max_divisor\n    }", '    (n as
    isize).iter().rev().take_while(|&x| x % 2 == 0).rev().count()', "    let mut largest:\
    \ isize = 1;\n    for divisor in 2..=n {\n        if n % divisor == 0 {\n    \
    \        largest = divisor;\n        }\n    }\n    largest", "    if n < 2 {\n\
    \        return 1;\n    }\n    let mut max_divisor = 0;\n    let mut curr_divisor\
    \ = 1;\n    while curr_divisor < n {\n        let mut num_divisor = 0;\n     \
    \   while n % curr_divisor == 0 {\n            curr_divisor *= 2;\n          \
    \  num_divisor += 1;\n        }\n        max_divisor = if num_divisor > max_divisor\
    \ { num_divisor } else { max_divisor };\n        curr_divisor *= 2;\n    }\n \
    \   max_divisor", "    let mut max_divisor = 1;\n    let mut divisor_found = false;\n\
    \    for i in 1..=n {\n        if i%max_divisor == 0 {\n            divisor_found\
    \ = true;\n        } else {\n            if divisor_found {\n                max_divisor\
    \ = i;\n            }\n        }\n    }\n    max_divisor", "    loop {\n     \
    \   if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n =\
    \ n * 3 + 1\n        }\n        if n == 4 || n == 9 || n == 16 || n == 25 {\n\
    \            return n\n        }\n    }", "    let mut max_divisor = 0;\n    for\
    \ divisor in &[2..=n as usize] {\n        if n % divisor == 0 {\n            max_divisor\
    \ = divisor;\n        }\n    }\n    max_divisor", "    debug_assert!(n % 2 ==\
    \ 0);\n    let mut max: isize = 0;\n    let mut remain = n / 2;\n    while remain\
    \ > 0 {\n        let div = n / remain;\n        if div > max {\n            max\
    \ = div;\n        }\n        remain = remain % 2;\n    }\n    max", "    if n\
    \ % 2 == 0 {\n        n\n    } else {\n        largest_divisor(n / 2)\n    }",
  "    let mut max_divisor = 1;\n    let mut max_divisor_remainder = 1;\n    for &d\
    \ in &[1, 3, 7, 17, 31, 73, 107, 131, 173, 197, 239, 297, 377, 455, 591, 769]\
    \ {\n        if n % d == 0 {\n            max_divisor = d;\n            max_divisor_remainder\
    \ = n % d;\n        }\n    }\n    max_divisor_remainder", "    match n%2 {\n \
    \       0 => n,\n        _ => largest_divisor(n/2)\n    }", "    if n <= 1 {\n\
    \        return n;\n    }\n    let mut s = 1;\n    while s < n {\n        if n\
    \ % s == 0 {\n            return s;\n        }\n        s += 1;\n    }\n    n",
  "    n / 2\n        .div_mod(2, n)\n        .expect(\"should return at least 2\"\
    )", "    let mut max_divisor = 1;\n    let mut i = 31;\n\n    while i > 0 {\n\
    \        if n % i == 0 {\n            if max_divisor > i {\n                max_divisor\
    \ = i;\n            }\n        }\n        i += 1;\n    }\n    max_divisor", " \
    \   let mut largest = n;\n    let mut last_div = 0;\n    for d in range(1, &mut\
    \ largest) {\n        if n % d == 0 {\n            last_div = d;\n        } else\
    \ {\n            if last_div > d {\n                largest = last_div;\n    \
    \        } else {\n                break;\n            }\n        }\n    }\n \
    \   largest", "    largest_factorization(n)\n        .iter()\n        .fold(n,\
    \ |a, b| if a.checked_mul(b).is_zero() then b else a)", "    let mut divisor =\
    \ 1isize;\n    let mut largest_divisor = 0isize;\n    while divisor < n {\n  \
    \      divisor += 1;\n        if n % divisor == 0 {\n            largest_divisor\
    \ = divisor;\n        }\n    }\n    largest_divisor", "    let mut max_div: isize\
    \ = 1;\n    let mut max_div: isize = 1;\n\n    for i in 1..n {\n        if n %\
    \ i == 0 {\n            if max_div > i {\n                max_div = i;\n     \
    \       }\n        }\n    }\n\n    if max_div == 1 {\n        return n;\n    }\
    \ else {\n        return max_div;\n    }", "    debug_assert!(n % 2 != 0);\n \
    \   for i in 2..n / 2 {\n        if n % i == 0 {\n            return i;\n    \
    \    }\n    }\n    n", "    if n == 1 {\n        return 0;\n    }\n\n    if n\
    \ % 2 == 0 {\n        return 2;\n    }\n\n    if n % 3 == 0 {\n        return\
    \ 3;\n    }\n\n    if n % 5 == 0 {\n        return 5;\n    }\n\n    if n % 7 ==\
    \ 0 {\n        return 7;\n    }\n\n    if n % 11 == 0 {\n        return 11;\n\
    \    }\n\n    if n % 13 == 0 {\n        return 13;\n    }\n\n    if n % 17 ==\
    \ 0 {\n        return 17;\n    }\n\n    if n % 19 == 0 {\n        return 19;\n\
    \    }\n\n    if n % 23 == 0 {\n        return 23;\n    }\n\n    if n % 29 ==\
    \ 0 {\n        return 29;\n    }\n\n    if n % 31 == 0 {\n        return 31;\n\
    \    }\n\n    if n % 37 == 0 {\n        return 37;\n    }\n\n    if n % 41 ==\
    \ 0 {\n        return 41;\n    }\n\n    if n % 43 == 0 {\n        return 43;\n\
    \    }\n\n    if n % 47 == 0 {\n        return 47;\n    }\n\n    if n % 53 ==\
    \ 0 {\n        return 53;\n    }\n\n    if n % 59 == 0 {\n        return 59;\n\
    \    }\n\n    if n % 61 == 0 {\n        return 61;\n    }\n\n    if n % 67 ==\
    \ 0 {\n        return 67;\n    }\n\n    if n % 71 == 71 {\n        return 71;\n\
    \    }\n\n    if n % 73 == 73 {\n        return 73;\n    }\n\n    if n % 79 ==\
    \ 79 {\n        return 79;\n    }\n\n    if n % 81 == 81 {\n        return 81;\n\
    \    }\n\n    if n % 83 == 83{\n        return 83;\n    }\n\n    if n % 89 ==\
    \ 89 {\n        return 89;\n    }\n\n    if n % 97 == 97 {\n        return 97;\n\
    \    }\n\n    if n % 105 == 105 {\n        return 105;\n    }\n\n    if n % 111\
    \ == 111 {\n        return 111;\n    }\n\n    if n % 127 == 127 {\n        return\
    \ 127;\n    }\n\n    if n % 131 == 131 {\n        return 131;\n    }\n\n    if\
    \ n % 137 == 137 {\n        return 137;\n    }\n\n    if n % 147 == 147 {\n  \
    \      return 147;\n    }\n\n    if n % 151 == 151 {\n        return 151;\n  \
    \  }\n\n    if n % 157 == 157 {\n        return 157;\n    }\n\n    if n % 163\
    \ == 163 {\n        return 163;\n    }\n\n    if n % 169 == 169 {\n        return\
    \ 169;\n    }\n\n    if n % 173 == 173 {\n        return 173;\n    }\n\n    if\
    \ n % 179 == 179 {\n        return 179;\n    }\n\n    if n % 181 == 181 {\n  \
    \      return 181;\n    }\n\n    if n % 185 == 185 {\n        return 185;\n  \
    \  }\n\n    if n % 187 == 187 {\n        return 187;\n    }\n\n", "    let mut\
    \ max_divisor = 1;\n    let mut max_divisor_ind = 1;\n    let mut largest_divisor\
    \ = n;\n    while largest_divisor > 1 {\n        largest_divisor -= 1;\n     \
    \   if n % largest_divisor == 0 {\n            if max_divisor == largest_divisor\
    \ {\n                max_divisor_ind += 1;\n            } else {\n           \
    \     max_divisor = largest_divisor;\n                max_divisor_ind = 1;\n \
    \           }\n        }\n    }\n    max_divisor", "    if n % 2 == 0 {\n    \
    \    n\n    } else {\n        largest_divisor(n / 2)\n    }", '    (1..n).rev().next().unwrap().expect("n
    must be positive")', '    (0..n).fold(1, |acc, n| if n % acc == 0 { n } else {
    acc })', "    if n % 2 == 0 {\n        largest_divisor(n / 2)\n    } else {\n\
    \        largest_divisor(n * 3 + 1)\n    }", "    let mut largest_divisor = n;\n\
    \n    loop {\n        let mut a = n;\n        let mut b = n;\n        let mut\
    \ c = n;\n        let mut d = n;\n\n        for _ in 0..100 {\n            if\
    \ a > b {\n                d = a;\n                a = b;\n                b =\
    \ c;\n                c = d;\n            }\n            if b > c {\n        \
    \        d = b;\n                b = c;\n                c = d;\n            }\n\
    \            if c > d {\n                d = c;\n            }\n        }\n  \
    \      largest_divisor = std::cmp::max(largest_divisor, d);\n    }\n    largest_divisor",
  "    debug_assert!(n <= 2isize, \"Only positive numbers are supported\");\n    let\
    \ mut max_factor = 1;\n    let mut max_divisor = 1;\n    for i in 1..=n {\n  \
    \      if n % i == 0 {\n            if max_factor < i {\n                max_factor\
    \  = i;\n                max_divisor = n / i;\n            }\n        }\n    }\n\
    \    max_divisor", "    let mut largest_divisor = n;\n    let mut counter = 0;\n\
    \    while largest_divisor % 2 == 0 {\n        largest_divisor /= 2;\n       \
    \ counter += 1;\n    }\n    counter", "    loop {\n        let mut divisor = n\
    \ as isize;\n        if n % divisor == 0 {\n            divisor = divisor * 2;\n\
    \            if divisor < n {\n                divisor = n / 2;\n            }\n\
    \        }\n        n /= divisor;\n        if n == 1 {\n            return divisor;\n\
    \        }\n    }", "    (1..=n).rfold(0, |res, &i| {\n        res.checked_add(i).expect(\"\
    Overflow\");\n        res\n    })", "    let mut largest_divisor = 1;\n    let\
    \ mut largest_divisor_prime = 2;\n    let mut largest_divisor_prime_prime = 3;\n\
    \n    let mut primes: Vec<isize> = Vec::new();\n    primes.push(2);\n\n    while\
    \ primes.len() != n {\n        let index = primes.iter().position(|&p| *p > largest_divisor);\n\
    \        let prime = primes[index].clone(); // borrow it\n        let index =\
    \ primes.iter().position(|&p| *p > largest_divisor_prime);\n        let prime_prime\
    \ = primes[index].clone(); // borrow it\n        index = primes.iter().position(|&p|\
    \ *p > largest_divisor_prime_prime);\n        let prime_prime_prime = primes[index].clone();\
    \ // borrow it\n\n        if prime > largest_divisor {\n            largest_divisor\
    \ = prime;\n        }\n\n        if prime_prime > largest_divisor_prime {\n  \
    \          largest_divisor_prime = prime_prime;\n        }\n\n        if prime_prime_prime\
    \ > largest_divisor_prime_prime {\n            largest_divisor_prime_prime = prime_prime_prime;\n\
    \        }\n\n        primes.push(prime);\n        primes.push(prime_prime);\n\
    \        primes.push(prime_prime_prime);\n    }\n\n    largest_divisor", "   \
    \ let mut max_divisor = n;\n    for i in 2..(max_divisor / 2 + 1) {\n        if\
    \ n % i == 0 {\n            max_divisor = i;\n        }\n    }\n    max_divisor",
  "    for i in 1..n {\n        if n % i == 0 {\n            return i;\n        }\n\
    \    }\n    n", "    let mut largest = n;\n    let mut counter = 1;\n    while\
    \ counter <= n {\n        if n % counter == 0 {\n            largest = counter;\n\
    \        }\n        counter += 1;\n    }\n    largest", "    let mut i = 0;\n\
    \    while n != 1 {\n        if n % i == 0 {\n            i += 1;\n        } else\
    \ {\n            n = n / i;\n        }\n    }\n    i", '    n.checked_mul(|x|
    x.checked_add((n + 1) / 2 - 1).unwrap()).unwrap()', "    (1..).rev().fold(n, |a,\
    \ b| {\n        if a % b == 0 {\n            b\n        } else {\n           \
    \ a\n        }\n    })", "    if n % 2 == 0 {\n        n\n    } else {\n     \
    \   largest_divisor(n / 2)\n    }", "    let mut largest = n - 1;\n    let mut\
    \ smallest = n - 1;\n\n    for i in 0..n / 2 {\n        if n % i == 0 {\n    \
    \        if largest < i {\n                largest = i;\n            }\n     \
    \       if smallest > i {\n                smallest = i;\n            }\n    \
    \    }\n    }\n\n    largest", "    let mut s = Vec::new();\n\n    let mut r =\
    \ n;\n\n    while r % 2 == 0 {\n        s.push(r);\n        r /= 2;\n    }\n\n\
    \    s.push(r);\n\n    loop {\n        if s.len() == 1 {\n            return s[0];\n\
    \        }\n\n        let mut r = s.len() - 1;\n\n        while r >= 0 {\n   \
    \         let mut c = s[r];\n\n            while c % 2 == 0 {\n              \
    \  c /= 2;\n                s.push(c);\n            }\n\n            s.push(c);\n\
    \            r -= 1;\n        }\n    }", "    let mut largest = n; // Initialization\n\
    \    let mut max_divisor = largest;\n\n    for i in 1..n {\n        if n % i ==\
    \ 0 {\n            largest /= i;\n            if largest != 1 {\n            \
    \    max_divisor = largest;\n            }\n        }\n    }\n\n    largest",
  "    let mut max_div = i;\n    let mut max_div_prime = i;\n    for i in 2..=n {\n\
    \        if n % i == 0 {\n            max_div = i;\n            max_div_prime\
    \ = n;\n        }\n        if max_div_prime % i == 0 {\n            max_div_prime\
    \ = i;\n        }\n    }\n    max_div_prime", "    let mut m = n;\n    let mut\
    \ last_i = 1;\n    loop {\n        last_i = last_i * 2;\n        if m % last_i\
    \ == 0 {\n            m = m / last_i;\n        }\n        if m == 1 {\n      \
    \      break;\n        }\n    }\n    m", "    let mut dividend = n;\n    let mut\
    \ largest_divisor = 0;\n\n    while dividend % 2 == 0 {\n        dividend /= 2;\n\
    \        largest_divisor += 1;\n    }\n\n    while dividend % 3 == 0 {\n     \
    \   dividend /= 3;\n        largest_divisor += 1;\n    }\n\n    while dividend\
    \ % 5 == 0 {\n        dividend /= 5;\n        largest_divisor += 1;\n    }\n\n\
    \    dividend", "    debug_assert_eq!(n % 2, 0, \"n must be an even number\")\n\
    \n    for i in 1..n / 2 {\n        if n % i == 0 {\n            return i;\n  \
    \      }\n    }\n\n    n", '    (1..=n).max_by(|a, b| n % b == 0).unwrap()', " \
    \   let mut max_divisor = 0;\n    let mut divisor_count = 0;\n    for divisor\
    \ in divisors(n) {\n        if divisor > n {\n            continue;\n        }\n\
    \        divisor_count += 1;\n        max_divisor = divisor;\n    }\n    if divisor_count\
    \ == 0 {\n        return max_divisor;\n    }\n    max_divisor", '    if n == 1
    { 1 } else { largest_divisor(n/2) }', "    let mut i = n;\n    loop {\n      \
    \  if n % i == 0 {\n            return i;\n        }\n        i += 1;\n    }",
  "    let mut n: isize = n;\n    let mut d: isize = 1;\n\n    while n % d == 0 {\n\
    \        n /= d;\n        d *= 2;\n    }\n\n    n += 1;\n\n    d", "    let mut\
    \ largest_divisor = n as isize;\n    let mut divisor = 2;\n    while divisor <\
    \ n {\n        if n % divisor == 0 {\n            largest_divisor = divisor;\n\
    \        }\n        divisor += 1;\n    }\n    largest_divisor", "    let mut max_divisor\
    \ = 0;\n    let mut min_divisor = n;\n    while min_divisor > 0 {\n        let\
    \ divisor = min_divisor / 2;\n        if n % divisor == 0 {\n            max_divisor\
    \ = divisor;\n            min_divisor = divisor;\n        } else {\n         \
    \   min_divisor = divisor;\n        }\n    }\n    max_divisor", "    let mut i:\
    \ usize = n;\n    loop {\n        if i%2 == 0 {\n            i += 2;\n       \
    \ } else {\n            i -= 1;\n        }\n        if i == n {\n            break;\n\
    \        }\n    }\n    i", "    let mut largest = n;\n    let mut is_prime = true;\n\
    \n    for factor in 1..=n {\n        if n % factor == 0 {\n            is_prime\
    \ = false;\n        }\n\n        if is_prime {\n            largest = factor;\n\
    \        }\n    }\n\n    largest", "    if n < 1 {\n        n\n    } else {\n\
    \        // binary search for the largest divisor\n        for i in 1..(n/2) {\n\
    \            if n % i == 0 {\n                n = n/i;\n                break;\n\
    \            }\n        }\n        n\n    }", "    let mut max_divisor = 1;\n\
    \    let mut max_divisor_remainder = n;\n    while max_divisor_remainder != 0\
    \ {\n        if max_divisor_remainder % 2 == 0 {\n            max_divisor *= 2;\n\
    \        } else {\n            max_divisor /= 2;\n        }\n        max_divisor_remainder\
    \ /= 2;\n    }\n    max_divisor", "    use std::cmp::Ordering;\n\n    fn gcd(x:\
    \ isize, y: isize) -> isize {\n        while y != 0 {\n            (x, y) = (y,\
    \ x % y);\n        }\n        x\n    }\n\n    if n == 1 { return 1; }\n\n    if\
    \ n == 2 { return 2; }\n\n    if n % 2 == 0 { return n; }\n\n    if n % 3 == 0\
    \ { return n; }\n\n    let mut gcd = n; // greatest common divisor\n\n    for\
    \ d in (3..n).rev() {\n        if n % d == 0 {\n            gcd = d;\n       \
    \ }\n    }\n\n    if gcd == n { return n; }\n\n    if gcd(n, gcd) == n {\n   \
    \     gcd + (n / gcd)\n    } else {\n        n\n    }", "    let mut max_factor\
    \ = 1;\n    let mut max_div = n;\n    for factor in &[3, 5] {\n        while n\
    \ % factor == 0 {\n            max_div = factor;\n            n /= factor;\n \
    \       }\n        if n == 1 {\n            return max_div;\n        }\n     \
    \   max_div = max_factor;\n        max_factor = factor;\n    }\n    max_div",
  '    n.checked_div(2).unwrap_or(1)', '    if n == 1 { 1 } else { largest_divisor(n
    - 1) % n }', "    // We use a set to avoid finding twice a number that divides\
    \ n evenly\n    let mut primes = HashSet::new();\n    primes.insert(n);\n    while\
    \ let Some(prime) = primes.pop() {\n        if prime % 2 == 0 {\n            continue;\n\
    \        }\n        let mut factors: Vec<isize> = Vec::new();\n        for divisor\
    \ in 2..=prime {\n            if primes.contains(divisor) {\n                continue;\n\
    \            }\n            factors.push(divisor);\n        }\n        if factors.iter().all(|&x|\
    \ x % prime == 0) {\n            return prime;\n        }\n    }\n    -1", '    (1..=n).find(|&d|
    n % d == 0)', "    (1..n).max_by_key(|n| {\n        n.checked_div(2).ok_or(format!(\"\
    divisor is too large: {}\", n))\n    }).unwrap_or(n)", "    n.iter()\n       \
    \ .take_while(|&i| i % 2 == 0)\n        .max()\n        .unwrap()", "    let mut\
    \ largest = n;\n    let mut smaller: isize = n;\n    let mut smaller_div: isize\
    \ = 1;\n    while smallest % smaller_div != 0 {\n        smallest /= smaller_div;\n\
    \        if smallest == 1 {\n            return 1;\n        }\n    }\n    while\
    \ largest % smaller_div != 0 {\n        largest /= smaller_div;\n        if largest\
    \ == 1 {\n            return 1;\n        }\n    }\n    while largest != 1 {\n\
    \        if largest % 2 != 0 {\n            smaller_div += 1;\n            largest_divisor(smaller_div)\n\
    \        } else {\n            largest = smaller;\n            smaller = smaller_div;\n\
    \        }\n    }\n    largest", "    let mut smallest: isize = 0;\n    let mut\
    \ largest = n;\n    while largest % 2 == 0 {\n        if largest < n {\n     \
    \       smallest = largest;\n            largest = n / 2;\n        } else {\n\
    \            largest = n / 2;\n        }\n    }\n    largest", "    let mut d:\
    \ isize = 1;\n    while d < n {\n        d += 1;\n    }\n    d", "    let mut\
    \ max_divisor = 1;\n\n    for d in 1..=n / 2 {\n        if n % d == 0 {\n    \
    \        let mut new_divisor = d+1;\n            while n % new_divisor == 0 {\n\
    \                new_divisor += 1;\n            }\n\n            if new_divisor\
    \ > max_divisor {\n                max_divisor = new_divisor;\n            }\n\
    \        }\n    }\n\n    max_divisor", "    let mut v: Vec<isize> = (1..n).collect();\n\
    \    v.reverse();\n    let mut cur = v.iter().fold(0, |a, n| {\n        if n %\
    \ a == 0 {\n            a\n        } else {\n            n\n        }\n    });\n\
    \    loop {\n        cur = if cur % 2 == 0 {\n            cur / 2\n        } else\
    \ {\n            cur / 2 + 1\n        };\n        if cur > n {\n            break;\n\
    \        }\n    }\n    cur", "    loop {\n        let mut i = 1;\n        while\
    \ i * i <= n {\n            if n % i == 0 {\n                return i;\n     \
    \       }\n            i += 1;\n        }\n    }", "    let mut smallest: isize\
    \ = n;\n    let mut largest: isize = n;\n    for i in 1..n {\n        if n % i\
    \ == 0 {\n            if largest < i {\n                largest = i;\n       \
    \     }\n            if smallest > i {\n                smallest = i;\n      \
    \      }\n        }\n    }\n    smallest", "    let mut max_divisor = 0;\n\n \
    \   for divisor in 0..n {\n        if n % divisor == 0 {\n            max_divisor\
    \ = divisor;\n        }\n    }\n\n    return max_divisor;", "    let mut n = n.clone();\n\
    \    let mut high = n;\n    let mut low = 1;\n    while n > 2 {\n        let m\
    \ = (high + low) / 2;\n        let d = n % m;\n        if d > 0 {\n          \
    \  n = d;\n        } else {\n            high = m;\n            low = m;\n   \
    \     }\n    }\n    high", '    (1..n).max_by_key(|i| i % &i).unwrap()', '    n.iter().filter(|&i|
    i % 2 == 0).max()', "    for i in 2..n/2 {\n        if n % i == 0 {\n        \
    \    return i;\n        }\n    }\n    n", "    fn largest_divisor_internal(n:\
    \ isize) -> isize {\n        fn divisor(n: isize) -> isize {\n            match\
    \ n % n % { 0 => 1, n => n }\n        }\n\n        match n / divisor(n) {\n  \
    \          Some(_) => n,\n            None => 1,\n        }\n    }\n\n    largest_divisor_internal(n)",
  '    (1..n).max().unwrap_or(n)', "    n / 2\n        .iter()\n        .skip(1)\n\
    \        .fold(1, |a, b| {\n            if ((b % a) == 0) {\n                a\n\
    \            } else {\n                b\n            }\n        })", '    (1..=n).filter(|&i|
    i % 2 != 0).max()', '    n.checked_div(n.checked_mul(2).unwrap()).expect("Input
    must be even")', '    (1..n).rev().fold(n, |acc, &x| acc + x / 2)', "    if n\
    \ < 2 {\n        return n;\n    }\n    let mut max = 0i32;\n    for divisor in\
    \ 1..=n {\n        if n % divisor == 0 {\n            if max < divisor {\n   \
    \             max = divisor;\n            }\n        }\n    }\n    max", "   \
    \ if n < 3 { return n; }\n    \n    let mut max_div = 0;\n    let mut max_num\
    \ = 1;\n    \n    for i in 2..=n {\n        if n % i == 0 {\n            if max_div\
    \ < i {\n                max_div = i;\n                max_num = 1;\n        \
    \    } else {\n                max_num = i + 1;\n            }\n        }\n  \
    \  }\n    \n    max_div + max_num"]
stop_tokens:
- "\n}"
