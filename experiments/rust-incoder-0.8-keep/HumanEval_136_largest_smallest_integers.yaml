name: HumanEval_136_largest_smallest_integers
language: rust
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a list.\n/// If there is no negative or positive integers, return them as None.\n\
  /// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n\
  /// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
  \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
  \ Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ["    if lst.is_empty() {\n        return (None, None);\n    }\n\n  \
    \  let mut greatest_smaller = Some(0);\n    let mut smallest_larger = Some(lst.iter().max().unwrap());\n\
    \    for i in lst.iter() {\n        if i < 0 {\n            greatest_smaller =\
    \ Some(i);\n        } else if i > 0 {\n            smallest_larger = Some(i);\n\
    \        }\n    }\n    (greatest_smaller, smallest_larger)", "    match (lst.iter().max_by_key(|x|\
    \ x < 0).collect::<Vec<_>>(), lst.iter().min_by_key(|x| x > 0).collect::<Vec<_>>())\
    \ {\n        (vec::<_>(vec![-1, -1]), vec::<_>(vec![])) => (None, None),\n   \
    \     (vec::<_>(vec![]), vec::<_>(vec![0])) => (None, None),\n        (vec::<_>(vec![0]),\
    \ vec::<_>(vec![])) => (None, None),\n        (vec::<_>(vec![-1, 0, 1, 2, -1,\
    \ -1]), vec::<_>(vec![1])) => (Some(-1), Some(0)),\n        (vec::<_>(vec![1]),\
    \ vec::<_>(vec![0])) => (Some(1), Some(0)),\n        (vec::<_>(vec![-1, 0, 1,\
    \ 2]), vec::<_>(vec![2])) => (Some(1), Some(2)),\n        (vec::<_>(vec![2]),\
    \ vec::<_>(vec![-1, 0, 1, 2])) => (Some(2), Some(1)),\n        (vec::<_>(vec![-1,\
    \ 0, 1, 2, -1, -1]), vec::<_>(vec![-1, 0, 1, 2, -1, -1])) => (None, None),\n \
    \       (vec::<_>(vec![-2, 0, 1, 2]), vec::<_>(vec![2, 0, 1, 2]))\n          \
    \  => (Some(2), Some(2)),\n        (vec::<_>(vec![2, 0, 1, 2]), vec::<_>(vec![-2,\
    \ 0, 1, 2]))\n            => (Some(2), Some(2)),\n        (vec::<_>(vec![-2, 0,\
    \ 1, 2]), vec::<_>(vec![-2, 0, 1, 2]))\n            => (None, None),\n       \
    \ (vec::<_>(vec![-2, 0, 1, 2]), vec::<_>(vec![-2, 0, 1, 2]))\n            => (None,\
    \ None),\n        (vec::<_>(vec![-2, -1, 1, 2, -1]), vec::<_>(vec![2, -1, 0, 1,\
    \ 2]))\n            => (Some(2), Some(-1)),\n        (vec::<_>(vec![2, -1, 0,\
    \ 1, 2]), vec::<_>(vec![-2, -1, 1, 2, -1]))\n            => (Some(-1), Some(2)),\n\
    \        (vec::<_>(vec![-2, -1, 1, 2, -1]), vec::<_>(vec![-2, -1, 1, 2, -1]))\n\
    \            => (None, None),\n        (vec::<_>(vec![-2, -1, 1, 2, -1]), vec::<_>(vec![-2,\
    \ -1, 1, 2, -1]))\n            => (None, None),\n        (vec::<_>(vec![-2, -1,\
    \ 1, 2, -1]), vec", "    let mut min: Option<isize> = None;\n    let mut max:\
    \ Option<isize> = None;\n    for (i, x) in\n        lst.iter().enumerate().rev().take(std::cmp::min(lst.len(),\
    \ 4)).by_ref()\n    {\n        match x {\n            None => min = Some(i),\n\
    \            Some(_) => max = Some(i),\n        }\n    }\n    (min, max)", " \
    \   let mut min_negative = None;\n    let mut max_positive = None;\n    for x\
    \ in lst {\n        match x < 0 {\n            true => {\n                if min_negative.is_none()\
    \ {\n                    min_negative = Some(x);\n                } else {\n \
    \                   min_negative = Some(min_negative.unwrap() + x);\n        \
    \        }\n            }\n            false => {}\n        }\n        match x\
    \ > 0 {\n            true => {\n                if max_positive.is_none() {\n\
    \                    max_positive = Some(x);\n                } else {\n     \
    \               max_positive = Some(max_positive.unwrap() + x);\n            \
    \    }\n            }\n            false => {}\n        }\n    }\n    (min_negative,\
    \ max_positive)", "    let mut max_n = None;\n    let mut min_n = None;\n    for\
    \ n in lst {\n        if n.is_some() {\n            if min_n.is_some() || n >=\
    \ 0 {\n                min_n = Some(n);\n            }\n            else {\n \
    \               max_n = Some(n);\n            }\n        }\n    }\n    (max_n,\
    \ min_n)", "    let mut max_i = None;\n    let mut min_i = None;\n    for i in\
    \ lst {\n        if min_i.is_none() && i > 0 {\n            min_i = Some(i);\n\
    \        } else if i.is_none() && max_i.is_none() {\n            max_i = Some(i);\n\
    \        } else if min_i.is_none() && i < 0 {\n            min_i = Some(i);\n\
    \        } else if max_i.is_none() && i < 0 {\n            max_i = Some(i);\n\
    \        } else if min_i.is_none() && i > 0 && max_i.is_none() {\n           \
    \ min_i = Some(i);\n            max_i = Some(i);\n        }\n    }\n    (min_i,\
    \ max_i)", "    let mut min = Some(std::i32::MAX);\n    let mut max = Some(std::i32::MIN);\n\
    \n    for x in lst {\n        if x < min {\n            min = Some(x);\n     \
    \   }\n        if x > max {\n            max = Some(x);\n        }\n    }\n\n\
    \    (min, max)", "    if lst.is_empty() {\n        return (None, None)\n    }\n\
    \    let mut min_val = None;\n    let mut max_val = None;\n    let mut largest_val\
    \ = isize::MAX;\n    let mut smallest_val = isize::MIN;\n    for i in lst {\n\
    \        if i < 0 {\n            if min_val.is_none() {\n                min_val\
    \ = Some(i);\n            } else if i < smallest_val {\n                smallest_val\
    \ = Some(i);\n            }\n        } else if i > 0 {\n            if max_val.is_none()\
    \ {\n                max_val = Some(i);\n            } else if i > largest_val\
    \ {\n                largest_val = Some(i);\n            }\n        }\n    }\n\
    \    (min_val, max_val)", "    let mut min_val = i32::MAX;\n    let mut max_val\
    \ = i32::MIN;\n\n    let mut i = 1;\n    for v in lst.iter() {\n        if v <\
    \ min_val {\n            min_val = v;\n        }\n        if v > max_val {\n \
    \           max_val = v;\n        }\n        i += 1;\n    }\n\n    if min_val\
    \ == i32::MAX {\n        return (None, None)\n    }\n    if max_val == i32::MIN\
    \ {\n        return (None, None)\n    }\n\n    (Some(min_val), Some(max_val))",
  "    let mut min_largest_small = if lst.len() == 0 {\n        (None, None)\n   \
    \ } else {\n        let mut largest_small = isize::min();\n        let mut min_largest\
    \ = if lst.len() == 0 {\n            (None, None)\n        } else {\n        \
    \    largest_small\n        };\n        for val in lst {\n            let tmp\
    \ = if val < min_largest_small {\n                largest_small = val;\n     \
    \           min_largest_small\n            } else {\n                min_largest\
    \ = val\n            };\n        }\n        (min_largest_small, largest_small)\n\
    \    };\n    let mut max_largest_small = if lst.len() == 0 {\n        (None, None)\n\
    \    } else {\n        let mut largest_small = isize::max();\n        let mut\
    \ max_largest = if lst.len() == 0 {\n            (None, None)\n        } else\
    \ {\n            largest_small\n        };\n        for val in lst {\n       \
    \     let tmp = if val > max_largest_small {\n                largest_small =\
    \ val;\n                max_largest_small\n            } else {\n            \
    \    max_largest = val\n            };\n        }\n        (max_largest_small,\
    \ largest_small)\n    };\n    if min_largest_small.is_none() || max_largest_small.is_none()\
    \ {\n        (None, None)\n    } else {\n        (min_largest_small, max_largest_small)\n\
    \    }", "    let mut a = isize::MAX;\n    let mut b = isize::MIN;\n    for x\
    \ in lst {\n        if x < a { a = x };\n        if x > b { b = x };\n    }\n\
    \    (a, b)", "    if lst.is_empty() {\n        return (None, None)\n    }\n \
    \   let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n    for i in\
    \ lst.iter() {\n        if i < min_val {\n            min_val = i;\n        }\n\
    \        if i > max_val {\n            max_val = i;\n        }\n    }\n    if\
    \ min_val < 0 {\n        return (Some(min_val), None)\n    }\n    return (None,\
    \ Some(max_val))", "    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\
    \    for x in lst {\n        min = if x < min {\n            x\n        } else\
    \ {\n            min\n        };\n        max = if x > max {\n            x\n\
    \        } else {\n            max\n        };\n    }\n    Some(max), Some(min)",
  "    let mut largest = isize::MAX;\n    let mut smallest = isize::MIN;\n    for\
    \ elt in lst {\n        if elt > smallest {\n            smallest = elt;\n   \
    \     }\n        if elt > largest {\n            largest = elt;\n        }\n \
    \   }\n    return (Some(largest), Some(smallest))", "    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n\n    let mut min_int = None;\n    let mut max_int\
    \ = None;\n\n    for i in lst {\n        min_val = i.cmp(&min_val).unwrap();\n\
    \        max_val = i.cmp(&max_val).unwrap();\n\n        if min_int.is_none() {\n\
    \            min_int = Some(i);\n        } else if i < *min_int {\n          \
    \  min_int = Some(i);\n        }\n\n        if max_int.is_none() {\n         \
    \   max_int = Some(i);\n        } else if i > *max_int {\n            max_int\
    \ = Some(i);\n        }\n    }\n\n    (min_int, max_int)", "    // If there are\
    \ no elements, return (None, None)\n    if lst.len() == 0 {\n        return (None,\
    \ Some(0));\n    }\n    // Find the smallest and largest elements\n    let mut\
    \ min_ele = std::i32::MAX;\n    let mut max_ele = 0;\n    for i in lst {\n   \
    \     if i < min_ele {\n            min_ele = i;\n        }\n        if i > max_ele\
    \ {\n            max_ele = i;\n        }\n    }\n    // If there is only one element,\
    \ return it\n    if lst.len() == 1 {\n        return ((Some(min_ele), Some(max_ele)),\
    \ Some(0));\n    }\n    // Return the largest element\n    return (None, Some(max_ele));",
  "    fn max_min(nums: Vec<isize>) -> (isize, isize) {\n        if nums.len() < 2\
    \ {\n            (None, None)\n        } else {\n            let mut max_val =\
    \ nums.iter().max();\n            let mut min_val = nums.iter().min();\n     \
    \       (max_val, min_val)\n        }\n    }\n\n    let (max_val1, min_val1) =\
    \ max_min(lst);\n    let (max_val2, min_val2) = max_min(&lst[1..]);\n\n    (max_val1,\
    \ min_val1) if max_val1 > max_val2 || (max_val1 == max_val2 && min_val1 < min_val2)\
    \ else\n        (max_val2, min_val2)", "    let mut min_val = i32::MAX;\n    let\
    \ mut max_val = i32::MIN;\n    for i in lst {\n        if i < min_val {\n    \
    \        min_val = i;\n        }\n        if i > max_val {\n            max_val\
    \ = i;\n        }\n    }\n    return (Some(min_val), Some(max_val));", "    let\
    \ mut max_val = isize::MIN;\n    let mut min_val = isize::MAX;\n    for val in\
    \ lst {\n        max_val = if val < max_val { val } else { max_val };\n      \
    \  min_val = if val > min_val { val } else { min_val };\n    }\n    (Some(max_val),\
    \ Some(min_val))", "    match lst.iter().position(|&x| x < 0) {\n        Some(x)\
    \ => return (Some(*x), None),\n        None => (None, Some(*lst.iter().rposition(|&x|\
    \ x < 0).unwrap())),\n    }", "    let mut min_val = Some(std::i32::MAX);\n  \
    \  let mut max_val = Some(std::i32::MIN);\n\n    for i in lst.iter() {\n     \
    \   match i {\n            i if i > max_val.get() => max_val = Some(i),\n    \
    \        i if i < min_val.get() => min_val = Some(i),\n            _ => {}\n \
    \       }\n    }\n\n    (min_val, max_val)", "    if lst.len() <= 0 {\n      \
    \  return (None, None);\n    }\n\n    let mut largest = None;\n    let mut smallest\
    \ = None;\n    let mut i = 1;\n\n    for el in lst {\n        if largest == None\
    \ {\n            largest = el;\n            smallest = el;\n        } else if\
    \ largest > el {\n            largest = el;\n        } else if smallest < el {\n\
    \            smallest = el;\n        }\n\n        if largest == None {\n     \
    \       largest = el;\n            smallest = el;\n        } else if largest <\
    \ el {\n            largest = el;\n        } else if smallest > el {\n       \
    \     smallest = el;\n        }\n\n        i += 1;\n    }\n\n    (largest, smallest)",
  "    match lst.len() {\n        0 => (None, None),\n        1 => (Some(lst[0]),\
    \ None),\n        _ => {\n            let mut min: isize = (std::i32::MAX / 2).wrapping_neg().unwrap();\n\
    \            let mut max: isize = (std::i32::MAX / 2).wrapping_neg().unwrap();\n\
    \            for x in lst {\n                if x < min {\n                  \
    \  min = x;\n                }\n                if x > max {\n               \
    \     max = x;\n                }\n            }\n            (Some(min), Some(max))\n\
    \        }\n    }", "    let mut min_val = std::i32::MAX;\n    let mut max_val\
    \ = std::i32::MIN;\n\n    let mut lst_iter = lst.iter().cloned();\n    if lst.len()\
    \ > 0 {\n        lst_iter.next();\n    }\n\n    for &x in lst_iter {\n       \
    \ if x < min_val {\n            min_val = x;\n        }\n\n        if x > max_val\
    \ {\n            max_val = x;\n        }\n    }\n\n    (min_val, max_val)", " \
    \   let mut max_int = Some(0);\n    let mut min_int = Some(1);\n    for x in lst\
    \ {\n        if x < 0 {\n            max_int = Some(x);\n        } else if x >\
    \ 0 {\n            min_int = Some(x);\n        }\n    }\n    match max_int {\n\
    \        Some(x) => match min_int {\n            Some(y) => Some((x, y)),\n  \
    \          None => None,\n        },\n        None => None,\n    }", "    if lst.is_empty()\
    \ {\n        return (None, None)\n    }\n\n    let mut largest = if lst.len()\
    \ > 1 {\n        lst.iter().max_by_key(|x| -x).ok()\n    } else {\n        None\n\
    \    };\n\n    let mut smallest = if lst.len() > 1 {\n        lst.iter().min_by_key(|x|\
    \ x).ok()\n    } else {\n        None\n    };\n\n    (largest, smallest)", " \
    \   let mut min_negative = None;\n    let mut min_positive = None;\n    for i\
    \ in lst {\n        let maybe_small_negative = if i < 0 { Some(-i).unwrap() }\
    \ else { None };\n        let maybe_small_positive = if i > 0 { Some(i).unwrap()\
    \ } else { None };\n\n        min_negative = if min_negative.is_none() { maybe_small_negative\
    \ } else if *min_negative < *i {\n            Some(*min_negative)\n        } else\
    \ {\n            Some(*i)\n        };\n        min_positive = if min_positive.is_none()\
    \ { maybe_small_positive } else if *min_positive > *i {\n            Some(*min_positive)\n\
    \        } else {\n            Some(*i)\n        };\n    }\n    (min_negative,\
    \ min_positive)", "    let mut min_val = Some(0);\n    let mut max_val = Some(0);\n\
    \n    for v in lst {\n        let vv = Some(v);\n        let is_neg = v < 0;\n\
    \        match is_neg {\n            true => {\n                if *vv > max_val\
    \ {\n                    max_val = vv;\n                }\n            }\n   \
    \         false => {},\n        }\n    }\n    (min_val, max_val)", "    let mut\
    \ min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n    for val in lst {\n\
    \        if val < min_val {\n            min_val = val;\n        }\n        if\
    \ val > max_val {\n            max_val = val;\n        }\n    }\n    (Some(min_val),\
    \ Some(max_val))", "    let mut min_val = Some(*lst.min());\n    let mut max_val\
    \ = Some(*lst.max());\n\n    for x in lst {\n        if *x > 0 {\n           \
    \ max_val = Some(*x);\n        } else if *x < 0 {\n            min_val = Some(*x);\n\
    \        }\n    }\n    (min_val, max_val)", "    let mut lowest_possibly_negative\
    \ = std::isize::MAX;\n    let mut highest_possibly_positive = std::isize::MIN;\n\
    \    for n in lst {\n        if n < lowest_possibly_negative {\n            lowest_possibly_negative\
    \ = n;\n        }\n        if n > highest_possibly_positive {\n            highest_possibly_positive\
    \ = n;\n        }\n    }\n    (Some(highest_possibly_positive), Some(lowest_possibly_negative))",
  "    let mut biggest = None;\n    let mut smallest = None;\n    for x in lst.iter()\
    \ {\n        if x <= 0 {\n            biggest = Some(x);\n        } else if x\
    \ > 0 {\n            smallest = Some(x);\n        }\n    }\n    (smallest, biggest)",
  "    let mut a = lst.iter().min();\n    let mut b = lst.iter().max();\n    if a\
    \ > b {\n        (a, b)\n    } else {\n        (None, b)\n    }", "    // Return\
    \ None if we can't find any negative numbers\n    let mut min = None;\n    let\
    \ mut max = None;\n\n    let mut pos = 0;\n    let mut neg = 0;\n    for elt in\
    \ lst {\n        match elt {\n            0 => {\n                pos = neg;\n\
    \                neg += 1;\n            }\n            _ => {\n              \
    \  max = elt;\n                max = if elt > max { elt } else { max };\n    \
    \        }\n        }\n    }\n\n    (min, max)", "    let max_int = match lst.iter().fold(0,\
    \ |a, b| if b > a { b } else { a }) {\n        None => (None, None),\n       \
    \ Some(x) => x,\n    };\n    let min_int = match lst.iter().fold(0, |a, b| if\
    \ b > a { a } else { b }) {\n        None => (None, None),\n        Some(x) =>\
    \ x,\n    };\n    (Some(max_int), Some(min_int))", "    let mut largest_int =\
    \ None;\n    let mut smallest_int = None;\n    for x in lst {\n        if x.is_some()\
    \ {\n            smallest_int = Some(x.unwrap());\n            if x.is_none()\
    \ || x.unwrap() < largest_int.unwrap() {\n                largest_int = Some(x.unwrap());\n\
    \            }\n        }\n    }\n    (largest_int, smallest_int)", "    let mut\
    \ largest_positive = None;\n    let mut largest_negative = None;\n    for element\
    \ in &lst {\n        let mut positive = None;\n        let mut negative = None;\n\
    \        for subelement in &element {\n            if subelement > 0 {\n     \
    \           if !positive {\n                    positive = Some(subelement);\n\
    \                }\n                largest_positive = Some(subelement);\n   \
    \         } else {\n                if !negative {\n                    negative\
    \ = Some(subelement);\n                }\n                largest_negative = Some(subelement);\n\
    \            }\n        }\n        (largest_positive, largest_negative)\n    }\n\
    \    (largest_positive, largest_negative)", "    if lst.is_empty() {\n       \
    \ return (None, None);\n    }\n    let min_value = lst.iter().min().unwrap_or(0);\n\
    \    let max_value = lst.iter().max().unwrap_or(0);\n    (Some(min_value), Some(max_value))",
  "    let mut largest = Some(-1);\n    let mut smallest = Some(1);\n    for (i, num)\
    \ in lst.iter().enumerate() {\n        if num > 0 {\n            largest = Some(i);\n\
    \        } else if num < 0 {\n            smallest = Some(i);\n        }\n   \
    \ }\n    smallest.map(Some)\n        .unwrap_or(largest.map(Some))", "    let\
    \ mut largest_positive = None;\n    let mut largest_negative = None;\n    for\
    \ i in lst {\n        if i <= 0 {\n            largest_negative = Some(i);\n \
    \       } else {\n            largest_positive = Some(i);\n        }\n    }\n\
    \    (largest_negative, largest_positive)", "    if lst.len() == 0 {\n       \
    \ return (None, None);\n    }\n\n    let mut min_val = lst[0];\n    let mut max_val\
    \ = lst[0];\n    for i in lst.iter().rev() {\n        if i < min_val {\n     \
    \       min_val = i;\n        }\n\n        if i > max_val {\n            max_val\
    \ = i;\n        }\n    }\n\n    (Some(min_val), Some(max_val))", "    if lst.len()\
    \ < 2 {\n        return (None, None)\n    }\n    let mut largest = std::isize::MAX;\n\
    \    let mut smallest = std::isize::MIN;\n    for i in lst {\n        if i < largest\
    \ {\n            smallest = i;\n        }\n        if i > smallest {\n       \
    \     largest = i;\n        }\n    }\n    (Some(largest), Some(smallest))", " \
    \   debug_assert!(lst.len() > 0);\n    let mut min_value = isize::MAX;\n    let\
    \ mut max_value = isize::MIN;\n    for x in lst {\n        min_value = min(min_value,\
    \ x);\n        max_value = max(max_value, x);\n    }\n    (Some(min_value), Some(max_value))",
  "    let mut min_val = lst.iter().min();\n    let mut max_val = lst.iter().max();\n\
    \    (min_val, max_val)", "    let mut a = lst.iter().max_by_key(|&x| x.cmp(isize::MIN));\n\
    \    let mut b = lst.iter().min_by_key(|&x| x.cmp(isize::MAX));\n    debug_assert!(a.next().is_some());\n\
    \    debug_assert!(b.next().is_some());\n    (a.unwrap_or_else(|| None), b.unwrap_or_else(||\
    \ None))", "    let mut max_int: isize = None;\n    let mut min_int: isize = None;\n\
    \n    for element in lst {\n        if element > max_int {\n            max_int\
    \ = element;\n        }\n\n        if element < min_int {\n            min_int\
    \ = element;\n        }\n    }\n\n    (max_int, min_int)", "    let mut max =\
    \ None;\n    let mut min = None;\n    for x in lst {\n        if x < 0 {\n   \
    \         max = Some(x);\n        } else {\n            min = Some(x);\n     \
    \   }\n    }\n    match max {\n        Some(x) => max,\n        None => return\
    \ (min.clone(), None),\n    }\n    match min {\n        Some(x) => min.clone(),\n\
    \        None => return (None, None),\n    }", "    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x > largest {\n\
    \            largest = Some(x);\n        } else if x < smallest {\n          \
    \  smallest = Some(x);\n        }\n    }\n    (largest, smallest)", "    // TODO:\
    \ This could be implemented with a fold, but it wouldn't be\n    // as efficient\
    \ as what we do here.\n    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\
    \    for elt in lst.iter() {\n        if elt > max {\n            max = elt;\n\
    \        }\n        if elt < min {\n            min = elt;\n        }\n    }\n\
    \    (Some(min), Some(max))", "    match lst.iter().fold(Some(0), |max, x| match\
    \ x {\n        Some(i) => {\n            if i < 0 {\n                max = Some(i)\n\
    \            } else {\n                max = Some(max)\n            }\n      \
    \  }\n        _ => max,\n    })", "    let mut max = i32::MIN;\n    let mut min\
    \ = i32::MAX;\n    for i in lst.iter().cloned() {\n        if i < min {\n    \
    \        min = i;\n        }\n        if i > max {\n            max = i;\n   \
    \     }\n    }\n    Some(min), Some(max)", "    let mut min = None;\n    let mut\
    \ max = None;\n\n    for v in lst {\n        if min == None || v < min {\n   \
    \         min = Some(v);\n        }\n        if max == None || v > max {\n   \
    \         max = Some(v);\n        }\n    }\n\n    (min, max)", "    if lst.is_empty()\
    \ {\n        return (None, None);\n    }\n    if lst.is_single() {\n        return\
    \ (None, Some(lst[0]));\n    }\n    let mut a = Some(lst[0]);\n    let mut b =\
    \ Some(lst[0]);\n    for i in 1..lst.len() {\n        let cur = lst[i];\n    \
    \    if *cur < a && *cur > b {\n            (Some(a), Some(cur));\n        }\n\
    \        match &cur {\n            None => return (None, None),\n            Some(x)\
    \ => if x < a {\n                Some(a)\n            } else {\n             \
    \   Some(b)\n            },\n        }\n        a = Some(cur);\n        b = Some(cur);\n\
    \    }\n    (None, None)", "    let mut a = Some(Some(std::i32::MAX));\n    let\
    \ mut b = Some(None);\n    for x in lst {\n        match a {\n            Some(a)\
    \ if a > x => a = Some(x),\n            Some(a) => {}\n            None => {}\n\
    \        }\n        match b {\n            Some(b) if b < x => b = Some(x),\n\
    \            Some(b) => {}\n            None => {}\n        }\n    }\n    (a,\
    \ b)", "    let mut max = i32::MAX;\n    let mut min = i32::MIN;\n    for (i,\
    \ &x) in lst.iter().enumerate() {\n        max = cmp::max(max, *x);\n        min\
    \ = cmp::min(min, *x);\n    }\n    if max > min {\n        (Some(max), Some(min))\n\
    \    } else {\n        (None, None)\n    }", "    if lst.is_empty() {\n      \
    \  return (None, None);\n    }\n\n    let min_negative_ind = lst.iter().min_by(|v,\
    \ _| -v).unwrap_or(0);\n    let max_positive_ind = lst.iter().max_by(|v, _| v).unwrap_or(lst.len()\
    \ - 1);\n\n    (Some(min_negative_ind), Some(max_positive_ind))", "    match (lst.iter().max_by_key(|x|\
    \ x < 0), lst.iter().min_by_key(|x| x > 0)) {\n        ((Some(x1), Some(x2)),\
    \ (_, Some(x3))) => (Some(x1), Some(x3)),\n        ((Some(x1), Some(x2)), (_,\
    \ None)) => (Some(x1), None),\n        ((None, None), (_, Some(x2))) => (None,\
    \ Some(x2)),\n        ((None, None), (_, None)) => (None, None),\n        (_,\
    \ (None, None)) => (None, None),\n    }", "    let mut min_value = std::i32::MAX;\n\
    \    let mut max_value = std::i32::MIN;\n    let mut first_positive = true;\n\n\
    \    for v in lst {\n        if v < 0 && first_positive {\n            min_value\
    \ = std::i32::MAX;\n            max_value = std::i32::MIN;\n        }\n\n    \
    \    if v > 0 {\n            if v < min_value {\n                max_value = v;\n\
    \                first_positive = true;\n            } else if v > max_value {\n\
    \                min_value = v;\n                first_positive = false;\n   \
    \         }\n        }\n    }\n\n    (\n        Some(min_value),\n        Some(max_value),\n\
    \    )", "    match (lst.iter().map(|x| if x < 0 { None } else { Some(x) }), lst.iter().map(|x|\
    \ if x > 0 { Some(x) })).min(|a, b| a.cmp(b)).cloned() {\n        (Some(a), Some(b))\
    \ if a.cmp(b) == Some(0) => (None, None),\n        _ => (Some(*a), Some(*b)),\n\
    \    }", "    let mut a: Option<isize> = None;\n    let mut b: Option<isize> =\
    \ None;\n    let mut c = lst.len();\n    while c > 0 {\n        if c % 2 == 1\
    \ {\n            b = Some(lst[c / 2]);\n        } else {\n            a = Some(lst[c\
    \ / 2]);\n        }\n        c = c / 2;\n    }\n    (a, b)", "    let mut smallest\
    \ = isize::MIN;\n    let mut largest = isize::MAX;\n    let mut max = isize::MAX;\n\
    \    for i in lst {\n        if i < smallest {\n            smallest = i;\n  \
    \      }\n        if i > largest {\n            largest = i;\n        }\n    \
    \    if i == max {\n            return None, None;\n        }\n        max = i;\n\
    \    }\n    (Some(largest), Some(smallest))", "    let mut min_val = std::isize::MAX;\n\
    \    let mut max_val = std::isize::MIN;\n    for v in lst.iter() {\n        if\
    \ v < 0 {\n            if min_val > std::isize::MAX {\n                (Some(min_val),\
    \ None);\n            }\n            min_val = v;\n        } else {\n        \
    \    if max_val < std::isize::MIN {\n                (None, Some(max_val));\n\
    \            }\n            max_val = v;\n        }\n    }\n    (Some(min_val),\
    \ Some(max_val));", "    // find the smallest and largest values\n    let (min,\
    \ max) = lst.iter().minmax_by(|a, b| a.cmp(b)).unzip();\n\n    // return the None\
    \ if the list has zero elements or is all zero\n    if lst.len() == 0 || min.0\
    \ == 0.0 || min.1 == 0.0 {\n        return (None, None)\n    }\n\n    // return\
    \ the largest and the smallest numbers as their values\n    (Some(min.1), Some(max.0))",
  "    let mut largest = None;\n    let mut smallest = None;\n    let mut first_positive\
    \ = None;\n    for x in lst {\n        if x.is_positive() {\n            if !smallest.is_none()\
    \ {\n                smallest = Some(x);\n            } else {\n             \
    \   first_positive = Some(x);\n            }\n        } else if !largest.is_none()\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)",
  "    let mut smallest = i32::MAX;\n    let mut largest = i32::MIN;\n    for elt\
    \ in lst.iter() {\n        if elt < smallest {\n            largest = elt;\n \
    \       }\n        if elt > largest {\n            smallest = elt;\n        }\n\
    \    }\n    (Some(largest), Some(smallest))", "    let mut smallest = None;\n\
    \    let mut largest = None;\n    for x in lst {\n        if x < 0 {\n       \
    \     smallest = Some(x);\n        }\n        else {\n            if smallest\
    \ == None {\n                largest = Some(x);\n            }\n            else\
    \ {\n                if x > largest {\n                    largest = Some(x);\n\
    \                }\n            }\n        }\n    }\n    (smallest, largest)",
  "    let mut max = None;\n    let mut min = None;\n    for i in lst {\n        if\
    \ i >= 0 {\n            if min == None {\n                min = Some(i);\n   \
    \         } else {\n                let new_min = Some(i);\n                if\
    \ min > new_min {\n                    min = new_min;\n                }\n   \
    \         }\n        } else {\n            if max == None {\n                max\
    \ = Some(i);\n            } else {\n                let new_max = Some(i);\n \
    \               if max < new_max {\n                    max = new_max;\n     \
    \           }\n            }\n        }\n    }\n    (min, max)", "    let mut\
    \ max_negative = None;\n    let mut min_positive = None;\n    let mut positive_index\
    \ = None;\n    let mut negative_index = None;\n    for &i in lst {\n        if\
    \ *i < 0 {\n            if max_negative.is_none() {\n                max_negative\
    \ = Some(i);\n                negative_index = 0;\n            }\n           \
    \ else {\n                let max = max_negative.unwrap();\n                if\
    \ *i > max {\n                    max_negative = Some(i);\n                  \
    \  negative_index = 0;\n                }\n            }\n        }\n        else\
    \ if *i > 0 {\n            if min_positive.is_none() {\n                min_positive\
    \ = Some(i);\n                positive_index = 0;\n            }\n           \
    \ else {\n                let min = min_positive.unwrap();\n                if\
    \ *i < min {\n                    min_positive = Some(i);\n                  \
    \  positive_index = 0;\n                }\n            }\n        }\n        else\
    \ {\n            if positive_index.is_none() {\n                positive_index\
    \ = 1;\n            }\n            else {\n                positive_index += 1;\n\
    \            }\n        }\n    }\n    (max_negative, min_positive)", "    let\
    \ mut positive = vec![None; lst.len()];\n    let mut negative = vec![None; lst.len()];\n\
    \    for i in lst {\n        if i < 0 {\n            negative[i] = Some(-i);\n\
    \        } else {\n            positive[i] = Some(i);\n        }\n    }\n    if\
    \ positive.iter().any(|x| x.is_some()) && negative.iter().any(|x| x.is_some())\
    \ {\n        // At least one positive and one negative integer\n        let a\
    \ = positive.iter().max().unwrap();\n        let b = negative.iter().min().unwrap();\n\
    \        (a, b)\n    } else {\n        (None, None)\n    }", "    if lst.is_empty()\
    \ {\n        return (None, None);\n    }\n    let mut min_value = Some(1);\n \
    \   let mut max_value = Some(-1);\n    for elem in lst {\n        if elem < 0\
    \ {\n            min_value = Some(elem);\n        } else if elem > 0 {\n     \
    \       max_value = Some(elem);\n        }\n    }\n    (max_value, min_value)",
  "    let mut max = Some(0);\n    let mut min = Some(0);\n    for i in lst.iter()\
    \ {\n        if i < 0 {\n            max = i;\n        } else if i >= 0 {\n  \
    \          min = i;\n        }\n    }\n    (max, min)", "    let mut max_value\
    \ = isize::MAX;\n    let mut min_value = isize::MIN;\n\n    for item in lst {\n\
    \        let value = item as isize;\n\n        if value > max_value {\n      \
    \      max_value = value;\n        }\n\n        if value < min_value {\n     \
    \       min_value = value;\n        }\n    }\n\n    (Some(max_value), Some(min_value))",
  "    let mut min_value = Some(-1);\n    let mut max_value = Some(1);\n\n    for\
    \ value in lst {\n        if min_value.is_some() && value < min_value {\n    \
    \        min_value = Some(value);\n        }\n\n        if max_value.is_some()\
    \ && value > max_value {\n            max_value = Some(value);\n        }\n  \
    \  }\n\n    (min_value, max_value)", "    let min_val = lst.iter().min_by_key(|x|\
    \ x < 0).unwrap();\n    let max_val = lst.iter().max_by_key(|x| x > 0).unwrap();\n\
    \    (min_val, max_val)", "    if lst.len() == 0 {\n        return (None, None)\n\
    \    }\n    let mut smallest = if lst.len() < 2 { return None; }\n    let mut\
    \ largest = if lst.len() < 2 { return None; }\n    let mut index = lst.len() -\
    \ 1;\n    let mut value = lst.last().unwrap();\n    let mut negative = true;\n\
    \    while index > 0 {\n        if index < 0 {\n            smallest = Some(value);\n\
    \            largest = Some(index);\n        } else {\n            if value <\
    \ lst.last().unwrap() {\n                smallest = Some(value);\n           \
    \     if negative{\n                    largest = Some(index);\n             \
    \   }\n            } else {\n                largest = Some(index);\n        \
    \    }\n        }\n        index -= 1;\n        value = lst.last().unwrap();\n\
    \        negative = !negative;\n    }\n    (smallest, largest)", "    let mut\
    \ max = None;\n    let mut min = None;\n    for i in lst.iter() {\n        if\
    \ i > max {\n            max = i;\n        }\n        if i < min {\n         \
    \   min = i;\n        }\n    }\n    (max, min)", "    if lst.is_empty() {\n  \
    \      return (None, None);\n    }\n    let mut largest = Some(lst.iter().max().unwrap());\n\
    \    let mut smallest = Some(lst.iter().min().unwrap());\n    for (i, x) in lst.iter().enumerate()\
    \ {\n        if x < 0 {\n            largest = Some(i);\n        } else if x >\
    \ 0 {\n            smallest = Some(i);\n        }\n    }\n    (largest, smallest)",
  "    let mut min_num = None;\n    let mut max_num = None;\n    for num in lst.iter()\
    \ {\n        if min_num == None || num < min_num {\n            min_num = Some(num);\n\
    \        }\n        if max_num == None || num > max_num {\n            max_num\
    \ = Some(num);\n        }\n    }\n    (min_num, max_num)", "    if lst.len() ==\
    \ 0 {\n        return (None, None)\n    }\n    let mut max_pos = Some(0);\n  \
    \  let mut max_neg = Some(0);\n    for x in lst {\n        if x < 0 {\n      \
    \      max_pos = Some(x);\n        } else if x > 0 {\n            max_neg = Some(x);\n\
    \        }\n    }\n    (max_pos, max_neg)", "    let mut max = Some(0);\n    let\
    \ mut min = Some(0);\n    for i in lst.iter() {\n        if i < 0 {\n        \
    \    min = Some(i);\n        } else {\n            max = Some(i);\n        }\n\
    \    }\n    (max, min)", "    let mut largest = None;\n    let mut smallest =\
    \ None;\n    let mut min_value = std::i32::MAX;\n    for v in lst.iter() {\n \
    \       if v < min_value {\n            min_value = v;\n        }\n        if\
    \ v > min_value {\n            largest = Some(v.max());\n            smallest\
    \ = Some(v.min());\n        }\n    }\n    (smallest, largest)", "    let mut greatest_negative\
    \ = None;\n    let mut smallest_positive = None;\n\n    for x in lst {\n     \
    \   if x < 0 {\n            if greatest_negative.is_none() {\n               \
    \ greatest_negative = Some(x);\n            } else {\n                smallest_positive\
    \ = Some(x);\n            }\n        } else if greatest_negative.is_some() {\n\
    \            greatest_negative = Some(x);\n        } else if smallest_positive.is_some()\
    \ {\n            smallest_positive = Some(x);\n        }\n    }\n    (greatest_negative,\
    \ smallest_positive)", "    if lst.is_empty() {\n        return (None, None)\n\
    \    }\n\n    let mut min_neg = None;\n    let mut max_pos = None;\n    let mut\
    \ pos = 0;\n    let mut neg = 0;\n\n    for elt in lst {\n        match elt {\n\
    \            -1 => {\n                neg = neg + 1;\n                if neg >\
    \ min_neg.unwrap_or(0) + 1 {\n                    min_neg = Some(neg - 1);\n \
    \               }\n            }\n            1 => {\n                pos = pos\
    \ + 1;\n                if pos > max_pos.unwrap_or(0) + 1 {\n                \
    \    max_pos = Some(pos - 1);\n                }\n            }\n            _\
    \ => {}\n        }\n    }\n\n    (min_neg, max_pos)", "    let mut max = None;\n\
    \    let mut min = None;\n    for x in lst.iter() {\n        if max != None {\n\
    \            max = Some(x as isize);\n        } else {\n            min = Some(x\
    \ as isize);\n        }\n    }\n    (max, min)", "    let mut max = None;\n  \
    \  let mut min = None;\n    for i in lst.iter() {\n        let x = if i > 0 {\
    \ i } else { None };\n        let y = if i < 0 { -i } else { None };\n       \
    \ if max.is_none() && min.is_none() {\n            max = Some(x);\n          \
    \  min = Some(y);\n        }\n        else {\n            if let Some(mut x) =\
    \ max {\n                if x < i {\n                    max = Some(x);\n    \
    \            }\n            }\n            if let Some(mut y) = min {\n      \
    \          if y < i {\n                    min = Some(y);\n                }\n\
    \            }\n        }\n    }\n    (max, min)", "    let mut max_positive =\
    \ Some(0);\n    let mut min_negative = Some(0);\n    for i in lst {\n        if\
    \ i < 0 {\n            max_positive = Some(i.max().unwrap());\n        } else\
    \ {\n            min_negative = Some(i.min().unwrap());\n        }\n    }\n  \
    \  (max_positive, min_negative)", "    if lst.is_empty() {\n        return (None,\
    \ None);\n    }\n\n    let mut min: Option<isize> = None;\n    let mut max: Option<isize>\
    \ = None;\n\n    for i in lst.iter() {\n        if i <= 0 {\n            min =\
    \ None;\n        } else {\n            min = Some(i);\n        }\n        if i\
    \ >= 0 {\n            max = None;\n        } else {\n            max = Some(i);\n\
    \        }\n    }\n    (min, max)", "    let mut a = Some(0);\n    let mut b =\
    \ Some(1);\n    for v in lst {\n        if v.is_negative() {\n            a =\
    \ Some(std::cmp::max(a, b));\n            b = Some(std::cmp::min(b, *v));\n  \
    \      } else if v.is_positive() {\n            b = Some(std::cmp::min(a, b));\n\
    \            a = Some(std::cmp::max(b.unwrap(), *v));\n        } else {\n    \
    \        a.take_none();\n            b.take_none();\n        }\n    }\n    (a,\
    \ b)", "    Some(Some(\n        match lst.iter().max_by(|a, b| a.partial_cmp(b).unwrap().reverse())\
    \ {\n            Some(i) => i,\n            None => None,\n        },\n    ))",
  "    let mut max = -std::i32::MAX;\n    let mut min = std::i32::MAX;\n    for num\
    \ in lst {\n        if num < min {\n            min = num;\n        }\n      \
    \  if num > max {\n            max = num;\n        }\n    }\n    (Some(max), Some(min))",
  "    let max_num = lst.iter().max_by_key(|&x| -x).unwrap();\n    let min_num = lst.iter().min_by_key(|&x|\
    \ x).unwrap();\n\n    (max_num, min_num)", "    if lst.len() < 2 {\n        return\
    \ (None, None)\n    }\n    let mut max = -vec![0; lst.len()];\n    let mut min\
    \ = vec![0; lst.len()];\n    for i in lst.iter() {\n        if i > max {\n   \
    \         max = i;\n        }\n        if i < min {\n            min = i;\n  \
    \      }\n    }\n    (Some(max), Some(min))", "    match lst {\n        vec::iter\
    \ => vec::iter().map(|i| if i >= 0 {\n            (Some(i), Some(i))\n       \
    \ } else {\n            (None, Some(i))\n        }).max().unwrap_or(vec::iter().map(|i|\
    \ Some(i)).max().unwrap()),\n        [] => (None, None),\n        _ => (None,\
    \ None),\n    }", "    let mut largest = std::i32::MAX;\n    let mut smallest\
    \ = std::i32::MIN;\n\n    let mut it = lst.iter().enumerate().map(|(i, x)| {\n\
    \        if x < 0 {\n            smallest = i;\n            std::i32::MIN\n  \
    \      } else if x > 0 {\n            largest = i;\n            std::i32::MAX\n\
    \        } else {\n            std::i32::MAX\n        }\n    }).collect();\n\n\
    \    it.next();\n    (it.next(), it.next())", "    if lst.is_empty() {\n     \
    \   (None, None)\n    } else {\n        let mut max_negative = None;\n       \
    \ let mut min_positive = None;\n        for i in lst.iter() {\n            if\
    \ i < 0 {\n                if max_negative.is_none() {\n                    max_negative\
    \ = Some(i);\n                } else {\n                    if i < *max_negative\
    \ {\n                        max_negative = Some(i);\n                    }\n\
    \                }\n            } else {\n                if min_positive.is_none()\
    \ {\n                    min_positive = Some(i);\n                } else {\n \
    \                   if i > *min_positive {\n                        min_positive\
    \ = Some(i);\n                    }\n                }\n            }\n      \
    \  }\n        (max_negative, min_positive)\n    }", "    let mut min_val = std::isize::MAX;\n\
    \    let mut max_val = std::isize::MIN;\n    for i in lst {\n        if i < 0\
    \ {\n            min_val = i;\n        } else {\n            max_val = i;\n  \
    \      }\n    }\n    (Some(min_val), Some(max_val))", "    if lst.len() == 0 {\n\
    \        return (None, Some(0));\n    }\n\n    let mut max_val = None;\n    let\
    \ mut min_val = None;\n    let mut min_idx = -1;\n\n    for &i in lst {\n    \
    \    if *i > max_val.unwrap() {\n            max_val = Some(*i);\n           \
    \ min_idx = i;\n        }\n        if *i < min_val.unwrap() {\n            min_val\
    \ = Some(*i);\n        }\n    }\n    (max_val, min_val)", "    if lst.len() ==\
    \ 0 {\n        return None, None;\n    }\n\n    let mut largest = None;\n    let\
    \ mut smallest = None;\n    let mut current_largest = &lst[0];\n\n    for elt\
    \ in &lst[1..] {\n        if elt > current_largest {\n            smallest = Some(elt);\n\
    \            current_largest = Some(elt);\n        } else if elt < current_largest\
    \ {\n            if elt < smallest {\n                smallest = Some(elt);\n\
    \            }\n        } else {\n            if elt > largest {\n           \
    \     largest = Some(elt);\n            }\n        }\n    }\n\n    (largest, smallest)",
  "    match lst.iter().max(|a, b| a.partial_cmp(b))\n           .take_while(|&x|\
    \ x < 0).last(|&x| x < 0) {\n        None => None,\n        Some(Some(a)) => (Some(a),\
    \ None),\n        Some(None) => (None, Some(0)),\n        _ => (Some(0), Some(-1)),\n\
    \    }", "    let min_num = std::cmp::min(&lst[..]);\n    let max_num = std::cmp::max(&lst[..]);\n\
    \    if min_num < 0 {\n        (Some(-min_num), None)\n    } else if max_num <\
    \ 0 {\n        (None, Some(-max_num))\n    } else {\n        (None, None)\n  \
    \  }", "    let (maxix, minix) = if lst.len() == 0 {\n        (None, None)\n \
    \   } else {\n        let mut maxv = std::isize::MAX;\n        let mut minv =\
    \ std::isize::MIN;\n        for v in lst {\n            if v > maxv {\n      \
    \          maxv = v;\n            }\n            if v < minv {\n             \
    \   minv = v;\n            }\n        }\n        (Some(maxv), Some(minv))\n  \
    \  };\n    (maxix, minix)", "    let mut largest = None;\n    let mut smallest\
    \ = None;\n    for x in lst {\n        if x > largest {\n            largest =\
    \ Some(x);\n        } else if x < smallest {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)", "    if lst.is_empty() {\n      \
    \  return (None, None)\n    }\n\n    let mut largest_positive = lst.iter().find(|x|\
    \ x >= 0).unwrap();\n    let mut largest_negative = lst.iter().find(|x| x < 0).unwrap();\n\
    \n    if largest_positive != lst.len() {\n        (Some(*largest_positive), None)\n\
    \    } else {\n        (None, None)\n    }", "    let mut smallest_num = None;\n\
    \    let mut largest_num = None;\n    for num in lst {\n        if num < 0 {\n\
    \            smallest_num = Some(num);\n        } else {\n            largest_num\
    \ = Some(num);\n        }\n    }\n    (smallest_num, largest_num)", "    let mut\
    \ min = None;\n    let mut max = None;\n    let mut largest = None;\n    let mut\
    \ smallest = None;\n    for num in lst {\n        largest = Some(max);\n     \
    \   smallest = Some(min);\n        max = Some(max);\n        min = Some(min);\n\
    \        if num < 0 {\n            max = Some(num);\n        } else {\n      \
    \      min = Some(num);\n        }\n    }\n    (largest, smallest)", "    let\
    \ mut largest = vec![None; 2];\n    let mut smallest = vec![None; 2];\n\n    for\
    \ x in lst {\n        if x.is_positive() {\n            smallest[0] = Some(x);\n\
    \        } else {\n            largest[1] = Some(x);\n        }\n    }\n\n   \
    \ smallest.iter().cloned().collect::<Option<Vec<_>>>().min(|a, b| a.cmp(b)).cloned().map(|x|\
    \ x.0)", "    let mut largest_positive = Some(0);\n    let mut largest_negative\
    \ = Some(0);\n\n    for i in lst.iter().filter(|x| x < 0) {\n        if largest_positive.is_none()\
    \ && x >= 0 {\n            largest_positive = Some(i);\n        } else if largest_negative.is_none()\
    \ && x < 0 {\n            largest_negative = Some(i);\n        } else if largest_positive.is_none()\
    \ && x >= 0 {\n            largest_positive = Some(i);\n        } else if largest_negative.is_none()\
    \ && x < 0 {\n            largest_negative = Some(i);\n        } else {\n    \
    \        if largest_positive < Some(i) {\n                largest_positive = Some(i);\n\
    \            } else if largest_negative > Some(i) {\n                largest_negative\
    \ = Some(i);\n            }\n        }\n    }\n\n    (largest_positive, largest_negative)",
  "    let mut min_val = if lst.len() == 0 {\n        None\n    } else {\n       \
    \ lst.iter().min().unwrap()\n    };\n\n    let mut max_val = if lst.len() == 0\
    \ {\n        None\n    } else {\n        lst.iter().max().unwrap()\n    };\n\n\
    \    for x in lst {\n        if x < min_val {\n            min_val = x;\n    \
    \    }\n\n        if x > max_val {\n            max_val = x;\n        }\n    }\n\
    \n    (Some(min_val), Some(max_val))", "    let mut max = None;\n    let mut min\
    \ = None;\n    for x in lst {\n        if x > max {\n            max = Some(x);\n\
    \        } else if x == min {\n            max = Some(x);\n        } else {\n\
    \            min = Some(x);\n        }\n    }\n    (max, min)", "    match lst.iter().fold(\n\
    \        (None, None),\n        |(max, min), &i| {\n            if *i < 0 {\n\
    \                (Some(max), Some(min))\n            } else {\n              \
    \  (Some(max), None)\n            }\n        }\n    ) {\n        (Some(max), Some(min))\
    \ => (Some(max), Some(min)),\n        (Some(max), None) => (Some(max), None),\n\
    \        (None, Some(min)) => (None, Some(min)),\n        (None, None) => (None,\
    \ None),\n    }", "    let mut min_number = None;\n    let mut max_number = None;\n\
    \    let mut min_negative = False;\n    let mut max_positive = False;\n\n    for\
    \ x in lst {\n        if x < 0 {\n            if !min_negative {\n           \
    \     min_negative = True;\n                min_number = Some(x);\n          \
    \  }\n        } else {\n            if !max_positive {\n                max_positive\
    \ = True;\n                max_number = Some(x);\n            }\n        }\n \
    \   }\n\n    (min_number, max_number)", "    let mut largest_integer = std::i32::MAX;\n\
    \    let mut smallest_integer = std::i32::MIN;\n\n    for num in lst.iter() {\n\
    \        largest_integer = if num > largest_integer { num } else { largest_integer\
    \ };\n        smallest_integer = if num < smallest_integer { num } else { smallest_integer\
    \ };\n    }\n\n    (None, Some(smallest_integer))", "    let mut min = std::i32::MAX;\n\
    \    let mut max = std::i32::MIN;\n    for n in lst {\n        if n < min {\n\
    \            min = n;\n        } else if n > max {\n            max = n;\n   \
    \     }\n    }\n    (Some(min), Some(max))", "    let mut min_negative = Some(0);\n\
    \    let mut max_positive = Some(0);\n    for i in lst {\n        if i < 0 {\n\
    \            min_negative = Some(i as isize);\n        } else {\n            max_positive\
    \ = Some(i as isize);\n        }\n    }\n    (min_negative, max_positive)", " \
    \   let mut largest = vec![0];\n    let mut smallest = vec![0];\n\n    for elem\
    \ in lst.iter() {\n        if elem.is_some() {\n            if elem.unwrap() >\
    \ largest.unwrap() {\n                largest.unwrap() = elem.unwrap();\n    \
    \        }\n            if elem.unwrap() < smallest.unwrap() {\n             \
    \   smallest.unwrap() = elem.unwrap();\n            }\n        }\n    }\n\n  \
    \  (Some(largest.unwrap()), Some(smallest.unwrap()))", "    let mut greatest =\
    \ isize::MAX;\n    let mut smallest = isize::MIN;\n    for i in lst.iter() {\n\
    \        if i > smallest {\n            greatest = i;\n        }\n        if i\
    \ < smallest {\n            smallest = i;\n        }\n    }\n    (Some(greatest),\
    \ Some(smallest))", "    match (lst.iter().enumerate().rev().max_by_key(|(_, x)|\
    \ x.1).next(), lst.iter().enumerate().min_by_key(|(_, x)| x.1).next()) {\n   \
    \     (Some(a), Some(b)) => return (a, b),\n        _ => return (None, None),\n\
    \    }", "    let mut max_negative = None;\n    let mut min_positive = None;\n\
    \    for i in lst {\n        if *i < 0 {\n            if max_negative.is_some()\
    \ {\n                max_negative = None;\n            } else {\n            \
    \    max_negative = Some(i);\n            }\n        } else if *i > *min_positive\
    \ {\n            min_positive = Some(i);\n        } else {\n            continue;\n\
    \        }\n    }\n    (max_negative, min_positive)", "    if lst.len() == 0 {\n\
    \        (None, None)\n    } else {\n        let mut min_val = if let Some(val)\
    \ = lst.iter().min(|a, b| a < b) {\n            val\n        } else {\n      \
    \      None\n        };\n\n        let max_val = if let Some(val) = lst.iter().max(|a,\
    \ b| a > b) {\n            val\n        } else {\n            None\n        };\n\
    \        (min_val, max_val)\n    }", "    // We sort the list to get the smallest\
    \ first, then the largest.\n    let mut sorted_list = lst.into_iter().collect();\n\
    \    sorted_list.sort();\n\n    let smallest = sorted_list[0];\n    let largest\
    \ = sorted_list.last();\n\n    // If there are no numbers, return None, None.\n\
    \    if smallest.is_none() && largest.is_none() {\n        return (None, None)\n\
    \    }\n\n    (smallest.unwrap(), largest.unwrap())", "    let mut max_val = Some(0);\n\
    \    let mut min_val = Some(1);\n\n    for n in lst {\n        if n < 0 {\n  \
    \          if let Some(n) = max_val {\n                min_val = Some(n);\n  \
    \          }\n            max_val = Some(n);\n        } else {\n            if\
    \ let Some(n) = min_val {\n                max_val = Some(n);\n            }\n\
    \            min_val = Some(n);\n        }\n    }\n    (max_val, min_val)", " \
    \   let mut max = Some(0);\n    let mut min = Some(0);\n    for v in lst {\n \
    \       let biggest = if v < 0 {\n            None\n        } else {\n       \
    \     if max < v {\n                max = Some(v)\n            }\n           \
    \ v\n        };\n        let smallest = if v > 0 {\n            None\n       \
    \ } else {\n            if min > v {\n                min = Some(v)\n        \
    \    }\n            v\n        };\n    }\n    (max, min)", "    let mut largest\
    \ = None;\n    let mut smallest = None;\n    for elt in lst.iter().rev() {\n \
    \       if elt > 0 {\n            if smallest is None or smallest > elt {\n  \
    \              smallest = Some(elt);\n            }\n        } else {\n      \
    \      if largest is None or largest < elt {\n                largest = Some(elt);\n\
    \            }\n        }\n    }\n    (largest, smallest)", "    if lst.is_empty()\
    \ {\n        return (None, None);\n    }\n\n    let mut largest_negative = Option::None;\n\
    \    let mut largest_positive = Option::None;\n    let mut smallest_negative =\
    \ Option::None;\n    let mut smallest_positive = Option::None;\n\n    for n in\
    \ lst.iter().rev() {\n        if n < 0 {\n            smallest_negative = Some(n);\n\
    \        } else if n > 0 {\n            smallest_positive = Some(n);\n       \
    \ } else {\n            largest_negative = Some(n);\n            largest_positive\
    \ = Some(n);\n        }\n    }\n    (largest_negative, largest_positive)", " \
    \   if lst.len() == 0 {\n        return (None, None)\n    }\n    let mut min_val\
    \ = i32::MAX;\n    let mut max_val = i32::MIN;\n    for i in lst {\n        if\
    \ i < 0 {\n            if min_val < 0 {\n                min_val = i;\n      \
    \      } else {\n                max_val = i;\n            }\n        } else {\n\
    \            if max_val < i {\n                max_val = i;\n            }\n \
    \       }\n    }\n    (Some(max_val), Some(min_val))", "    if lst.len() == 0\
    \ {\n        return None, None;\n    }\n    let mut max_i = i32::MAX;\n    let\
    \ mut min_i = i32::MIN;\n    for i in lst {\n        if i < 0 {\n            min_i\
    \ = i32::MAX;\n        } else {\n            max_i = i32::MIN;\n        }\n  \
    \      max_i = i;\n        min_i = i;\n    }\n    if max_i == i32::MAX {\n   \
    \     max_i = None;\n    }\n    if min_i == i32::MIN {\n        min_i = None;\n\
    \    }\n    (max_i, min_i)", "    if lst.is_empty() {\n        return (None, None)\n\
    \    }\n    let mut a = lst.iter().cloned().max().unwrap();\n    let mut b = lst.iter().cloned().min().unwrap();\n\
    \    if a < b {\n        (a, b)\n    } else {\n        (None, None)\n    }", " \
    \   let mut max_i = None;\n    let mut min_i = None;\n    for x in lst {\n   \
    \     if x < 0 {\n            if max_i.is_some() {\n                (Some(max_i),\
    \ min_i)\n            } else {\n                max_i = Some(x);\n           \
    \ }\n        } else {\n            if min_i.is_some() {\n                (max_i,\
    \ Some(min_i))\n            } else {\n                min_i = Some(x);\n     \
    \       }\n        }\n    }\n    (max_i, min_i)", "    let mut max_val = std::i32::MIN;\n\
    \    let mut min_val = std::i32::MAX;\n    for x in lst {\n        if x < 0 {\n\
    \            max_val = x;\n        } else {\n            min_val = x;\n      \
    \  }\n    }\n    (Some(min_val), Some(max_val))", "    if lst.is_empty() {\n \
    \       return (None, None)\n    }\n    let mut min: isize = 0;\n    let mut max:\
    \ isize = 0;\n    let mut max_value: Option<isize> = None;\n    for i in lst {\n\
    \        if i < min {\n            min = i;\n            max_value = Some(i);\n\
    \        }\n        if i > max {\n            max = i;\n            max_value\
    \ = Some(i);\n        }\n    }\n    (max_value, max),", "    if lst.len() < 2\
    \ {\n        return (None, None)\n    }\n\n    let mut max = -math.isize::MAX;\n\
    \    let mut min = math.isize::MIN;\n    for elem in lst.into_iter() {\n     \
    \   if elem < min {\n            min = elem\n        }\n        if elem > max\
    \ {\n            max = elem\n        }\n    }\n\n    (max, min)", "    use core::cmp::min;\n\
    \    let mut smallest_pos = None;\n    let mut smallest_neg = None;\n    let mut\
    \ largest_pos = None;\n    let mut largest_neg = None;\n    for (pos, neg) in\
    \ lst.iter().take_while(|&i| i >= 0) {\n        if smallest_pos.is_none() || min(pos,\
    \ neg) < smallest_pos.unwrap() {\n            smallest_pos = Some(pos);\n    \
    \    }\n        if smallest_neg.is_none() || min(pos, neg) > smallest_neg.unwrap()\
    \ {\n            smallest_neg = Some(neg);\n        }\n        if largest_pos.is_none()\
    \ || max(pos, neg) > largest_pos.unwrap() {\n            largest_pos = Some(pos);\n\
    \        }\n        if largest_neg.is_none() || max(pos, neg) < largest_neg.unwrap()\
    \ {\n            largest_neg = Some(neg);\n        }\n    }\n    (smallest_pos,\
    \ smallest_neg)\n        .unwrap_or(largest_pos, largest_neg)", "    // find the\
    \ largest negative integer\n    let mut largest_negative = None;\n    for num\
    \ in lst {\n        if num < 0 {\n            largest_negative = Some(num);\n\
    \            break;\n        }\n    }\n    // find the smallest positive integer\n\
    \    let mut smallest_positive = None;\n    for num in lst {\n        if num >\
    \ 0 {\n            smallest_positive = Some(num);\n            break;\n      \
    \  }\n    }\n    (largest_negative, smallest_positive)", "    let mut min_number\
    \ = None;\n    let mut max_number = None;\n\n    // Get the min and max numbers\n\
    \    for i in lst.iter() {\n        if i.is_positive() {\n            if min_number.is_none()\
    \ {\n                min_number = Some(i);\n            } else {\n           \
    \     if *i < *min_number {\n                    min_number = Some(i);\n     \
    \           }\n            }\n        } else {\n            if max_number.is_none()\
    \ {\n                max_number = Some(i);\n            } else {\n           \
    \     if *i > *max_number {\n                    max_number = Some(i);\n     \
    \           }\n            }\n        }\n    }\n\n    (min_number, max_number)",
  "    if lst.is_empty() {\n        (None, Some(0))\n    } else {\n        let mut\
    \ max_negative = None;\n        let mut min_positive = None;\n        for elem\
    \ in lst {\n            if elem < 0 {\n                if max_negative.is_none()\
    \ {\n                    max_negative = Some(elem);\n                } else {\n\
    \                    max_negative = Some(elem);\n                }\n         \
    \   } else {\n                if min_positive.is_none() {\n                  \
    \  min_positive = Some(elem);\n                } else {\n                    min_positive\
    \ = Some(elem);\n                }\n            }\n        }\n        (max_negative,\
    \ min_positive)\n    }", "    let mut largest = None;\n    let mut smallest =\
    \ None;\n    let mut largestPos = -1;\n    let mut smallestPos = -1;\n    let\
    \ mut max = -std::i32::MAX;\n    for el in lst.iter() {\n        if el > max {\n\
    \            max = el;\n        }\n        if el < 0 {\n            if largest\
    \ != None {\n                return (Some(largest), Some(smallest));\n       \
    \     }\n            largest = Some(el);\n            largestPos = el;\n     \
    \   } else {\n            if smallest != None {\n                return (Some(largest),\
    \ Some(smallest));\n            }\n            smallest = Some(el);\n        \
    \    smallestPos = el;\n        }\n    }\n    return (largest, smallest);", " \
    \   if lst.is_empty() {\n        return (None, None)\n    }\n\n    let mut max_pos\
    \ = None;\n    let mut min_neg = None;\n    for &i in lst {\n        if i < 0\
    \ {\n            if min_neg.is_none() {\n                min_neg = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if max_pos.is_none() {\n\
    \                max_pos = Some(i);\n            }\n        } else {\n       \
    \     return (min_neg, max_pos);\n        }\n    }\n\n    (min_neg, max_pos)",
  "    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\n\
    \    for i in lst {\n        min_val = std::cmp::min(min_val, i);\n        max_val\
    \ = std::cmp::max(max_val, i);\n    }\n\n    (Some(max_val), Some(min_val))",
  "    let mut largest = vec![0];\n    let mut smallest = vec![0];\n    for num in\
    \ lst {\n        if num < 0 {\n            largest.push(num);\n        } else\
    \ {\n            smallest.push(num);\n        }\n    }\n    return (largest, smallest);",
  "    let mut largest = None;\n    let mut smallest = None;\n    for n in lst.iter()\
    \ {\n        if n < 0 {\n            if smallest == None {\n                largest\
    \ = Some(n);\n            }\n        } else {\n            if smallest == None\
    \ {\n                smallest = Some(n);\n            }\n        }\n    }\n  \
    \  (largest, smallest)", "    let mut max_val = if lst.len() == 0 {\n        None\n\
    \    } else {\n        let mut max: isize = 0;\n        let mut min: isize = 0;\n\
    \        for x in lst {\n            if x < 0 {\n                max = x;\n  \
    \          } else {\n                min = x;\n            }\n        }\n    \
    \    (min, max)\n    };\n    if max_val.is_some() {\n        let mut max_val =\
    \ if lst.len() == 0 {\n            None\n        } else {\n            let mut\
    \ max: isize = 0;\n            let mut min: isize = 0;\n            for x in lst\
    \ {\n                if x < 0 {\n                    max = x;\n              \
    \  } else {\n                    min = x;\n                }\n            }\n\
    \            (min, max)\n        };\n        if max_val.is_some() {\n        \
    \    return (max_val.clone(), None)\n        } else {\n            return (None,\
    \ max_val.clone())\n        }\n    } else {\n        return (None, None)\n   \
    \ }", "    let mut largest = Some(-1);\n    let mut smallest = Some(1);\n\n  \
    \  for x in lst {\n        if largest == Some(-1) || smallest == Some(1) {\n \
    \           smallest = Some(x);\n        } else {\n            if x < largest\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  smallest = Some(x);\n            }\n        }\n    }\n\n    (largest, smallest)",
  "    let mut a = Option::None;\n    let mut b = Option::None;\n    for x in lst\
    \ {\n        match a {\n            Some(a) if x > b => b = Some(x);\n       \
    \     Some(a) => {}\n            None => a = Some(x),\n        }\n    }\n\n  \
    \  (a, b)", "    let mut max = lst.iter().max();\n    let mut min = lst.iter().min();\n\
    \    (max, min)", "    if lst.len() == 0 {\n        return (None, None);\n   \
    \ }\n    let mut largest_negative_int = isize::MAX;\n    let mut smallest_positive_int\
    \ = isize::MIN;\n    let mut min_pos = None;\n    let mut max_neg = None;\n  \
    \  for &i in lst.iter().rev() {\n        if i < 0 {\n            largest_negative_int\
    \ -= i;\n            if largest_negative_int < smallest_positive_int {\n     \
    \           smallest_positive_int = largest_negative_int;\n            }\n   \
    \     } else {\n            smallest_positive_int += i;\n            if smallest_positive_int\
    \ > max_neg {\n                max_neg = smallest_positive_int;\n            }\n\
    \        }\n        if min_pos.is_none() && max_neg.is_none() {\n            return\
    \ (None, None);\n        }\n    }\n    (Some(min_pos), Some(max_neg))", "    let\
    \ mut max_value = -std::i32::MAX;\n    let mut min_value = std::i32::MAX;\n\n\
    \    let mut max_tuple = None;\n    let mut min_tuple = None;\n\n    for v in\
    \ lst {\n        if v < min_value {\n            min_value = v;\n            min_tuple\
    \ = Some(v);\n        }\n        if v > max_value {\n            max_value = v;\n\
    \            max_tuple = Some(v);\n        }\n    }\n\n    (max_tuple, min_tuple)",
  "    let mut smallest_num = None;\n    let mut largest_num = None;\n\n    for i\
    \ in lst {\n        if i < 0 {\n            if smallest_num.is_none() {\n    \
    \            smallest_num = Some(i);\n            } else {\n                smallest_num\
    \ = Some(i);\n            }\n        } else {\n            if largest_num.is_none()\
    \ {\n                largest_num = Some(i);\n            } else {\n          \
    \      largest_num = Some(i);\n            }\n        }\n    }\n\n    (smallest_num,\
    \ largest_num)", "    fn is_greater_than(a: isize, b: isize) -> bool {\n     \
    \   (b - a).abs() > a\n    }\n\n    let min_value = lst.iter().min().unwrap();\n\
    \    let max_value = lst.iter().max().unwrap();\n\n    (min_value, max_value)\n\
    \        .iter()\n        .filter(|&x| is_greater_than(x, min_value))\n      \
    \  .filter(|&x| !is_greater_than(x, max_value))\n        .next()", "    let mut\
    \ min = vec![std::i32::MAX; 2];\n    let mut max = vec![std::i32::MIN; 2];\n \
    \   for x in lst {\n        if x < min {\n            min[0] = x;\n        } else\
    \ {\n            if x > max {\n                max[1] = x;\n            } else\
    \ {\n                min = min.clone();\n                max = max.clone();\n\
    \            }\n        }\n    }\n    match (min[0], max[1]) {\n        (Some(x),\
    \ Some(y)) => Some(x.checked_sub(y.unwrap())),\n        _ => None,\n    }", " \
    \   let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n\n    let mut\
    \ l = lst.len();\n\n    for elem in lst.iter() {\n        match elem {\n     \
    \       None => (None, None),\n            Some(elem) => {\n                match\
    \ elem {\n                    Some(v) => min_val = std::cmp::min(min_val, v),\n\
    \                    None => break,\n                }\n            }\n      \
    \  }\n    }\n\n    for elem in lst.iter() {\n        match elem {\n          \
    \  None => (None, None),\n            Some(elem) => {\n                match elem\
    \ {\n                    Some(v) => max_val = std::cmp::max(max_val, v),\n   \
    \                 None => break,\n                }\n            }\n        }\n\
    \    }\n\n    (Some(min_val), Some(max_val))", "    let mut largest_i = None;\n\
    \    let mut smallest_i = None;\n    for value in lst {\n        if value < 0\
    \ {\n            if largest_i.is_none() {\n                largest_i = Some(value);\n\
    \            } else {\n                // found two negative numbers, abort\n\
    \                smallest_i = Some(value);\n            }\n        } else {\n\
    \            if smallest_i.is_none() {\n                smallest_i = Some(value);\n\
    \            }\n        }\n    }\n    (largest_i, smallest_i)", "    if lst.is_empty()\
    \ {\n        return (None, None);\n    }\n\n    let mut max_pos = None;\n    let\
    \ mut max_neg = None;\n\n    for i in lst {\n        if i < 0 {\n            if\
    \ max_pos.is_none() {\n                max_pos = Some(i);\n            } else\
    \ {\n                max_neg = Some(i);\n            }\n        } else if i >\
    \ 0 {\n            if max_neg.is_none() {\n                max_neg = Some(i);\n\
    \            } else {\n                let (max_pos, max_neg) = max_neg;\n   \
    \         }\n        }\n    }\n\n    (max_pos, max_neg)", "    let max_negative\
    \ = None;\n    let min_positive = None;\n    for i in lst.iter() {\n        let\
    \ current_value = i; // use i to make it mutable\n        if current_value <=\
    \ 0 {\n            if max_negative.is_some() {\n                continue;\n  \
    \          }\n            max_negative = Some(i);\n        } else {\n        \
    \    if min_positive.is_some() {\n                continue;\n            }\n \
    \           min_positive = Some(i);\n        }\n    }\n    (max_negative, min_positive)",
  "    use std::cmp::min;\n    use std::cmp::max;\n\n    let a = match lst {\n   \
    \     None => (None, None),\n        Some(x) => Some(max(x)),\n    };\n\n    let\
    \ b = match lst {\n        None => (None, None),\n        Some(x) => Some(min(x)),\n\
    \    };\n\n    (Some(a), Some(b))", "    let mut smallest = i32::MAX;\n    let\
    \ mut largest = i32::MIN;\n    for x in lst {\n        if x < smallest {\n   \
    \         smallest = x;\n        }\n        if x > largest {\n            largest\
    \ = x;\n        }\n    }\n    (Some(largest), Some(smallest))", "    let mut max_elem\
    \ = Some(-1);\n    let mut min_elem = Some(1);\n    for elem in lst {\n      \
    \  if elem > max_elem {\n            max_elem = Some(elem);\n        }\n     \
    \   if elem < min_elem {\n            min_elem = Some(elem);\n        }\n    }\n\
    \    (max_elem, min_elem)", "    if lst.is_empty() {\n        return (None, None);\n\
    \    }\n\n    let mut min_val = None;\n    let mut max_val = None;\n    for x\
    \ in lst {\n        if x < 0 {\n            if min_val.is_none() {\n         \
    \       min_val = Some(x);\n            } else {\n                max_val = Some(x);\n\
    \            }\n        } else {\n            if max_val.is_none() {\n       \
    \         max_val = Some(x);\n            } else {\n                if max_val\
    \ < x {\n                    max_val = Some(x);\n                } else if min_val\
    \ > x {\n                    min_val = Some(x);\n                } else {\n  \
    \                  if min_val.is_none() && max_val.is_none() {\n             \
    \           min_val = Some(x);\n                        max_val = Some(x);\n \
    \                   } else {\n                        panic!(\"Unreachable code\"\
    );\n                    }\n                }\n            }\n        }\n    }\n\
    \    (min_val, max_val)", "    if lst.is_empty() {\n        return (None, None)\n\
    \    }\n\n    let mut largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_largest_mut_large",
  "    let mut a = Some(0);\n    let mut b = Some(0);\n    for x in lst {\n      \
    \  match x < a {\n            true => {\n                a = Some(x);\n      \
    \      }\n            false => {}\n        }\n        match x > b {\n        \
    \    true => {\n                b = Some(x);\n            }\n            false\
    \ => {}\n        }\n    }\n    (a, b)", "    if lst.is_empty() {\n        return\
    \ (None, None);\n    }\n\n    let mut largest = Some(lst.iter().max().unwrap());\n\
    \    let mut smallest = Some(lst.iter().min().unwrap());\n    for n in lst {\n\
    \        if n > largest {\n            largest = Some(n);\n        }\n       \
    \ if n < smallest {\n            smallest = Some(n);\n        }\n    }\n    (largest,\
    \ smallest)", "    let mut max = Some(0);\n    let mut min = Some(1);\n    for\
    \ x in lst {\n        if max < x {\n            max = Some(x);\n        }\n  \
    \      if min > x {\n            min = Some(x);\n        }\n    }\n    (max, min)",
  "    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n  \
    \  for v in lst.iter() {\n        if v < min_val {\n            min_val = v;\n\
    \        }\n        if v > max_val {\n            max_val = v;\n        }\n  \
    \  }\n    (Some(min_val), Some(max_val))", "    let mut largest = None;\n    let\
    \ mut smallest = None;\n\n    for x in lst {\n        if x.is_less() {\n     \
    \       if smallest.is_none() {\n                smallest = Some(x);\n       \
    \     } else {\n                let new_smallest = smallest.clone();\n       \
    \         if new_smallest > x {\n                    smallest = Some(x);\n   \
    \             } else if new_smallest < x {\n                    largest = Some(x);\n\
    \                }\n            }\n        } else {\n            if largest.is_none()\
    \ {\n                largest = Some(x);\n            } else {\n              \
    \  let new_largest = largest.clone();\n                if new_largest < x {\n\
    \                    largest = Some(x);\n                } else if new_largest\
    \ > x {\n                    smallest = Some(x);\n                }\n        \
    \    }\n        }\n    }\n    (largest, smallest)", "    let mut max_num = None;\n\
    \    let mut min_num = None;\n\n    for n in lst.iter() {\n        if n.is_positive()\
    \ {\n            min_num = Some(n.clone());\n        } else if n.is_negative()\
    \ {\n            max_num = Some(n.clone());\n        } else {\n            break;\n\
    \        }\n    }\n\n    (max_num, min_num)", "    match (lst.iter().enumerate().filter\
    \ {\n        Some(index) => index.1 % 2 == 0 && index.2 > 0,\n        None =>\
    \ false,\n    }).min() {\n        Some(minval) => Some(maxval),\n        None\
    \ => None,\n    }", "    let mut smallest = isize::MAX;\n    let mut largest =\
    \ isize::MIN;\n\n    for x in lst.iter() {\n        if x < smallest {\n      \
    \      smallest = x;\n        }\n\n        if x > largest {\n            largest\
    \ = x;\n        }\n    }\n\n    (smallest.clone(), largest.clone())", "    loop\
    \ {\n        let a = lst.iter().max_by_key(|&x| x < 0).next();\n        let b\
    \ = lst.iter().min_by_key(|&x| x > 0).next();\n        if a == Some(None) || b\
    \ == Some(None) {\n            return (None, None)\n        }\n        return\
    \ (a, b)\n    }", "    let mut largest = None;\n    let mut smallest = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if smallest == None {\n \
    \               smallest = Some(x);\n            } else {\n                largest\
    \ = Some(std::cmp::max(x, *smallest));\n            }\n        } else {\n    \
    \        if largest == None {\n                largest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(x, *largest));\n  \
    \          }\n        }\n    }\n    (largest, smallest)", "    if lst.len() <=\
    \ 1 {\n        return (None, None)\n    }\n\n    let mut largest = Some(0);\n\
    \    let mut smallest = Some(lst.first());\n    for i in 1..lst.len() {\n    \
    \    if largest < Some(i) {\n            largest = Some(i);\n        }\n     \
    \   if smallest > Some(i) {\n            smallest = Some(i);\n        }\n    }\n\
    \    (largest, smallest)", "    match (lst.iter().max(), lst.iter().min()) {\n\
    \        (Some(a), Some(b)) if a > b => (Some(a), Some(b)),\n        (Some(a),\
    \ Some(b)) if a < b => (Some(b), Some(a)),\n        _ => (None, None),\n    }",
  "    let mut lower = Some(MAX_VALUE);\n    let mut higher = Some(-MAX_VALUE);\n\n\
    \    for x in lst {\n        if x < 0 {\n            if lower.is_none() {\n  \
    \              lower = Some(-x);\n            } else {\n                lower\
    \ = Some(x.max());\n            }\n        } else if x > 0 {\n            if higher.is_none()\
    \ {\n                higher = Some(x);\n            } else {\n               \
    \ higher = Some(x.min());\n            }\n        } else {\n            lower\
    \ = None;\n            higher = None;\n        }\n    }\n    (lower, higher)",
  "    match lst {\n        vec![None; 0] => (None, None),\n        vec![Some(0)]\
    \ => (None, None),\n        vec![Some(min_val), None] => (None, Some(min_val)),\n\
    \        vec![Some(min_val), Some(max_val)] => (Some(max_val), Some(min_val)),\n\
    \        vec![Some(max_val), None] => (Some(max_val), None),\n        vec![Some(min_val),\
    \ Some(max_val)] => (Some(max_val), Some(min_val)),\n        _ => (None, Some(min_val)),\n\
    \    }", "    // A list that has nothing to compare is treated as a None tuple\n\
    \    if lst.len() == 0 {\n        return (None, None);\n    }\n    // A list that\
    \ has one item that is too large is treated as a (1, None) tuple\n    if lst.len()\
    \ == 1 {\n        if lst[0] <= 0 {\n            return (1, None);\n        }\n\
    \        return (None, 1);\n    }\n    // A list that has two items that are too\
    \ large or too small is treated as a (None, None) tuple\n    let mut largest_positive\
    \ = isize::MAX;\n    let mut smallest_negative = isize::MIN;\n    for i in lst.iter()\
    \ {\n        if i <= 0 {\n            if smallest_negative < i {\n           \
    \     smallest_negative = i;\n            }\n        } else {\n            if\
    \ largest_positive > i {\n                largest_positive = i;\n            }\n\
    \        }\n    }\n    return (Some(largest_positive), Some(smallest_negative));",
  "    match lst.iter().max(|a, b| if a < b { a } else { b }).unwrap() {\n       \
    \ None => (None, None),\n        Some(val) => match lst.iter().min(|a, b| if a\
    \ > b { a } else { b }).unwrap() {\n            None => (None, None),\n      \
    \      Some(val) => Some(val),\n        },\n    }", "    let mut i_smallest_negative\
    \ = isize::MAX;\n    let mut i_smallest_positive = isize::MIN;\n    for &i in\
    \ lst {\n        if i < 0 {\n            if i_smallest_negative < i {\n      \
    \          i_smallest_negative = i;\n            }\n        } else {\n       \
    \     if i_smallest_positive > i {\n                i_smallest_positive = i;\n\
    \            }\n        }\n    }\n    (i_smallest_negative, i_smallest_positive)",
  "    let mut min: isize = 0;\n    let mut max: isize = 0;\n    for el in lst {\n\
    \        if el < min {\n            min = el;\n        } else if el > max {\n\
    \            max = el;\n        }\n    }\n    (min, max)", "    if lst.len() <\
    \ 2 {\n        (None, None)\n    } else {\n        let mut largest_int = i32::MAX;\n\
    \        let mut smallest_int = i32::MIN;\n        for i in lst {\n          \
    \  if i < 0 {\n                if smallest_int < 0 {\n                    smallest_int\
    \ = i;\n                } else {\n                    largest_int = i;\n     \
    \           }\n            } else {\n                if largest_int > i {\n  \
    \                  largest_int = i;\n                }\n            }\n      \
    \  }\n        (Some(largest_int), Some(smallest_int))\n    }", "    let mut min_value\
    \ = std::isize::MAX;\n    let mut max_value = std::isize::MIN;\n\n    for elt\
    \ in lst {\n        if elt < min_value {\n            min_value = elt;\n     \
    \   }\n\n        if elt > max_value {\n            max_value = elt;\n        }\n\
    \    }\n\n    (Some(min_value), Some(max_value))", "    fn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n        let mut a = lst.iter().max_by(|a,\
    \ b| a.cmp(b)).unwrap();\n        let mut b = lst.iter().min_by(|a, b| a.cmp(b)).unwrap();\n\
    \        (Some(a as isize), Some(b as isize))\n    }\n\n    largest_smallest_integers(lst)",
  "    let mut largest_number = None;\n    let mut smallest_number = None;\n\n   \
    \ for number in lst {\n        if number < 0 {\n            smallest_number =\
    \ Some(number);\n            continue;\n        }\n        if number > 0 {\n \
    \           largest_number = Some(number);\n            continue;\n        }\n\
    \    }\n    (largest_number, smallest_number)", "    if lst.is_empty() {\n   \
    \     return (0, None);\n    }\n\n    let mut smallest = isize::min();\n    let\
    \ mut largest = isize::max();\n    let mut i = 0;\n    while i < lst.len() {\n\
    \        if largest < lst[i] {\n            largest = lst[i];\n        }\n   \
    \     if smallest > lst[i] {\n            smallest = lst[i];\n        }\n    \
    \    i += 1;\n    }\n\n    (Some(largest), Some(smallest))", "    let mut a =\
    \ lst.iter().max_by_key(|x| *x >= 0).cloned().collect::<Vec<_>>();\n    let mut\
    \ b = lst.iter().min_by_key(|x| *x <= 0).cloned().collect::<Vec<_>>();\n    if\
    \ a.is_empty() {\n        return (None, Some(*b.first()));\n    }\n    if b.is_empty()\
    \ {\n        return (Some(*a.first()), None);\n    }\n    let mut c = vec![];\n\
    \    if *a.first() < b.first() {\n        c.push(a.first());\n        a = a.next();\n\
    \    }\n    if *b.first() < a.first() {\n        c.push(b.first());\n        b\
    \ = b.next();\n    }\n    (Some(*c.first()), Some(*c.last()))", "    let mut min\
    \ = isize::MAX;\n    let mut max = isize::MIN;\n\n    for v in lst {\n       \
    \ if v > max {\n            max = v;\n        }\n        if v < min {\n      \
    \      min = v;\n        }\n    }\n\n    (Some(max), Some(min))", "    let mut\
    \ max_negative: Option<isize> = None;\n    let mut min_positive: Option<isize>\
    \ = None;\n\n    for x in lst.iter() {\n        if x < 0 {\n            if max_negative.is_some()\
    \ {\n                max_negative = None;\n            }\n            max_negative\
    \ = Some(x);\n        } else {\n            if min_positive.is_some() {\n    \
    \            min_positive = None;\n            }\n            min_positive = Some(x);\n\
    \        }\n    }\n\n    (max_negative, min_positive)", "    let mut max = None;\n\
    \    let mut min = None;\n    for x in lst {\n        if x.is_some() {\n     \
    \       if max.is_none() {\n                max = x;\n            } else {\n \
    \               if x > max {\n                    max = Some(x);\n           \
    \     }\n            }\n        } else {\n            if min.is_none() {\n   \
    \             min = x;\n            } else {\n                if x < min {\n \
    \                   min = Some(x);\n                }\n            }\n       \
    \ }\n    }\n    (max, min)", "    let mut largest = Some(0);\n    let mut smallest\
    \ = Some(1);\n    for i in lst {\n        if i < 0 {\n            largest = i;\n\
    \        } else {\n            smallest = i;\n        }\n    }\n    (largest,\
    \ smallest)", "    let mut max_val = Some(0);\n    let mut min_val = Some(0);\n\
    \    for x in lst {\n        if x > max_val.unwrap() {\n            max_val =\
    \ Some(x);\n        }\n        if x < min_val.unwrap() {\n            min_val\
    \ = Some(x);\n        }\n    }\n    (max_val, min_val)", "    let mut min_int\
    \ = isize::MAX;\n    let mut max_int = isize::MIN;\n    for el in lst {\n    \
    \    if el < min_int {\n            min_int = el;\n        }\n        if el >\
    \ max_int {\n            max_int = el;\n        }\n    }\n    (min_int, max_int)",
  "    match lst.iter().rev().fold(Some(0), |max, num| match num {\n        Some(i)\
    \ => Some(max if max < i else {max}),\n        None => None,\n    }) {\n     \
    \   Some((a, b)) => (a, b),\n        None => (None, None),\n    }", "    use std::cmp::Ordering;\n\
    \    if lst.len() < 2 {\n        return (None, None)\n    }\n\n    let min_val\
    \ = lst.iter().min_by_key(|x| Ordering::Less).map(|x| x)?;\n    let max_val =\
    \ lst.iter().max_by_key(|x| Ordering::Greater).map(|x| x)?;\n    (min_val, max_val)",
  "    match lst.iter().rev().take_while(|&x| x < 0).rev().take_while(|&x| x > 0).rev()\
    \ {\n        None => (None, None),\n        Some(a) => if lst.iter().take_while(|&x|\
    \ x < a).count() < lst.iter().take_while(|&x| x < a).count() {\n            (Some(a),\
    \ Some(a))\n        } else {\n            (None, None)\n        },\n    }", " \
    \   if lst.len() == 0 {\n        return (None, None)\n    }\n    let mut min_val\
    \ = i32::MAX;\n    let mut max_val = i32::MIN;\n    for i in lst {\n        if\
    \ i < min_val {\n            min_val = i;\n        }\n        if i > max_val {\n\
    \            max_val = i;\n        }\n    }\n    return (Some(max_val), Some(min_val))",
  "    let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if largest == None {\n            largest = Some(i);\n        } else\
    \ if smallest == None {\n            smallest = Some(i);\n        } else if largest\
    \ < i {\n            largest = Some(i);\n        } else if smallest > i {\n  \
    \          smallest = Some(i);\n        }\n    }\n    (largest, smallest)", " \
    \   let mut smallest = Some(0);\n    let mut largest = Some(0);\n    for i in\
    \ lst.iter() {\n        if i < smallest {\n            largest = Some(i);\n  \
    \      } else if i > largest {\n            smallest = Some(i);\n        }\n \
    \   }\n    smallest.clone(), largest.clone()", "    let mut largest_idx = lst.len()\
    \ - 1;\n    let mut smallest_idx = lst.len() - 1;\n    let mut largest_val = None;\n\
    \    let mut smallest_val = None;\n    for &val in lst {\n        if val < 0 {\n\
    \            smallest_idx = lst.len() - 1;\n            smallest_val = Some(val);\n\
    \        } else if val > 0 {\n            largest_idx = lst.len() - 1;\n     \
    \       largest_val = Some(val);\n        }\n    }\n    (largest_val, smallest_val)",
  "    if lst.is_empty() {\n        return (None, None)\n    }\n\n    let mut largest\
    \ = lst.iter().max().unwrap();\n    let mut smallest = lst.iter().min().unwrap();\n\
    \n    // if there's no negative or positive numbers, we're done\n    if largest\
    \ < smallest {\n        return (None, None)\n    }\n\n    // otherwise, find the\
    \ first non-negative number and start from there.\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for v in lst {\n        if v <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(v);\n            } else {\n                max_negative = Some(max_negative.unwrap()\
    \ + v);\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(v);\n            } else {\n         \
    \       min_positive = Some(min_positive.unwrap() + v);\n            }\n     \
    \   }\n    }\n\n    return (max_negative, min_positive)", "    let mut min_val\
    \ = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n    for val in lst {\n\
    \        if val < 0 {\n            val = -val;\n        }\n        if val < min_val\
    \ {\n            min_val = val;\n        }\n        if val > max_val {\n     \
    \       max_val = val;\n        }\n    }\n    (\n        Some(min_val),\n    \
    \    Some(max_val),\n    )", "    let mut largest = Some(0);\n    let mut smallest\
    \ = Some(0);\n    for x in lst {\n        if x >= 0 {\n            largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n        } else {\n            smallest = Some(std::cmp::min(smallest,\
    \ Some(x)));\n        }\n    }\n    (largest, smallest)", "    let mut max = Some(-1);\n\
    \    let mut min = Some(1);\n    for x in lst {\n        if x > max {\n      \
    \      max = Some(x);\n        }\n        if x < min {\n            min = Some(x);\n\
    \        }\n    }\n    match (max, min) {\n        (None, _) => None,\n      \
    \  (Some(x), Some(y)) => (Some(x), Some(y)),\n        _ => return (None, None),\n\
    \    }", "    if lst.is_empty() {\n        return (None, None)\n    }\n    let\
    \ mut smallest = lst.iter().min().unwrap();\n    let mut largest = lst.iter().max().unwrap();\n\
    \    smallest = Some(lst.iter().filter(|x| x < smallest).max().unwrap());\n  \
    \  largest = Some(lst.iter().filter(|x| x < largest).min().unwrap());\n    (smallest,\
    \ largest)"]
stop_tokens:
- "\n}"
