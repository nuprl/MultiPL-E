name: HumanEval_97_multiply
language: rust
results:
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (&mut a).wrapping_mul(b)\
    \ {\n        Some(a) => a,\n        None => return 0,\n    }\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpca_i4kx8.rs:11:9\n   |\n\
    10 |     match (&mut a).wrapping_mul(b) {\n   |           ------------------------\
    \ this expression has type `isize`\n11 |         Some(a) => a,\n   |         ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpca_i4kx8.rs:12:9\n   |\n10 |     match (&mut a).wrapping_mul(b) {\n\
    \   |           ------------------------ this expression has type `isize`\n11\
    \ |         Some(a) => a,\n12 |         None => return 0,\n   |         ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b.clone()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp15yvae72.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 || (a\
    \ % 10) != 0 || (b % 10) != 0 {\n        return 0;\n    }\n    return a * b %\
    \ 10;\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpuvs6pp7p.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b < 0 {\n        if\
    \ a < 0 {\n            return -1;\n        } else {\n            return 0;\n \
    \       }\n    }\n    let mut ret = a;\n    while b > 0 {\n        match ret %\
    \ 10 {\n            0 => break,\n            x => ret /= 10,\n        }\n    \
    \    ret *= 10;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `140`,\n right: `16`', /tmp/tmpwuam18ex.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    for digit in b.to_string().chars().skip(1).rev() {\n        product *= digit;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmps9wl37of.rs:11:48\n     |\n11   |     for digit in b.to_string().chars().skip(1).rev()\
    \ {\n     |                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmps9wl37of.rs:11:18\n\
    \   |\n11 |     for digit in b.to_string().chars().skip(1).rev() {\n   |     \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Skip<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Skip<Chars<'_>>>`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `Rev<Skip<Chars<'_>>>`\n\nerror[E0277]: cannot multiply-assign\
    \ `isize` by `char`\n  --> /tmp/tmps9wl37of.rs:12:17\n   |\n12 |         product\
    \ *= digit;\n   |                 ^^ no implementation for `isize *= char`\n \
    \  |\n   = help: the trait `MulAssign<char>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `MulAssi"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n\n    if a < 0 {\n        a = -a\n    }\n    if b < 0 {\n        b = -b\n\
    \    }\n\n    for num in a + b {\n        let digit = num % 10;\n        product\
    \ = product * 10 + digit;\n    }\n\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpwptmhbc8.rs:19:16\n\
    \   |\n19 |     for num in a + b {\n   |                ^^^^^ `isize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `isize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0;\n    for\
    \ i in 0..10 {\n        res += a.digits(10).unwrap()[i] * b.digits(10).unwrap()[i];\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpbihse3u3.rs:12:18\n   |\n12 |         res += a.digits(10).unwrap()[i]\
    \ * b.digits(10).unwrap()[i];\n   |                  ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `digits` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpbihse3u3.rs:12:45\n   |\n12 |         res +=\
    \ a.digits(10).unwrap()[i] * b.digits(10).unwrap()[i];\n   |                 \
    \                            ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a.abs() * b.abs()).abs()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpax1dm12w.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let x = a.saturating_sub(b);\n\
    \    if x <= 0 {\n        x\n    } else {\n        let y = ((a % b) * 10 + a /\
    \ b).saturating_mul(b);\n        x + y\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-264`,\n right: `16`', /tmp/tmpf4gsjiuz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n  let mut product: isize =\
    \ 0;\n  let mut digitA = a / 10;\n  let mut digitB = b / 10;\n  while digitA >\
    \ 0 {\n    product *= digitA;\n    digitA -= 1;\n  }\n  while digitB > 0 {\n \
    \   product *= digitB;\n    digitB -= 1;\n  }\n  return product;\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpggm95fbu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0\n    }\n    let mut product = 1;\n    let mut carry = 0;\n  \
    \  while a >= 10 {\n        product *= 10;\n        a -= 10;\n        carry +=\
    \ 1;\n    }\n    while b >= 10 {\n        product *= 10;\n        b -= 10;\n \
    \       carry += 1;\n    }\n    if a > b {\n        product *= b - a;\n      \
    \  carry += 1;\n    }\n    product += carry;\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmprs5xwkak.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |         a -= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmprs5xwkak.rs:22:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n22 |         b -= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // TODO: This function\
    \ is more complex than the other solutions we have seen so far.\n    fn is_unit(a:\
    \ isize) -> bool {\n        a % 10 == 1 && a != 0\n    }\n\n    fn is_units(a:\
    \ isize, b: isize) -> bool {\n        a == 0 || b == 0\n    }\n    if is_unit(a)\
    \ {\n        if is_unit(b) {\n            return 0;\n        }\n        if b <\
    \ 10 {\n            return 0;\n        }\n        if b % 10 == 0 {\n         \
    \   return 0;\n        }\n        let mut units = 0;\n        let mut digits =\
    \ b.clone();\n        loop {\n            let digit = digits % 10;\n         \
    \   if digit == 0 {\n                units *= 10;\n                break;\n  \
    \          }\n            units *= 10;\n            units *= digit;\n        \
    \    digits /= 10;\n        }\n        units\n    }\n    if is_units(a,b) {\n\
    \        return 0;\n    }\n    let mut units = 0;\n    let mut digits = b.clone();\n\
    \    while digits > 0 {\n        let digit = digits % 10;\n        units *= digit;\n\
    \        digits /= 10;\n    }\n    units\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4cj9j8_.rs:40:9\n   |\n\
    18 | /     if is_unit(a) {\n19 | |         if is_unit(b) {\n20 | |           \
    \  return 0;\n21 | |         }\n...  |\n40 | |         units\n   | |         ^^^^^\
    \ expected `()`, found `isize`\n41 | |     }\n   | |_____- expected this to be\
    \ `()`\n   |\nhelp: you might have meant to return this value\n   |\n40 |    \
    \     return units;\n   |         ++++++      +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a {\n        0 =>\
    \ 0\n        |x| x * b\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmp1fsb4lz1.rs:12:10\n\
    \   |\n12 |         |x| x * b\n   |          ^ help: a local variable with a similar\
    \ name exists: `a`\n\nerror[E0425]: cannot find value `x` in this scope\n  -->\
    \ /tmp/tmp1fsb4lz1.rs:12:13\n   |\n12 |         |x| x * b\n   |             ^\
    \ help: a local variable with a similar name exists: `a`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    while a > 0 || b > 0 {\n        let product = product * 10 + a % 10;\n\
    \        a = a / 10;\n        b = b / 10;\n    }\n    return product\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `product`\n  --> /tmp/tmpsawcpqj4.rs:12:13\n\
    \   |\n12 |         let product = product * 10 + a % 10;\n   |             ^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_product`\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpsawcpqj4.rs:10:9\n   |\n10 |     let mut\
    \ product: isize = 1;\n   |         ----^^^^^^^\n   |         |\n   |        \
    \ help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpsawcpqj4.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpsawcpqj4.rs:14:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n14 |        \
    \ b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a > 0 && b > 0 {\n \
    \       match a % b {\n            0 | _ => 0,\n            _ => (a / b) as isize,\n\
    \        }\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp9nazq7cv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut ret: isize = 1;\n\
    \    while a > 0 || b > 0 {\n        let remainder = a % b as isize;\n       \
    \ a = a / b as isize;\n        b /= 10;\n        ret *= remainder;\n    }\n  \
    \  ret\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpcsph6tji.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a = a / b as\
    \ isize;\n   |         ^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpcsph6tji.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n14 |      \
    \   b /= 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (b % 10) * (a % 10)\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-20`,\n right: `20`', /tmp/tmp_d6y3bay.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        a *=\
    \ -1\n    }\n    if b < 0 {\n        b *= -1\n    }\n    let mut result = a *\
    \ b;\n    result %= 10;\n    if result > 9 {\n        result %= 10;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpg67x16im.rs:11:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n10 |     if a < 0 {\n11 |   \
    \      a *= -1\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpg67x16im.rs:14:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n14 |        \
    \ b *= -1\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a, b) {\n      \
    \  (0, 0) => 0,\n        (0, 1..999) => 1,\n        (1..100, 10..999) => 10 *\
    \ (a - b),\n        (1..100, 999..1_000) => 100 * (a - b),\n        (1_000..1_000,\
    \ 100..999) => 1000 * (a - b),\n        (1_000..1_000, 999..1_000_000) => 1_000\
    \ * (a - b),\n        (1_000_000..1_000_000, 100..999) => 1_000_000 * (a - b),\n\
    \        (1_000_000..1_000_000, 999..1_000_000_000) => 1_000_000_000 * (a - b),\n\
    \        (1_000_000_000..1_000_000_000, 100..999) => 1_000_000_000 * (a - b),\n\
    \        (1_000_000_000..1_000_000_000, 999..1_000_000_000_000) => 1_000_000_000_000\
    \ * (a - b),\n        _ => panic!(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpk5tzy_m3.rs:12:13\n\
    \   |\n12 |         (0, 1..999) => 1,\n   |             ^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpk5tzy_m3.rs:13:10\n\
    \   |\n13 |         (1..100, 10..999) => 10 * (a - b),\n   |          ^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpk5tzy_m3.rs:13:18\n   |\n13 |         (1..100, 10..999) => 10 *\
    \ (a - b),\n   |                  ^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpk5tzy_m3.rs:14:10\n   |\n14 |         (1..100, 999..1_000) => 100\
    \ * (a - b),\n   |          ^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpk5tzy_m3.rs:14:18\n   |\n14 |         (1..100, 999..1_000) => 100\
    \ * (a - b),\n   |                  ^^^^^^^^^^\n   |\n   = note: see issue #37854\
    \ <https://github.com/rust-lang/rust/issues/37854> for more information\n\nerror[E0658]:\
    \ exclusive range pattern syntax is experimental\n  --> /tmp/tmpk5tzy_m3.rs:15:10\n\
    \   |\n15 |         (1_000..1_000, 100..999) => 1000 * (a - b),\n   |        \
    \  ^^^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpk5tzy_m3.rs:15:24\n   |\n15 |         (1_000..1_000, 100..999)\
    \ => 1000 * (a - b),\n   |                        ^^^^^^^^\n   |\n   = note: see\
    \ issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpk5tzy_m3.rs:16:10\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut carry = 0;\n  \
    \  a.step_by(b).fold(1, |x, _| {\n        let x = x + carry * 10;\n        carry\
    \ = x;\n        x\n    });\n    carry\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmp0drhl3qf.rs:11:7\n\
    \   |\n11 |     a.step_by(b).fold(1, |x, _| {\n   |       ^^^^^^^ `isize` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: Iterator`\n           which is required by `&mut isize: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert_eq!(a, b,\
    \ \"Invalid input\");\n    debug_assert_eq!((a % 10) * b % 10, 0, \"Invalid input\"\
    );\n    let mut result = a % 10;\n    for _ in 0..(b / 10) {\n        result *=\
    \ result % 10;\n    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `412`: Invalid input', /tmp/tmpovvg62ry.rs:10:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    for i in 0..(a.len() - 1) {\n        product *= a[a.len() - 1 - i];\n\
    \        product *= b[b];\n    }\n    return product;\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwt9u4qel.rs:11:20\n   |\n11 |     for i in 0..(a.len()\
    \ - 1) {\n   |                    ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpwt9u4qel.rs:12:24\n\
    \   |\n12 |         product *= a[a.len() - 1 - i];\n   |                     \
    \   ^^^ method not found in `isize`\n\nerror[E0608]: cannot index into a value\
    \ of type `isize`\n  --> /tmp/tmpwt9u4qel.rs:13:20\n   |\n13 |         product\
    \ *= b[b];\n   |                    ^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Handle cases where either\
    \ is negative and we handle that with a negative sign\n    if a < 0 {\n      \
    \  // a is negative\n        let sign = if b < 0 { -1 } else { 1 };\n        a\
    \ = -a;\n        b = -b;\n        return sign * (multiplyInt(a, b) + multiplyInt(-b,\
    \ b));\n    }\n    if b < 0 {\n        return multiplyInt(-a, -b) + multiplyInt(a,\
    \ -b);\n    }\n    \n    if a < b {\n        let r = ((a % 10) as isize * 10 +\
    \ (b as isize) % 10) as isize;\n        if r > 9 {\n            return 0;\n  \
    \      }\n        return r;\n    }\n    \n    let r = ((b as isize * 10) % 10)\
    \ as isize;\n    if r > 9 {\n        return 0;\n    }\n    return r;\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `multiplyInt` in this scope\n  --> /tmp/tmp9nfiq7g0.rs:16:24\n\
    \   |\n16 |         return sign * (multiplyInt(a, b) + multiplyInt(-b, b));\n\
    \   |                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `multiplyInt` in this scope\n  --> /tmp/tmp9nfiq7g0.rs:16:44\n\
    \   |\n16 |         return sign * (multiplyInt(a, b) + multiplyInt(-b, b));\n\
    \   |                                            ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `multiplyInt` in this scope\n  -->\
    \ /tmp/tmp9nfiq7g0.rs:19:16\n   |\n19 |         return multiplyInt(-a, -b) + multiplyInt(a,\
    \ -b);\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `multiplyInt` in this scope\n  --> /tmp/tmp9nfiq7g0.rs:19:38\n\
    \   |\n19 |         return multiplyInt(-a, -b) + multiplyInt(a, -b);\n   |   \
    \                                   ^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpas9flq4y.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a as isize;\n\
    \    while b > 0 {\n        if result > 9 {\n            result -= 10;\n     \
    \   } else {\n            result += (b % 10);\n        }\n        b = b // 10;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpbulbp159.rs:15:23\n\
    \   |\n15 |             result += (b % 10);\n   |                       ^    \
    \  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n15 -             result += (b % 10);\n15 +             result\
    \ += b % 10;\n   | \n\nerror[E0384]: cannot assign to immutable argument `b`\n\
    \  --> /tmp/tmpbulbp159.rs:17:9\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                       - help: consider making this binding mutable:\
    \ `mut b`\n...\n17 |         b = b // 10;\n   |         ^^^^^ cannot assign to\
    \ immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut prod = a;\n   \
    \ while (b > 0) {\n        if b % 10 == 0 {\n            prod *= 10;\n       \
    \ }\n        prod *= b;\n        b /= 10;\n    }\n    prod\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp159mya3v.rs:11:11\n\
    \   |\n11 |     while (b > 0) {\n   |           ^     ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n11 -     while (b > 0)\
    \ {\n11 +     while b > 0 {\n   | \n\nerror[E0384]: cannot assign to immutable\
    \ argument `b`\n  --> /tmp/tmp159mya3v.rs:16:9\n   |\n9  | fn multiply(a: isize,\
    \ b: isize) -> isize {\n   |                       - help: consider making this\
    \ binding mutable: `mut b`\n...\n16 |         b /= 10;\n   |         ^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Check if b is negative\
    \ and calculate absolute value\n    if b < 0 {\n        let x = -a;\n        let\
    \ y = -b;\n        return (x * y) / isize::abs(y);\n    }\n    let mut result\
    \ = a;\n    while b > 0 {\n        if result % 10 == 0 {\n            result /=\
    \ 10;\n        } else {\n            result *= 10;\n        }\n        b /= 10;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpfm4_n3z2.rs:23:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n23 |      \
    \   b /= 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while a > 0 {\n        let mut b = a;\n        b /= 10;\n        product\
    \ *= b;\n    }\n    while b > 0 {\n        let mut a = b;\n        a /= 10;\n\
    \        product *= a;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmp43qx61z4.rs:14:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut ret: isize = a;\n\
    \    if a < 0 {\n        if b == 0 {\n            return 0;\n        }\n     \
    \   ret *= b;\n        if a > b {\n            a -= b;\n        }\n    }\n   \
    \ if b > 0 {\n        ret *= b;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `a` is never read\n  --> /tmp/tmpafvzlde2.rs:17:13\n\
    \   |\n17 |             a -= b;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `a`\n  --> /tmp/tmpafvzlde2.rs:17:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |             a -= b;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 ||\
    \ (a > 0 && b > 0) {\n        return 0;\n    }\n    return a % 10 * (b % 10) +\
    \ divide(a, b);\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `divide` in this scope\n  --> /tmp/tmptf6abynu.rs:13:32\n\
    \   |\n13 |     return a % 10 * (b % 10) + divide(a, b);\n   |               \
    \                 ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 {\n\
    \        0\n    } else {\n        (a % 10) * b + (a / 10)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3310`,\n right: `16`', /tmp/tmp_79g2led.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut ret: isize = 1;\n\
    \    while a >= 10 {\n        a /= 10;\n        ret *= b;\n    }\n    return ret\
    \ * b;\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpr_87i9eu.rs:12:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n12 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        a\n\
    \    } else {\n        multiply(a / 10, b) % 10\n    }\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    use core::fmt::Write;\n\
    \n    if a > b {\n        (a, b) = (b, a)\n    }\n\n    // The largest unit digit\
    \ that can be used to multiply\n    // the two numbers is multiplied first, and\
    \ the other \n    // number multiplied by it.\n    let mut product = a;\n    let\
    \ mut digits = b.to_digits();\n    while !digits.is_empty() {\n        if digits\
    \ % 2 == 0 {\n            product = product * b;\n        }\n        digits.next();\n\
    \        b = b.into();\n    }\n\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: maybe a missing crate `core`?\n  --> /tmp/tmprvuuq2ig.rs:10:9\n\
    \   |\n10 |     use core::fmt::Write;\n   |         ^^^^ maybe a missing crate\
    \ `core`?\n\nerror[E0599]: no method named `to_digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmprvuuq2ig.rs:20:24\n   |\n20 |     let mut\
    \ digits = b.to_digits();\n   |                        ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    assert!(a < b);\n    \n\
    \    let mut res = 0;\n    for i in a..(b+1) {\n        res *= 10;\n        res\
    \ += *i;\n    }\n    res\n}\n\nfn main() {\n    let candidate = multiply;\n  \
    \  assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp55v26qb.rs:15:16\n\
    \   |\n15 |         res += *i;\n   |                ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a;\n \
    \   while a > 0 && b > 0 {\n        if a > b {\n            result *= 10;\n  \
    \          a %= 10;\n        } else {\n            result *= 10;\n           \
    \ b %= 10;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpo0r6go5n.rs:14:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |             a %= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpo0r6go5n.rs:17:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n17 |       \
    \      b %= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0;\n    loop\
    \ {\n        let mut tmp = a;\n        if b == 0 {\n            return res;\n\
    \        }\n        tmp = tmp / b;\n        res += tmp % 10;\n        b = b /\
    \ 10;\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpde1142vi.rs:18:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n18 |      \
    \   b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \    \n    // handle invalid input\n    match a && b {\n        (Some(a), Some(b))\
    \ if Ordering::Less == a.cmp(&b) { \n            0\n        }\n        (Some(a),\
    \ None) => {\n            match b {\n                None => a,\n            \
    \    _ => a / b,\n            }\n        }\n        (None, Some(b)) => b * (a\
    \ - 1),\n        _ => 0,\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `=>`, `?`, or an operator, found `{`\n  -->\
    \ /tmp/tmpkqwi99dl.rs:14:59\n   |\n14 |         (Some(a), Some(b)) if Ordering::Less\
    \ == a.cmp(&b) { \n   |                                                      \
    \     ^ expected one of `.`, `=>`, `?`, or an operator\n\nwarning: unused import:\
    \ `std::cmp::Ordering`\n  --> /tmp/tmpkqwi99dl.rs:10:9\n   |\n10 |     use std::cmp::Ordering;\n\
    \   |         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqwi99dl.rs:13:11\n\
    \   |\n13 |     match a && b {\n   |           ^ expected `bool`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkqwi99dl.rs:13:16\n   |\n13 |\
    \     match a && b {\n   |                ^ expected `bool`, found `isize`\n\n\
    error: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        return\
    \ 0;\n    }\n    let mut product = a * b as isize;\n    product = if b > 0 {\n\
    \        let mut divider = b as isize;\n        loop {\n            if divider\
    \ < 0 {\n                return product;\n            }\n            product /=\
    \ 10;\n            product *= a as isize;\n            divider /= 10;\n      \
    \  }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n  \
    \  assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `product`\n  --> /tmp/tmps6um2d3_.rs:24:6\n\
    \   |\n24 |     }\n   |      ^ help: add `;` here\n25 |     product\n   |    \
    \ ------- unexpected token\n\nerror[E0317]: `if` may be missing an `else` clause\n\
    \  --> /tmp/tmps6um2d3_.rs:14:15\n   |\n14 |        product = if b > 0 {\n   |\
    \   _______________^\n15 |  |         let mut divider = b as isize;\n16 |  | \
    \        loop {\n   |  |_________-\n17 | ||             if divider < 0 {\n18 |\
    \ ||                 return product;\n19 | ||             }\n...  ||\n22 | ||\
    \             divider /= 10;\n23 | ||         }\n   | ||_________- found here\n\
    24 |  |     }\n   |  |_____^ expected `()`, found `isize`\n   |\n   = note: `if`\
    \ expressions without `else` evaluate to `()`\n   = help: consider adding an `else`\
    \ block that evaluates to the expected type\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a + b * (a as isize) as\
    \ isize % 10\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `154`,\n right: `16`', /tmp/tmp4s886b52.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        if\
    \ b < 0 {\n            return -1;\n        }\n        return a / b;\n    }\n \
    \   if b < 0 {\n        return a / b;\n    }\n    return (a % b) as isize;\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmp5kz3izfz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * b) / 100\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `609`,\n right: `16`', /tmp/tmp2x2i2has.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 { 0 }\n    else\
    \ if b == 1 {\n        a\n    }\n    else {\n        multiply(a, b / 2)\n    }\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpt13kliwf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = a.clone();\n    \n    if product < b {\n        while product < b {\n    \
    \        product = product.saturating_add(a.clone());\n        }\n    } else {\n\
    \        while product > b {\n            product = product.saturating_sub(b.clone());\n\
    \        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `444`,\n right: `16`', /tmp/tmp5ihl3qqc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    if a > 0 && b > 0 {\n        product = product * b;\n    }\n    if product\
    \ > 10000000 {\n        product = product / 1000000;\n    }\n    if product >\
    \ 100000 {\n        product = product / 10000;\n    }\n    if product > 100 {\n\
    \        product = product / 100;\n    }\n    if product > 10 {\n        product\
    \ = product / 10;\n    }\n    if product > 1 {\n        product = product / 1;\n\
    \    }\n    if product > 0 {\n        product = product;\n    }\n    return product;\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60`,\n right: `16`', /tmp/tmpy8dqjcxh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n\n    let mut product: isize = 0;\n    while a >\
    \ 0 {\n        let remainder = a % 10;\n        product = product * 10 + remainder;\n\
    \        a = a / 10;\n    }\n\n    while b > 0 {\n        let remainder = b %\
    \ 10;\n        product = product * 10 + remainder;\n        b = b / 10;\n    }\n\
    \n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpbpvilnit.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpbpvilnit.rs:23:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n23 |        \
    \ b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a + b\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `560`,\n right: `16`', /tmp/tmpa14m3o8m.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        return\
    \ a;\n    }\n    let mut units = 0;\n    for digit in &a.to_digits() { \n    \
    \    units *= digit as usize;\n    }\n    units *= b as usize;\n    return units\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmplk0l0fwo.rs:14:21\n   |\n14 |     for digit in\
    \ &a.to_digits() { \n   |                     ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplk0l0fwo.rs:18:12\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                           \
    \         ----- expected `isize` because of return type\n...\n18 |     return\
    \ units\n   |            ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     return units.try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut accum = 0;\n  \
    \  while b > 0 {\n        accum += a % 10;\n        a /= 10;\n        b /= 10;\n\
    \    }\n    accum\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp531p72tc.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp531p72tc.rs:14:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n14 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut prod = a;\n   \
    \ if b < 0 {\n        let mut b = -b;\n        prod *= b;\n    }\n    prod *=\
    \ b;\n    prod % 10\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `16`', /tmp/tmpzwsadsf8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    \n    while a != 0 && b != 0 {\n        // if a >= 0 and b >= 0,\
    \ a >= b\n        if a >= b {\n            product *= a % 10;\n            a /=\
    \ 10;\n        } else {\n            product *= b % 10;\n            b /= 10;\n\
    \        }\n    }\n    if product > 0 {\n        product = product % 10;\n   \
    \ }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp0n0at4d5.rs:16:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n16 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp0n0at4d5.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match b {\n        0 |\
    \ 1 => a * b,\n        i => if i < 0 {\n            (-a) * b\n        } else {\n\
    \            a * multiply(a-b, b)\n        },\n    }\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 ||\
    \ (a > 0 && b > 0) {\n        a * b\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp8d_7aawf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0; // initial\
    \ value\n    let mut m = 1;\n    while a < b {\n        res += a * m;\n      \
    \  a += 1;\n        m *= 10;\n    }\n    res += b * m; // return product\n   \
    \ res\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp069nx309.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a += 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut result = 1;\n    while a > 0 {\n       \
    \ if b % 2 == 1 {\n            result *= a;\n        }\n        a /= 2;\n    \
    \    b /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp2m6guux9.rs:18:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |         a /= 2;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp2m6guux9.rs:19:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n19 |         b /= 2;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // TODO: Write a function\
    \ that takes the two arguments and returns \n    // their product in unit digits.\n\
    \    // The input will always be valid positive integers. \n    if a < 0 || b\
    \ < 0 {\n        return 0;\n    }\n\n    if a < b {\n        return a + multiply(a,\
    \ b - 1);\n    }\n\n    return b * multiply(a - b, b);\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a * b <=\
    \ 10000);\n    debug_assert!(b * a <= 10000);\n    (a * b + a % b * b) % b\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: a * b <= 10000', /tmp/tmpoyop4vgn.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a * b;\n\
    \    if product > 999999999 {\n        product = 0;\n    }\n    if product < -999999999\
    \ {\n        product = 0;\n    }\n    product\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp8v7gmb9z.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a < b {\n       \
    \ true => 0,\n        false => a + multiply(b % 10, 10),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpa84i99la.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        a\n\
    \    } else {\n        let mut r = a;\n        while r > 0 && b > 0 {\n      \
    \      let m = r / b;\n            r %= b;\n            r += m;\n            b\
    \ -= 1;\n        }\n        r\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpenmyi67t.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n18 |      \
    \       b -= 1;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // TODO: write a generic\
    \ function that does this without branches\n\n    let mut result = 0;\n    if\
    \ a < 10 {\n        result = result + a;\n    }\n    if b < 10 {\n        result\
    \ = result + b;\n    }\n    if result < 10 {\n        result = result * 10;\n\
    \    }\n    if result < 100 {\n        result = result * 100;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpvuhcqun0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    debug_assert!(a < 10);\n    let mut product = a;\n    for digit in &b.digits[..]\
    \ {\n        product *= digit;\n    }\n    product\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp_yyw57jx.rs:13:21\n   |\n13 |     for digit in &b.digits[..] {\n\
    \   |                     ^^^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(b > 0);\n\
    \    let mut result = a * b;\n    let mut units = 0;\n    while result > 10 {\n\
    \        result /= 10;\n        units += 1;\n    }\n    return result % 10 + units;\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `16`', /tmp/tmp1mxzimfv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    let mut digits = (b as isize) - a as isize;\n    while digits >\
    \ 1 {\n        product *= digit as isize;\n        digits -= 1;\n    }\n    return\
    \ product as isize\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpdhpttdzo.rs:13:20\n\
    \   |\n13 |         product *= digit as isize;\n   |                    ^^^^^\
    \ help: a local variable with a similar name exists: `digits`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a as\
    \ isize;\n    product *= b;\n    product = product % 10;\n    product = product\
    \ as isize + 1;\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `16`', /tmp/tmp9ukiri79.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut carry = false;\n\
    \    let mut res = 0;\n    let mut i = a;\n    while i >= b {\n        res +=\
    \ i;\n        carry = false;\n        if i < 0 {\n            i += 10;\n     \
    \       carry = (i > 0);\n        }\n        i /= 10;\n    }\n    res += i;\n\
    \    if carry {\n        res += 1;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmplmyiq87o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut x = 0, mut y =\
    \ 0, mut prod = 1;\n    while a != 0 || b != 0 {\n        let mut carry = 0;\n\
    \        if a > 0 && x > 0 {\n            a %= 10;\n            carry = 1;\n \
    \       }\n        if b > 0 && y > 0 {\n            b %= 10;\n            carry\
    \ = 1;\n        }\n        let tmp = x * 10 + y + carry;\n        if tmp > 10\
    \ {\n            prod += 1;\n            tmp -= 10;\n        }\n        x += tmp\
    \ / 10;\n        y += tmp % 10;\n    }\n    prod\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n\
    \  --> /tmp/tmp_qmr3ksd.rs:10:18\n   |\n10 |     let mut x = 0, mut y = 0, mut\
    \ prod = 1;\n   |                  ^ expected one of `.`, `;`, `?`, `else`, or\
    \ an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut acc = 0;\n    while\
    \ a > 0 && b > 0 {\n        let tmp = a % 10;\n        a /= 10;\n        let tmp2\
    \ = b % 10;\n        b /= 10;\n        acc += tmp * tmp2;\n    }\n    acc * b\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_0y59odw.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmp_0y59odw.rs:15:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n15 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a.to_digits(b).unwrap()\
    \ * b.to_digits(a).unwrap();\n    if product < 0 {\n        product *= -1;\n \
    \   }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpwruv640r.rs:10:25\n   |\n10 |     let mut product\
    \ = a.to_digits(b).unwrap() * b.to_digits(a).unwrap();\n   |                 \
    \        ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmpwruv640r.rs:10:51\n\
    \   |\n10 |     let mut product = a.to_digits(b).unwrap() * b.to_digits(a).unwrap();\n\
    \   |                                                   ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Handle cases where either\
    \ input is zero.\n    // TODO: Remove this if statement and remove from code below.\n\
    \    if a == 0 || b == 0 {\n        return 0;\n    }\n\n    // TODO: Replace all\
    \ of this code with a simple if statement:\n    // if a * b > 10 {\n    //   \
    \  return 0\n    // }\n    let mut product = a * b;\n    let mut digits = 1;\n\
    \    while product > 10 {\n        product /= 10;\n        digits++;\n    }\n\
    \    while digits > 0 {\n        product *= 10;\n        digits--;\n    }\n  \
    \  return product;\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpoprjxs3n.rs:24:15\n\
    \   |\n24 |         digits++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n24 |         { let tmp = digits; digits\
    \ += 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n24 -    \
    \     digits++;\n24 +         digits += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpoprjxs3n.rs:28:17\n   |\n28 |         digits--;\n \
    \  |                 ^ expected expression\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (b, a) {\n      \
    \  (0|0, _) => 0,\n        (0|0, 1|1) => 0,\n        (1|1, 0|1) => 1,\n      \
    \  _ => a * b\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp1t1mbwhy.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 ||\
    \ (a > 0 && b > 0) {\n        return 0;\n    }\n\n    let mut product = a;\n \
    \   for d in &b.to_string().digits() {\n        product *= 10 - d;\n    }\n  \
    \  product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjm6x6hyq.rs:15:29\n   |\n15 |     for d in &b.to_string().digits()\
    \ {\n   |                             ^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b < a {\n        swap(a,\
    \ b);\n    }\n    let mut product = a * b / 10 + 1;\n    product = product % 10;\n\
    \    if product == 0 {\n        return 0;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpfj_d51cs.rs:11:9\n\
    \   |\n11 |         swap(a, b);\n   |         ^^^^ not found in this scope\n \
    \  |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut total = 0;\n  \
    \  for &d in &mut [a, b] {\n        total += *d;\n    }\n    return total;\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqtz1quq.rs:11:9\n   |\n\
    11 |     for &d in &mut [a, b] {\n   |         ^^    ----------- this expression\
    \ has type `Option<&mut isize>`\n   |         |\n   |         types differ in\
    \ mutability\n   |         help: you can probably remove the explicit borrow:\
    \ `d`\n   |\n   = note: expected mutable reference `&mut isize`\n            \
    \          found reference `&_`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut total = 0;\n  \
    \  loop {\n        let a = a % 10;\n        let b = b % 10;\n        if b == 0\
    \ && a > 0 {\n            total -= a as isize;\n            a = a / 10;\n    \
    \    }\n        if b == 0 && a < 0 {\n            total += a as isize;\n     \
    \       a = a / 10;\n        }\n        total += a as isize * b;\n        if total\
    \ == 0 {\n            return 0;\n        }\n        if total > 10 {\n        \
    \    total -= 10;\n        }\n        a = a / 10;\n        b = b / 10;\n    }\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `a` is never read\n  --> /tmp/tmpq0zvlsyj.rs:29:9\n\
    \   |\n29 |         a = a / 10;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `b` is never read\n  --> /tmp/tmpq0zvlsyj.rs:30:9\n   |\n\
    30 |         b = b / 10;\n   |         ^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `a`\n  --> /tmp/tmpq0zvlsyj.rs:16:13\n   |\n12 |         let a = a % 10;\n \
    \  |             -\n   |             |\n   |             first assignment to `a`\n\
    \   |             help: consider making this binding mutable: `mut a`\n...\n16\
    \ |             a = a / 10;\n   |             ^^^^^^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `a`\n  --> /tmp/tmpq0zvlsyj.rs:20:13\n   |\n12 |         let a = a % 10;\n \
    \  |             -\n   |             |\n   |             first assignment to `a`\n\
    \   |             help: consider making this binding mutable: `mut a`\n...\n20\
    \ |             a = a / 10;\n   |             ^^^^^^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `a`\n  --> /tmp/tmpq0zvlsyj.rs:29:9\n   |\n12 |         let a = a % 10;\n  \
    \ |             -\n   |             |\n   |             first assignment to `a`\n\
    \   |             help: consider making this binding mutable: `mut a`\n...\n29\
    \ |         a = a / 10;\n   |         ^^^^^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror[E0384]: cannot assign twice to immutable variable `b`\n  -->\
    \ /tmp/tmpq0zvlsyj.rs:30:9\n   |\n13 |         let b = b % 10;\n   |         \
    \    -\n   |             |\n   |             first assignment to `b`\n   |   \
    \          help: consider making this binding mutable: `mut b`\n...\n30 |    \
    \     b = b / 10;\n   |         ^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.pow(b).unwrap()\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpip4ieiqi.rs:10:11\n   |\n\
    10 |     a.pow(b).unwrap()\n   |           ^ expected `u32`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n10 |     a.pow(b.try_into().unwrap()).unwrap()\n   |    \
    \        ++++++++++++++++++++\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpip4ieiqi.rs:10:14\n   |\n\
    10 |     a.pow(b).unwrap()\n   |              ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!(\"Invalid input.\")\n    }\n    \n    match b {\n        1 => a,\n\
    \        _ => a * b,\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpguktyoze.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 ||\
    \ a == 1 || b == 1 || a == b { 0 }\n    else { \n        let mut product = a *\
    \ b; // First number is multiplied.\n        let remainder = product;\n      \
    \  while remainder > 9 { \n            product *= 10; \n            remainder\
    \ -= 10;\n        }\n        while remainder > 0 { \n            product *= remainder;\
    \ \n            remainder -= remainder % 10;\n        }\n        product\n   \
    \ }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `remainder`\n \
    \ --> /tmp/tmpdf_ifzvo.rs:16:13\n   |\n13 |         let remainder = product;\n\
    \   |             ---------\n   |             |\n   |             first assignment\
    \ to `remainder`\n   |             help: consider making this binding mutable:\
    \ `mut remainder`\n...\n16 |             remainder -= 10;\n   |             ^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `remainder`\n  --> /tmp/tmpdf_ifzvo.rs:20:13\n   |\n13\
    \ |         let remainder = product;\n   |             ---------\n   |       \
    \      |\n   |             first assignment to `remainder`\n   |             help:\
    \ consider making this binding mutable: `mut remainder`\n...\n20 |           \
    \  remainder -= remainder % 10;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a > 0 && b > 0 && a\
    \ * b <= 10_000 {\n        let mut product = 1;\n        let mut digit_mul = &a\
    \ as *const isize as *const isize;\n        while *digit_mul < b {\n         \
    \   product *= *digit_mul;\n            digit_mul += 1;\n        }\n        return\
    \ product;\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `*const isize`\n  --> /tmp/tmpmbgc9lr9.rs:15:13\n   |\n15 |             digit_mul\
    \ += 1;\n   |             ---------^^^^^\n   |             |\n   |           \
    \  cannot use `+=` on type `*const isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \    if b < 0 {\n        negate(a * b)\n    } else if b > 0 {\n        mul(a,\
    \ b * 10)\n    } else {\n        a * b\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `negate` in this scope\n  --> /tmp/tmps0ddmhv9.rs:12:9\n\
    \   |\n12 |         negate(a * b)\n   |         ^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `mul` in this scope\n  --> /tmp/tmps0ddmhv9.rs:14:9\n\
    \   |\n14 |         mul(a, b * 10)\n   |         ^^^ not found in this scope\n\
    \nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmps0ddmhv9.rs:10:9\n\
    \   |\n10 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a/b, a/10*b*10)\
    \ {\n        (0,_) => {0} // 0*a is 0\n        (0,_) => { 0 } // 0*a is 0\n  \
    \      (_,0) => { 0 } // a*b*10 is 0\n        (_,a) => { a } // a*b*10 is a\n\
    \    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpr0h9hdj9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 1;\n \
    \   while a >= 10 {\n        a %= 10;\n        result *= a;\n    }\n    while\
    \ b >= 10 {\n        b %= 10;\n        result *= b;\n    }\n    result *= a %\
    \ 10;\n    result *= b % 10;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpkfkqp3ry.rs:12:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n12 |         a %= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpkfkqp3ry.rs:16:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n16 |         b %= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * b).checked_mul(10).expect(\"\
    Input must be an integer\")\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `609760`,\n right: `16`', /tmp/tmpkiw5341p.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        return\
    \ 0;\n    } else if b < 0 {\n        return 0;\n    }\n\n    let mut product =\
    \ 0;\n\n    for digit in a.to_string().chars() {\n        product *= digit as\
    \ isize;\n    }\n\n    for digit in b.to_string().chars() {\n        product *=\
    \ digit as isize;\n    }\n\n    product\n}\n\nfn main() {\n    let candidate =\
    \ multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp0neff2f7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        a =\
    \ -a\n    }\n    if b < 0 {\n        b = -b\n    }\n    let a = a % 10;\n    let\
    \ b = b % 10;\n    let sum = a * b\n    return sum % 10;\n}\n\nfn main() {\n \
    \   let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `return`\n  --> /tmp/tmpjs1g30hr.rs:18:20\n\
    \   |\n18 |     let sum = a * b\n   |                    ^ help: add `;` here\n\
    19 |     return sum % 10;\n   |     ------ unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a * b\
    \ as isize;\n    let mut carry: isize = 0;\n    for i in 2..a.checked_mul(b.checked_mul(&mut\
    \ result).unwrap()).checked_div(10).unwrap() {\n        result *= i as isize +\
    \ carry;\n        carry = result % 10;\n        result /= 10;\n    }\n    result\
    \ + carry\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpalf9yuxc.rs:12:45\n   |\n\
    12 |     for i in 2..a.checked_mul(b.checked_mul(&mut result).unwrap()).checked_div(10).unwrap()\
    \ {\n   |                                             ^^^^^^^^^^^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider removing the borrow\n   |\n12 -   \
    \  for i in 2..a.checked_mul(b.checked_mul(&mut result).unwrap()).checked_div(10).unwrap()\
    \ {\n12 +     for i in 2..a.checked_mul(b.checked_mul(result).unwrap()).checked_div(10).unwrap()\
    \ {\n   | \n\nerror[E0599]: no method named `checked_div` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpalf9yuxc.rs:12:68\n   |\n12 |     for i\
    \ in 2..a.checked_mul(b.checked_mul(&mut result).unwrap()).checked_div(10).unwrap()\
    \ {\n   |                                                                    ^^^^^^^^^^^\
    \ method not found in `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % 10 {\n      \
    \  0 => b * 10,\n        y => a*10+y,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1488`,\n right: `16`', /tmp/tmpa5nc7xd9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n\n    for digit in b.clone() {\n        product = product * a.into();\n\
    \    }\n\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpu8m7qr26.rs:12:18\n\
    \   |\n12 |     for digit in b.clone() {\n   |                  ^^^^^^^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert_eq!(a, b);\n\
    \    // To avoid overflow, divide the product by 10 first (the unit digit of the\
    \ input).\n    // It doesn't seem to be a problem here because we know that all\
    \ valid inputs are less than 10.\n    let (div, mod) = divrem(10 * a * b, b);\n\
    \    let mut product = a * div;\n    product *= mod;\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmp1wd97pw_.rs:13:15\n\
    \   |\n13 |     let (div, mod) = divrem(10 * a * b, b);\n   |               ^^^\
    \ expected identifier, found keyword\n   |\nhelp: escape `mod` to use it as an\
    \ identifier\n   |\n13 |     let (div, r#mod) = divrem(10 * a * b, b);\n   | \
    \              ++\n\nerror: expected expression, found keyword `mod`\n  --> /tmp/tmp1wd97pw_.rs:15:16\n\
    \   |\n15 |     product *= mod;\n   |                ^^^ expected expression\n\
    \nerror[E0425]: cannot find function `divrem` in this scope\n  --> /tmp/tmp1wd97pw_.rs:13:22\n\
    \   |\n13 |     let (div, mod) = divrem(10 * a * b, b);\n   |                \
    \      ^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        a\n\
    \    } else {\n        let mut product = a;\n        while product > 0 {\n   \
    \         if product % 10 == b {\n                return product;\n          \
    \  }\n            product /= 10;\n        }\n    }\n    0\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn39ro0i8.rs:11:9\n   |\n\
    10 | /     if b == 0 {\n11 | |         a\n   | |         ^ expected `()`, found\
    \ `isize`\n12 | |     } else {\n13 | |         let mut product = a;\n...  |\n\
    19 | |         }\n20 | |     }\n   | |_____- expected this to be `()`\n   |\n\
    help: you might have meant to return this value\n   |\n11 |         return a;\n\
    \   |         ++++++  +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    for digit in 0..(10 - b.digits().len()) {\n        let factor = product.digits()\
    \ as usize;\n        product *= 10 + factor;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpekvexx70.rs:11:29\n   |\n11 |     for digit in 0..(10 -\
    \ b.digits().len()) {\n   |                             ^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpekvexx70.rs:12:30\n   |\n12 |         let\
    \ factor = product.digits() as usize;\n   |                              ^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 0;\n \
    \   let mut carry = 0;\n    for i in 0..(a / 10) {\n        result = result +\
    \ (a%10 * b + carry * 10);\n        carry = 1;\n    }\n    if carry == 0 {\n \
    \       result = result + (a%10 * b); \n    }\n    return result;\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `46274`,\n right: `16`', /tmp/tmp37r9dol7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a;\n \
    \   while result > b {\n        result = (result - b) * 10;\n    }\n    while\
    \ result < b {\n        result = result * 10;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmp6h4otig0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < b {\n        let\
    \ mut x = a;\n        let mut y = b;\n        while x > y {\n            y /=\
    \ 10;\n        }\n        while x % 10 != 0 {\n            x /= 10;\n        }\n\
    \        return x*y;\n    }\n    else {\n        let mut x = b;\n        let mut\
    \ y = a;\n        while x > y {\n            y /= 10;\n        }\n        while\
    \ x % 10 != 0 {\n            x /= 10;\n        }\n        return x*y;\n    }\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpkevv2fvj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    assert!(b >= 0);\n    let\
    \ mut product = a;\n    while b > 0 {\n        if b % 2 == 1 {\n            product\
    \ *= 10;\n        }\n        b = b >> 1;\n    }\n    product\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpc0na7ib3.rs:16:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n16 |      \
    \   b = b >> 1;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a * b\
    \ as isize;\n    if product > 10 {\n        product /= 10;\n    }\n    if product\
    \ < -10 {\n        product *= 10;\n    }\n    if product < 0 {\n        product\
    \ *= -1;\n    }\n    if product > 100 {\n        product /= 100;\n    }\n    if\
    \ product > 1000 {\n        product /= 1000;\n    }\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60`,\n right: `16`', /tmp/tmp1fbxxdbu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 {\n        product = product * 10 + a % 10;\n        a = a /\
    \ 10;\n    }\n    while b > 0 {\n        product = product * 10 + b % 10;\n  \
    \      b = b / 10;\n    }\n    product\n}\n\nfn main() {\n    let candidate =\
    \ multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpxnbqlo80.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpxnbqlo80.rs:17:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n17 |        \
    \ b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a*b).unwrap() % 10\n}\n\
    \nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpniya_tnu.rs:10:11\n   |\n10 |     (a*b).unwrap() % 10\n\
    \   |           ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a as f64 * b as f64).round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmppvzxd_ko.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    while b > 0 {\n        let digit = a % 10;\n        product = product\
    \ * digit + product;\n        a = a / 10;\n        b = b / 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp_u8freah.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp_u8freah.rs:15:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n15 |        \
    \ b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!();\n    }\n    let mut product: isize = 1;\n    for i in 0..a /\
    \ b {\n        product = product*b;\n    }\n    if a % b != 0 {\n        product\
    \ = product*b;\n    }\n    return product;\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `412`,\n right: `16`', /tmp/tmp47nqfn3f.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       0\n    } else if a == 0 || b == 0 {\n        1\n    } else {\n       \
    \ let mut sum = 0;\n        while a > 0 && b > 0 {\n            let m = a % 10;\n\
    \            let n = b % 10;\n            sum += m * n;\n            a /= 10;\n\
    \            b /= 10;\n        }\n        sum\n    }\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp3jz72wi6.rs:20:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n20 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmp3jz72wi6.rs:21:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n21 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 10 {\n        return\
    \ a*b\n    }\n    if b < 10 {\n        return b*a\n    }\n\n    if a == 0 {\n\
    \        return 0;\n    }\n\n    if b == 0 {\n        return a;\n    }\n\n   \
    \ let mut prod = a*0;\n    for i in 1..b {\n        prod *= a%10;\n        a /=\
    \ 10;\n    }\n    if prod > 9 {\n        prod -= 10;\n    }\n    prod\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpymrezjwu.rs:26:9\n   |\n26\
    \ |     for i in 1..b {\n   |         ^ help: if this is intentional, prefix it\
    \ with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by\
    \ default\n\nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpymrezjwu.rs:28:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n28 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    if a > b {\n        (a, b)\n    } else {\n        (a, b)\n    }\n    .iter()\n\
    \    .fold(1, |acc, &(digit, power)| {\n        acc * digit * power.pow(10)\n\
    \    })\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for tuple `(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmptp7iasi3.rs:16:6\n   |\n16 |     .iter()\n\
    \   |      ^^^^ method not found in `(isize, isize)`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match std::mem::swap(&a,\
    \ &b) {\n        (x, y) => x * y,\n        (_, x) => (x * -1) - 1,\n        (_,\
    \ _) => 0,\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jtm4acm.rs:10:26\n   |\n\
    10 |     match std::mem::swap(&a, &b) {\n   |                          ^^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut _`\n\
    \                      found reference `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7jtm4acm.rs:10:30\n   |\n10 |     match std::mem::swap(&a, &b)\
    \ {\n   |                              ^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut _`\n                      found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jtm4acm.rs:11:9\n\
    \   |\n10 |     match std::mem::swap(&a, &b) {\n   |           ----------------------\
    \ this expression has type `()`\n11 |         (x, y) => x * y,\n   |         ^^^^^^\
    \ expected `()`, found tuple\n   |\n   = note: expected unit type `()`\n     \
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jtm4acm.rs:12:9\n\
    \   |\n10 |     match std::mem::swap(&a, &b) {\n   |           ----------------------\
    \ this expression has type `()`\n11 |         (x, y) => x * y,\n12 |         (_,\
    \ x) => (x * -1) - 1,\n   |         ^^^^^^ expected `()`, found tuple\n   |\n\
    \   = note: expected unit type `()`\n                  found tuple `(_, _)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7jtm4acm.rs:13:9\n   |\n10 |   \
    \  match std::mem::swap(&a, &b) {\n   |           ---------------------- this\
    \ expression has type `()`\n...\n13 |         (_, _) => 0,\n   |         ^^^^^^\
    \ expected `()`, found tuple\n   |\n   = note: expected unit type `()`\n     \
    \             found tuple `(_, _)`\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0;\n\n  \
    \  while a > 0 {\n        if a % 10 == b {\n            res *= 10;\n         \
    \   a = (a / 10) - 1;\n        } else {\n            res *= a;\n        }\n  \
    \  }\n\n    return res;\n}\n\nfn main() {\n    let candidate = multiply;\n   \
    \ assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpyb_5s8zx.rs:15:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n15 |             a = (a\
    \ / 10) - 1;\n   |             ^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut total: isize =\
    \ 1;\n    while a > 0 && b > 0 {\n        total += a % 10;\n        total += (b\
    \ % 10) * 10;\n        a /= 10;\n        b /= 10;\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpdmz3xw3q.rs:14:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n14 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpdmz3xw3q.rs:15:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n15 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut prod: isize = 0;\n\
    \    while a > 0 && b > 0 {\n        match a % b {\n            0 => prod += b,\n\
    \            a % b => prod += a,\n            _ => prod += a%b,\n        }\n \
    \       a /= b;\n        b /= 10;\n    }\n    prod\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `%`\n  --> /tmp/tmpj71pc84a.rs:14:15\n\
    \   |\n14 |             a % b => prod += a,\n   |               ^ expected one\
    \ of `=>`, `@`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 { \n        0\
    \ \n    } else { \n        let mut c = a % 10; \n        for i in 1..(b as usize)\
    \ {\n            c *= 10; \n            c %= 10; \n        }\n        c\n    }\
    \ \n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp3u_xix_6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (1..9).map(|x| x % 10).filter(|&x|\
    \ x != 0 || b != 0).product()\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `40320`,\n right: `16`', /tmp/tmpql9i_akd.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n  let mut sum = 0;\n  let mut\
    \ product = 1;\n  for d in a.to_string().chars() {\n    sum += d*b.to_digit(2);\n\
    \    product *= d;\n  }\n  return sum + product;\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpk3uwm94d.rs:13:16\n   |\n13 |     sum += d*b.to_digit(2);\n\
    \   |                ^^^^^^^^ method not found in `isize`\n\nerror[E0277]: cannot\
    \ multiply-assign `{integer}` by `char`\n  --> /tmp/tmpk3uwm94d.rs:14:13\n   |\n\
    14 |     product *= d;\n   |             ^^ no implementation for `{integer} *=\
    \ char`\n   |\n   = help: the trait `MulAssign<char>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `MulAssign<Rhs>`:\n    \
    \         <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n        \
    \     <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n            \
    \ <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n             <i16\
    \ as MulAssign<&i16>>\n             <i16 as MulAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0;\n    while\
    \ a > 0 || b > 0 {\n        if a > 0 {\n            res *= a;\n            res\
    \ %= 10;\n            a /= 10;\n        } else {\n            res *= b;\n    \
    \        res %= 10;\n            b /= 10;\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpegaels6q.rs:15:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n15 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpegaels6q.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b).expect(\"\
    multiply overflow\")\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp8p9a1227.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a * b;\n\
    \    let mut sign = 1;\n    if product < 0 {\n        sign = -1;\n        product\
    \ *= -1;\n    }\n    // Handle the case when both are zero\n    if product ==\
    \ 0 {\n        return 0;\n    }\n    // Handle the case when one is a unit digit\
    \ and the other is not\n    if a >= 10 {\n        product *= sign;\n    } else\
    \ {\n        let mut remainder = 0;\n        for i in product.digits().into_iter()\
    \ {\n            remainder *= 10;\n            if i % 2 == 0 {\n             \
    \   remainder += 1;\n            }\n        }\n        product *= sign * remainder;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpht8nsu4h.rs:25:26\n   |\n25 |         for i in product.digits().into_iter()\
    \ {\n   |                          ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => 0,\n        x => x,\n        y => y * multiply(b, a / b),\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpwg6ydlxi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    for i in 0..(a as usize) {\n        product *= (b as usize - i);\n    }\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpz5izlhj5.rs:12:20\n\
    \   |\n12 |         product *= (b as usize - i);\n   |                    ^  \
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n12 -         product *= (b as usize - i);\n\
    12 +         product *= b as usize - i;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz5izlhj5.rs:14:5\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n14 |     product\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n14 |     product.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0);\n\
    \    debug_assert!(b >= 0);\n    debug_assert!(a < 10);\n    debug_assert!(b <\
    \ 10);\n\n    let mut product = a * b;\n    for i in 0..a.len() {\n        product\
    \ *= a % 10 + b % 10;\n        a = a / 10;\n        b = b / 10;\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpaje229w8.rs:16:19\n   |\n16 |     for i in 0..a.len() {\n\
    \   |                   ^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    \n    // The largest possible result we can get is 1 less than the\
    \ \n    // absolute maximum of our operands. Since we can't represent \n    //\
    \ the absolute max of negative integers, this should only ever\n    // happen\
    \ in extreme edge cases.\n    let max = std::cmp::max(std::cmp::max(a, b), std::cmp::max(b,\
    \ a));\n    \n    for i in 0..max {\n        if a * i == b * i {\n           \
    \ product += i;\n        } else {\n            break;\n        }\n    }\n    \n\
    \    // If our product is greater than the largest possible result, then we\n\
    \    // need to add 1. This is because we can't represent -0, but we \n    //\
    \ can represent other values by adding one.\n    if product > max {\n        product\
    \ += 1;\n    }\n    \n    return product;\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpu7mrs1wl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut res = 0;\n    while\
    \ a > 0 || b > 0 {\n        // The result has 3 units and we can't have more than\
    \ 3 units left.\n        let mut remaining = min(3, a - b);\n        res += a;\n\
    \        a -= remaining;\n        b -= remaining;\n    }\n    res.0\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpl8j4g4qk.rs:13:29\n\
    \   |\n13 |         let mut remaining = min(3, a - b);\n   |                 \
    \            ^^^\n...\n21 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    13 |         let mut remaining = main(3, a - b);\n   |                       \
    \      ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpl8j4g4qk.rs:18:9\n   |\n18 |     res.0\n   |         ^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0610.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       return 0;\n    }\n    let mut c = a;\n    loop {\n        if c == 0 {\n\
    \            break;\n        }\n        c = b * (c / 10) + c % 10;\n    }\n  \
    \  return c;\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpu32qy4tk.rs:18:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a, b){\n       \
    \ (a, b) => a * b,\n        (a, _) => 0,\n        (_, b) => 0,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpgpz6zkev.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 {\n\
    \        return 0;\n    }\n    \n    let mut product = 1;\n    while a > 0 &&\
    \ b > 0 {\n        if a % 10 == 0 && b % 10 == 0 {\n            product *= a;\n\
    \            a /= 10;\n            b /= 10;\n        } else {\n            product\
    \ *= b;\n            b /= 10;\n        }\n    }\n    \n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpb0lgc5e6.rs:18:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpb0lgc5e6.rs:19:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpb0lgc5e6.rs:22:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n22 |      \
    \       b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a <= b);\n\
    \    if a == 0 || b == 0 || a == -b || (b != 0 && a % b != 0) {\n        return\
    \ 0;\n    }\n    a as isize * (b as isize) % 100 as isize\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp45tsverz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a as isize) * (b as isize)\
    \ as isize\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp4qtpk_bo.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * b) / pow((10), (a\
    \ * b).digits())\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpmwq1hbz7.rs:10:15\n\
    \   |\n10 |     (a * b) / pow((10), (a * b).digits())\n   |               ^^^\
    \ not found in this scope\n\nwarning: unnecessary parentheses around function\
    \ argument\n  --> /tmp/tmpmwq1hbz7.rs:10:19\n   |\n10 |     (a * b) / pow((10),\
    \ (a * b).digits())\n   |                   ^  ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n10 -     (a * b) / pow((10),\
    \ (a * b).digits())\n10 +     (a * b) / pow(10, (a * b).digits())\n   | \n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpmwq1hbz7.rs:10:33\n   |\n10 |     (a * b) / pow((10), (a * b).digits())\n\
    \   |                                 ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 1;\n    for i in 0..a%10 {\n        product *= (b%10 as usize) - i;\n    \
    \    b/=10;\n    }\n    return product;\n}\n\nfn main() {\n    let candidate =\
    \ multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy8ym2afi.rs:12:23\n   |\n\
    12 |         product *= (b%10 as usize) - i;\n   |                       ^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n\
    \  --> /tmp/tmpy8ym2afi.rs:12:22\n   |\n12 |         product *= (b%10 as usize)\
    \ - i;\n   |                      ^ no implementation for `isize % usize`\n  \
    \ |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * b) % MOD\n}\n\nfn\
    \ main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MOD` in this scope\n  --> /tmp/tmp3hznx2jx.rs:10:15\n\
    \   |\n10 |     (a * b) % MOD\n   |               ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut s = a;\n    let\
    \ mut x = b;\n    while s > 10 {\n        x /= 10;\n        s += x;\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Calculate the unit digit\n\
    \    let mut unitdigit: isize = 0;\n    let mut unitdigit_temp: isize = 0;\n \
    \   \n    if a < 10 {\n        unitdigit = a % 10;\n    } else if a > 9 && a <\
    \ 100 {\n        unitdigit = 10;\n    } else if a == 100 {\n        unitdigit\
    \ = a % 10;\n    }\n    \n    if b < 10 {\n        unitdigit_temp = b % 10;\n\
    \    } else if b > 9 && b < 100 {\n        unitdigit_temp = 20;\n    } else if\
    \ b == 100 {\n        unitdigit_temp = b % 10;\n    }\n    \n    unitdigit * unitdigit_temp\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpds8lou7x.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 { 0\
    \ }\n    else if a == 1 || b == 1 { 1 }\n    else if a == -1 || b == -1 { -1 }\n\
    \    else { a * b }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpn8g8a2d8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 { return 0; }\n\
    \n    match a%10 {\n        0 | a < 10 => return a * b,\n        _ => return multiply(a/10,\
    \ b),\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `<`\n  --> /tmp/tmpkwg1jl07.rs:13:15\n\
    \   |\n13 |         0 | a < 10 => return a * b,\n   |               ^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b.clone()).unwrap().unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpron5rig1.rs:10:39\n   |\n10 |     a.checked_mul(b.clone()).unwrap().unwrap()\n\
    \   |                                       ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Only care about unit\
    \ digits\n    a % 10 == 0 ? a as isize * b as isize : 0\n}\n\nfn main() {\n  \
    \  let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmp06r5ak2r.rs:11:19\n   |\n11 |     a % 10 == 0 ? a as isize * b\
    \ as isize : 0\n   |                   ^ expected one of `.`, `;`, `?`, `}`, or\
    \ an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 1;\n \
    \   for i in 0 .. b.leading_zeros() {\n        result = result * a % 10;\n   \
    \     a = a / 10;\n    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpvbx84p4a.rs:11:9\n   |\n11\
    \ |     for i in 0 .. b.leading_zeros() {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `a`\n  -->\
    \ /tmp/tmpvbx84p4a.rs:13:9\n   |\n9  | fn multiply(a: isize, b: isize) -> isize\
    \ {\n   |             - help: consider making this binding mutable: `mut a`\n\
    ...\n13 |         a = a / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a.to_digits().product();\n\
    \    for i in 1..b {\n        product = product * i;\n    }\n    product\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpmt7_dzjx.rs:10:25\n   |\n10 |     let mut product\
    \ = a.to_digits().product();\n   |                         ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a, b) {\n      \
    \  (i, 0) -> i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n         \
    \   \"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(&format!(\"{}\"\
    , i::from_str_radix(\n                \"{}\", i::from_str_radix(&format!(\"{}\"\
    , i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n                    \"\
    {}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n\
    \                        \"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n                            \"{}\", i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n                \
    \                &format!(\"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n                                    &format!(\"{}\"\
    , i::from_str_radix(&format!(\"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n\
    \                                        &format!(\"{}\", i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n                \
    \                            &format!(\"{}\", i::from_str_radix(&format!(\"{}\"\
    , i::from_str_radix(\n                                                &format!(\"\
    {}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n                \
    \                                    &format!(\"{}\", i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n                                                   \
    \     &format!(\"{}\", i::from_str_radix(&format!(\"{}\", i::from_str_radix(\n\
    \                                                            &format!(\"{}\",\
    \ i::from_str_radix(\n                                                       \
    \         &format!(\"{}\", i::from_str_radix(\n                              \
    \                                      &format!(\"{}\", i::from_str_radix(\n \
    \                                                                       &format!(\"\
    {}\", i::from_str_radix(\n                                                   \
    \                         &format!(\"{}\", i::from_str_radix(&format!(\"{}\",\
    \ i::from_str_radix(\n                                                       \
    \                         &format!(\"{}\", i::\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdhudahdu.rs:42:3\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n10 |     match (a, b) {\n   |\
    \                  - this delimiter might not be properly closed...\n...\n30 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n42 |\
    \ }\n   |   ^\n\nerror: expected one of `=>`, `if`, or `|`, found `->`\n  -->\
    \ /tmp/tmpdhudahdu.rs:11:16\n   |\n11 |         (i, 0) -> i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n   |                ^^\n   |                |\n   |\
    \                expected one of `=>`, `if`, or `|`\n   |                help:\
    \ try using a fat arrow here: `=>`\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpdhudahdu.rs:29:89\n   |\n9  | fn multiply(a: isize, b: isize) ->\
    \ isize {\n   |                                          - closing delimiter possibly\
    \ meant for this\n...\n29 |                                                  \
    \                               &format!(\"{}\", i::\n   |                   \
    \                                                                      ^ unclosed\
    \ delimiter\n30 | }\n   | ^ mismatched closing delimiter\n\nerror: expected identifier,\
    \ found `<eof>`\n  --> /tmp/tmpdhudahdu.rs:29:97\n   |\n29 | ...             \
    \      &format!(\"{}\", i::\n   |                                       ^^ expected\
    \ identifier\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `i`\n  --> /tmp/tmpdhudahdu.rs:11:19\n   |\n11 |         (i, 0) -> i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n   |                   ^ use of undeclared crate or\
    \ module `i`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `i`\n  --> /tmp/tmpdhudahdu.rs:11:52\n   |\n11 |         (i, 0) -> i::from_str_radix(&format!(\"\
    {}\", i::from_str_radix(\n   |                                               \
    \     ^ use of undeclared crate or module `i`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `i`\n  --> /tmp/tmpdhudahdu.rs:12:19\n   |\n\
    12 |             \"{}\", i:"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a > b {\n        (a,\
    \ b) = (b, a)\n    }\n    if a < 0 {\n        a = -a\n    }\n    if b < 0 {\n\
    \        b = -b\n    }\n    while b != 0 {\n        let c = a % b\n        a =\
    \ b\n        b = c\n    }\n    a\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `a`\n  --> /tmp/tmpl9m6220b.rs:20:22\n   |\n\
    20 |         let c = a % b\n   |                      ^ help: add `;` here\n21\
    \ |         a = b\n   |         - unexpected token\n\nerror: expected `;`, found\
    \ `b`\n  --> /tmp/tmpl9m6220b.rs:21:14\n   |\n21 |         a = b\n   |       \
    \       ^ help: add `;` here\n22 |         b = c\n   |         - unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    while product < b {\n        if product % 10 == 0 {\n            product\
    \ *= 10;\n            product -= 1;\n        } else {\n            product *=\
    \ 10;\n        }\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1480`,\n right: `16`', /tmp/tmpxl0kx4v7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a, b)\n        .iter()\n\
    \        .fold(0, |x, y| x * digit_to_int(y) / digit_to_int(x))\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `digit_to_int` in this scope\n  -->\
    \ /tmp/tmp9jhu35u8.rs:12:29\n   |\n12 |         .fold(0, |x, y| x * digit_to_int(y)\
    \ / digit_to_int(x))\n   |                             ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `digit_to_int` in this scope\n\
    \  --> /tmp/tmp9jhu35u8.rs:12:47\n   |\n12 |         .fold(0, |x, y| x * digit_to_int(y)\
    \ / digit_to_int(x))\n   |                                               ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `iter` found for tuple\
    \ `(isize, isize)` in the current scope\n  --> /tmp/tmp9jhu35u8.rs:11:10\n   |\n\
    11 |         .iter()\n   |          ^^^^ method not found in `(isize, isize)`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp7bipiygb.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = isize::MAX;\n\
    \    let mut carry = 0;\n    let a = a % 10 * (isize::MAX as usize);\n    let\
    \ b = b % 10 * (isize::MAX as usize);\n    while a < 10 {\n        product +=\
    \ a;\n        carry += 1;\n        a = a % 10 * (isize::MAX as usize);\n    }\n\
    \    while b < 10 {\n        product += b;\n        carry += 1;\n        b = b\
    \ % 10 * (isize::MAX as usize);\n    }\n    if carry > 0 {\n        product +=\
    \ 1;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n  \
    \  assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_f0mlmj.rs:12:22\n   |\n\
    12 |     let a = a % 10 * (isize::MAX as usize);\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by\
    \ `usize`\n  --> /tmp/tmpo_f0mlmj.rs:12:20\n   |\n12 |     let a = a % 10 * (isize::MAX\
    \ as usize);\n   |                    ^ no implementation for `isize * usize`\n\
    \   |\n   = help: the trait `Mul<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n             <&'a\
    \ f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128\
    \ as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as\
    \ Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo_f0mlmj.rs:13:22\n   |\n13 |     let b = b\
    \ % 10 * (isize::MAX as usize);\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by\
    \ `usize`\n  --> /tmp/tmpo_f0mlmj.rs:13:20\n   |\n13 |     let b = b % 10 * (isize::MAX\
    \ as usize);\n   |                    ^ no implementation for `isize * usize`\n\
    \   |\n   = help: the trait `Mul<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n             <&'a\
    \ f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128\
    \ as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as\
    \ Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo_f0mlmj.rs:17:22\n   |\n17 |         a = a\
    \ % 10 * (isize::MAX as usize);\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by\
    \ `usize`\n  --> /tmp/tmpo_f0mlmj.rs:17:20\n   |\n17 |         a = a % 10 * (isize::MAX\
    \ as usize);\n   |                    ^ no im"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mul = a.to_digits()\
    \ * b.to_digits();\n    mul.sum_digits() - mul.last_digits()\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmps29s0sky.rs:10:17\n   |\n10 |     let mul = a.to_digits()\
    \ * b.to_digits();\n   |                 ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmps29s0sky.rs:10:33\n   |\n10 |     let mul = a.to_digits()\
    \ * b.to_digits();\n   |                                 ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    a.checked_mul(b).unwrap()\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp1fmuv885.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 1;\n\n\
    \    for &digit in &a % 10 as [isize; 10] {\n        result = result * digit +\
    \ &b / 10;\n        b = &b / 10;\n    }\n\n    result * b\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `&isize` by `[isize; 10]`\n  --> /tmp/tmp_2cz6q6y.rs:12:22\n\
    \   |\n12 |     for &digit in &a % 10 as [isize; 10] {\n   |                 \
    \     ^ no implementation for `&isize % [isize; 10]`\n   |\n   = help: the trait\
    \ `Rem<[isize; 10]>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0605]: non-primitive\
    \ cast: `{integer}` as `[isize; 10]`\n  --> /tmp/tmp_2cz6q6y.rs:12:24\n   |\n\
    12 |     for &digit in &a % 10 as [isize; 10] {\n   |                        ^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 {\n        return\
    \ b;\n    }\n\n    let mut result = b;\n\n    for i in a.to_digits().iter_mut()\
    \ {\n        *i /= 10;\n        *i *= result;\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpsodyf7dy.rs:16:16\n   |\n16 |     for i in a.to_digits().iter_mut()\
    \ {\n   |                ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut prod = 1;\n   \
    \ while a > 0 {\n        prod *= b;\n        a -= 1;\n        b *= 10;\n    }\n\
    \    return prod;\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmph_68n178.rs:13:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n13 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmph_68n178.rs:14:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n14 |         b *= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    loop {\n        if a >=\
    \ b {\n            break\n        }\n        \n        a %= 10;\n        b %=\
    \ 10;\n        if a >= b {\n            break\n        }\n        \n        let\
    \ ret = a * b + a / 10 + b / 10;\n        \n        a %= 10;\n        b %= 10;\n\
    \        if a >= b {\n            break\n        }\n        \n        ret *= 10;\n\
    \        ret += a / 10 + b / 10;\n        \n        if ret < 0 {\n           \
    \ ret *= -1;\n        }\n        \n        return ret;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvixh7b9d.rs:12:13\n   |\n\
    9  | fn multiply(a: isize, b: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n12 |        \
    \     break\n   |             ^^^^^\n   |             |\n   |             expected\
    \ `isize`, found `()`\n   |             help: give it a value of the expected\
    \ type: `break 42`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    if a < 0 {\n        a * -1\n    } else {\n        if b < 0 {\n          \
    \  0\n        } else {\n            a * b\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp85xqy4zr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a, b){\n       \
    \ (0, 0) => 0,\n        (_, 0) => 0,\n        (0, _) => 0,\n        (_, _) =>\
    \ 1,\n        (min(a, b), min(a, b)) => 0,\n        (min(a, b), max(a, b)) =>\
    \ min(a, b) * min(a, b),\n        (max(a, b), max(a, b)) => max(a, b) * max(a,\
    \ b),\n        (min(a, b), min(b, min(a, a))) => min(a, b) * min(b, min(a, a)),\n\
    \        (min(a, b), max(b, max(a, a))) => max(a, b) * max(b, max(a, a)),\n  \
    \      (max(a, b), max(b, max(a, a))) => max(a, b) * max(b, max(a, a)),\n    \
    \    (min(a, b), min(b, max(a, a))) => max(a, b) * max(b, max(a, a)),\n      \
    \  (max(a, b), min(b, min(a, a))) => max(a, b) * min(b, min(a, a)),\n        (min(a,\
    \ b), min(b, min(a, a))) => max(a, b) * min(b, min(a, a)),\n        (max(a, b),\
    \ min(b, max(a, a))) => max(a, b) * max(b, max(a, a)),\n        (min(a, b), max(b,\
    \ max(a, a))) => min(a, b) * max(b, max(a, a)),\n        (min(a, b), max(b, min(a,\
    \ a))) => min(a, b) * min(b, min(a, a)),\n        (max(a, b), min(b, min(a, a)))\
    \ => min(a, b) * min(b, min(a, a)),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0416]: identifier `a` is bound more than once in the same pattern\n\
    \  --> /tmp/tmp1r7hjwti.rs:15:25\n   |\n15 |         (min(a, b), min(a, b)) =>\
    \ 0,\n   |                         ^ used in a pattern more than once\n\nerror[E0416]:\
    \ identifier `b` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:15:28\n\
    \   |\n15 |         (min(a, b), min(a, b)) => 0,\n   |                       \
    \     ^ used in a pattern more than once\n\nerror[E0416]: identifier `a` is bound\
    \ more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:16:25\n   |\n\
    16 |         (min(a, b), max(a, b)) => min(a, b) * min(a, b),\n   |          \
    \               ^ used in a pattern more than once\n\nerror[E0416]: identifier\
    \ `b` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:16:28\n\
    \   |\n16 |         (min(a, b), max(a, b)) => min(a, b) * min(a, b),\n   |   \
    \                         ^ used in a pattern more than once\n\nerror[E0416]:\
    \ identifier `a` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:17:25\n\
    \   |\n17 |         (max(a, b), max(a, b)) => max(a, b) * max(a, b),\n   |   \
    \                      ^ used in a pattern more than once\n\nerror[E0416]: identifier\
    \ `b` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:17:28\n\
    \   |\n17 |         (max(a, b), max(a, b)) => max(a, b) * max(a, b),\n   |   \
    \                         ^ used in a pattern more than once\n\nerror[E0416]:\
    \ identifier `b` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:18:25\n\
    \   |\n18 |         (min(a, b), min(b, min(a, a))) => min(a, b) * min(b, min(a,\
    \ a)),\n   |                         ^ used in a pattern more than once\n\nerror[E0416]:\
    \ identifier `a` is bound more than once in the same pattern\n  --> /tmp/tmp1r7hjwti.rs:18:32\n\
    \   |\n18 |         (min(a, b), min(b, min(a, a))) => min(a, b) * min(b, min(a,\
    \ a)),\n   |                                ^ used in a pattern more than once\n\
    \nerror[E0416]: identifier `a` is bound more than once in the same pattern\n \
    \ --> /tmp/tmp1r7hjwti.rs:18:35\n   |\n18 |         (min(a, b), min(b, mi"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 { 0\
    \ }\n    else if b == 1 && a > 0 { 0 }\n    else { a / b }\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmp4r5711p2.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        return\
    \ a\n    }\n    a.checked_mul(mult_helper(b)).unwrap_or(0)\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mult_helper` in this scope\n  --> /tmp/tmp3pmiuska.rs:13:19\n\
    \   |\n13 |     a.checked_mul(mult_helper(b)).unwrap_or(0)\n   |             \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b < 0 {\n        return\
    \ 0;\n    }\n    let mut result: isize = 0;\n    while b > 0 {\n        let remainder\
    \ = a % 10;\n        result = result * 10 + remainder;\n        a = a / 10;\n\
    \        b = b - 1;\n    }\n    return result;\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpb_kx2do2.rs:17:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n17 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpb_kx2do2.rs:18:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n18 |        \
    \ b = b - 1;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < b {\n        multiply(b,\
    \ a)\n    } else {\n        let mut res = 0;\n        let mut a_rem = a % 10;\n\
    \        let mut b_rem = b % 10;\n        while a_rem > 0 && b_rem > 0 {\n   \
    \         res *= 10;\n            if a_rem == b_rem {\n                res +=\
    \ a_rem;\n                a_rem %= 10;\n                b_rem %= 10;\n       \
    \     } else {\n                res += a_rem % b_rem;\n                a_rem /=\
    \ 10;\n                b_rem /= 10;\n            }\n        }\n        res *=\
    \ b;\n        if a_rem > 0 {\n            res\n        } else {\n            res\
    \ + b\n        }\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n   \
    \ assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `444`,\n right: `16`', /tmp/tmp2s4rf_dd.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    while a > 0 && b > 0 {\n        if a % 10 == b % 10 {\n            product\
    \ += a % 10\n            a /= 10;\n            b /= 10;\n        } else {\n  \
    \          product += b%10\n            b /= 10;\n        }\n    }\n    product\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `a`\n  --> /tmp/tmp_m2kspr8.rs:13:30\n   |\n\
    13 |             product += a % 10\n   |                              ^ help:\
    \ add `;` here\n14 |             a /= 10;\n   |             - unexpected token\n\
    \nerror: expected `;`, found `b`\n  --> /tmp/tmp_m2kspr8.rs:17:28\n   |\n17 |\
    \             product += b%10\n   |                            ^ help: add `;`\
    \ here\n18 |             b /= 10;\n   |             - unexpected token\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a < b {\n       \
    \ true => {\n            let mut result = 0;\n            while a > 0 {\n    \
    \            result *= 10;\n                a %= 10;\n            }\n        \
    \    while b > 0 {\n                result *= 10;\n                b %= 10;\n\
    \            }\n            result\n        }\n        false => {\n          \
    \  let mut result = 0;\n            while b > 0 {\n                result *= 10;\n\
    \                b %= 10;\n            }\n            while a > 0 {\n        \
    \        result *= 10;\n                a %= 10;\n            }\n            result\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmph77d_3as.rs:15:17\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n15 |                 a %=\
    \ 10;\n   |                 ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmph77d_3as.rs:19:17\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n19 |       \
    \          b %= 10;\n   |                 ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmph77d_3as.rs:27:17\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n27 |      \
    \           b %= 10;\n   |                 ^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmph77d_3as.rs:31:17\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n31 |                 a %=\
    \ 10;\n   |                 ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        a =\
    \ -a\n    }\n    if b < 0 {\n        b = -b\n    }\n    let mut product: isize\
    \ = 1\n    product.wrapping_mul(a.wrapping_mul(b))\n}\n\nfn main() {\n    let\
    \ candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `product`\n  --> /tmp/tmpucbbvgdf.rs:16:31\n\
    \   |\n16 |     let mut product: isize = 1\n   |                             \
    \  ^ help: add `;` here\n17 |     product.wrapping_mul(a.wrapping_mul(b))\n  \
    \ |     ------- unexpected token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \    \n    if a == 0 || b == 0 { 0 }\n    else if a.is_even() && b.is_even() {\
    \ a.checked_mul(b.clone()).unwrap() }\n    else if a.is_odd() || b.is_odd() {\
    \ b.checked_mul(a).unwrap() }\n    else { 0 }\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp2cv7msla.rs:10:9\n\
    \   |\n10 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_even` found for type `isize` in the current scope\n  --> /tmp/tmp2cv7msla.rs:13:15\n\
    \   |\n13 |     else if a.is_even() && b.is_even() { a.checked_mul(b.clone()).unwrap()\
    \ }\n   |               ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `is_even` found for type `isize` in the current scope\n  --> /tmp/tmp2cv7msla.rs:13:30\n\
    \   |\n13 |     else if a.is_even() && b.is_even() { a.checked_mul(b.clone()).unwrap()\
    \ }\n   |                              ^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `is_odd` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp2cv7msla.rs:14:15\n   |\n14 |     else if a.is_odd() || b.is_odd()\
    \ { b.checked_mul(a).unwrap() }\n   |               ^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_odd` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp2cv7msla.rs:14:29\n   |\n14 |     else if a.is_odd()\
    \ || b.is_odd() { b.checked_mul(a).unwrap() }\n   |                          \
    \   ^^^^^^ method not found in `isize`\n\nerror: aborting due to 4 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    use std::cmp::Ordering::*;\n\
    \    \n    if a < b {\n        (a, b) = (b, a)\n    }\n\n    if a == 0 || b ==\
    \ 0 {\n        return 0;\n    }\n    \n    let mut result = a;\n    let mut carry\
    \ = 0;\n\n    while b > 0 {\n        let digit = b % 10;\n        let r = result\
    \ + digit;\n        result *= 10;\n        if r < result {\n            result\
    \ -= r;\n            carry = 1;\n        }\n        b /= 10;\n    }\n\n    if\
    \ carry != 0 {\n        result += 1;\n    }\n    \n    result\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n  --> /tmp/tmp51luxs2m.rs:10:9\n\
    \   |\n10 |     use std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0384]: cannot\
    \ assign to immutable argument `a`\n  --> /tmp/tmp51luxs2m.rs:13:10\n   |\n9 \
    \ | fn multiply(a: isize, b: isize) -> isize {\n   |             - help: consider\
    \ making this binding mutable: `mut a`\n...\n13 |         (a, b) = (b, a)\n  \
    \ |          ^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign\
    \ to immutable argument `b`\n  --> /tmp/tmp51luxs2m.rs:13:13\n   |\n9  | fn multiply(a:\
    \ isize, b: isize) -> isize {\n   |                       - help: consider making\
    \ this binding mutable: `mut b`\n...\n13 |         (a, b) = (b, a)\n   |     \
    \        ^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign\
    \ to immutable argument `b`\n  --> /tmp/tmp51luxs2m.rs:31:9\n   |\n9  | fn multiply(a:\
    \ isize, b: isize) -> isize {\n   |                       - help: consider making\
    \ this binding mutable: `mut b`\n...\n31 |         b /= 10;\n   |         ^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 3 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < 10000);\n\
    \    debug_assert!(b < 10000);\n\n    let mut res = 0;\n    while a > 0 {\n  \
    \      debug_assert!(a % 10 == 0);\n        let r = a % 10;\n        debug_assert!(b\
    \ % 10 == 0);\n        let s = b % 10;\n        res += (r * s);\n        a /=\
    \ 10;\n        b /= 10;\n    }\n    if a > 0 {\n        debug_assert!(b == 0);\n\
    \        res += a;\n    }\n    if res < 0 {\n        res += 10_000;\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpn_smtet7.rs:19:16\n\
    \   |\n19 |         res += (r * s);\n   |                ^     ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    19 -         res += (r * s);\n19 +         res += r * s;\n   | \n\nerror[E0384]:\
    \ cannot assign to immutable argument `a`\n  --> /tmp/tmpn_smtet7.rs:20:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n20 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpn_smtet7.rs:21:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n21 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a;\n\
    \    let mut digit = a;\n    \n    while b % 10 != 0 {\n        product *= digit;\n\
    \        digit /= 10;\n    }\n    \n    product *= digit;\n    product\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    loop {\n        let mut\
    \ c = a;\n        c /= 10;\n        if c == 0 || b == 0 {\n            return\
    \ c;\n        }\n        let mut d = b;\n        d /= 10;\n        if d == 0 {\n\
    \            return c;\n        }\n        c = c * d;\n        b -= d;\n    }\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `c` is never read\n  --> /tmp/tmpgx5nv935.rs:21:9\n\
    \   |\n21 |         c = c * d;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpgx5nv935.rs:22:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n22 |        \
    \ b -= d;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * b + b * a + a * b)\
    \ * a / b\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `65712`,\n right: `16`', /tmp/tmpye076hfp.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 0;\n \
    \   while a > 0 {\n        a %= 10;\n        result *= 10;\n        result +=\
    \ (a % b) / 10;\n        result %= 10;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpfkzn0urj.rs:12:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n12 |         a %= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a < b);\n\
    \    debug_assert!(b <= i64::MAX);\n    let mut result = 1;\n    while b > 0 {\n\
    \        let mut carry = 0;\n        while a >= 10 {\n            carry += a %\
    \ 10;\n            a /= 10;\n        }\n        let digit = a % 10;\n        result\
    \ *= digit;\n        result += carry;\n        a *= 10;\n        b -= digit;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqs6qc1i.rs:11:24\n   |\n\
    11 |     debug_assert!(b <= i64::MAX);\n   |                        ^^^^^^^^ expected\
    \ `isize`, found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n11 |     debug_assert!(b <=\
    \ i64::MAX.try_into().unwrap());\n   |                                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Validate that the number\
    \ is valid for this function.\n    // If we are doing string multiplication, it\
    \ is enough to check the signs.\n    // Otherwise, we should also check that the\
    \ number of digits is valid.\n    if a < 0 || b < 0 {\n        0\n    } else {\n\
    \        if a.is_zero() || b.is_zero() {\n            return 0\n        }\n  \
    \      if a.is_zero() {\n            return b\n        }\n        if b.is_zero()\
    \ {\n            return a\n        }\n        // We know that both a and b are\
    \ non-zero integers,\n        // so we can safely take the modulus.\n        let\
    \ mut result = a % b;\n        for digit in &b % b {\n            result *= digit;\n\
    \        }\n        result\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpdfm5ns_x.rs:16:14\n   |\n16 |         if a.is_zero() ||\
    \ b.is_zero() {\n   |              ^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_zero` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpdfm5ns_x.rs:16:29\n   |\n16 |         if a.is_zero() || b.is_zero()\
    \ {\n   |                             ^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpdfm5ns_x.rs:19:14\n   |\n19 |         if a.is_zero() {\n\
    \   |              ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `is_zero` found for type `isize` in the current scope\n  --> /tmp/tmpdfm5ns_x.rs:22:14\n\
    \   |\n22 |         if b.is_zero() {\n   |              ^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0277]: `isize` is not an iterator\n  --> /tmp/tmpdfm5ns_x.rs:28:22\n\
    \   |\n28 |         for digit in &b % b {\n   |                      ^^^^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Add up all the unit\
    \ digits.\n    let mut total: isize = 0;\n    while a > 0 || b > 0 {\n       \
    \ // If one has unit digits, multiply them and add them to the total.\n      \
    \  if a > 0 {\n            total += a % 10;\n            a /= 10;\n        }\n\
    \        if b > 0 {\n            total += b % 10;\n            b /= 10;\n    \
    \    }\n    }\n    total * 10\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpumlksa8z.rs:16:13\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n16 |             a /= 10;\n\
    \   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpumlksa8z.rs:20:13\n \
    \  |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                  \
    \     - help: consider making this binding mutable: `mut b`\n...\n20 |       \
    \      b /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = isize::max_value();\n\
    \    if a < b {\n        product = b as isize;\n    } else {\n        product\
    \ = a as isize;\n    }\n    if product % 10 == 0 {\n        product /= 10;\n \
    \   }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `412`,\n right: `16`', /tmp/tmp8l5pbtek.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a;\n \
    \   let mut product = a / b;\n    if a < b {\n        result = (result * b) +\
    \ a;\n        product = (product * b);\n    }\n    product %= 10;\n    result\
    \ *= product;\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n \
    \   assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpp2b0k8p8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // Get digits of one number\n\
    \    let mut num_digits = a.log10_digits();\n    num_digits += 1;\n\n    let mut\
    \ result = a.0;\n\n    // Keep a buffer of digit to multiply\n    let mut buffer\
    \ = [0u8; num_digits];\n\n    // Multiply by another number\n    while b > 0 {\n\
    \        // Extract least digit\n        let mut next_digit = b % 10;\n\n    \
    \    // Update buffer\n        buffer.pop();\n        buffer.push(next_digit as\
    \ u8);\n\n        // Update result\n        result *= next_digit as usize;\n \
    \       b /= 10;\n    }\n\n    let mut result_digits = result.log10_digits();\n\
    \n    // Add buffer to result digits\n    result_digits += buffer.len();\n\n \
    \   // Calculate the carry\n    let mut carry: isize = 1;\n    for i in buffer.iter().rev()\
    \ {\n        carry += (i * result) as isize;\n        result /= 10;\n    }\n\n\
    \    // Add carry\n    carry += result % 10;\n\n    // Return carry\n    carry\
    \ % 10\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmplovvkc_3.rs:17:28\n   |\n11 |     let mut num_digits = a.log10_digits();\n\
    \   |     ------------------ help: consider using `const` instead of `let`: `const\
    \ num_digits`\n...\n17 |     let mut buffer = [0u8; num_digits];\n   |       \
    \                     ^^^^^^^^^^ non-constant value\n\nerror[E0599]: no method\
    \ named `log10_digits` found for type `isize` in the current scope\n  --> /tmp/tmplovvkc_3.rs:11:28\n\
    \   |\n11 |     let mut num_digits = a.log10_digits();\n   |                 \
    \           ^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmplovvkc_3.rs:14:24\n\
    \   |\n14 |     let mut result = a.0;\n   |                        ^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0435, E0599, E0610.\nFor more information about an error, try `rustc --explain\
    \ E0435`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let x = a % 10;\n    let\
    \ y = b % 10;\n    x + (y * 10 as isize)\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `28`,\n right: `16`', /tmp/tmpapm3wsg2.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       0\n    } else if b == 0 {\n        a\n    } else {\n        a.checked_mul(b).unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpaghvjfl9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a > 0 &&\
    \ b > 0);\n    if a > b {\n        (a, b)\n    } else {\n        (b, a)\n    }\n\
    }\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1m930t1v.rs:12:9\n   |\n\
    9  | fn multiply(a: isize, b: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n12 |        \
    \ (a, b)\n   |         ^^^^^^ expected `isize`, found tuple\n   |\n   = note:\
    \ expected type `isize`\n             found tuple `(isize, isize)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1m930t1v.rs:14:9\n   |\n9  | fn multiply(a:\
    \ isize, b: isize) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n...\n14 |         (b, a)\n   |         ^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(isize, isize)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a > 0 && b > 0 {\n \
    \       return a * b;\n    }\n    else if b == 0 {\n        return 0;\n    }\n\
    \    else {\n        return a;\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmpwa0w2jre.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b < 0 {\n        return\
    \ 0;\n    }\n    if a < 0 {\n        return 0;\n    }\n    if a == 0 || b == 0\
    \ {\n        return 0;\n    }\n    if b == 1 {\n        return a;\n    }\n   \
    \ if a == 1 {\n        return b;\n    }\n    let mut res = 1;\n    while a > 0\
    \ {\n        if a % 10 == 0 {\n            res *= b;\n        }\n        a /=\
    \ 10;\n    }\n    return res;\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmp130knuei.rs:30:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n30 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    assert!(b < a);\n    let\
    \ mut ans = isize::one();\n    ans *= a;\n    ans *= b;\n    ans %= 10;\n    ans\
    \ %= 10;\n    ans %= 10;\n    ans\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp7d9vqwj4.rs:11:26\n   |\n11 |  \
    \   let mut ans = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a * 10 + b).mod(10_isize)\
    \ as isize\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmp7r5ngr_n.rs:10:18\n\
    \   |\n10 |     (a * 10 + b).mod(10_isize) as isize\n   |                  ^^^\
    \ expected identifier, found keyword\n   |\nhelp: escape `mod` to use it as an\
    \ identifier\n   |\n10 |     (a * 10 + b).r#mod(10_isize) as isize\n   |     \
    \             ++\n\nerror[E0599]: no method named `r#mod` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp7r5ngr_n.rs:10:18\n   |\n10 |     (a * 10\
    \ + b).mod(10_isize) as isize\n   |                  ^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 {\n \
    \       panic!(\"Invalid arguments for multiply function\");\n    }\n    let mut\
    \ product = 0;\n    let mut carry = 0;\n    while a > 0 {\n        let digit =\
    \ a % 10;\n        product = product * 10 + digit;\n        a = a / 10;\n    \
    \    carry = (a / 10) * 10;\n    }\n    while b > 0 {\n        let digit = b %\
    \ 10;\n        product = product * 10 + digit;\n        b = b / 10;\n        carry\
    \ = (b / 10) * 10;\n    }\n    product + carry\n}\n\nfn main() {\n    let candidate\
    \ = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpt131oyda.rs:18:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n18 |         a = a / 10;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `b`\n  --> /tmp/tmpt131oyda.rs:24:9\n  \
    \ |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                   \
    \    - help: consider making this binding mutable: `mut b`\n...\n24 |        \
    \ b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 0;\n\
    \    for _ in 0..min(10, a.cmp(b)) {\n        let a = a % 10;\n        let b =\
    \ b % 10;\n        if a == 0 && b == 0 {\n            break;\n        }\n    \
    \    product += (a * b) as isize;\n        a = a / 10;\n        b = b / 10;\n\
    \    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpj4ewmkjs.rs:11:17\n\
    \   |\n11 |     for _ in 0..min(10, a.cmp(b)) {\n   |                 ^^^\n...\n\
    24 | fn main() {\n   | --------- similarly named function `main` defined here\n\
    \   |\nhelp: a function with a similar name exists\n   |\n11 |     for _ in 0..main(10,\
    \ a.cmp(b)) {\n   |                 ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj4ewmkjs.rs:11:31\n   |\n11 |     for _ in 0..min(10, a.cmp(b)) {\n\
    \   |                               ^\n   |                               |\n\
    \   |                               expected `&isize`, found `isize`\n   |   \
    \                            help: consider borrowing here: `&b`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a < 0 || b < 0 {\n\
    \        true => 0, // a * b will overflow with negative numbers\n        false\
    \ => return a * b\n    }\n    let mut sum = a;\n    while b > 0 {\n        //\
    \ Calculate the next digit of sum\n        // by taking the remainder after dividing\n\
    \        // by 10\n        let digit = sum % 10;\n        sum = sum / 10;\n  \
    \      sum += digit * b;\n        b = b / 10;\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_ohzbm0.rs:10:5\n   |\n\
    10 | /     match a < 0 || b < 0 {\n11 | |         true => 0, // a * b will overflow\
    \ with negative numbers\n12 | |         false => return a * b\n13 | |     }\n\
    \   | |     ^- help: consider using a semicolon here\n   | |_____|\n   |     \
    \  expected `()`, found integer\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a % b {\n       \
    \ 0 => a,\n        _ => multiply(b / 10, a * 10 % b),\n    }\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmp2m3hgq71.rs:10:11\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if b == 0 {\n        return\
    \ a;\n    }\n    \n    let mut result = a;\n    while a > 0 && b > 0 {\n     \
    \   result *= 10; a /= 10; b /= 10;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpcx3knqg1.rs:16:23\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n16 |         result *= 10;\
    \ a /= 10; b /= 10;\n   |                       ^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpcx3knqg1.rs:16:32\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n16 |      \
    \   result *= 10; a /= 10; b /= 10;\n   |                                ^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0 &&\
    \ a%10 == 0);\n    debug_assert!(b >= 0 && b%10 == 0);\n    (a as isize * 10 as\
    \ isize) / b as isize\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: a >= 0 && a % 10 == 0', /tmp/tmph919l6hw.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = a;\n \
    \   while a > 0 {\n        if b & 1 == 1 {\n            result *= 10;\n      \
    \      result += a - b as isize;\n        }\n        a /= 10;\n        b /= 10;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpl_xypxqk.rs:16:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n16 |         a /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpl_xypxqk.rs:17:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n17 |         b /= 10;\n\
    \   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < b {\n        multiply(b,\
    \ a)\n    } else {\n        (a * b).min(MAX_INT)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_INT` in this scope\n  --> /tmp/tmpvzeq9z6j.rs:13:21\n\
    \   |\n13 |         (a * b).min(MAX_INT)\n   |                     ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a < b {\n       \
    \ true => 0,\n        false => (a % b) + multiply(a, b - a % b),\n    }\n}\n\n\
    fn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412),\
    \ 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `16`', /tmp/tmpcamoix5y.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 || b < 0 { return\
    \ 0; }\n    if a > INT_MAX / 10 || b > INT_MAX / 10 { \n        return 0;\n  \
    \  }\n    if a == 0 || b == 0 { \n        return INT_MAX / 10; \n    }\n    let\
    \ mut result = INT_MAX / 10;\n    for i in 0..10 {\n        result *= a % 10;\n\
    \        a /= 10;\n        result *= b % 10;\n        b /= 10;\n    }\n    if\
    \ a == 1 && b == 0 { \n        result = 0\n    }\n    if a != 0 || b != 1 { \n\
    \        result = 0\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19,\
    \ 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14,\
    \ -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17,\
    \ 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0,\
    \ 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `INT_MAX` in this scope\n  --> /tmp/tmpwdyk8kiv.rs:11:12\n\
    \   |\n11 |     if a > INT_MAX / 10 || b > INT_MAX / 10 { \n   |            ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `INT_MAX` in this\
    \ scope\n  --> /tmp/tmpwdyk8kiv.rs:11:32\n   |\n11 |     if a > INT_MAX / 10 ||\
    \ b > INT_MAX / 10 { \n   |                                ^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `INT_MAX` in this scope\n  -->\
    \ /tmp/tmpwdyk8kiv.rs:15:16\n   |\n15 |         return INT_MAX / 10; \n   |  \
    \              ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `INT_MAX` in this scope\n  --> /tmp/tmpwdyk8kiv.rs:17:22\n   |\n17 |     let\
    \ mut result = INT_MAX / 10;\n   |                      ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = a * b\
    \ as isize;\n    let mut digit = 1;\n\n    while product % 10 == 0 {\n       \
    \ product /= 10;\n        digit++;\n    }\n\n    product = product * digit;\n\
    \    product\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpavxi00h_.rs:15:14\n\
    \   |\n15 |         digit++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp = digit; digit +=\
    \ 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n15 -         digit++;\n\
    15 +         digit += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    // TODO: Use a BigInt for\
    \ multiplication if necessary.\n    let mut product = a * b as isize;\n    //\
    \ The product is zero only when both operands are zero.\n    if product == 0 {\n\
    \        product = 1;\n    }\n    // The product is negative if at least one of\
    \ the operands is\n    // negative.\n    if product < 0 {\n        product *=\
    \ -1;\n    }\n    return product;\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `60976`,\n right: `16`', /tmp/tmp0vov5oqy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a > b {\n        multiply(b,\
    \ a)\n    }\n    if a == 0 {\n        return 0;\n    }\n    if a < 0 {\n     \
    \   multiply(-a, b)\n    } else {\n        let mut m: isize = 1;\n        for\
    \ digit in (a..=b).rev() {\n            m *= digit as isize;\n        }\n    \
    \    m\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmporum9a1c.rs:11:9\n   |\n\
    10 | /     if a > b {\n11 | |         multiply(b, a)\n   | |         ^^^^^^^^^^^^^^\
    \ expected `()`, found `isize`\n12 | |     }\n   | |_____- expected this to be\
    \ `()`\n   |\nhelp: consider using a semicolon here\n   |\n11 |         multiply(b,\
    \ a);\n   |                       +\nhelp: consider using a semicolon here\n \
    \  |\n12 |     };\n   |      +\nhelp: you might have meant to return this value\n\
    \   |\n11 |         return multiply(b, a);\n   |         ++++++              \
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match (a, b) {\n      \
    \  (&0, &0) -> 0,\n        (&0, &1) -> 1,\n        (&1, &0) -> 1,\n        (&1,\
    \ &1) -> 0,\n        (&1, &2) -> 2,\n        (&2, &0) -> 2,\n        (&2, &1)\
    \ -> 1,\n        (&2, &2) -> 1,\n        (&3, &0) -> 3,\n        (&3, &1) -> 2,\n\
    \        (&3, &2) -> 1,\n        (&3, &3) -> 0,\n        (&4, &0) -> 4,\n    \
    \    (&4, &1) -> 3,\n        (&4, &2) -> 2,\n        (&4, &3) -> 1,\n        (&4,\
    \ &4) -> 1,\n        (&5, &0) -> 5,\n        (&5, &1) -> 4,\n        (&5, &2)\
    \ -> 3,\n        (&5, &3) -> 2,\n        (&5, &4) -> 1,\n        (&5, &5) -> 0,\n\
    \        (&6, &0) -> 6,\n        (&6, &1) -> 5,\n        (&6, &2) -> 4,\n    \
    \    (&6, &3) -> 3,\n        (&6, &4) -> 2,\n        (&6, &5) -> 1,\n        (&6,\
    \ &6) -> 1,\n        _ => panic!(\"invalid input\"),\n    }\n}\n\nfn main() {\n\
    \    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n   \
    \ assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n\
    \    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n\
    \    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n\
    \    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:11:18\n\
    \   |\n11 |         (&0, &0) -> 0,\n   |                  ^^\n   |           \
    \       |\n   |                  expected one of `=>`, `if`, or `|`\n   |    \
    \              help: try using a fat arrow here: `=>`\n\nerror: expected one of\
    \ `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:12:18\n   |\n12 |\
    \         (&0, &1) -> 1,\n   |                  ^^\n   |                  |\n\
    \   |                  expected one of `=>`, `if`, or `|`\n   |              \
    \    help: try using a fat arrow here: `=>`\n\nerror: expected one of `=>`, `if`,\
    \ or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:13:18\n   |\n13 |         (&1,\
    \ &0) -> 1,\n   |                  ^^\n   |                  |\n   |         \
    \         expected one of `=>`, `if`, or `|`\n   |                  help: try\
    \ using a fat arrow here: `=>`\n\nerror: expected one of `=>`, `if`, or `|`, found\
    \ `->`\n  --> /tmp/tmpm8qm6_p8.rs:14:18\n   |\n14 |         (&1, &1) -> 0,\n \
    \  |                  ^^\n   |                  |\n   |                  expected\
    \ one of `=>`, `if`, or `|`\n   |                  help: try using a fat arrow\
    \ here: `=>`\n\nerror: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:15:18\n\
    \   |\n15 |         (&1, &2) -> 2,\n   |                  ^^\n   |           \
    \       |\n   |                  expected one of `=>`, `if`, or `|`\n   |    \
    \              help: try using a fat arrow here: `=>`\n\nerror: expected one of\
    \ `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:16:18\n   |\n16 |\
    \         (&2, &0) -> 2,\n   |                  ^^\n   |                  |\n\
    \   |                  expected one of `=>`, `if`, or `|`\n   |              \
    \    help: try using a fat arrow here: `=>`\n\nerror: expected one of `=>`, `if`,\
    \ or `|`, found `->`\n  --> /tmp/tmpm8qm6_p8.rs:17:18\n   |\n17 |         (&2,\
    \ &1) -> 1,\n   |                  ^^\n   |                  |\n   |         \
    \         expected one of `=>`, `if`, or `|`\n   |                  help: try\
    \ using a fat arrow here: `=>`\n\nerror: expected one of `=>`, `if`, or `"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0 &&\
    \ b >= 0);\n    let mut prod = isize::MAX;\n    while a > 0 {\n        prod =\
    \ if b % a == 0 {\n            prod.checked_add(a).unwrap()\n        } else {\n\
    \            prod.checked_mul(a).unwrap()\n        }\n        a /= 10\n    }\n\
    \    while b > 0 {\n        prod = if a * b % 10 == 0 {\n            prod.checked_add(b).unwrap()\n\
    \        } else {\n            prod.checked_mul(b).unwrap()\n        }\n     \
    \   b /= 10;\n    }\n    prod\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `a`\n  --> /tmp/tmpwgx5vzlu.rs:17:10\n   |\n\
    17 |         }\n   |          ^ help: add `;` here\n18 |         a /= 10\n   |\
    \         - unexpected token\n\nerror: expected `;`, found `b`\n  --> /tmp/tmpwgx5vzlu.rs:25:10\n\
    \   |\n25 |         }\n   |          ^ help: add `;` here\n26 |         b /= 10;\n\
    \   |         - unexpected token\n\nerror: aborting due to 2 previous errors\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    (a as f64).mul_int(b as\
    \ f64)\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `mul_int` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3i0y9xmk.rs:10:16\n   |\n10 |     (a as f64).mul_int(b\
    \ as f64)\n   |                ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut x = a;\n    let\
    \ mut y = b;\n    loop {\n        match x % 10 {\n            0 => { break; }\n\
    \            1 => {\n                x = x / 10;\n                y = y / 10;\n\
    \                let r = x * y;\n                x /= 10;\n                y /=\
    \ 10;\n                return r;\n            }\n            x => { y *= 10; }\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5bwxo6r.rs:14:20\n   |\n\
    9  | fn multiply(a: isize, b: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n14 |        \
    \     0 => { break; }\n   |                    ^^^^^\n   |                   \
    \ |\n   |                    expected `isize`, found `()`\n   |              \
    \      help: give it a value of the expected type: `break 42`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product_digits\
    \ = 0.0;\n    while a > 0 || b > 0 {\n        let mut digit1 = a % 10;\n     \
    \   let mut digit2 = b % 10;\n        product_digits += (digit1 * digit2);\n \
    \       a /= 10;\n        b /= 10;\n    }\n    product_digits\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpv0676qo3.rs:14:27\n\
    \   |\n14 |         product_digits += (digit1 * digit2);\n   |               \
    \            ^               ^\n   |\n   = note: `#[warn(unused_parens)]` on by\
    \ default\nhelp: remove these parentheses\n   |\n14 -         product_digits +=\
    \ (digit1 * digit2);\n14 +         product_digits += digit1 * digit2;\n   | \n\
    \nerror[E0277]: cannot add-assign `isize` to `{float}`\n  --> /tmp/tmpv0676qo3.rs:14:24\n\
    \   |\n14 |         product_digits += (digit1 * digit2);\n   |               \
    \         ^^ no implementation for `{float} += isize`\n   |\n   = help: the trait\
    \ `AddAssign<isize>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv0676qo3.rs:18:5\n   |\n9  | fn multiply(a: isize, b: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n18 |     product_digits\n   |     ^^^^^^^^^^^^^^ expected\
    \ `isize`, found floating-point number\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product: isize\
    \ = 0;\n    let mut carry = 0;\n    while a > 0 && b > 0 {\n        let q = a\
    \ / 10;\n        let r = a % 10;\n        let s = b / 10;\n        let t = b %\
    \ 10;\n\n        product = product.saturating_add(t * q * r);\n        carry =\
    \ product.saturating_add((q * t) % 10);\n        a = a / 10;\n        b = b /\
    \ 10;\n    }\n\n    if carry > 0 {\n        product += 1;\n    }\n\n    while\
    \ a > 0 {\n        product += 1;\n        a -= 1;\n    }\n\n    while b > 0 {\n\
    \        product += 1;\n        b -= 1;\n    }\n\n    product\n}\n\nfn main()\
    \ {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n\
    \    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851),\
    \ 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67),\
    \ 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1),\
    \ 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `s`\n  --> /tmp/tmpn7_qext5.rs:15:13\n   |\n\
    15 |         let s = b / 10;\n   |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_s`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `a`\n  -->\
    \ /tmp/tmpn7_qext5.rs:20:9\n   |\n9  | fn multiply(a: isize, b: isize) -> isize\
    \ {\n   |             - help: consider making this binding mutable: `mut a`\n\
    ...\n20 |         a = a / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `b`\n  --> /tmp/tmpn7_qext5.rs:21:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut b`\n...\n21 |      \
    \   b = b / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpn7_qext5.rs:30:9\n\
    \   |\n9  | fn multiply(a: isize, b: isize) -> isize {\n   |             - help:\
    \ consider making this binding mutable: `mut a`\n...\n30 |         a -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `b`\n  --> /tmp/tmpn7_qext5.rs:35:9\n   |\n9  |\
    \ fn multiply(a: isize, b: isize) -> isize {\n   |                       - help:\
    \ consider making this binding mutable: `mut b`\n...\n35 |         b -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 4 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    let mut prod = 1;\n   \
    \ for &n in a.to_digits().rev() {\n        let mut mult = prod;\n        for &p\
    \ in b.to_digits().rev() {\n            mult *= n % p;\n        }\n        prod\
    \ = mult;\n    }\n    prod\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpo5gk6ys4.rs:11:17\n   |\n11 |     for &n in a.to_digits().rev()\
    \ {\n   |                 ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpo5gk6ys4.rs:13:21\n   |\n13 |         for &p in b.to_digits().rev()\
    \ {\n   |                     ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    match a {\n        0 =>\
    \ return b * 10,\n        _ if b < 10 => return b * 10,\n        x => return a\
    \ * 10 + b * 10,\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n   \
    \ assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5600`,\n right: `16`', /tmp/tmpdew0_5ws.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < 0 {\n        0\n\
    \    } else if b < 0 {\n        a * -1\n    } else {\n        (a % 10) * b % 10\n\
    \    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `16`', /tmp/tmpgocrxvm1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    if a < b {\n        let\
    \ mut min = std::cmp::min(a, b);\n        return std::cmp::max(min, std::cmp::min(std::cmp::max(a\
    \ % 10, b % 10), 10));\n    }\n    else { \n        let mut min = std::cmp::min(a,\
    \ b);\n        return std::cmp::max(min, std::cmp::min(std::cmp::max(a % 10, b\
    \ % 10), 10));\n    }\n}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148,\
    \ 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020,\
    \ 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76,\
    \ 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0,\
    \ 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `148`,\n right: `16`', /tmp/tmpdeel6tqz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Complete the function that takes two integers and returns \n/// the\
    \ product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n\
    /// multiply(148, 412) should return 16.\n/// multiply(19, 28) should return 72.\n\
    /// multiply(2020, 1851) should return 0.\n/// multiply(14,-15) should return\
    \ 20.\nfn multiply(a: isize, b: isize) -> isize {\n    debug_assert!(a >= 0 &&\n\
    \                b >= 0 &&\n                a <= b && \n                a <= 10);\n\
    \    let mut product = a * b as isize;\n    for &d in &b {\n        product *=\
    \ 10 + d;\n    }\n    product\n}\n\nfn main() {\n    let candidate = multiply;\n\
    \    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n\
    \    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15),\
    \ 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27),\
    \ 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmpr0vhfoqs.rs:15:15\n\
    \   |\n15 |     for &d in &b {\n   |               ^^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
