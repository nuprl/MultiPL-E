name: HumanEval_48_is_palindrome
language: rust
results:
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().skip_while(|c| *c == ' '))\n  \
    \      .take(text.len() / 2)\n        .all(|(a, b)| a == b)\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpud42d0h7.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = String::new();\n    s.clear();\n    text.iter().for_each(|c|\
    \ {\n        *s = c;\n        if s.starts_with(&s[..s.len() - 1]) {\n        \
    \    return false;\n        }\n    });\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1rbk32uz.rs:13:10\n   |\n13 |     text.iter().for_each(|c|\
    \ {\n   |          ^^^^ method not found in `String`\n   |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n   |\n13 |     text.chars().for_each(|c| {\n \
    \  |          ~~~~~\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmp1rbk32uz.rs:13:27\n   |\n13 |  \
    \   text.iter().for_each(|c| {\n   |                           ^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\nhelp: function arguments must have a statically known size, borrowed\
    \ types always have a known size\n   |\n13 |     text.iter().for_each(|&c| {\n\
    \   |                           +\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmp1rbk32uz.rs:14:9\n\
    \   |\n14 |         *s = c;\n   |         ^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1rbk32uz.rs:15:9\n   |\n15 | /         if s.starts_with(&s[..s.len()\
    \ - 1]) {\n16 | |             return false;\n17 | |         }\n   | |_________^\
    \ expected `bool`, found `()`\n   |\nnote: return type inferred to be `bool` here\n\
    \  --> /tmp/tmp1rbk32uz.rs:16:20\n   |\n16 |             return false;\n   | \
    \                   ^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase()\n        .chars()\n        .fold(1, |res,\
    \ c| {\n            if c == res {\n                0\n            } else {\n \
    \               match c % 10 {\n                    0 => c / 10,\n           \
    \         1 => c / 10 + 10\n                }\n            }\n        })\n   \
    \     == 0\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbvbqvhg2.rs:14:21\n   |\n\
    14 |             if c == res {\n   |                     ^^^ expected `char`,\
    \ found integer\n\nerror[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpbvbqvhg2.rs:17:25\n\
    \   |\n17 |                 match c % 10 {\n   |                       - ^ --\
    \ {integer}\n   |                       |\n   |                       char\n\n\
    error[E0369]: cannot divide `char` by `{integer}`\n  --> /tmp/tmpbvbqvhg2.rs:18:28\n\
    \   |\n18 |                     0 => c / 10,\n   |                          -\
    \ ^ -- {integer}\n   |                          |\n   |                      \
    \    char\n\nerror[E0369]: cannot divide `char` by `{integer}`\n  --> /tmp/tmpbvbqvhg2.rs:19:28\n\
    \   |\n19 |                     1 => c / 10 + 10\n   |                       \
    \   - ^ -- {integer}\n   |                          |\n   |                  \
    \        char\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().enumerate().filter_map(|(i, c)| {\n        if c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase() {\n            c.to_lowercase()\n        } else {\n\
    \            c.to_uppercase()\n        }\n    }).fold(true, |s, (c, i)| {\n  \
    \      if c.is_ascii_lowercase() || c.is_ascii_uppercase() {\n            s =\
    \ s.is_ascii_lowercase() && s.is_ascii_uppercase() || s;\n        } else {\n \
    \           s = s.is_ascii_lowercase() || s.is_ascii_uppercase();\n        }\n\
    \        s = s.is_ascii_lowercase() && s.is_ascii_uppercase() || s;\n        s\
    \ == c\n    });\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkob1t12o.rs:13:13\n   |\n\
    13 |             c.to_lowercase()\n   |             ^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found struct `ToLowercase`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `ToLowercase`\nhelp: try wrapping the expression in\
    \ `Some`\n   |\n13 |             Some(c.to_lowercase())\n   |             +++++\
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkob1t12o.rs:15:13\n\
    \   |\n15 |             c.to_uppercase()\n   |             ^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found struct `ToUppercase`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `ToUppercase`\nhelp: try wrapping the expression in\
    \ `Some`\n   |\n15 |             Some(c.to_uppercase())\n   |             +++++\
    \                +\n\nerror[E0599]: no method named `is_ascii_lowercase` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpkob1t12o.rs:19:19\n   |\n\
    19 |             s = s.is_ascii_lowercase() && s.is_ascii_uppercase() || s;\n\
    \   |                   ^^^^^^^^^^^^^^^^^^ method not found in `bool`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for type `bool` in the current scope\n\
    \  --> /tmp/tmpkob1t12o.rs:19:45\n   |\n19 |             s = s.is_ascii_lowercase()\
    \ && s.is_ascii_uppercase() || s;\n   |                                      \
    \       ^^^^^^^^^^^^^^^^^^ method not found in `bool`\n\nerror[E0599]: no method\
    \ named `is_ascii_lowercase` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmpkob1t12o.rs:21:19\n   |\n21 |             s = s.is_ascii_lowercase()\
    \ || s.is_ascii_uppercase();\n   |                   ^^^^^^^^^^^^^^^^^^ method\
    \ not found in `bool`\n\nerror[E0599]: no method named `is_ascii_uppercase` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpkob1t12o.rs:21:45\n   |\n\
    21 |             s = s.is_ascii_lowercase() || s.is_ascii_uppercase();\n   | \
    \                                            ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `bool`\n\nerror[E0599]: no method named `is_ascii_lowercase` found for type\
    \ `bool` in the current scope\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.char_indices().rev();\n    loop {\n       \
    \ let (s, e) = it.next();\n        if s != e {\n            break;\n        }\n\
    \    }\n    it == text.char_indices().rev().rev()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6fxq_bmm.rs:13:13\n   |\n\
    13 |         let (s, e) = it.next();\n   |             ^^^^^^   --------- this\
    \ expression has type `Option<(usize, char)>`\n   |             |\n   |      \
    \       expected enum `Option`, found tuple\n   |\n   = note: expected enum `Option<(usize,\
    \ char)>`\n             found tuple `(_, _)`\n\nerror[E0369]: binary operation\
    \ `==` cannot be applied to type `Rev<CharIndices<'_>>`\n  --> /tmp/tmp6fxq_bmm.rs:18:8\n\
    \   |\n18 |     it == text.char_indices().rev().rev()\n   |     -- ^^ -------------------------------\
    \ Rev<Rev<CharIndices<'_>>>\n   |     |\n   |     Rev<CharIndices<'_>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut string = text.to_string();\n    let mut i = (string.len()\
    \ - 1) as usize;\n    let mut j = (string.len() - 1) as usize;\n\n    while i\
    \ >= 0 {\n        if string[i] != string[j] {\n            return false;\n   \
    \     }\n        j--;\n        i--;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpcjiena_q.rs:19:12\n\
    \   |\n19 |         j--;\n   |            ^ expected expression\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcjiena_q.rs:16:12\n\
    \   |\n16 |         if string[i] != string[j] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcjiena_q.rs:16:25\n   |\n16 |         if string[i] != string[j]\
    \ {\n   |                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut len = text.len();\n    let mut i = 0;\n\n    while i\
    \ < len {\n        if text[i] != text[len - i - 1] {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8h408aiu.rs:15:12\n\
    \   |\n15 |         if text[i] != text[len - i - 1] {\n   |            ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8h408aiu.rs:15:23\n   |\n15 |         if text[i] != text[len -\
    \ i - 1] {\n   |                       ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text == \"\" {\n        return true;\n    }\n    for i in\
    \ 0..text.len() {\n        if text[i] != text[(text.len() - 1) - i] {\n      \
    \      return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmoj4hy_2.rs:15:12\n\
    \   |\n15 |         if text[i] != text[(text.len() - 1) - i] {\n   |         \
    \   ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmoj4hy_2.rs:15:23\n   |\n15 |         if text[i] != text[(text.len()\
    \ - 1) - i] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_ascii_lowercase()\n        .rev()\n        .chars()\n\
    \        .collect::<Vec<_>>()\n        .is_eq(&text[0..text.len()/2])\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmptomcccfe.rs:12:10\n\
    \    |\n12  |           .rev()\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut l = text\n        .chars()\n        .cloned()\n     \
    \   .collect::<Vec<_>>();\n    l.sort();\n    l == l.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp932ic0kr.rs:13:10\n     |\n13   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp932ic0kr.rs:14:10\n\
    \   |\n14 |           .collect::<Vec<_>>();\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_length = text.len();\n    let text_reverse = text.chars().map(|c|\
    \ c.to_string()).collect::<Vec<char>>();\n    let text_reverse: String = text_reverse.join();\n\
    \    text_reverse == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `String`\n    --> /tmp/tmp9wxlsuhy.rs:12:60\n     |\n\
    12   |     let text_reverse = text.chars().map(|c| c.to_string()).collect::<Vec<char>>();\n\
    \     |                                                            ^^^^^^^ value\
    \ of type `Vec<char>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<char>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: the method `join` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmp9wxlsuhy.rs:13:45\n\
    \   |\n13 |     let text_reverse: String = text_reverse.join();\n   |        \
    \                                     ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_lowercase();\n    s = s.chars().cloned().collect::<Vec<char>>().reverse();\n\
    \    if s == text {\n        true\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmps6og25at.rs:12:19\n     |\n12   |     s = s.chars().cloned().collect::<Vec<char>>().reverse();\n\
    \     |                   ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmps6og25at.rs:12:28\n   |\n12 |       s = s.chars().cloned().collect::<Vec<char>>().reverse();\n\
    \   |                              ^^^^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().skip(1).fold(true, |s, c| s == c)\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3j9pu__.rs:11:49\n   |\n\
    11 |     text.chars().skip(1).fold(true, |s, c| s == c)\n   |                \
    \                                 ^ expected `bool`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all() &&\n        text.chars().rref().rev().iter().all(|&c|\
    \ text.chars().contains(c))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpn4zj4vq5.rs:11:18\n     |\n11   |     text.chars().all() &&\n\
    \     |                  ^^^- supplied 0 arguments\n     |                  |\n\
    \     |                  expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `rref` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpn4zj4vq5.rs:12:22\n   |\n12 |         text.chars().rref().rev().iter().all(|&c|\
    \ text.chars().contains(c))\n   |                      ^^^^ method not found in\
    \ `Chars<'_>`\n\nerror[E0599]: no method named `contains` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpn4zj4vq5.rs:12:64\n   |\n12 |         text.chars().rref().rev().iter().all(|&c|\
    \ text.chars().contains(c))\n   |                                            \
    \                    ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .rev()\n        .join(\"\")\n        .eq(&text[0..text.len()\
    \ / 2].reverse())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `join` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmpap2k2u8j.rs:13:10\n   |\n13 |         .join(\"\")\n   |\
    \          ^^^^ method not found in `Rev<Chars<'_>>`\n\nerror[E0599]: no method\
    \ named `reverse` found for type `str` in the current scope\n  --> /tmp/tmpap2k2u8j.rs:14:38\n\
    \   |\n14 |         .eq(&text[0..text.len() / 2].reverse())\n   |            \
    \                          ^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().enumerate().filter(|(i, c)| {\n        text.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).take(i) == Some(c)\n    }).all(|(_, c)| c != ' ')\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp94qazin9.rs:12:40\n   |\n12 |         text.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).take(i) == Some(c)\n   |                             \
    \           ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94qazin9.rs:12:64\n\
    \   |\n12 |         text.chars().skip_while(|c| !c.is_ascii_letter()).take(i)\
    \ == Some(c)\n   |                                                           \
    \     ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n12 |         text.chars().skip_while(|c| !c.is_ascii_letter()).take(*i)\
    \ == Some(c)\n   |                                                           \
    \     +\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::iter::Take<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp94qazin9.rs:12:33: 12:57]>>`\n  --> /tmp/tmp94qazin9.rs:12:67\n\
    \   |\n12 |         text.chars().skip_while(|c| !c.is_ascii_letter()).take(i)\
    \ == Some(c)\n   |         ---------------------------------------------------------\
    \ ^^ ------- Option<&char>\n   |         |\n   |         std::iter::Take<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp94qazin9.rs:12:33: 12:57]>>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut is_palindrome = true;\n    let mut first = text.len()\
    \ - 1;\n    let mut last = text.len() - 1;\n\n    while first > last {\n     \
    \   if text[first] != text[last] {\n            is_palindrome = false;\n     \
    \       break;\n        }\n        first -= 1;\n        last -= 1;\n    }\n  \
    \  is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps3fjc803.rs:16:12\n\
    \   |\n16 |         if text[first] != text[last] {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps3fjc803.rs:16:27\n   |\n16 |         if text[first] != text[last]\
    \ {\n   |                           ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut index = 0;\n    let mut rev_text = String::from(text);\n\
    \n    rev_text.rev();\n\n    if text == rev_text {\n        return true;\n   \
    \ }\n    else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpwkb3sln8.rs:14:14\n\
    \    |\n14  |       rev_text.rev();\n    |                ^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .rev()\n        .map(|c| c.to_digit(10))\n\
    \        .zip(0..text.len())\n        .all(|(a, b)| a == b)\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_l83gjv_.rs:15:28\n   |\n\
    15 |         .all(|(a, b)| a == b)\n   |                            ^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<u32>`\n\
    \              found type `usize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.length <= 1 {\n        return true;\n    }\n\n    let\
    \ mut half = text.length / 2;\n    let left   = text[0..half];\n    let right\
    \ = text[half..];\n\n    if left != right {\n        return false;\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpzy19rc0y.rs:11:13\n\
    \   |\n11 |     if text.length <= 1 {\n   |             ^^^^^^ unknown field\n\
    \nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpzy19rc0y.rs:15:25\n\
    \   |\n15 |     let mut half = text.length / 2;\n   |                        \
    \ ^^^^^^ unknown field\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpzy19rc0y.rs:16:9\n   |\n16 |   \
    \  let left   = text[0..half];\n   |         ^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n16 |     let left   = &text[0..half];\n   |                  +\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpzy19rc0y.rs:17:9\n   |\n17 |     let right = text[half..];\n   |   \
    \      ^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\nhelp: consider borrowing here\n   |\n17 |     let right = &text[half..];\n\
    \   |                 +\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text[..text.len() /2 -1] == text[..text.len() /2 -1].reversed()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp3c7xz6zu.rs:11:10\n\
    \   |\n11 |     text == text[..text.len() /2 -1] == text[..text.len() /2 -1].reversed()\n\
    \   |          ^^                          ^^\n   |\nhelp: split the comparison\
    \ into two\n   |\n11 |     text == text[..text.len() /2 -1] && text[..text.len()\
    \ /2 -1] == text[..text.len() /2 -1].reversed()\n   |                        \
    \              +++++++++++++++++++++++++++\n\nerror[E0599]: no method named `reversed`\
    \ found for type `str` in the current scope\n  --> /tmp/tmp3c7xz6zu.rs:11:66\n\
    \   |\n11 |     text == text[..text.len() /2 -1] == text[..text.len() /2 -1].reversed()\n\
    \   |                                                                  ^^^^^^^^\
    \ method not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    for i in 0..len / 2-1 {\n        let\
    \ a = text[i];\n        let b = text[len - 1 - i];\n        if a != b {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpigzj4dvk.rs:13:17\n\
    \   |\n13 |         let a = text[i];\n   |                 ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpigzj4dvk.rs:14:17\n   |\n14 |         let b = text[len - 1 - i];\n\
    \   |                 ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .zip(text.chars().skip_while(|&x| x !=\
    \ 'a'))\n        .all(|&(l, r)| l == r)\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcl13t_y_.rs:13:15\n   |\n\
    13 |         .all(|&(l, r)| l == r)\n   |               ^^^^^^-\n   |        \
    \       |     |\n   |               |     expected due to this\n   |         \
    \      expected tuple, found reference\n   |\n   = note:  expected tuple `(char,\
    \ char)`\n           found reference `&_`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    if len < 2 {\n        return true;\n\
    \    }\n\n    let mut left = 0;\n    let mut right = len - 1;\n\n    while left\
    \ < right {\n        if text[left] != text[right] {\n            return false;\n\
    \        }\n\n        left += 1;\n        right -= 1;\n    }\n\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9b1xl47h.rs:20:12\n\
    \   |\n20 |         if text[left] != text[right] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9b1xl47h.rs:20:26\n   |\n20 |         if text[left] != text[right]\
    \ {\n   |                          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text1 = text.to_lowercase();\n    let mut text2 = text1.clone();\n\
    \    text2 = text2.chars().rev().collect::<String>();\n    text1 == text2\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let mut i = 0;\n    let mut j = len\
    \ - 1;\n    let mut rev = false;\n\n    while i < j {\n        if text[i] != text[j]\
    \ {\n            rev = true;\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n\n    rev\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8ojxsauh.rs:17:12\n\
    \   |\n17 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8ojxsauh.rs:17:23\n   |\n17 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() != text.chars().count() {\n        return false;\n\
    \    }\n    for i in text.chars().rposition(|c| c == text[(text.len() - 1) - i])\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp8golu8g4.rs:14:70\n\
    \   |\n14 |     for i in text.chars().rposition(|c| c == text[(text.len() - 1)\
    \ - i]) {\n   |                                                              \
    \        ^ help: a local variable with a similar name exists: `c`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp8golu8g4.rs:14:27\n\
    \     |\n14   |     for i in text.chars().rposition(|c| c == text[(text.len()\
    \ - 1) - i]) {\n     |                           ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp8golu8g4.rs:14:46\n   |\n14 |  \
    \   for i in text.chars().rposition(|c| c == text[(text.len() - 1) - i]) {\n \
    \  |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.chars().take(text.len() / 2).collect::<String>().rev().iter().map(|c|\
    \ c as char);\n    let text = iter.collect::<String>();\n    text == text\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp46oztfpq.rs:11:74\n\
    \    |\n11  |       let mut iter = text.chars().take(text.len() / 2).collect::<String>().rev().iter().map(|c|\
    \ c as char);\n    |                                                         \
    \                   ^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Reverse the string\n    let reversed_text = text.chars().collect::<String>().reverse();\n\
    \    // Compare the reverse string and original string\n    reversed_text == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp2l529wej.rs:12:58\n   |\n12 |     let reversed_text\
    \ = text.chars().collect::<String>().reverse();\n   |                        \
    \                                  ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.chars();\n    let first = iter.next();\n\
    \    let mut last = iter.next();\n    while let Some(next) = iter.next() {\n \
    \       last = Some(next);\n    }\n    last == first\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeckf5yts.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 { return true }\n    let mut s = text.chars().take(text.len()\
    \ / 2).collect::<String>();\n    s = s.chars().rev().collect::<String>();\n  \
    \  s = s.chars().take(s.len() / 2).collect::<String>();\n    s = s.chars().rev().collect::<String>();\n\
    \    s.to_lowercase().eq_ignore_ascii_case(text.to_lowercase())\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r0wys7m.rs:16:43\n   |\n\
    16 |     s.to_lowercase().eq_ignore_ascii_case(text.to_lowercase())\n   |    \
    \                                       ^^^^^^^^^^^^^^^^^^^\n   |            \
    \                               |\n   |                                      \
    \     expected `&str`, found struct `String`\n   |                           \
    \                help: consider borrowing here: `&text.to_lowercase()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.char_indices();\n    let len = it.len();\n\
    \    it.next().unwrap();\n    let mut i = 0;\n    let mut j = len - 1;\n    while\
    \ i <= j {\n        if *it[i] != *it[j] {\n            return false;\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpeqjhmh8l.rs:12:18\n   |\n12 |     let len = it.len();\n\
    \   |                  ^^^ method not found in `CharIndices<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `CharIndices<'_>`\n  --> /tmp/tmpeqjhmh8l.rs:17:13\n\
    \   |\n17 |         if *it[i] != *it[j] {\n   |             ^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `CharIndices<'_>`\n  --> /tmp/tmpeqjhmh8l.rs:17:23\n\
    \   |\n17 |         if *it[i] != *it[j] {\n   |                       ^^^^^\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all(|c| c == text.chars().skip_while(|c| *c == c).last().unwrap())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjowplilh.rs:11:65\n   |\n\
    11 |     text.chars().all(|c| c == text.chars().skip_while(|c| *c == c).last().unwrap())\n\
    \   |                                                                 ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    11 |     text.chars().all(|c| c == text.chars().skip_while(|c| *c == *c).last().unwrap())\n\
    \   |                                                                 +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(true, (current, next) => {\n        match current\
    \ {\n            c if !('a' <= c && c <= 'z' ||\n                   'A' <= c &&\
    \ c <= 'Z' ||\n                   '0' <= c && c <= '9') => *current = next,\n\
    \            _ => true\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmptgcmoblu.rs:11:45\n   |\n11 |     text.chars().fold(true, (current,\
    \ next) => {\n   |                                             ^^ expected one\
    \ of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().skip(1).eq(text.chars().skip(text.len() - 1).rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpqbu3x6xs.rs:11:63\n     |\n11   |     text.chars().skip(1).eq(text.chars().skip(text.len()\
    \ - 1).rev())\n     |                                                        \
    \       ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Skip<Chars<'_>>`\nnote: required by\
    \ a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmpqbu3x6xs.rs:11:29\n   |\n11 |     text.chars().skip(1).eq(text.chars().skip(text.len()\
    \ - 1).rev())\n   |                          -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n   |     \
    \                     |\n   |                          required by a bound introduced\
    \ by this call\n   |\n   = help: the following other types implement trait `ExactSizeIterator`:\n\
    \             &mut I\n             Args\n             ArgsOs\n             ArrayChunks<'_,\
    \ T, N>\n             ArrayChunksMut<'_, T, N>\n             ArrayWindows<'_,\
    \ T, N>\n             Box<I, A>\n             Chunks<'_, T>\n           and 109\
    \ others\n   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Skip<Chars<'_>>`\n   = note: required because of the requirements on the\
    \ impl of `Iterator` for `Rev<Skip<Chars<'_>>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    while i <= text.len()\
    \ - 1 {\n        j = text.len() - 1;\n        while j >= i {\n            if text[i..j]\
    \ != text[j..i] {\n                return false;\n            }\n            j--;\n\
    \        }\n        i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpq3xtkkao.rs:19:16\n\
    \   |\n19 |             j--;\n   |                ^ expected expression\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect::<Vec<_>>()\n        .palindrome()\n   \
    \     .all(|c| c == text[text.len() - 1 - text.chars().enumerate().filter(|(_,\
    \ c2)| *c2 != *c).next().unwrap().0]);\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `palindrome` found for struct `Vec<char>`\
    \ in the current scope\n  --> /tmp/tmph874yhjb.rs:12:10\n   |\n12 |         .palindrome()\n\
    \   |          ^^^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmph874yhjb.rs:13:23\n\
    \   |\n13 |         .all(|c| c == text[text.len() - 1 - text.chars().enumerate().filter(|(_,\
    \ c2)| *c2 != *c).next().unwrap().0]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph874yhjb.rs:10:35\n\
    \   |\n10 | fn is_palindrome(text: String) -> bool {\n   |    -------------  \
    \                ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    let mut iter = text.char_indices();\n\
    \    let len = text.len();\n\n    // reverse iterator if string is a palindrome\n\
    \    if len == 1 {\n        iter = iter.map(|(&i, &j)| (j, i));\n    }\n\n   \
    \ for n in iter.by_ref() {\n        if n == text[..(n-1)].chars().last().unwrap()\
    \ {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpicdb9n_a.rs:17:27\n   |\n\
    17 |         iter = iter.map(|(&i, &j)| (j, i));\n   |                       \
    \    ^^    - expected due to this\n   |                           |\n   |    \
    \                       expected `usize`, found reference\n   |              \
    \             help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `usize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpicdb9n_a.rs:17:31\n   |\n17 |         iter =\
    \ iter.map(|(&i, &j)| (j, i));\n   |                               ^^- expected\
    \ due to this\n   |                               |\n   |                    \
    \           expected `char`, found reference\n   |                           \
    \    help: you can probably remove the explicit borrow: `j`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpicdb9n_a.rs:17:16\n   |\n12 |     let mut iter = text.char_indices();\n\
    \   |                    ------------------- expected due to this value\n...\n\
    17 |         iter = iter.map(|(&i, &j)| (j, i));\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `CharIndices`, found struct `Map`\n   |\n   = note: expected\
    \ struct `CharIndices<'_>`\n              found struct `Map<CharIndices<'_>, [closure@/tmp/tmpicdb9n_a.rs:17:25:\
    \ 17:42]>`\n\nerror[E0369]: cannot subtract `{integer}` from `(usize, char)`\n\
    \  --> /tmp/tmpicdb9n_a.rs:21:26\n   |\n21 |         if n == text[..(n-1)].chars().last().unwrap()\
    \ {\n   |                         -^- {integer}\n   |                        \
    \ |\n   |                         (usize, char)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpicdb9n_a.rs:21:17\n   |\n21 |         if n == text[..(n-1)].chars().last().unwrap()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found `char`\n   |\n   = note: expected tuple `(usize, char)`\n            \
    \   found type `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more informat"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    text.rev();\n    text.eq(&text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp8053nz0n.rs:12:10\n\
    \    |\n12  |       text.rev();\n    |            ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(false, |is_palindrome, char| {\n        match\
    \ char {\n            'a' => {\n                is_palindrome\n            }\n\
    \            'a' | 'b' => {\n                is_palindrome\n            }\n  \
    \          'b' => {\n                is_palindrome\n            }\n          \
    \  _ => {\n                if is_palindrome {\n                    is_palindrome\n\
    \                } else {\n                    false\n                }\n    \
    \        }\n        }\n    })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt4ive2aa.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().r_cmp(&text.chars().next().unwrap(), Ordering::Descending)\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp0ow0q9hz.rs:11:55\n   |\n11 |     text.chars().r_cmp(&text.chars().next().unwrap(),\
    \ Ordering::Descending) == 0\n   |                                           \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: no method\
    \ named `r_cmp` found for struct `Chars` in the current scope\n  --> /tmp/tmp0ow0q9hz.rs:11:18\n\
    \   |\n11 |     text.chars().r_cmp(&text.chars().next().unwrap(), Ordering::Descending)\
    \ == 0\n   |                  ^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut index = 0;\n    let mut text = String::from(text);\n\
    \    while text.len() > 0 {\n        let char = text.get_char();\n        if index\
    \ == 0 {\n            index = index + 1\n        } else {\n            if char\
    \ == text.get_char() {\n                index = index + 1\n            } else\
    \ {\n                index = index\n            }\n        }\n        text = &text[1..];\n\
    \    }\n    text == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `get_char` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5ol4by7k.rs:14:25\n   |\n14 |         let char\
    \ = text.get_char();\n   |                         ^^^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `get_char` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5ol4by7k.rs:18:29\n   |\n18 |          \
    \   if char == text.get_char() {\n   |                             ^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ol4by7k.rs:24:16\n\
    \   |\n12 |     let mut text = String::from(text);\n   |                    ------------------\
    \ expected due to this value\n...\n24 |         text = &text[1..];\n   |     \
    \           ^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n24 |         text = (&text[1..]).to_string();\n\
    \   |                +          +++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .skip_while(|c| !c.is_ascii_letter())\n\
    \        .rev()\n        .eq(text.chars().skip_while(|c| !c.is_ascii_letter()).rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpmverhvvr.rs:12:28\n   |\n12 |         .skip_while(|c|\
    \ !c.is_ascii_letter())\n   |                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ the trait bound `SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21: 12:45]>:\
    \ DoubleEndedIterator` is not satisfied\n    --> /tmp/tmpmverhvvr.rs:13:10\n \
    \    |\n13   |         .rev()\n     |          ^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21:\
    \ 12:45]>`\n     |\nnote: required by a bound in `rev`\n\nerror[E0599]: the method\
    \ `eq` exists for struct `Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21:\
    \ 12:45]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpmverhvvr.rs:14:10\n\
    \   |\n14 |            .eq(text.chars().skip_while(|c| !c.is_ascii_letter()).rev())\n\
    \   |             ^^ method cannot be called on `Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21:\
    \ 12:45]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21:\
    \ 12:45]>: DoubleEndedIterator`\n           which is required by `Rev<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpmverhvvr.rs:12:21: 12:45]>>: Iterator`\n           `Rev<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpmverhvvr.rs:12:21: 12:45]>>: Iterator`\n           which is\
    \ required by `&mut Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:12:21:\
    \ 12:45]>>: Iterator`\n\nerror[E0599]: no method named `is_ascii_letter` found\
    \ for reference `&char` in the current scope\n  --> /tmp/tmpmverhvvr.rs:14:44\n\
    \   |\n14 |         .eq(text.chars().skip_while(|c| !c.is_ascii_letter()).rev())\n\
    \   |                                            ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0277]: the\
    \ trait bound `SkipWhile<Chars<'_>, [closure@/tmp/tmpmverhvvr.rs:14:37: 14:61]>:\
    \ Double"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .take(text.len() / 2)\n        .collect::<String>()\n\
    \        == text.chars()\n            .skip(text.len() / 2)\n            .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa57_qyp7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s: String = text;\n    while s.len() > 0 {\n        if\
    \ s.chars().nth(s.len() - 1).unwrap() != s.chars().nth(s.len() - 2).unwrap() {\n\
    \            return false;\n        }\n        s = s.chars().skip_while(|&c| !c.is_ascii_whitespace()).collect();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdx_jqmwr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars()\n        .cloned()\n        .filter_map(|c|\
    \ c.to_digit())\n        .collect::<Vec<i32>>()\n        .iter()\n        .rev()\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .zip(text.chars().cloned())\n\
    \        .all(|(a, b)| a.to_digit() == b.to_digit())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpsli9x88r.rs:12:10\n     |\n12   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `filter_map` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpsli9x88r.rs:13:10\n\
    \   |\n13 |           .filter_map(|c| c.to_digit())\n   |            ^^^^^^^^^^\
    \ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpsli9x88r.rs:19:27\n \
    \    |\n19   |         .zip(text.chars().cloned())\n     |                   \
    \        ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.char_indices().rev();\n\n    if let Some(first_index)\
    \ = it.next() {\n        if first_index >= text.len() || first_index < 0 {\n \
    \           return false;\n        }\n        if text[first_index] != text[it.prev()]\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5uqt615u.rs:14:27\n   |\n\
    14 |         if first_index >= text.len() || first_index < 0 {\n   |         \
    \                  ^^^^^^^^^^ expected tuple, found `usize`\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n               found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5uqt615u.rs:14:55\n   |\n14 |         if first_index\
    \ >= text.len() || first_index < 0 {\n   |                                   \
    \                    ^ expected tuple, found integer\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `{integer}`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `(usize, char)`\n  --> /tmp/tmp5uqt615u.rs:17:12\n\
    \   |\n17 |         if text[first_index] != text[it.prev()] {\n   |          \
    \  ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `(usize, char)`\n   |\n   =\
    \ help: the trait `Index<(usize, char)>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `prev` found for struct `Rev` in\
    \ the current scope\n  --> /tmp/tmp5uqt615u.rs:17:41\n   |\n17 |         if text[first_index]\
    \ != text[it.prev()] {\n   |                                         ^^^^ method\
    \ not found in `Rev<CharIndices<'_>>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reverse = String::new();\n    let len = text.len();\n\
    \    reverse.push_str(&text[(len - 2) as usize..(len - 1)]);\n    reverse == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp2ae8v223.rs:13:28\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut a = text;\n    let mut b = text;\n\n    while a.len()\
    \ > 0 || b.len() > 0 {\n        if a.len() > 0 {\n            a += &a[a.len()\
    \ - 1];\n        }\n\n        if b.len() > 0 {\n            b += &b[b.len() -\
    \ 1];\n        }\n    }\n    a == b\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpagpxi8ts.rs:16:19\n\
    \   |\n16 |             a += &a[a.len() - 1];\n   |                   ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpagpxi8ts.rs:20:19\n   |\n20 |             b += &b[b.len() - 1];\n\
    \   |                   ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut input = text.chars();\n    let mut input_iter = input.clone();\n\
    \    input_iter.rev();\n    input.is_eq(&input_iter)\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_eq` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpq6gda8j9.rs:14:11\n   |\n14 |     input.is_eq(&input_iter)\n\
    \   |           ^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut buffer = text.to_lowercase().chars().collect::<String>();\n\
    \    let rev = buffer.chars().fold(|mut acc, x| {\n        match x {\n       \
    \     'a' => acc + 1,\n            'z' => acc + 26 + 1,\n            'a' | 'z'\
    \ => acc + 1,\n            _ => acc,\n        }\n    }, 0);\n    buffer.reverse()\
    \ == rev\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(_, char)>` closure, found `{integer}`\n\
    \    --> /tmp/tmpdzwl_te3.rs:19:8\n     |\n12   |     let rev = buffer.chars().fold(|mut\
    \ acc, x| {\n     |                              ---- required by a bound introduced\
    \ by this call\n...\n19   |     }, 0);\n     |        ^ expected an `FnMut<(_,\
    \ char)>` closure, found `{integer}`\n     |\n     = help: the trait `FnMut<(_,\
    \ char)>` is not implemented for `{integer}`\nnote: required by a bound in `fold`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdzwl_te3.rs:20:12\n   |\n20 |     buffer.reverse() == rev\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect()\n        .reverse()\n        .reduce(|x,\
    \ y| x == y) ? true : false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `true`\n  --> /tmp/tmpqc_onslw.rs:13:34\n   |\n13 |         .reduce(|x, y| x\
    \ == y) ? true : false\n   |                                  ^^^^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // empty string is palindrome\n    if text.is_empty() {\n   \
    \     return true;\n    }\n\n    // if length of text is not even\n    // then\
    \ text is not a palindrome\n    // also if length is odd then text is not a palindrome\n\
    \    let len = text.len();\n    if len % 2 == 0 {\n        return false;\n   \
    \ }\n    if len % 2 == 1 {\n        return false;\n    }\n\n    // compare first\
    \ half of text and last half of text\n    // if equal then text is a palindrome\n\
    \    // otherwise text is not a palindrome\n    let first_half = String::from(&text[..(len\
    \ / 2)]);\n    let last_half = String::from(&text[..(len / 2)].rev());\n    if\
    \ first_half == last_half {\n        return true;\n    }\n    else {\n       \
    \ return false;\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `str` is not an iterator\n  --> /tmp/tmpdi3kn9vv.rs:31:53\n\
    \   |\n31 |     let last_half = String::from(&text[..(len / 2)].rev());\n   |\
    \                                                     ^^^ `str` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `str:\
    \ Iterator`\n           which is required by `&mut str: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text == text.to_lowercase() {\n        return true;\n    }\n\
    \    let mut s = String::new();\n    text.to_lowercase().chars().for_each(|c|\
    \ {\n        if *c <= 'z' && *c >= 'a' {\n            *s = *c.to_string() + s;\n\
    \        }\n    });\n    if s.chars().count() > text.len() / 2 {\n        return\
    \ false;\n    }\n    let mut i = 1;\n    while i <= text.len() - 1 {\n       \
    \ if text[i..i + 1] != s[i..i + 1] {\n            return false;\n        }\n \
    \       i += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpu2i4jn6m.rs:16:12\n\
    \   |\n16 |         if *c <= 'z' && *c >= 'a' {\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpu2i4jn6m.rs:16:25\n   |\n\
    16 |         if *c <= 'z' && *c >= 'a' {\n   |                         ^^\n\n\
    error[E0369]: cannot add `String` to `str`\n  --> /tmp/tmpu2i4jn6m.rs:17:33\n\
    \   |\n17 |             *s = *c.to_string() + s;\n   |                  --------------\
    \ ^ - String\n   |                  |\n   |                  str\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpu2i4jn6m.rs:17:13\n   |\n17 |             *s = *c.to_string() + s;\n\
    \   |             ^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0369, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n\n    if len < 2 || len % 2 == 1 || (len\
    \ / 2) != (len / 2) {\n        return false;\n    }\n\n    let mut s = String::from(\"\
    \");\n    for i in 0..(len / 2) - 1{\n        s = s.as_bytes().swap_remove(i);\n\
    \    }\n\n    text == s\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_remove` found for reference `&[u8]`\
    \ in the current scope\n  --> /tmp/tmpmdebnou_.rs:19:26\n   |\n19 |         s\
    \ = s.as_bytes().swap_remove(i);\n   |                          ^^^^^^^^^^^ method\
    \ not found in `&[u8]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text;\n    let mut t = text;\n\n    while t != s.rev()\
    \ {\n        s = t.rev();\n        t = s;\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp2nqy19nb.rs:14:18\n\
    \    |\n14  |       while t != s.rev() {\n    |                    ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp2nqy19nb.rs:15:15\n    |\n15  |         \
    \  s = t.rev();\n    |                 ^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    let mut i = 0;\n    while\
    \ i < text.len() {\n        if text[i] != text[text.len() - 1 - i] {\n       \
    \     return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq9k539np.rs:14:12\n\
    \   |\n14 |         if text[i] != text[text.len() - 1 - i] {\n   |           \
    \ ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq9k539np.rs:14:23\n   |\n14 |         if text[i] != text[text.len()\
    \ - 1 - i] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_lowercase();\n\n    if text.len() == 1\
    \ {\n        return true;\n    }\n\n    let mut reversed_text = String::new();\n\
    \    let mut itr = text.chars().cloned().rev().take(text.len() - 1).collect();\n\
    \n    for &i in itr {\n        reversed_text.push(i);\n    }\n\n    return text\
    \ == reversed_text;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpom9r4cba.rs:18:32\n     |\n18   |     let mut itr = text.chars().cloned().rev().take(text.len()\
    \ - 1).collect();\n     |                                ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `rev` exists for struct `Cloned<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpom9r4cba.rs:18:41\n   |\n18 |       let mut\
    \ itr = text.chars().cloned().rev().take(text.len() - 1).collect();\n   |    \
    \                                       ^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed = text.chars()\n        .skip_while(|x| x ==\
    \ ' ' || x == '\\t')\n        .collect::<Vec<Char>>()\n        .into_iter().rev();\n\
    \    text.chars().for_each(|x| {\n        reversed.next().unwrap().unwrap() ==\
    \ x\n    });\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpxwbskb80.rs:13:24\n\
    \   |\n13 |         .collect::<Vec<Char>>()\n   |                        ^^^^\n\
    \   |\nhelp: a builtin type with a similar name exists\n   |\n13 |         .collect::<Vec<char>>()\n\
    \   |                        ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n10 | fn is_palindrome<Char>(text: String) -> bool {\n   |             \
    \    ++++++\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxwbskb80.rs:12:27\n\
    \   |\n12 |         .skip_while(|x| x == ' ' || x == '\\t')\n   |            \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpxwbskb80.rs:12:39\n   |\n12 |         .skip_while(|x|\
    \ x == ' ' || x == '\\t')\n   |                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxwbskb80.rs:16:9\n   |\n16 |   \
    \      reversed.next().unwrap().unwrap() == x\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found `bool`\n   |\nhelp: you might have meant to return this\
    \ value\n   |\n16 |         return reversed.next().unwrap().unwrap() == x;\n \
    \  |         ++++++                                       +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0412.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut len = text.len();\n    let mid = len / 2;\n    let mid2\
    \ = len - mid;\n    let left = String::from(&text[..mid]);\n    let right = String::from(&text[mid..]);\n\
    \    left == right\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_qqdnak5.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut len = text.len();\n    let mut reversed = String::new();\n\
    \n    while len > 0 {\n        reversed.push(text[len - 1]);\n        len -= 1;\n\
    \    }\n\n    reversed == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplcvmk6db.rs:15:23\n\
    \   |\n15 |         reversed.push(text[len - 1]);\n   |                      \
    \ ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text == text.to_lowercase().rev() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp12rlyq3f.rs:11:36\n\
    \    |\n11  |       if text == text.to_lowercase().rev() {\n    |            \
    \                          ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut input = text;\n    let mut s = text.len();\n    while\
    \ s > 0 {\n        let c = input[s - 1];\n        input[s - 1] = (input[s] as\
    \ char).to_lowercase();\n        input[s] = (c as char).to_lowercase();\n    \
    \    s = s - 1;\n    }\n    input.is_palindrome()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn4dy8p_8.rs:14:17\n\
    \   |\n14 |         let c = input[s - 1];\n   |                 ^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn4dy8p_8.rs:15:9\n   |\n15 |         input[s - 1] = (input[s] as\
    \ char).to_lowercase();\n   |         ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn4dy8p_8.rs:15:25\n   |\n15 |         input[s - 1] = (input[s]\
    \ as char).to_lowercase();\n   |                         ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Rang"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let mut i = 0;\n    let mut j = len\
    \ as u8;\n    while (i < j / 2 && text[i] != text[j]) {\n        i += 1;\n   \
    \     j -= 1;\n    }\n    i == j\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgyy56clm.rs:14:11\n\
    \   |\n14 |     while (i < j / 2 && text[i] != text[j]) {\n   |           ^  \
    \                             ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n14 -     while (i < j / 2\
    \ && text[i] != text[j]) {\n14 +     while i < j / 2 && text[i] != text[j] {\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `u8`\n  --> /tmp/tmpgyy56clm.rs:14:25\n\
    \   |\n14 |     while (i < j / 2 && text[i] != text[j]) {\n   |              \
    \           ^^^^^^^ `String` cannot be indexed by `u8`\n   |\n   = help: the trait\
    \ `Index<u8>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `u8`\n  -->\
    \ /tmp/tmpgyy56clm.rs:14:36\n   |\n14 |     while (i < j / 2 && text[i] != text[j])\
    \ {\n   |                                    ^^^^^^^ `String` cannot be indexed\
    \ by `u8`\n   |\n   = help: the trait `Index<u8>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect()\n        .filter(|c| c != ' ' && c !=\
    \ '\\t')\n        .rev()\n        == text.chars().collect()\n        .filter(|c|\
    \ c != ' ' && c != '\\t')\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpvr4eil4w.rs:11:18\n\
    \   |\n11 |     text.chars().collect()\n   |                  ^^^^^^^ cannot infer\
    \ type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n11 |     text.chars().collect::<B>()\n\
    \   |                         +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut char_iter = text.char_indices();\n    let start = char_iter.next().unwrap();\n\
    \    if start == 0 {\n        return true;\n    }\n    let end = char_iter.next_back().unwrap();\n\
    \    if start > end {\n        return false;\n    }\n    start == end\n      \
    \  && char_iter.next().is_ok()\n        && char_iter.next_back().is_ok()\n   \
    \     && is_palindrome_aux(text.as_bytes(), start, end)\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome_aux` in this scope\n\
    \  --> /tmp/tmpp926ge4c.rs:23:12\n   |\n23 |         && is_palindrome_aux(text.as_bytes(),\
    \ start, end)\n   |            ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp926ge4c.rs:13:17\n   |\n13 |     if start ==\
    \ 0 {\n   |                 ^ expected tuple, found integer\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n               found type `{integer}`\n\nerror[E0599]:\
    \ no method named `is_ok` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpp926ge4c.rs:21:29\n   |\n21 |         && char_iter.next().is_ok()\n\
    \   |                             ^^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0599]: no method named `is_ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpp926ge4c.rs:22:34\n   |\n22 |         && char_iter.next_back().is_ok()\n\
    \   |                                  ^^^^^ method not found in `Option<(usize,\
    \ char)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n    for i in\
    \ 0..text.len() {\n        let reversed_text = text.rev();\n        if text !=\
    \ reversed_text {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp3v2q2b7b.rs:15:34\n\
    \    |\n15  |           let reversed_text = text.rev();\n    |               \
    \                     ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed = String::new();\n\n    for ch in text.chars()\
    \ {\n        reversed.push_str(&ch.to_string() + reversed);\n    }\n\n    text\
    \ == reversed\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `String` to `&String`\n  --> /tmp/tmp1qe4msdm.rs:14:43\n\
    \   |\n14 |         reversed.push_str(&ch.to_string() + reversed);\n   |     \
    \                      --------------- ^ -------- String\n   |               \
    \            |               |\n   |                           |             \
    \  `+` cannot be used to concatenate a `&str` with a `String`\n   |          \
    \                 &String\n   |\nhelp: remove the borrow on the left and add one\
    \ on the right\n   |\n14 -         reversed.push_str(&ch.to_string() + reversed);\n\
    14 +         reversed.push_str(ch.to_string() + &reversed);\n   | \n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.char_indices();\n    let mut len = it.len();\n\
    \    let mut i = 0;\n    let mut j = len - 1;\n    while i != j {\n        let\
    \ mut first = it.next().unwrap();\n        let mut last = it.next().unwrap();\n\
    \        if *first != *last {\n            return false;\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmph0az1c1b.rs:12:22\n   |\n12 |     let mut len =\
    \ it.len();\n   |                      ^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmph0az1c1b.rs:18:12\n\
    \   |\n18 |         if *first != *last {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmph0az1c1b.rs:18:22\n\
    \   |\n18 |         if *first != *last {\n   |                      ^^^^^\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.is_empty() {\n        return true;\n    }\n    let text_len\
    \ = text.len();\n    let text_len = text_len as usize;\n    let mut i = 0;\n \
    \   let mut j = text_len as usize;\n\n    for _ in 0..text_len {\n        if i\
    \ >= text_len {\n            return false;\n        }\n        if j >= text_len\
    \ {\n            break;\n        }\n        if text[i] != text[j] {\n        \
    \    return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppon2log8.rs:26:12\n\
    \   |\n26 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppon2log8.rs:26:23\n   |\n26 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_string();\n    text.chars()\n        .chain(text.chars().enumerate())\
    \ // We are going to iterate over each character in given string\n        .filter(|(_,\
    \ char)| char == char.to_string()[..]) // And filter out non-letters\n       \
    \ .filter(|(_, char)| char == 'a' || char == 'z' || char == 'A' || char == 'Z')\
    \ // And filter out non-capital letters\n        .map(|(_, char)| char.to_string()[..])\
    \ // And convert each character to a string\n        .rev()\n        .is_subset(text.chars().map(|c|\
    \ c.to_string()).rev())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Enumerate<Chars<'_>> as IntoIterator>::Item\
    \ == char`\n   --> /tmp/tmp9kicp664.rs:13:10\n    |\n13  |         .chain(text.chars().enumerate())\
    \ // We are going to iterate over each character in given string\n    |      \
    \    ^^^^^ expected `char`, found tuple\n    |\n    = note: expected type `char`\n\
    \              found tuple `(usize, char)`\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0599]: the method `filter` exists for struct `std::iter::Chain<Chars<'_>,\
    \ Enumerate<Chars<'_>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp9kicp664.rs:14:10\n\
    \   |\n14 |           .filter(|(_, char)| char == char.to_string()[..]) // And\
    \ filter out non-letters\n   |            ^^^^^^ method cannot be called on `std::iter::Chain<Chars<'_>,\
    \ Enumerate<Chars<'_>>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Enumerate<Chars<'_>>\
    \ as Iterator>::Item = char`\n           which is required by `std::iter::Chain<Chars<'_>,\
    \ Enumerate<Chars<'_>>>: Iterator`\n           `std::iter::Chain<Chars<'_>, Enumerate<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut std::iter::Chain<Chars<'_>,\
    \ Enumerate<Chars<'_>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed_text = text.to_owned();\n    reversed_text.reverse();\n\
    \    text == reversed_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdsc7ihyy.rs:12:19\n   |\n12 |     reversed_text.reverse();\n\
    \   |                   ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_lowercase();\n    s.reverse();\n    s ==\
    \ text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpzjhvancg.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars()).all(|(a, b)| a == b)\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd8tylsap.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed_text = text;\n    reversed_text.chars().for_each(|c|\
    \ {\n        *reversed_text.mutable_str() = c;\n        reversed_text.reverse_mut();\n\
    \    });\n    text == reversed_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `mutable_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpnivl4nq9.rs:13:24\n   |\n13 |         *reversed_text.mutable_str()\
    \ = c;\n   |                        ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `reverse_mut` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnivl4nq9.rs:14:23\n   |\n14 |         reversed_text.reverse_mut();\n\
    \   |                       ^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut str_to_reverse: Vec<String> = Vec::new();\n    for i\
    \ in text.chars().cloned() {\n        str_to_reverse.push(i);\n    }\n    str_to_reverse.reverse();\n\
    \    text.chars().zip(str_to_reverse).all(|(a, b)| a == b)\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpd0sdpq_i.rs:12:27\n     |\n12   |     for i in text.chars().cloned()\
    \ {\n     |                           ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpd0sdpq_i.rs:12:14\n\
    \   |\n12 |     for i in text.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpd0sdpq_i.rs:12:14\n   |\n12 |     for i in text.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd0sdpq_i.rs:16:56\n   |\n16 |\
    \     text.chars().zip(str_to_reverse).all(|(a, b)| a == b)\n   |            \
    \                                            ^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = text.len();\n    let mut right = text.len();\n\
    \    while left > 0 {\n        if left > right {\n            return false;\n\
    \        }\n        let mut mid = (left + right) / 2;\n        let mut i = 0;\n\
    \        let mut j = 0;\n        while i < mid && j < mid {\n            if text[i]\
    \ != text[j] {\n                break;\n            }\n            i += 1;\n \
    \           j += 1;\n        }\n        if i == mid {\n            left -= 1;\n\
    \        } else {\n            right -= 1;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_tvz485.rs:21:16\n\
    \   |\n21 |             if text[i] != text[j] {\n   |                ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_tvz485.rs:21:27\n   |\n21 |             if text[i] != text[j]\
    \ {\n   |                           ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.char_indices().rev();\n    let mut left =\
    \ 0;\n    let mut right = text.len();\n    while left < right {\n        if iter\n\
    \            .next()\n            .unwrap()\n            .unwrap()\n         \
    \   != text\n            .chars()\n            .nth(left)\n            .unwrap()\n\
    \            .unwrap()\n        {\n            left++;\n        } else {\n   \
    \         right--;\n        }\n    }\n    left == right\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpz_96biz4.rs:25:17\n\
    \   |\n25 |             left++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp = left; left\
    \ += 1; tmp };\n   |             +++++++++++     ~~~~~~~~~~~~~~~~~~\n25 -    \
    \         left++;\n25 +             left += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpz_96biz4.rs:27:20\n   |\n27 |             right--;\n\
    \   |                    ^ expected expression\n\nerror[E0599]: no method named\
    \ `unwrap` found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpz_96biz4.rs:18:14\n\
    \   |\n18 |             .unwrap()\n   |              ^^^^^^ method not found in\
    \ `(usize, char)`\n\nerror[E0599]: no method named `unwrap` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpz_96biz4.rs:23:14\n   |\n23 |          \
    \   .unwrap()\n   |              ^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut temp = text;\n    let mut len = text.length();\n\n  \
    \  while len > 0 {\n        if temp[0] == temp[len] {\n            temp.remove(..(len\
    \ - 1));\n            len -= 1;\n        } else {\n            len -= 1;\n   \
    \     }\n    }\n\n    text == temp\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpn3eg8xvs.rs:12:24\n   |\n12 |     let mut len =\
    \ text.length();\n   |                        ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmpn3eg8xvs.rs:15:12\n   |\n15 |     \
    \    if temp[0] == temp[len] {\n   |            ^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3eg8xvs.rs:16:25\n\
    \   |\n16 |             temp.remove(..(len - 1));\n   |                      \
    \   ^^^^^^^^^^^ expected `usize`, found struct `RangeTo`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `RangeTo<_>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars().collect::<String>();\n    let reverse\
    \ = chars.iter().cloned().collect::<String>().reverse();\n\n    chars.iter().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n        && chars.iter().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n        && chars.iter().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n        && chars.iter().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdfp2k2ox.rs:12:25\n   |\n12 |     let reverse = chars.iter().cloned().collect::<String>().reverse();\n\
    \   |                         ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n12 |     let reverse = chars.chars().cloned().collect::<String>().reverse();\n\
    \   |                         ~~~~~\n\nerror[E0599]: no method named `iter` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpdfp2k2ox.rs:14:11\n\
    \   |\n14 |     chars.iter().zip(chars.iter().cloned()).all(|(char1, char2)| char1\
    \ == char2)\n   |           ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n14 |     chars.chars().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n   |           ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n  --> /tmp/tmpdfp2k2ox.rs:14:28\n\
    \   |\n14 |     chars.iter().zip(chars.iter().cloned()).all(|(char1, char2)| char1\
    \ == char2)\n   |                            ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n14 |     chars.iter().zip(chars.chars().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n   |                            ~~~~~\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpdfp2k2ox.rs:15:18\n   |\n15 |         && chars.iter().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)\n   |                  ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n15 |         && chars.chars().zip(chars.iter().cloned()).all(|(char1,\
    \ char2)| char1 == char2)"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reverse_text = text.to_string().rev();\n    let mut ascii_text\
    \ = (&reverse_text).chars().collect::<Vec<_>>();\n\n    for (index, char) in ascii_text.iter().enumerate()\
    \ {\n        if char != ascii_text[index] {\n            return false;\n     \
    \   }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp1j4zbjm_.rs:11:45\n\
    \    |\n11  |       let mut reverse_text = text.to_string().rev();\n    |    \
    \                                           ^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = String::from(text);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        let reversed = s.chars().rev().nth(i).unwrap();\n        if c\
    \ != reversed {\n            return false;\n        }\n    });\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbygyhq0.rs:15:20\n   |\n\
    15 |             return false;\n   |                    ^^^^^ expected `()`, found\
    \ `bool`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.char_indices();\n    let mut left = iter.next();\n\
    \    let mut right = iter.next();\n    while let Ok(Some(left)) = left {\n   \
    \     right = iter.next();\n    }\n    while let Ok(Some(right)) = right {\n \
    \       if left != right {\n            return false;\n        }\n        left\
    \ = iter.next();\n        right = iter.next();\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiyy_fm3k.rs:14:15\n   |\n\
    14 |     while let Ok(Some(left)) = left {\n   |               ^^^^^^^^^^^^^^\
    \   ---- this expression has type `Option<(usize, char)>`\n   |              \
    \ |\n   |               expected enum `Option`, found enum `Result`\n   |\n  \
    \ = note: expected enum `Option<(usize, char)>`\n              found enum `Result<_,\
    \ _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiyy_fm3k.rs:17:15\n   |\n\
    17 |     while let Ok(Some(right)) = right {\n   |               ^^^^^^^^^^^^^^^\
    \   ----- this expression has type `Option<(usize, char)>`\n   |             \
    \  |\n   |               expected enum `Option`, found enum `Result`\n   |\n \
    \  = note: expected enum `Option<(usize, char)>`\n              found enum `Result<_,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Reverse string and compare equality with original string\n\
    \    text == text.chars()\n        .map(|c| c as char).rev()\n        .collect::<String>()\n\
    \        .join(\"\")\n        == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpo0vxx5ez.rs:12:10\n\
    \   |\n12 |     text == text.chars()\n   |          ^^\n...\n16 |         == text\n\
    \   |         ^^\n   |\nhelp: split the comparison into two\n   |\n15 ~      \
    \   .join(\"\") && text.chars()\n16 +         .map(|c| c as char).rev()\n17 +\
    \         .collect::<String>()\n18 +         .join(\"\")\n   |\n\nerror[E0599]:\
    \ no method named `join` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpo0vxx5ez.rs:15:10\n   |\n15 |         .join(\"\")\n   |          ^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo0vxx5ez.rs:16:12\n\
    \   |\n16 |         == text\n   |            ^^^^ expected `bool`, found struct\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_string();\n    let len = text.len();\n   \
    \ let mut left = 0;\n    let mut right = len - 1;\n    loop {\n        if left\
    \ + 1 < right {\n            if text.get(left) != text.get(right) {\n        \
    \        return false;\n            }\n            left += 1;\n            right\
    \ -= 1;\n        } else {\n            break;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmptzkblwqx.rs:17:25\n\
    \    |\n17  |             if text.get(left) != text.get(right) {\n    |      \
    \               --- ^^^^ string indices are ranges of `usize`\n    |         \
    \            |\n    |                     required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for\
    \ `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    note: required by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n   --> /tmp/tmptzkblwqx.rs:17:43\n\
    \    |\n17  |             if text.get(left) != text.get(right) {\n    |      \
    \                                 --- ^^^^^ string indices are ranges of `usize`\n\
    \    |                                       |\n    |                        \
    \               required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n    = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound\
    \ in `core::str::<impl str>::get`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(true, (result, _) -> result && text == String::from_utf8(text.to_utf8()).chars().collect::<String>().reverse().collect())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `->`\n\
    \  --> /tmp/tmpvldqlwll.rs:11:41\n   |\n11 |     text.chars().fold(true, (result,\
    \ _) -> result && text == String::from_utf8(text.to_utf8()).chars().collect::<String>().reverse().coll...\n\
    \   |                                         ^^ expected one of `)`, `,`, `.`,\
    \ `?`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // reverse the string and check if it's the same as it started\n\
    \    // if it's the same, the string is a palindrome\n    // if it's not the same,\
    \ then it's not a palindrome\n    // since strings are immutable, this is done\
    \ in place\n\n    let text_reversed = text.chars().collect::<String>().rev().collect();\n\
    \    text == text_reversed\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpscvx2vlr.rs:16:58\n\
    \    |\n16  |       let text_reversed = text.chars().collect::<String>().rev().collect();\n\
    \    |                                                            ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let s = text.to_lowercase();\n    let mut i = 0;\n    let mut\
    \ j = (s.len() - 1) as usize;\n    while i <= j {\n        if s[i] == s[j] {\n\
    \            i += 1;\n            j -= 1;\n        } else if s[j] > s[i] {\n \
    \           i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n\
    \    i == j\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm6atpkbu.rs:15:12\n\
    \   |\n15 |         if s[i] == s[j] {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm6atpkbu.rs:15:20\n   |\n15 |         if s[i] == s[j] {\n   | \
    \                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm6atpkbu.rs:18:19\n   |\n18 |         } else if s[j] > s[i] {\n\
    \   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut i = 0;\n    let mut\
    \ j = chars.len() - 1;\n    while i < j {\n        if chars.get(&mut i) != chars.get(&mut\
    \ j) {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpy59883gx.rs:13:23\n   |\n13 |     let mut j = chars.len()\
    \ - 1;\n   |                       ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `get` found for struct `Chars` in the current scope\n  --> /tmp/tmpy59883gx.rs:15:18\n\
    \   |\n15 |         if chars.get(&mut i) != chars.get(&mut j) {\n   |        \
    \          ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `get` found for struct `Chars` in the current scope\n  --> /tmp/tmpy59883gx.rs:15:39\n\
    \   |\n15 |         if chars.get(&mut i) != chars.get(&mut j) {\n   |        \
    \                               ^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect::<Vec<char>>().iter()\n        .cloned()\n\
    \        .reverse()\n        .eq(&text)\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmphiqkl5cd.rs:13:10\n   |\n13 |         .reverse()\n\
    \   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, char>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        true\n    } else {\n        text.chars().zip(text.chars()).all(|(a,\
    \ b)| a == b)\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8aylhqy8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(false, |state, c| state && c != c.rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpolrdup5b.rs:11:57\n\
    \   |\n11 |     text.chars().fold(false, |state, c| state && c != c.rev())\n \
    \  |                                                         ^^^ `char` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `char: Iterator`\n           which is required by `&mut char: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    (text.chars().collect::<Vec<_>>())\n        .iter()\n       \
    \ .rev()\n        == text.chars()\n            .collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Rev<std::slice::Iter<'_,\
    \ char>>`\n  --> /tmp/tmpb3vi31kj.rs:14:9\n   |\n11 | /     (text.chars().collect::<Vec<_>>())\n\
    12 | |         .iter()\n13 | |         .rev()\n   | |______________- Rev<std::slice::Iter<'_,\
    \ char>>\n14 |           == text.chars()\n   |  _________^^_-\n15 | |        \
    \     .collect::<Vec<_>>()\n   | |________________________________- Vec<char>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_lowercase();\n    s = s.chars().collect::<Vec<char>>();\n\
    \    s = s.iter().cloned().collect::<Vec<_>>();\n    s = s.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    s == s.iter().cloned().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3w_9e54k.rs:12:9\n   |\n\
    11 |     let mut s = text.to_lowercase();\n   |                 -------------------\
    \ expected due to this value\n12 |     s = s.chars().collect::<Vec<char>>();\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `String`\n              found\
    \ struct `Vec<char>`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp3w_9e54k.rs:13:11\n   |\n13 | \
    \    s = s.iter().cloned().collect::<Vec<_>>();\n   |           ^^^^ method not\
    \ found in `String`\n   |\nhelp: because of the in-memory representation of `&str`,\
    \ to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n\
    13 |     s = s.chars().cloned().collect::<Vec<_>>();\n   |           ~~~~~\n\n\
    error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp3w_9e54k.rs:14:11\n   |\n14 |     s = s.iter().cloned().rev().collect::<Vec<_>>();\n\
    \   |           ^^^^ method not found in `String`\n   |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n   |\n14 |     s = s.chars().cloned().rev().collect::<Vec<_>>();\n\
    \   |           ~~~~~\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp3w_9e54k.rs:15:12\n   |\n15 | \
    \    s == s.iter().cloned().collect::<Vec<_>>()\n   |            ^^^^ method not\
    \ found in `String`\n   |\nhelp: because of the in-memory representation of `&str`,\
    \ to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n\
    15 |     s == s.chars().cloned().collect::<Vec<_>>()\n   |            ~~~~~\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    (text.as_bytes())\n        .into_iter()\n        .rev()\n   \
    \     .eq_bytes()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `eq_bytes` found for struct `Rev` in the\
    \ current scope\n  --> /tmp/tmp9cfhvo1y.rs:14:10\n   |\n14 |         .eq_bytes()\n\
    \   |          ^^^^^^^^ method not found in `Rev<std::slice::Iter<'_, u8>>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut i = 0;\n    let mut j = text.len() - 1;\n    while i\
    \ <= j {\n        if text[i] != text[j] {\n            break;\n        }\n   \
    \     i += 1;\n        j -= 1;\n    }\n    i == j\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8cm7fy7u.rs:14:12\n\
    \   |\n14 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8cm7fy7u.rs:14:23\n   |\n14 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Convert text to lower case\n    let lower = text\n       \
    \ .chars()\n        .map(|c| c.to_lowercase())\n        .collect::<Vec<_>>();\n\
    \n    // Reverse text and compare\n    text\n        .chars()\n        .rev()\n\
    \        .eq(&lower)\n        .unwrap_or(false)\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<&Vec<ToLowercase> as IntoIterator>::Item\
    \ == char`\n  --> /tmp/tmpcn3bk9rr.rs:21:10\n   |\n21 |         .eq(&lower)\n\
    \   |          ^^ expected `&ToLowercase`, found `char`\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for type `bool` in the current scope\n  --> /tmp/tmpcn3bk9rr.rs:22:10\n\
    \   |\n22 |         .unwrap_or(false)\n   |          ^^^^^^^^^ method not found\
    \ in `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n    let mut\
    \ s = text;\n    s.pop();\n    s = s.chars().filter(|&c| c != 'z')\n        .map(|&c|\
    \ c + 'a')\n        .collect::<String>();\n    \n    let mut i = 0;\n    let mut\
    \ j = text.len() - 1;\n    let mut reversed = false;\n\n    while i < text.len()\
    \ {\n        if text[i] != text[j] {\n            break;\n        }\n        reversed\
    \ = reversed == true ? false : true;\n        i += 1;\n        j -= 1;\n    }\n\
    \    \n    reversed == true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `false`\n  --> /tmp/tmplsalloxw.rs:28:39\n   |\n28 |         reversed = reversed\
    \ == true ? false : true;\n   |                                       ^^^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplsalloxw.rs:17:15\n   |\n17 |         .map(|&c| c + 'a')\n   |\
    \               ^--\n   |               ||\n   |               |expected due to\
    \ this\n   |               expected `char`, found reference\n   |            \
    \   help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmplsalloxw.rs:25:12\n   |\n25 |         if text[i]\
    \ != text[j] {\n   |            ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplsalloxw.rs:25:23\n   |\n25 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors ha"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text\n        .chars()\n        .filter(|c| c.is_ascii())\n \
    \       .fold(true, (!text.is_empty()) && (text.chars().windows(2).all(|c| c.is_ascii())))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpalajggsz.rs:14:57\n   |\n14 |         .fold(true,\
    \ (!text.is_empty()) && (text.chars().windows(2).all(|c| c.is_ascii())))\n   |\
    \                                                         ^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0277]: expected a `FnMut<(bool, char)>` closure, found\
    \ `bool`\n    --> /tmp/tmpalajggsz.rs:14:10\n     |\n14   |         .fold(true,\
    \ (!text.is_empty()) && (text.chars().windows(2).all(|c| c.is_ascii())))\n   \
    \  |          ^^^^ expected an `FnMut<(bool, char)>` closure, found `bool`\n \
    \    |\n     = help: the trait `FnMut<(bool, char)>` is not implemented for `bool`\n\
    note: required by a bound in `fold`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect::<Vec<char>>().into_iter().rev() == text.chars().collect::<Vec<char>>().into_iter()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Rev<std::vec::IntoIter<char>>`\n\
    \  --> /tmp/tmpxx35yrnc.rs:11:59\n   |\n11 |     text.chars().collect::<Vec<char>>().into_iter().rev()\
    \ == text.chars().collect::<Vec<char>>().into_iter()\n   |     -----------------------------------------------------\
    \ ^^ ----------------------------------------------- std::vec::IntoIter<char>\n\
    \   |     |\n   |     Rev<std::vec::IntoIter<char>>\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed: Vec<u8> = vec![];\n    for (i, &c) in text.chars().enumerate()\
    \ {\n        reversed.push(c);\n        if i >= text.len() / 2 {\n           \
    \ if reversed.iter().any(|c| c != c) {\n                return false;\n      \
    \      }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn3moa0ke.rs:12:13\n   |\n\
    12 |     for (i, &c) in text.chars().enumerate() {\n   |             ^^     ------------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.char_indices().rev();\n    loop {\n     \
    \   let (idx, val) = iter.next().unwrap();\n        if val != text[idx - 1] {\n\
    \            break;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm6rmxhrh.rs:14:19\n\
    \   |\n14 |         if val != text[idx - 1] {\n   |                   ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text).fold(false, |b, a| b && (a == a.reverse()))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmphiadw0n9.rs:11:22\n\
    \   |\n11 |     text.chars().zip(text).fold(false, |b, a| b && (a == a.reverse()))\n\
    \   |                  --- ^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |                  |\n   |                  required by a\
    \ bound introduced by this call\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0599]: the method `fold` exists\
    \ for struct `Zip<Chars<'_>, String>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmphiadw0n9.rs:11:28\n    |\n11  |       text.chars().zip(text).fold(false,\
    \ |b, a| b && (a == a.reverse()))\n    |                              ^^^^ method\
    \ cannot be called on `Zip<Chars<'_>, String>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `Zip<Chars<'_>, String>:\
    \ Iterator`\n            `Zip<Chars<'_>, String>: Iterator`\n            which\
    \ is required by `&mut Zip<Chars<'_>, String>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.is_empty() {\n        return true;\n    }\n\n    let\
    \ mut text_reversed = String::new();\n    let mut cursor = text.len() - 1;\n \
    \   while cursor >= 0 {\n        text_reversed.push_str(&text[cursor]);\n    \
    \    cursor -= 1;\n    }\n    text_reversed == text\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppb_5yugm.rs:18:33\n\
    \   |\n18 |         text_reversed.push_str(&text[cursor]);\n   |             \
    \                    ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .skip_while(|c| !c.is_ascii_letter())\n\
    \        .windows(2)\n        .all(|w| w.chars().all(|c| c.to_ascii_lowercase().cmp(&c.to_ascii_lowercase())\
    \ == -1))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp6g88fnjo.rs:12:28\n   |\n12 |         .skip_while(|c|\
    \ !c.is_ascii_letter())\n   |                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `windows` found for struct `SkipWhile` in the current scope\n\
    \  --> /tmp/tmp6g88fnjo.rs:13:10\n   |\n13 |         .windows(2)\n   |       \
    \   ^^^^^^^ method not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmp6g88fnjo.rs:12:21:\
    \ 12:45]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase()\n        .reverse()\n        .eq(&text.to_lowercase())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpc8zhsp2h.rs:12:10\n   |\n12 |         .reverse()\n\
    \   |          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s: String = text;\n    s.reverse();\n    s == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplvh4tz08.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ it = (0..text.len()).rev();\n    let first = it.next();\n    let second = it.next();\n\
    \n    while first.peek().unwrap() == second.peek().unwrap() {\n        first =\
    \ it.next();\n        second = it.next();\n    }\n    first.peek().unwrap() ==\
    \ second.peek().unwrap()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `peek` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp4ux5xqrp.rs:18:17\n   |\n18 |     while first.peek().unwrap()\
    \ == second.peek().unwrap() {\n   |                 ^^^^ method not found in `Option<usize>`\n\
    \nerror[E0599]: no method named `peek` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp4ux5xqrp.rs:18:43\n   |\n18 |     while first.peek().unwrap()\
    \ == second.peek().unwrap() {\n   |                                          \
    \ ^^^^ method not found in `Option<usize>`\n\nerror[E0599]: no method named `peek`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp4ux5xqrp.rs:22:11\n\
    \   |\n22 |     first.peek().unwrap() == second.peek().unwrap()\n   |        \
    \   ^^^^ method not found in `Option<usize>`\n\nerror[E0599]: no method named\
    \ `peek` found for enum `Option` in the current scope\n  --> /tmp/tmp4ux5xqrp.rs:22:37\n\
    \   |\n22 |     first.peek().unwrap() == second.peek().unwrap()\n   |        \
    \                             ^^^^ method not found in `Option<usize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let s = text.to_string();\n    s.chars().cloned().reverse().collect::<Vec<char>>()\
    \ == s\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpnj94ohur.rs:12:15\n     |\n12   |     s.chars().cloned().reverse().collect::<Vec<char>>()\
    \ == s\n     |               ^^^^^^ expected reference, found `char`\n     |\n\
    \     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpnj94ohur.rs:12:24\n\
    \   |\n12 |     s.chars().cloned().reverse().collect::<Vec<char>>() == s\n   |\
    \                        ^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut index = 0;\n    let mut temp = text[index];\n    while\
    \ index < text.len() - 1 {\n        if temp != text[index + 1] {\n           \
    \ return false;\n        }\n        temp /= 10;\n        index += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpa2hy1yrx.rs:12:20\n   |\n12 |     let mut temp = text[index];\n   |\
    \                    ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa2hy1yrx.rs:14:20\n   |\n14 |         if temp != text[index + 1]\
    \ {\n   |                    ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text\n        .chars()\n        .filter(|x| x != ' ')\n     \
    \   .fold(false, |acc, c| acc && c == text[text.len() - 1 - acc.len()])\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp708igqua.rs:13:23\n\
    \   |\n13 |         .filter(|x| x != ' ')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `len` found for type `bool` in the current scope\n\
    \  --> /tmp/tmp708igqua.rs:14:69\n   |\n14 |         .fold(false, |acc, c| acc\
    \ && c == text[text.len() - 1 - acc.len()])\n   |                            \
    \                                         ^^^ method not found in `bool`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp708igqua.rs:14:43\n\
    \   |\n14 |         .fold(false, |acc, c| acc && c == text[text.len() - 1 - acc.len()])\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    for i in 0..len / 2 {\n        if\
    \ text[i] != text[(len - 1) - i] {\n            return false;\n        }\n   \
    \ }\n    return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqh1507bc.rs:13:12\n\
    \   |\n13 |         if text[i] != text[(len - 1) - i] {\n   |            ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqh1507bc.rs:13:23\n   |\n13 |         if text[i] != text[(len -\
    \ 1) - i] {\n   |                       ^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    text.pop_back();\n    text.pop_back();\n\
    \    text == text\n        .reverse()\n        .into_iter()\n        .collect()\n\
    \        .is_ok()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop_back` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8sicqgg7.rs:12:10\n   |\n12 |     text.pop_back();\n\
    \   |          ^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `pop_back` found for struct `String` in the current scope\n  --> /tmp/tmp8sicqgg7.rs:13:10\n\
    \   |\n13 |     text.pop_back();\n   |          ^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8sicqgg7.rs:15:10\n   |\n15 |         .reverse()\n   |\
    \          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase()\n        .remove('a')\n        .remove('z')\n\
    \        .remove('a')\n        .remove('z')\n        .is_palindrome()\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2lhl41z.rs:12:17\n   |\n\
    12 |         .remove('a')\n   |                 ^^^ expected `usize`, found `char`\n\
    \nerror[E0599]: no method named `remove` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpk2lhl41z.rs:13:10\n   |\n13 |         .remove('z')\n  \
    \ |          ^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n    let first_char\
    \ = text.get(0).unwrap().to_string();\n    let second_char = text.get(1).unwrap().to_string();\n\
    \    if first_char == second_char {\n        return is_palindrome(&text[2..]);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpmszfhwf7.rs:14:31\n\
    \    |\n14  |     let first_char = text.get(0).unwrap().to_string();\n    |  \
    \                         --- ^ string indices are ranges of `usize`\n    |  \
    \                         |\n    |                           required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not\
    \ implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `{integer}`\n   --> /tmp/tmpmszfhwf7.rs:15:32\n    |\n15  |  \
    \   let second_char = text.get(1).unwrap().to_string();\n    |               \
    \             --- ^ string indices are ranges of `usize`\n    |              \
    \              |\n    |                            required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmszfhwf7.rs:17:30\n   |\n17 |         return is_palindrome(&text[2..]);\n\
    \   |                              ^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n17 |         return\
    \ is_palindrome((&text[2..]).to_string());\n   |                             \
    \ +          +++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().count() == text.chars().rcount().reverse().count()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rcount` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp25b3_k1k.rs:11:42\n   |\n11 |     text.chars().count()\
    \ == text.chars().rcount().reverse().count()\n   |                           \
    \               ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().skip(1)).all(|(a, b)| a == b)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphh2vdcxt.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    (text.to_lowercase().chars()\n        .rev()\n        .eq(&text.to_lowercase().chars())\n\
    \        .cloned()\n        .chain(text)\n        .collect::<Vec<_>>())\n    \
    \    .all(|b| *b == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpin1rkqy5.rs:13:13\n\
    \   |\n13 |         .eq(&text.to_lowercase().chars())\n   |          -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&Chars<'_>` is not an iterator\n   |          |\n   |          required by\
    \ a bound introduced by this call\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `&Chars<'_>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&Chars<'_>`\nhelp: consider dereferencing\
    \ here\n   |\n13 |         .eq(*&text.to_lowercase().chars())\n   |          \
    \   +\nhelp: consider removing the leading `&`-reference\n   |\n13 -         .eq(&text.to_lowercase().chars())\n\
    13 +         .eq(text.to_lowercase().chars())\n   | \nhelp: consider changing\
    \ this borrow's mutability\n   |\n13 |         .eq(&mut text.to_lowercase().chars())\n\
    \   |             ~~~~\n\nerror[E0599]: `bool` is not an iterator\n  --> /tmp/tmpin1rkqy5.rs:14:10\n\
    \   |\n14 |         .cloned()\n   |          ^^^^^^ `bool` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ Iterator`\n           which is required by `&mut bool: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().next().unwrap() == text.chars().last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpl1n2q02q.rs:11:25\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // reverse text\n    let mut reversed_text = text.rev();\n\n\
    \    // check if text is the same as the reversed_text\n    reversed_text == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpj0ehk9td.rs:12:34\n\
    \    |\n12  |       let mut reversed_text = text.rev();\n    |               \
    \                     ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        return true;\n    }\n    let (left,\
    \ right) = (0, text.len());\n    while left < right {\n        if text[left] !=\
    \ text[right - 1] {\n            return false;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpexvjvhzi.rs:16:12\n\
    \   |\n16 |         if text[left] != text[right - 1] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpexvjvhzi.rs:16:26\n   |\n16 |         if text[left] != text[right\
    \ - 1] {\n   |                          ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .chain(text.chars().skip_while(|c| !c.is_ascii()))\n\
    \        .take(text.len() / 2)\n        .rev()\n        .is_eq(&text[0..text.len()\
    \ / 2])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `std::iter::Chain<Chars<'_>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp9ot53eb3.rs:12:40: 12:57]>>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp9ot53eb3.rs:14:10\n     |\n14   |         .rev()\n     |    \
    \      ^^^ the trait `ExactSizeIterator` is not implemented for `std::iter::Chain<Chars<'_>,\
    \ SkipWhile<Chars<'_>, [closure@/tmp/tmp9ot53eb3.rs:12:40: 12:57]>>`\n     |\n\
    \     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `std::iter::Take<std::iter::Chain<Chars<'_>,\
    \ SkipWhile<Chars<'_>, [closure@/tmp/tmp9ot53eb3.rs:12:40: 12:57]>>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `SkipWhile<Chars<'_>, [closure@/tmp/tmp9ot53eb3.rs:12:40:\
    \ 12:57]>: DoubleEndedIterator` is not satisfied\n    --> /tmp/tmp9ot53eb3.rs:14:10\n\
    \     |\n14   |         .rev()\n     |          ^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `SkipWhile<Chars<'_>, [closure@/tmp/tmp9ot53eb3.rs:12:40:\
    \ 12:57]>`\n     |\n     = help: the trait `DoubleEndedIterator` is implemented\
    \ for `std::iter::Take<I>`\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `std::iter::Chain<Chars<'_>, SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp9ot53eb3.rs:12:40: 12:57]>>`\n     = note: 1 redundant requirement\
    \ hidden\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `std::iter::Take<std::iter::Chain<Chars<'_>, SkipWhile<Chars<'_>, [closure@/tmp/tmp9ot53eb3.rs:12:40:\
    \ 12:57]>>>`\nnote: required by a bound in `rev`\n\nerror[E0599]: no method named\
    \ `is_eq` found for struct `Rev` in the current scope\n  --> /tmp/tmp9ot53eb3.rs:15:10\n\
    \   |\n15 |         .is_eq(&text[0..text.len() / 2])\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.chars();\n    let mut end = it.next().unwrap().unwrap();\n\
    \    while end != it.next() {\n        end += 1;\n    }\n    let mut start = it.next().unwrap().unwrap();\n\
    \    while start != it.next() {\n        start += 1;\n    }\n    start == end\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpa1wi7cof.rs:12:38\n   |\n12 |     let mut end = it.next().unwrap().unwrap();\n\
    \   |                                      ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpa1wi7cof.rs:16:40\n   |\n16 |     let mut start = it.next().unwrap().unwrap();\n\
    \   |                                        ^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(true, (current, next) => {\n        return\
    \ current != next && current.to_string() == next.to_string();\n    })\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmptxip_h0d.rs:11:45\n   |\n11 |     text.chars().fold(true, (current,\
    \ next) => {\n   |                                             ^^ expected one\
    \ of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_string();\n    let len = s.len();\n    if\
    \ s.len() < 2 {\n        return true;\n    }\n    for i in 1..len - 1 {\n    \
    \    if s[i] != s[len - 1 - i] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnpqwgzon.rs:17:12\n\
    \   |\n17 |         if s[i] != s[len - 1 - i] {\n   |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnpqwgzon.rs:17:20\n   |\n17 |         if s[i] != s[len - 1 - i]\
    \ {\n   |                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed_text = text.clone();\n    reversed_text.chars().skip_while(\
    \ |c| c != 'a' ).take_while( |c| c != 'z').for_each(|c| {\n        reversed_text.push(c);\n\
    \    });\n    reversed_text == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp33cptf15.rs:12:45\n\
    \   |\n12 |     reversed_text.chars().skip_while( |c| c != 'a' ).take_while( |c|\
    \ c != 'z').for_each(|c| {\n   |                                             ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp33cptf15.rs:12:72\n\
    \   |\n12 |     reversed_text.chars().skip_while( |c| c != 'a' ).take_while( |c|\
    \ c != 'z').for_each(|c| {\n   |                                             \
    \                           ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text;\n\n    let rev = text.chars().rev();\n \
    \   let first = text.chars().next();\n    let second = rev.next();\n\n    second.unwrap()\n\
    \        == first.unwrap()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp07aw1lj4.rs:11:9\n\
    \   |\n11 |     let mut text = text;\n   |         ----^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `rev` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp07aw1lj4.rs:15:18\n   |\n13 |     let rev\
    \ = text.chars().rev();\n   |         --- help: consider changing this to be mutable:\
    \ `mut rev`\n14 |     let first = text.chars().next();\n15 |     let second =\
    \ rev.next();\n   |                  ^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    if len <= 1 {\n        return true;\n\
    \    }\n    for i in 0..len {\n        let (left, right) = text.split_at(i);\n\
    \        if left != right {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgrvz0j1_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut i = 0;\n    let mut j = text.len() - 1;\n\n    while\
    \ i >= 0 || j >= 0 {\n        if i < 0 {\n            i += 1;\n        } else\
    \ if j < 0 {\n            j -= 1;\n        }\n\n        if text[i] != text[j]\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpg7mc532z.rs:21:12\n   |\n21 |         if text[i] != text[j] {\n   |\
    \            ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg7mc532z.rs:21:23\n\
    \   |\n21 |         if text[i] != text[j] {\n   |                       ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut len = text.len();\n    loop {\n        let mid = len\
    \ / 2;\n        if mid < 0 {\n            return false;\n        }\n        if\
    \ text.get(mid) != text.get(len - mid - 1) {\n            return false;\n    \
    \    }\n        len = mid - 1;\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmp4uy81qwb.rs:17:21\n\
    \    |\n17  |         if text.get(mid) != text.get(len - mid - 1) {\n    |   \
    \              --- ^^^ string indices are ranges of `usize`\n    |           \
    \      |\n    |                 required by a bound introduced by this call\n\
    \    |\n    = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `usize`\n   --> /tmp/tmp4uy81qwb.rs:17:38\n    |\n17  |      \
    \   if text.get(mid) != text.get(len - mid - 1) {\n    |                     \
    \             --- ^^^^^^^^^^^^^ string indices are ranges of `usize`\n    |  \
    \                                |\n    |                                  required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .map(|c| match c {\n            'a' | ('B'..'Z').contains(c)\
    \ => c as char,\n            'a' => 0,\n            _ => c as char\n        })\n\
    \        .windows(2)\n        .all(|(a, b)| a == b)\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `if`, or `|`, found `.`\n  --> /tmp/tmpiip05vx4.rs:13:29\n\
    \   |\n13 |             'a' | ('B'..'Z').contains(c) => c as char,\n   |     \
    \                        ^ expected one of `=>`, `if`, or `|`\n\nerror[E0599]:\
    \ no method named `windows` found for struct `Map` in the current scope\n  -->\
    \ /tmp/tmpiip05vx4.rs:17:10\n   |\n17 |         .windows(2)\n   |          ^^^^^^^\
    \ method not found in `Map<Chars<'_>, [closure@/tmp/tmpiip05vx4.rs:12:14: 16:10]>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rposition(|char| char == char).is_some()\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp7l635405.rs:11:18\n     |\n11   |     text.chars().rposition(|char|\
    \ char == char).is_some()\n     |                  ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    (text + 'a').chars().take(text.len() / 2).as_str() == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjvq92vt8.rs:11:13\n   |\n\
    11 |     (text + 'a').chars().take(text.len() / 2).as_str() == text\n   |    \
    \         ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n11 |     (text + \"a\").chars().take(text.len()\
    \ / 2).as_str() == text\n   |             ~~~\n\nerror[E0599]: no method named\
    \ `as_str` found for struct `std::iter::Take` in the current scope\n  --> /tmp/tmpjvq92vt8.rs:11:47\n\
    \   |\n11 |     (text + 'a').chars().take(text.len() / 2).as_str() == text\n \
    \  |                                               ^^^^^^ method not found in\
    \ `std::iter::Take<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    std::mem::swap(&mut text,\
    \ &mut text[text.len()..]);\n    text == text[0..text.len() / 2]\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9463x43.rs:12:31\n   |\n\
    12 |     std::mem::swap(&mut text, &mut text[text.len()..]);\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `str`\n\
    \   |\n   = note: expected mutable reference `&mut String`\n              found\
    \ mutable reference `&mut str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all(|c| {\n        c != text.chars().last().unwrap()\n\
    \    })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5n50mwpi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut buffer = String::new();\n    text.chars().for_each(|c|\
    \ buffer.push_str(&format!(\"{}\", c)));\n    let mut text2 = buffer;\n    text2.reverse();\n\
    \    text2.cmp(&text) == 0\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpn9zef8w1.rs:14:11\n   |\n14 |     text2.reverse();\n\
    \   |           ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9zef8w1.rs:15:25\n\
    \   |\n15 |     text2.cmp(&text) == 0\n   |                         ^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.chars();\n    let mut is_palindrome = true;\n\
    \n    while let Some(next_char) = (it.next(), it.next()) {\n        if *next_char\
    \ != *it {\n            is_palindrome = false;\n            break;\n        }\n\
    \    }\n    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2d294i_m.rs:14:15\n   |\n\
    14 |     while let Some(next_char) = (it.next(), it.next()) {\n   |          \
    \     ^^^^^^^^^^^^^^^   ---------------------- this expression has type `(Option<char>,\
    \ Option<char>)`\n   |               |\n   |               expected tuple, found\
    \ enum `Option`\n   |\n   = note: expected tuple `(Option<char>, Option<char>)`\n\
    \               found enum `Option<_>`\n\nerror[E0614]: type `Chars<'_>` cannot\
    \ be dereferenced\n  --> /tmp/tmp2d294i_m.rs:15:26\n   |\n15 |         if *next_char\
    \ != *it {\n   |                          ^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text;\n    let mut len = s.len();\n    let mut isPalindrome\
    \ = true;\n\n    while len >= 2 {\n        if s[len / 2 - 1] != s[len / 2]\n \
    \           || (s[len / 2] != s[len / 2 - 1])\n        {\n            isPalindrome\
    \ = false;\n            break;\n        }\n\n        len -= 1;\n    }\n\n    isPalindrome\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz37b0aj7.rs:16:12\n\
    \   |\n16 |         if s[len / 2 - 1] != s[len / 2]\n   |            ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz37b0aj7.rs:16:30\n   |\n16 |         if s[len / 2 - 1] != s[len\
    \ / 2]\n   |                              ^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz37b0aj7.rs:17:17\n   |\n17 |             || (s[len / 2] != s[len\
    \ / 2 - 1])\n   |                 ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // empty string is a palindrome\n    if text.is_empty() {\n \
    \       return true;\n    }\n\n    // if the string is not of same length\n  \
    \  if text.len() != text.chars().count() {\n        return false;\n    }\n\n \
    \   // convert string into char array\n    let char_array = text.chars().collect::<Vec<char>>();\n\
    \    let char_array_reversed = char_array.reverse();\n\n    // return true only\
    \ if they are equal or not\n    char_array == char_array_reversed\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<char>` with `()`\n  --> /tmp/tmpoi76b307.rs:26:16\n\
    \   |\n26 |     char_array == char_array_reversed\n   |                ^^ no implementation\
    \ for `Vec<char> == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented\
    \ for `Vec<char>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let length = text.len();\n\n    if length <= 1 {\n        return\
    \ true;\n    }\n\n    let (left, right) = text.char_indices().skip(1).next();\n\
    \n    left == right\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcc0s3c5o.rs:17:9\n   |\n\
    17 |     let (left, right) = text.char_indices().skip(1).next();\n   |       \
    \  ^^^^^^^^^^^^^   ---------------------------------- this expression has type\
    \ `Option<(usize, char)>`\n   |         |\n   |         expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<(usize, char)>`\n      \
    \       found tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .into_iter()\n        .cloned()\n     \
    \   .rev()\n        .join(\"\")\n        == text\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpar817vb9.rs:13:10\n     |\n13   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `rev` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpar817vb9.rs:14:10\n \
    \  |\n14 |           .rev()\n   |            ^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = text.chars().next().unwrap();\n    let mut right\
    \ = text.chars().next().unwrap();\n    while left != right {\n        if *left\
    \ != *right {\n            return false;\n        }\n        left = text.chars().next().unwrap();\n\
    \        right = text.chars().next().unwrap();\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpc5myudu1.rs:14:12\n\
    \   |\n14 |         if *left != *right {\n   |            ^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpc5myudu1.rs:14:21\n   |\n\
    14 |         if *left != *right {\n   |                     ^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = text.len();\n    let mut right = text.reverse().len();\n\
    \    left > 0 && right > 0 && left == right {\n        midpoint(&text, &left,\
    \ &right)\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `,` or `}`, found `(`\n  --> /tmp/tmprkwh_1ud.rs:14:17\n\
    \   |\n13 |     left > 0 && right > 0 && left == right {\n   |               \
    \                       ----- while parsing this struct\n14 |         midpoint(&text,\
    \ &left, &right)\n   |                 ^ expected one of `,` or `}`\n\nerror:\
    \ expected identifier, found `&`\n  --> /tmp/tmprkwh_1ud.rs:14:25\n   |\n13 |\
    \     left > 0 && right > 0 && left == right {\n   |                         \
    \             ----- while parsing this struct\n14 |         midpoint(&text, &left,\
    \ &right)\n   |                         ^ expected identifier\n\nerror: expected\
    \ identifier, found `&`\n  --> /tmp/tmprkwh_1ud.rs:14:32\n   |\n13 |     left\
    \ > 0 && right > 0 && left == right {\n   |                                  \
    \    ----- while parsing this struct\n14 |         midpoint(&text, &left, &right)\n\
    \   |                                ^ expected identifier\n\nerror[E0574]: expected\
    \ struct, variant or union type, found local variable `right`\n  --> /tmp/tmprkwh_1ud.rs:13:38\n\
    \   |\n13 |     left > 0 && right > 0 && left == right {\n   |               \
    \                       ^^^^^ not a struct, variant or union type\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmprkwh_1ud.rs:12:26\n   |\n12 |     let mut right = text.reverse().len();\n\
    \   |                          ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0574, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0574`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n\tlet mut index = text.len();\n\tlet mut result = false;\n\n\twhile\
    \ index > 0 {\n\t\tif text[index - 1] != text[index] {\n\t\t\tresult = true;\n\
    \t\t\tbreak;\n\t\t}\n\t\tindex -= 1;\n\t}\n\tresult\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkqmx2w55.rs:15:6\n\
    \   |\n15 |         if text[index - 1] != text[index] {\n   |            ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkqmx2w55.rs:15:25\n   |\n15 |         if text[index - 1] != text[index]\
    \ {\n   |                               ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_lowercase();\n    text = text.chars().skip_while(|c|\
    \ c.is_whitespace());\n    let mut lower = text.as_bytes();\n    let mut lower\
    \ = lower.clone();\n    let mut upper = text.as_bytes();\n    let mut upper =\
    \ upper.clone();\n    let mut i = text.len();\n    if i > 0 {\n        i += 1;\n\
    \        let mut j = (i / 2) as usize;\n        while j > 0 {\n            if\
    \ *lower != *upper {\n                println!(\"{} != {}\", lower, upper);\n\
    \                return false;\n            }\n            lower += 1;\n     \
    \       upper -= 1;\n            i -= 1;\n            j -= 1;\n        }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqwdl9ste.rs:12:12\n   |\n\
    11 |     let mut text = text.to_lowercase();\n   |                    -------------------\
    \ expected due to this value\n12 |     text = text.chars().skip_while(|c| c.is_whitespace());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `SkipWhile`\n   |\n   = note: expected struct `String`\n\
    \              found struct `SkipWhile<Chars<'_>, [closure@/tmp/tmpqwdl9ste.rs:12:36:\
    \ 12:57]>`\n\nerror[E0277]: `[u8]` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmpqwdl9ste.rs:23:38\n   |\n23 |                 println!(\"{} != {}\"\
    , lower, upper);\n   |                                      ^^^^^ `[u8]` cannot\
    \ be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `[u8]`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: `[u8]` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpqwdl9ste.rs:23:45\n   |\n23 |                 println!(\"{} !=\
    \ {}\", lower, upper);\n   |                                             ^^^^^\
    \ `[u8]` cannot be formatted with the default formatter\n   |\n   = help: the\
    \ trait `std::fmt::Display` is not implemented for `[u8]`\n   = note: in format\
    \ strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n\
    \   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&[u8]`\n  --> /tmp/tmpqwdl9ste.rs:26:13\n\
    \   |\n26 |             lower += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `&[u8]`\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `&[u8]`\n  --> /tmp/tmpqwdl9ste.rs:27:13\n\
    \   |\n27 |             upper -= 1;\n   |             -----^^^^^\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text;\n    let len = text.len();\n    let (left,\
    \ right) = text.split_at_mut(len);\n\n    for &s in right {\n        if s != s.chars().nth(len\
    \ - 1 - right[len - 1 - right].index()) {\n            return false;\n       \
    \ }\n    }\n\n    for &s in left {\n        if s != s.chars().nth(len - 1 - left[len\
    \ - 1 - left].index()) {\n            return false;\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `str` is not an iterator\n  --> /tmp/tmp225uvanp.rs:15:15\n\
    \   |\n15 |     for &s in right {\n   |               ^^^^^ `str` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `str`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `&mut str`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&mut str`\n\nerror[E0277]: cannot subtract `&mut str` from `usize`\n  -->\
    \ /tmp/tmp225uvanp.rs:16:55\n   |\n16 |         if s != s.chars().nth(len - 1\
    \ - right[len - 1 - right].index()) {\n   |                                  \
    \                     ^ no implementation for `usize - &mut str`\n   |\n   = help:\
    \ the trait `Sub<&mut str>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: `str` is\
    \ not an iterator\n  --> /tmp/tmp225uvanp.rs:21:15\n   |\n21 |     for &s in left\
    \ {\n   |               ^^^^ `str` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `str`\n   = note: required because of the\
    \ requirements on the impl of `Iterator` for `&mut str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&mut str`\n\nerror[E0277]:\
    \ cannot subtract `&mut str` from `usize`\n  --> /tmp/tmp225uvanp.rs:22:54\n \
    \  |\n22 |         if s != s.chars().nth(len - 1 - left[len - 1 - left].index())\
    \ {\n   |                                                      ^ no implementation\
    \ for `usize - &mut str`\n   |\n   = help: the trait `Sub<&mut str>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    if len < 2 { return true; }\n\n  \
    \  let mut i = 0;\n    let mut j = len - 1;\n    let mut p = false;\n\n    while\
    \ i < len && j >= 0 {\n        if text[i] != text[j] {\n            p = !p;\n\
    \            break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    p\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp938truag.rs:19:12\n\
    \   |\n19 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp938truag.rs:19:23\n   |\n19 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed = text.chars().rev();\n    let mut last = 0;\n\
    \    while reversed != last.chars().iter().take(text.length).rev() {\n       \
    \ let mut found = false;\n        for pos in reversed {\n            if text !=\
    \ text[pos as usize] {\n                found = true;\n                break;\n\
    \            }\n        }\n        if !found {\n            return false;\n  \
    \      }\n        reversed.next();\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmp1uznguyu.rs:13:28\n   |\n13 |     while reversed\
    \ != last.chars().iter().take(text.length).rev() {\n   |                     \
    \       ^^^^^ method not found in `{integer}`\n\nerror[E0609]: no field `length`\
    \ on type `String`\n  --> /tmp/tmp1uznguyu.rs:13:53\n   |\n13 |     while reversed\
    \ != last.chars().iter().take(text.length).rev() {\n   |                     \
    \                                ^^^^^^ unknown field\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp1uznguyu.rs:16:24\n   |\n\
    16 |             if text != text[pos as usize] {\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text\n        .chars()\n        .cloned()\n \
    \       .collect::<Vec<_>>();\n    let mut start = chars.len() / 2;\n    let mut\
    \ end = chars.len() - 1;\n    while start < end {\n        if chars[start].unwrap()\
    \ != chars[end].unwrap() {\n            return false;\n        }\n        start\
    \ += 1;\n        end -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp9737tbsm.rs:13:10\n     |\n13   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp9737tbsm.rs:14:10\n\
    \   |\n14 |           .collect::<Vec<_>>();\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    if len < 2 {\n        return true;\n\
    \    }\n\n    let mid = len / 2;\n    let is_sub = text.split_at(mid).eq(text.split_at_mut(mid).reverse());\n\
    \    !is_sub\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for tuple `(&mut str, &mut\
    \ str)` in the current scope\n  --> /tmp/tmp21z0l9r1.rs:17:63\n   |\n17 |    \
    \ let is_sub = text.split_at(mid).eq(text.split_at_mut(mid).reverse());\n   |\
    \                                                               ^^^^^^^ method\
    \ not found in `(&mut str, &mut str)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reverse_text = text;\n    let mut i = 0;\n    while i\
    \ < text.len() {\n        if text[i] != reverse_text[i] {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5fvv9pru.rs:14:12\n\
    \   |\n14 |         if text[i] != reverse_text[i] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5fvv9pru.rs:14:23\n   |\n14 |         if text[i] != reverse_text[i]\
    \ {\n   |                       ^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // reverse the string\n    let mut new_text = text.to_lowercase();\n\
    \    new_text = new_text.rev();\n\n    // if we don't have the same length then\
    \ it is not a palindrome\n    if text.len() != new_text.len() {\n        return\
    \ false;\n    }\n\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n      \
    \  // if they don't match then we can return false\n        if text[i] != new_text[j]\
    \ {\n            return false;\n        }\n\n        i += 1;\n        j += 1;\n\
    \        // if we run out of characters then it's not a palindrome\n        if\
    \ i >= text.len() || j >= new_text.len() {\n            return false;\n      \
    \  }\n    }\n    // if we got here then they match\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpylikg3lq.rs:13:25\n\
    \    |\n13  |       new_text = new_text.rev();\n    |                        \
    \   ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  \
    \  |\n    = note: the following trait bounds were not satisfied:\n           \
    \ `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpylikg3lq.rs:24:12\n\
    \   |\n24 |         if text[i] != new_text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpylikg3lq.rs:24:23\n   |\n24 |         if text[i] != new_text[j]\
    \ {\n   |                       ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nwarning: unreachable expression\n  --> /tmp/tmpylikg3lq.rs:36:5\n\
    \   |\n22 | /     loop {\n23 | |         // if they don't match then we can return\
    \ false\n24 | |         if text[i] != new_text[j] {\n25 | | "
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s: String = text;\n    let mut i: u32 = 0;\n\n    while\
    \ i < s.len() {\n        if s[i] != s[(s.len() - 1) - i] {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpol18vcv6.rs:14:15\n   |\n\
    14 |     while i < s.len() {\n   |               ^^^^^^^ expected `u32`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     while i < s.len().try_into().unwrap() {\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `u32`\n  --> /tmp/tmpol18vcv6.rs:15:12\n   |\n15 |    \
    \     if s[i] != s[(s.len() - 1) - i] {\n   |            ^^^^ `String` cannot\
    \ be indexed by `u32`\n   |\n   = help: the trait `Index<u32>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpol18vcv6.rs:15:38\n\
    \   |\n15 |         if s[i] != s[(s.len() - 1) - i] {\n   |                  \
    \                    ^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract\
    \ `u32` from `usize`\n  --> /tmp/tmpol18vcv6.rs:15:36\n   |\n15 |         if s[i]\
    \ != s[(s.len() - 1) - i] {\n   |                                    ^ no implementation\
    \ for `usize - u32`\n   |\n   = help: the trait `Sub<u32>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpol18vcv6.rs:15:20\n   |\n15 |         if s[i] != s[(s.len() - 1)\
    \ - i] {\n   |                    ^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(true, |result, char| {\n        if !result\
    \ && char == 'a' {\n            false\n        } else if char == 'z' {\n     \
    \       true\n        } else {\n            result && (char == char[text.len()\
    \ - text.len() % char.len()])\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpe0wxn51u.rs:17:68\n   |\n17 |             result && (char\
    \ == char[text.len() - text.len() % char.len()])\n   |                       \
    \                                             ^^^ method not found in `char`\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpe0wxn51u.rs:17:32\n\
    \   |\n17 |             result && (char == char[text.len() - text.len() % char.len()])\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 { return true; }\n    let mut a = text.chars().collect::<Vec<char>>();\n\
    \    a.sort();\n    for i in a.iter().rev() {\n        if *i != *i { break; }\n\
    \    }\n    a.is_empty()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8ilkd9zl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n\n    let mut\
    \ buffer = vec![String::new(); text.len()];\n    buffer.rev();\n    let mut is_palindrome\
    \ = true;\n\n    for (i, c) in text.chars().enumerate() {\n        if buffer.len()\
    \ < i {\n            is_palindrome = false;\n            break;\n        }\n \
    \       if c != buffer[i] {\n            is_palindrome = false;\n            break;\n\
    \        }\n    }\n\n    is_palindrome\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmptqzgapf9.rs:16:12\n\
    \    |\n16  |       buffer.rev();\n    |              ^^^ `Vec<String>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqzgapf9.rs:24:17\n\
    \   |\n24 |         if c != buffer[i] {\n   |                 ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text\n        .reverse()\n        .eq(&text.to_string())\n  \
    \      .unwrap_or(true)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0udte9jr.rs:12:10\n   |\n12 |         .reverse()\n\
    \   |          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // O(n) solution\n    let mut i = 0;\n    let mut j = text.len()\
    \ - 1;\n    while i != j {\n        if text[i..j].reverse() == text[i..j] {\n\
    \            return true;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp6apxonvd.rs:15:23\n   |\n15 |         if text[i..j].reverse()\
    \ == text[i..j] {\n   |                       ^^^^^^^ method not found in `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().fold(true, (acc, char) => (char == char.into() &&\
    \ (acc.is_some() || !acc)))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmprxbtad7n.rs:11:41\n   |\n11 |     text.chars().fold(true, (acc,\
    \ char) => (char == char.into() && (acc.is_some() || !acc)))\n   |           \
    \                              ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let mut rev_text = text.reverse();\n\
    \    let mut i = 0;\n    while i < len {\n        if text[i] != rev_text[i] {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp654hfkcs.rs:12:29\n   |\n12 |     let mut rev_text\
    \ = text.reverse();\n   |                             ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp654hfkcs.rs:15:12\n   |\n\
    15 |         if text[i] != rev_text[i] {\n   |            ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().enumerate().filter(|(_, i)| i as usize == text.len()\
    \ - i as usize)\n        .is_ok()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmpcp81glfq.rs:12:10\n   |\n12 |         .is_ok()\n\
    \   |          ^^^^^ method not found in `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmpcp81glfq.rs:11:37:\
    \ 11:83]>`\n\nerror[E0606]: casting `&char` as `usize` is invalid\n  --> /tmp/tmpcp81glfq.rs:11:46\n\
    \   |\n11 |     text.chars().enumerate().filter(|(_, i)| i as usize == text.len()\
    \ - i as usize)\n   |                                              ^^^^^^^^^^\n\
    \   |\n   = help: cast through a raw pointer first\n\nerror[E0606]: casting `&char`\
    \ as `usize` is invalid\n  --> /tmp/tmpcp81glfq.rs:11:73\n   |\n11 |     text.chars().enumerate().filter(|(_,\
    \ i)| i as usize == text.len() - i as usize)\n   |                           \
    \                                              ^^^^^^^^^^\n   |\n   = help: cast\
    \ through a raw pointer first\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed = String::new();\n    for i in text.chars()\
    \ {\n        if let Some(k) = i.to_digit(10) {\n            reversed.push((*k\
    \ as char).to_string());\n        }\n    }\n    reversed.reverse().trim().is_equivalent(text)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `u32` cannot be dereferenced\n  --> /tmp/tmpd07ty_wc.rs:14:28\n\
    \   |\n14 |             reversed.push((*k as char).to_string());\n   |       \
    \                     ^^\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpd07ty_wc.rs:17:14\n   |\n\
    17 |     reversed.reverse().trim().is_equivalent(text)\n   |              ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.as_bytes();\n    let n = s.len();\n\n    for\
    \ i in 0..n / 2 {\n        if s[i] as u8 != s[n - i - 1] as u8 {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // check if text is empty, return True\n    if text.len() < 2\
    \ {\n        return true;\n    }\n\n    // reverse text and check if it is equal\
    \ to text\n    let reversed = revstr(text);\n\n    if reversed == text {\n   \
    \     return true;\n    }\n\n    // if not, return False\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `revstr` in this scope\n  --> /tmp/tmp4bezril2.rs:17:20\n\
    \   |\n17 |     let reversed = revstr(text);\n   |                    ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut buffer = String::new();\n    for c in text.chars() {\n\
    \        buffer.push(c);\n    }\n    buffer.reverse();\n    buffer.chars().all(|c|\
    \ c == text)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpcm8mqhyg.rs:15:12\n   |\n15 |     buffer.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcm8mqhyg.rs:16:33\n\
    \   |\n16 |     buffer.chars().all(|c| c == text)\n   |                      \
    \           ^^^^ expected `char`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text\n        .chars()\n        .filter(|c| !c.is_alphanumeric())\n\
    \        .rev()\n        .eq(&text.chars().cloned().reverse())\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpdrzjj9a4.rs:15:27\n     |\n15   |         .eq(&text.chars().cloned().reverse())\n\
    \     |                           ^^^^^^ expected reference, found `char`\n  \
    \   |\n     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpdrzjj9a4.rs:15:36\n\
    \   |\n15 |         .eq(&text.chars().cloned().reverse())\n   |              \
    \                      ^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = String::new();\n    s.reserve(text.len());\n    for\
    \ (i, c) in text.chars().enumerate() {\n        if i % 2 == 0 {\n            s.push(c.to_string());\n\
    \        } else {\n            s.push(c.to_string().rev());\n        }\n    }\n\
    \    text == s\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcwi6urqg.rs:15:20\n   |\n\
    15 |             s.push(c.to_string());\n   |                    ^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmpcwi6urqg.rs:17:34\n    |\n17  |               s.push(c.to_string().rev());\n\
    \    |                                    ^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    (text.len() * 2 - 1) / 2 != text.chars().count();\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7q2vmhf.rs:10:35\n   |\n\
    10 | fn is_palindrome(text: String) -> bool {\n   |    -------------         \
    \         ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n11 |     (text.len() *\
    \ 2 - 1) / 2 != text.chars().count();\n   |                                  \
    \                   - help: remove this semicolon\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text == text.to_lowercase().rev() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp5cotx_h2.rs:11:36\n\
    \    |\n11  |       if text == text.to_lowercase().rev() {\n    |            \
    \                          ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect()\n        .zip(text.chars().skip(1))\n\
    \        .all(|(l, r)| (l == r) && is_palindrome(text.to_string()))\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpub3swr1y.rs:11:18\n\
    \   |\n11 |     text.chars().collect()\n   |                  ^^^^^^^ cannot infer\
    \ type for type parameter `B` declared on the associated function `collect`\n\
    \   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n11 |     text.chars().collect::<B>()\n\
    \   |                         +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut string = text;\n    let mut reverse = string;\n    for\
    \ i in 0..string.len() {\n        let mut start = i;\n        let mut end = string.len()\
    \ - 1 - i;\n        while start < end {\n            if string[start] != string[end]\
    \ {\n                let mut temp = string[start];\n                string[start]\
    \ = string[end];\n                string[end] = temp;\n                start =\
    \ end;\n                end = string.len() - 1 - i;\n            } else {\n  \
    \              start++;\n                end--;\n            }\n        }\n  \
    \  }\n    reverse == string\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpsq1ddbhq.rs:24:22\n\
    \   |\n24 |                 start++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |               \
    \  { let tmp = start; start += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n24 -                 start++;\n24 +                 start\
    \ += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsq1ddbhq.rs:17:16\n   |\n17 |             if string[start] != string[end]\
    \ {\n   |                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsq1ddbhq.rs:17:33\n   |\n17 |             if string[start] != string[end]\
    \ {\n   |                                 ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsq1ddbhq.rs:18:32\n   |\n18 |                 let mut temp = string[start];\n\
    \   |                                ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = h"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_string();\n    s.reverse();\n    s == text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpz85ymjlk.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text;\n    let mut reversed_text = text.to_ascii_lowercase();\n\
    \    text.as_bytes().iter().for_each(|b| {\n        reversed_text = reversed_text.to_ascii_lowercase().chain(b);\n\
    \    });\n    text == reversed_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp7ocfhzsq.rs:14:60\n\
    \    |\n14  |           reversed_text = reversed_text.to_ascii_lowercase().chain(b);\n\
    \    |                                                              ^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    text.chars().rposition(|c|\
    \ *c == *text.chars().last().unwrap()).is_ok()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpb4shoxxs.rs:12:18\n     |\n12   |     text.chars().rposition(|c|\
    \ *c == *text.chars().last().unwrap()).is_ok()\n     |                  ^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n \
    \    = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\nnote: required by a bound in `rposition`\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpb4shoxxs.rs:12:32\n\
    \   |\n12 |     text.chars().rposition(|c| *c == *text.chars().last().unwrap()).is_ok()\n\
    \   |                                ^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmpb4shoxxs.rs:12:38\n   |\n12 |     text.chars().rposition(|c|\
    \ *c == *text.chars().last().unwrap()).is_ok()\n   |                         \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_ok`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpb4shoxxs.rs:12:69\n\
    \   |\n12 |     text.chars().rposition(|c| *c == *text.chars().last().unwrap()).is_ok()\n\
    \   |                                                                     ^^^^^\
    \ method not found in `Option<usize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut i = 0;\n    let mut j = text.len() - 1;\n\n    while\
    \ i != j {\n        if text[i] != text[j] {\n            return false;\n     \
    \   }\n\n        i += 1;\n        j -= 1;\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxp7dn_ld.rs:15:12\n\
    \   |\n15 |         if text[i] != text[j] {\n   |            ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxp7dn_ld.rs:15:23\n   |\n15 |         if text[i] != text[j] {\n\
    \   |                       ^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // check for empty string\n    if text.len() == 0 {\n       \
    \ return true;\n    }\n    let mut current_char = text[0];\n    let mut last_char\
    \ = text[0];\n    for current_char in text.chars().rev() {\n        last_char\
    \ = current_char;\n        if text != current_char.to_string().to_string().reverse()\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpuekv4ch9.rs:15:28\n   |\n15 |     let mut current_char = text[0];\n\
    \   |                            ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpuekv4ch9.rs:16:25\n   |\n16 |     let mut last_char = text[0];\n\
    \   |                         ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpuekv4ch9.rs:19:57\n   |\n19 |         if\
    \ text != current_char.to_string().to_string().reverse() {\n   |             \
    \                                            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut index = 0;\n    let mut text = String::from(text);\n\
    \    let mut is_palindrome = true;\n    while index < text.len() && is_palindrome\
    \ {\n        let current_char = text.chars().nth(index).unwrap();\n        let\
    \ next_char = text.chars().nth(index).unwrap();\n        if current_char != next_char\
    \ {\n            is_palindrome = false;\n        }\n        index += 1;\n    }\n\
    \    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp23wytqop.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().enumerate().filter(|(_, c)| {\n        c.is_alphanumeric()\
    \ || c.is_control() || c.is_whitespace()\n    }).fold(true, |acc, (_, c)| {\n\
    \        acc && c == text[text.len() - 1 - acc.len()]\n    })\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpcvke7xky.rs:14:47\n   |\n14 |         acc && c == text[text.len()\
    \ - 1 - acc.len()]\n   |                                               ^^^ method\
    \ not found in `bool`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpcvke7xky.rs:14:21\n   |\n14 |         acc && c == text[text.len()\
    \ - 1 - acc.len()]\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut input = text.chars();\n    let mut it = input.iter();\n\
    \    let len = it.len();\n    let mut i = 0; // current index\n    let mut j =\
    \ 0;\n    while i < len {\n        j = i - 1;\n        if it.next().get(0) !=\
    \ it.previous().get() {\n            return false;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpcvgtsv0k.rs:12:24\n   |\n12 |     let mut it = input.iter();\n\
    \   |                        ^^^^ private field, not a method\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text == text.chars().fold(String::new(), |mut s, c| {\n  \
    \      s += &c.to_string();\n        s\n    }) {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn7a4q8sx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .rev()\n        .zip(text.chars())\n  \
    \      .filter(|&(c1, c2)| c1 == c2)\n        .all(|&(c1, c2)| c1 == c2)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx1mlohvm.rs:15:15\n   |\n\
    15 |         .all(|&(c1, c2)| c1 == c2)\n   |               ^^^^^^^^-\n   |  \
    \             |       |\n   |               |       expected due to this\n   |\
    \               expected tuple, found reference\n   |\n   = note:  expected tuple\
    \ `(char, char)`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.chars();\n    let mut i = 1;\n    loop {\n\
    \        if i != it.len() {\n            if text[i] != it[it.len() - i] {\n  \
    \              return false;\n            }\n        } else {\n            if\
    \ *i == *it.len() {\n                return true;\n            }\n        }\n\
    \        i += 1;\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpqrc9k2ta.rs:14:20\n   |\n14 |         if i != it.len()\
    \ {\n   |                    ^^^ method not found in `Chars<'_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqrc9k2ta.rs:15:16\n\
    \   |\n15 |             if text[i] != it[it.len() - i] {\n   |               \
    \ ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpqrc9k2ta.rs:15:33\n   |\n15 |             if\
    \ text[i] != it[it.len() - i] {\n   |                                 ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpqrc9k2ta.rs:19:16\n   |\n19 |             if *i == *it.len() {\n\
    \   |                ^^\n\nerror[E0599]: no method named `len` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpqrc9k2ta.rs:19:26\n   |\n19 |  \
    \           if *i == *it.len() {\n   |                          ^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Check for empty string\n    if text.len() <= 0 {\n       \
    \ return true;\n    }\n    // Do the normal check\n    let mut left = text.chars().nth(0);\n\
    \    let mut right = text.chars().nth(text.len() - 1);\n    // While left and\
    \ right are equal, swap them\n    while left != right {\n        let tmp = left;\n\
    \        left = right;\n        right = tmp;\n    }\n    left == right\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text: Vec<u8> = vec![];\n    for c in text.chars() {\n\
    \        let c = c.to_digit(10);\n        if c == 0 {\n            return false;\n\
    \        }\n        text.push(c);\n    }\n    let text = text.into_iter().collect::<Vec<u8>>();\n\
    \    let reversed_text = text.iter().rev().collect::<Vec<u8>>();\n    let result\
    \ = text == reversed_text;\n    println!(\"{:?}\", result);\n    result\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmp_422ofhs.rs:12:19\n   |\n12 |     for c in text.chars()\
    \ {\n   |                   ^^^^^ method not found in `Vec<u8>`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `&u8`\n    --> /tmp/tmp_422ofhs.rs:20:43\n     |\n20   |     let reversed_text\
    \ = text.iter().rev().collect::<Vec<u8>>();\n     |                          \
    \                 ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n\
    \     |\n     = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Return True for empty text\n    if text.len() == 0 {\n   \
    \     return true;\n    }\n    \n    // Set last and first character as middle\
    \ of string\n    let middle = text.len() / 2;\n    let start = text.chars().nth(middle\
    \ - 1).unwrap();\n    let end = text.chars().nth(middle + 1).unwrap();\n    \n\
    \    // Iterate through text\n    for pos in text.char_indices().rev() {\n   \
    \     // If char is not palindromic then return False\n        if text[pos.0]\
    \ != start {\n            return false;\n        }\n    }\n    \n    // Return\
    \ True\n    return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5jvtbhbq.rs:24:12\n\
    \   |\n24 |         if text[pos.0] != start {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rfold(|acc, x| {\n        if acc.is_empty() {\n\
    \            acc.push(x.to_string())\n        } else {\n            acc\n    \
    \            .iter()\n                .cloned()\n                .zip(x.to_string().chars().iter().cloned())\n\
    \                .filter(|(a,b)| a == b)\n                .count() == 2 ||\n \
    \               acc.push(x.to_string())\n        }\n        acc\n    })\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpn9ppohzl.rs:11:25\n\
    \   |\n11 |     text.chars().rfold(|acc, x| {\n   |                         ^^^\
    \ consider giving this closure parameter a type\n   |\n   = note: type must be\
    \ known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9ppohzl.rs:15:13\n\
    \   |\n12 |  /         if acc.is_empty() {\n13 |  |             acc.push(x.to_string())\n\
    14 |  |         } else {\n15 |  |             acc\n   |  |_____________^\n16 |\
    \ ||                 .iter()\n17 | ||                 .cloned()\n18 | ||     \
    \            .zip(x.to_string().chars().iter().cloned())\n19 | ||            \
    \     .filter(|(a,b)| a == b)\n20 | ||                 .count() == 2 ||\n21 |\
    \ ||                 acc.push(x.to_string())\n   | ||_______________________________________^\
    \ expected `()`, found `bool`\n22 |  |         }\n   |  |_________- expected this\
    \ to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n22 |        \
    \ };\n   |          +\nhelp: you might have meant to return this value\n   |\n\
    15 ~             return acc\n16 |                 .iter()\n17 |              \
    \   .cloned()\n18 |                 .zip(x.to_string().chars().iter().cloned())\n\
    19 |                 .filter(|(a,b)| a == b)\n20 |                 .count() ==\
    \ 2 ||\n ...\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpn9ppohzl.rs:11:18\n    |\n11  |       text.chars().rfold(|acc,\
    \ x| {\n    |  __________________^^^^^_-\n    | |                  |\n    | |\
    \                  expected 2 arguments\n12  | |         if acc.is_empty() {\n\
    13  | |             acc.push(x.to_string())\n14  | |         } else {\n...   |\n\
    23  | |         acc\n24  | |     })\n    | |_____- supplied 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n\n    if len < 2 {\n        return true;\n\
    \    }\n\n    if len == 2 {\n        text == text.reversed()\n    } else {\n \
    \       let mid = len / 2;\n        let left = text.split_first_match_at(mid);\n\
    \        let right = text.split_last_match_at(len - mid);\n\n        left.join()\
    \ == right.join()\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reversed` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu98ymy8n.rs:18:22\n   |\n18 |         text == text.reversed()\n\
    \   |                      ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `split_first_match_at` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpu98ymy8n.rs:21:25\n   |\n21 |         let left = text.split_first_match_at(mid);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at_mut`\n\nerror[E0599]: no method named\
    \ `split_last_match_at` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu98ymy8n.rs:22:26\n   |\n22 |         let right = text.split_last_match_at(len\
    \ - mid);\n   |                          ^^^^^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `split_at_mut`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().next().unwrap() == text.chars().last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp3szv4ajq.rs:11:25\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_string();\n    text.chars().for_each(|c|\
    \ *text = format!(\"{}{}\", c, text));\n\n    text == text.reverse()\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfac_ezwp.rs:12:39\n   |\n\
    12 |     text.chars().for_each(|c| *text = format!(\"{}{}\", c, text));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpfac_ezwp.rs:12:31\n   |\n12 |     text.chars().for_each(|c| *text =\
    \ format!(\"{}{}\", c, text));\n   |                               ^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: the left-hand-side of an assignment must have\
    \ a statically known size\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpfac_ezwp.rs:14:18\n   |\n\
    14 |     text == text.reverse()\n   |                  ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars()\n        .filter_map(|c| c.to_digit(10).ok())\n\
    \        .eq(text.rev_chars().filter_map(|c| c.to_digit(10).ok()))\n        .unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpl8yabk3o.rs:12:40\n   |\n12 |         .filter_map(|c| c.to_digit(10).ok())\n\
    \   |                                        ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror[E0599]: no method named `rev_chars` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpl8yabk3o.rs:13:18\n\
    \   |\n13 |         .eq(text.rev_chars().filter_map(|c| c.to_digit(10).ok()))\n\
    \   |                  ^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `chars`\n\nerror[E0599]: no method named `unwrap_or` found for\
    \ type `bool` in the current scope\n  --> /tmp/tmpl8yabk3o.rs:14:10\n   |\n14\
    \ |         .unwrap_or(true)\n   |          ^^^^^^^^^ method not found in `bool`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all(|c| c == text.chars().cloned()[text.len() -\
    \ text.chars().len() - 1])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpkb00_lzh.rs:11:44\n     |\n11   |     text.chars().all(|c|\
    \ c == text.chars().cloned()[text.len() - text.chars().len() - 1])\n     |   \
    \                                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpkb00_lzh.rs:11:79\n\
    \   |\n11 |     text.chars().all(|c| c == text.chars().cloned()[text.len() - text.chars().len()\
    \ - 1])\n   |                                                                \
    \               ^^^ method not found in `Chars<'_>`\n\nerror[E0608]: cannot index\
    \ into a value of type `Cloned<Chars<'_>>`\n  --> /tmp/tmpkb00_lzh.rs:11:31\n\
    \   |\n11 |     text.chars().all(|c| c == text.chars().cloned()[text.len() - text.chars().len()\
    \ - 1])\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        return true;\n    }\n\n    let\
    \ mut left = text[0..text.len() / 2].chars().collect::<Vec<_>>();\n    let mut\
    \ right = text[2..].chars().collect::<Vec<_>>();\n\n    left.reverse();\n    right.reverse();\n\
    \n    if left == right {\n        return true;\n    }\n\n    return false;\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnq6g6f3s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().all(|c| c == text[0])\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpoioxc97_.rs:11:37\n   |\n11 |     text.chars().rev().all(|c| c == text[0])\n\
    \   |                                     ^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = 0;\n    let mut right = text.len() - 1;\n    loop\
    \ {\n        if text[left] != text[right] {\n            return false;\n     \
    \   }\n        if left >= right {\n            break;\n        }\n        left\
    \ += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpp2ailg0m.rs:14:12\n   |\n14 |         if text[left] != text[right] {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp2ailg0m.rs:14:26\n   |\n14 |         if text[left] != text[right]\
    \ {\n   |                          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(0..text.len()).all(|(c, i)| c == text[i..].to_string()[..i])\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkfjjkp86.rs:11:55\n   |\n\
    11 |     text.chars().zip(0..text.len()).all(|(c, i)| c == text[i..].to_string()[..i])\n\
    \   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut reversed = String::new();\n    for &c in text.chars()\
    \ {\n        reversed.push(c); // append the characters to the reverse string\
    \ in reverse\n    }\n\n    // reverse the reversed string\n    reversed.reverse();\n\
    \n    // compare the original text and reversed text\n    text == reversed\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0ko_pdq.rs:12:9\n   |\n\
    12 |     for &c in text.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmph0ko_pdq.rs:17:14\n   |\n17 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut a = text.chars().collect::<Vec<_>>();\n    a.sort();\n\
    \    a.iter().eq(text.chars().collect::<Vec<_>>())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n    --> /tmp/tmpzvx8vxgj.rs:13:14\n\
    \     |\n13   |     a.iter().eq(text.chars().collect::<Vec<_>>())\n     |    \
    \          ^^ no implementation for `&char == char`\n     |\n     = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n     = help: the trait\
    \ `PartialEq` is implemented for `char`\nnote: required by a bound in `std::iter::Iterator::eq`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text.to_lowercase();\n    s.reverse();\n    s ==\
    \ text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsjgmh__k.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == reverse(text)\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp2lh1sdtx.rs:11:13\n\
    \   |\n11 |     text == reverse(text)\n   |             ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n\
    /// True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
    /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut s = text;\n    let mut len = 0;\n    while let Some(d)\
    \ = s.chars().next() {\n        *d += 1;\n        len = s.len();\n        if len\
    \ <= 0 {\n            return false;\n        }\n        s = s.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpnqilf_xw.rs:14:9\n\
    \   |\n14 |         *d += 1;\n   |         ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnqilf_xw.rs:19:13\n   |\n11 |     let mut s = text;\n   |     \
    \            ---- expected due to this value\n...\n19 |         s = s.chars().next().unwrap();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |             |\n   |             expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
