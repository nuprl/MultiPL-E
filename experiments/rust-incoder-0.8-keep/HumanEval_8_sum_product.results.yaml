name: HumanEval_8_sum_product
language: rust
results:
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), number|\
    \ {\n        (*sum + number, *product * number)\n    })\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpprwl0f12.rs:9:10\n\
    \  |\n9 |         (*sum + number, *product * number)\n  |          ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n --> /tmp/tmpprwl0f12.rs:9:25\n  |\n9 |\
    \         (*sum + number, *product * number)\n  |                         ^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = isize::zero();\n    let mut product =\
    \ isize::one();\n    for i in numbers {\n        sum += i;\n        product *=\
    \ i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `zero` found for type\
    \ `isize` in the current scope\n --> /tmp/tmpo48us62i.rs:8:26\n  |\n8 |     let\
    \ mut sum = isize::zero();\n  |                          ^^^^ function or associated\
    \ item not found in `isize`\n\nerror[E0599]: no function or associated item named\
    \ `one` found for type `isize` in the current scope\n --> /tmp/tmpo48us62i.rs:9:30\n\
    \  |\n9 |     let mut product = isize::one();\n  |                           \
    \   ^^^ function or associated item not found in `isize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0,1);\n  \
    \  }\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(a, b)| {\n        (a.0,\
    \ a.1 + b.0)\n    }) as (isize, isize)\n}\n\nfn main() {\n    let candidate =\
    \ sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n --> /tmp/tmpq8pgtjai.rs:8:20\n  |\n8 |\
    \     numbers.iter().fold((0, 1), |(a, b)| {\n  |                    ^^^^    \
    \     -------- takes a single 2-tuple as argument\n  |                    |\n\
    \  |                    expected closure that takes 2 distinct arguments\n  |\n\
    help: change the closure to take multiple arguments instead of a single tuple\n\
    \  |\n8 |     numbers.iter().fold((0, 1), |a, b| {\n  |                      \
    \           ~~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0593`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(s, n)| (s + n, s * n))\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n --> /tmp/tmp2d2zz6u6.rs:8:20\n  |\n8 |\
    \     numbers.iter().fold((0, 1), |(s, n)| (s + n, s * n))\n  |              \
    \      ^^^^         -------- takes a single 2-tuple as argument\n  |         \
    \           |\n  |                    expected closure that takes 2 distinct arguments\n\
    \  |\nhelp: change the closure to take multiple arguments instead of a single\
    \ tuple\n  |\n8 |     numbers.iter().fold((0, 1), |s, n| (s + n, s * n))\n  |\
    \                                 ~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0593`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum_so_far = 0;\n    let mut product_so_far = 1;\n    for x\
    \ in numbers {\n        sum_so_far = sum_so_far + x;\n        product_so_far =\
    \ product_so_far * x;\n    }\n    (sum_so_far, product_so_far)\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers.is_sorted());\n    let mut sum = isize::zero();\n\
    \    let mut product = isize::one();\n    for n in numbers.iter() {\n        sum\
    \ += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n -->\
    \ /tmp/tmp9_57yj9n.rs:8:21\n  |\n8 |     assert!(numbers.is_sorted());\n  |  \
    \                   ^^^^^^^^^\n  |\n  = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0599]: no function or associated item named `zero`\
    \ found for type `isize` in the current scope\n --> /tmp/tmp9_57yj9n.rs:9:26\n\
    \  |\n9 |     let mut sum = isize::zero();\n  |                          ^^^^\
    \ function or associated item not found in `isize`\n\nerror[E0599]: no function\
    \ or associated item named `one` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp9_57yj9n.rs:10:30\n   |\n10 |     let mut product = isize::one();\n\
    \   |                              ^^^ function or associated item not found in\
    \ `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0658.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers != Vec::new(), \"List cannot be empty\"\
    );\n    let mut sum = 0;\n    let mut product = 1;\n\n    for &n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwqzbvipe.rs:12:9\n   |\n\
    12 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for &n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ca6psw_.rs:15:9\n   |\n\
    15 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0,0);\n  \
    \  }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp9195dlia.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers != vec![]);\n\n    let mut result:\
    \ (u32, u32) = (0, 1);\n\n    for n in numbers {\n        let (nsum, nprod) =\
    \ result.1.divmod(n);\n\n        result.0 = nsum + n;\n        result.1 = nprod\
    \ * n;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `divmod` found for type `u32` in the current\
    \ scope\n  --> /tmp/tmpq3byw5hj.rs:13:38\n   |\n13 |         let (nsum, nprod)\
    \ = result.1.divmod(n);\n   |                                      ^^^^^^ method\
    \ not found in `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq3byw5hj.rs:19:5\n\
    \   |\n7  | fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n   |    \
    \                                    -------------- expected `(isize, isize)`\
    \ because of return type\n...\n19 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `u32`\n   |\n   = note: expected tuple `(isize, isize)`\n            \
    \  found tuple `(u32, u32)`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(0, |sum, number| {\n        (sum\
    \ * number, sum * number + number)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoyhtgnv4.rs:8:25\n  |\n8 |\
    \     numbers.iter().fold(0, |sum, number| {\n  |                         ^ expected\
    \ tuple, found integer\n  |\n  = note: expected tuple `(isize, isize)`\n     \
    \         found type `{integer}`\n\nerror[E0369]: cannot multiply `(isize, isize)`\
    \ by `&isize`\n --> /tmp/tmpoyhtgnv4.rs:9:14\n  |\n9 |         (sum * number,\
    \ sum * number + number)\n  |          --- ^ ------ &isize\n  |          |\n \
    \ |          (isize, isize)\n\nerror[E0369]: cannot multiply `(isize, isize)`\
    \ by `&isize`\n --> /tmp/tmpoyhtgnv4.rs:9:28\n  |\n9 |         (sum * number,\
    \ sum * number + number)\n  |                        --- ^ ------ &isize\n  |\
    \                        |\n  |                        (isize, isize)\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), n| {\n\
    \        (sum + n, product * n)\n    })\n}\n\nfn main() {\n    let candidate =\
    \ sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 0)) {\n        (sum, product)\
    \ => (sum + $1, product * $1)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n\
    \ --> /tmp/tmpw_zwpmmt.rs:8:33\n  |\n8 |     numbers.iter().fold((0, 0)) {\n \
    \ |                                 ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum_ = 0;\n    let mut product_ = 1;\n\n  \
    \  for n in numbers {\n        sum_ += n;\n        product_ *= n;\n    }\n\n \
    \   (sum_, product_)\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter()\n        .cloned()\n        .fold(\n\
    \            (0, 1),\n            (mut sum, mut product) => {\n              \
    \  sum += *product;\n                product += *sum;\n                (*sum,\
    \ 0)\n            },\n        )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found keyword `mut`\n  --> /tmp/tmp9yofzh6a.rs:12:14\n\
    \   |\n12 |             (mut sum, mut product) => {\n   |              ^^^ expected\
    \ expression\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found\
    \ `=>`\n  --> /tmp/tmp9yofzh6a.rs:12:36\n   |\n12 |             (mut sum, mut\
    \ product) => {\n   |                                    ^^ expected one of `)`,\
    \ `,`, `.`, `?`, or an operator\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers.iter() {\n        sum += number;\n        product *= number;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers_are_positive(numbers));\n    let mut\
    \ product = 1;\n    let mut sum = 0;\n\n    for x in numbers {\n        sum +=\
    \ x;\n        product *= x;\n    }\n\n    (sum, product)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `numbers_are_positive` in this scope\n\
    \ --> /tmp/tmpox6ybeui.rs:8:13\n  |\n8 |     assert!(numbers_are_positive(numbers));\n\
    \  |             ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0,1)\n    } else\
    \ {\n        let mut product = 1;\n        let mut sum = 0;\n\n        for n in\
    \ numbers {\n            sum += n;\n            product *= n;\n        }\n\n \
    \       (sum, product)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1))((x, y) => x.checked_add(y).unwrap())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \ --> /tmp/tmp7br5j8oq.rs:8:40\n  |\n8 |     numbers.iter().fold((0, 1))((x, y)\
    \ => x.checked_add(y).unwrap())\n  |                                        ^^\
    \ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpwgjbhq1h.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut prod = 1;\n    for x\
    \ in numbers {\n        sum += x;\n        prod *= x;\n    }\n    (sum, prod)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    match numbers {\n        vec::[] => (0, 1),\n     \
    \   numbers => {\n            let mut product = 1;\n            let mut sum =\
    \ 0;\n            for n in numbers {\n                sum += n;\n            \
    \    product *= n;\n            }\n            (sum, product)\n        }\n   \
    \ }\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `[`\n --> /tmp/tmp798kqnfw.rs:9:14\n\
    \  |\n9 |         vec::[] => (0, 1),\n  |              ^ expected identifier\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers[0], numbers[0] * numbers[0])\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpvt9fna_k.rs:8:6\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0, 1);\n    }\n\n\
    \    let mut sum = 0;\n    let mut product = 1;\n\n    for n in numbers {\n  \
    \      sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut product = 1;\n    let mut sum = 0;\n    for n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut sum_product = numbers[0];\n    for n in numbers {\n       \
    \ sum_product *= n;\n    }\n    (sum_product, numbers[0])\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp4ych96gp.rs:15:19\n\
    \    |\n7   | fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    | \
    \               ------- move occurs because `numbers` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     (sum_product, numbers[0])\n    |                   ^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `numbers`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12\
    \  |     for n in &numbers {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().cloned().fold((0, 1), |(sum, product),\
    \ number| {\n        (sum + number, product * number)\n    });\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpws1_ciuz.rs:7:40\n   |\n\
    7  | fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n   |    -----------\
    \                         ^^^^^^^^^^^^^^ expected tuple, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n10 |     });\n   |       - help: remove this semicolon\n   |\n   = note:\
    \  expected tuple `(isize, isize)`\n           found unit type `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n\n  \
    \  (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ &n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsllu7a21.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut product = 1;\n    let mut sum = 0;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (0,1),\n        |sum,x|\
    \ (sum+x,x*sum))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&isize` to `(isize, isize)`\n  --> /tmp/tmp0u3aiwk6.rs:10:21\n\
    \   |\n10 |         |sum,x| (sum+x,x*sum))\n   |                  ---^- &isize\n\
    \   |                  |\n   |                  (isize, isize)\n\nerror[E0277]:\
    \ cannot multiply `&isize` by `(isize, isize)`\n  --> /tmp/tmp0u3aiwk6.rs:10:25\n\
    \   |\n10 |         |sum,x| (sum+x,x*sum))\n   |                         ^ no\
    \ implementation for `&isize * (isize, isize)`\n   |\n   = help: the trait `Mul<(isize,\
    \ isize)>` is not implemented for `&isize`\n   = help: the following other types\
    \ implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n          \
    \   <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n            \
    \ <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a\
    \ i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a isize\
    \ as Mul<isize>>\n           and 49 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for n in numbers {\n        sum += *n;\n        product *= *n;\n \
    \   }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpt3jfqsu2.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpt3jfqsu2.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0, 1);\n    }\n \
    \   let mut product_of_first_number = 1;\n    let mut sum_of_first_number = 0;\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        sum_of_first_number\
    \ += number;\n        product_of_first_number *= i;\n    }\n    (sum_of_first_number,\
    \ product_of_first_number);\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgdwq7fno.rs:7:40\n  |\n7 |\
    \ fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n  |    -----------\
    \                         ^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note:  expected tuple `(isize, isize)`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut product = 1;\n    let mut sum = 0;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (1, 1);\n \
    \   }\n\n    let mut sum_product: (isize, isize) = (0, 1);\n\n    for number in\
    \ numbers {\n        sum_product = sum_product.0 * number + sum_product.1;\n \
    \   }\n\n    sum_product\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkldil55k.rs:15:23\n   |\n\
    12 |     let mut sum_product: (isize, isize) = (0, 1);\n   |                 \
    \         -------------- expected due to this type\n...\n15 |         sum_product\
    \ = sum_product.0 * number + sum_product.1;\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `isize`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \               found type `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = isize::max_value();\n    let mut t = isize::max_value();\n\
    \    for n in numbers {\n        s += n;\n        t *= n;\n    }\n    (s, t)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(9223372036854775807, 9223372036854775807)`,\n right: `(0, 1)`', /tmp/tmpdddd8l2t.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 0), |(sum, product), number|\
    \ {\n        (sum + number, product * number)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpw3jabkxx.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum_num = 0;\n    let mut prod_num = 1;\n    for n in numbers\
    \ {\n        sum_num += n;\n        prod_num *= n;\n    }\n    (sum_num, prod_num)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    match numbers.len() {\n        0 => (0, 1),\n     \
    \   _ => (numbers[0], numbers.iter().product()),\n    }\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1, 1)`,\n right: `(3, 1)`', /tmp/tmpiv5j3ufq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut total = 0;\n    let mut prod = 1;\n    for\
    \ n in numbers {\n        total = total + n;\n        prod = prod * n;\n    }\n\
    \    (total, prod)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut total = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        total += number;\n        product *= number;\n    }\n    (total,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpgmw4bls2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers.len() > 0);\n\n    let mut sum_ = 0;\n\
    \    let mut prod_ = 1;\n    for number in numbers {\n        sum_ += number;\n\
    \        prod_ *= number;\n    }\n\n    (sum_, prod_)\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: numbers.len() > 0', /tmp/tmpgkdof2t5.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for i in numbers\
    \ {\n        sum += i;\n        product *= i;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum_ = 0;\n    let mut prod_ = 1;\n    for &i in &numbers {\n\
    \        sum_ += i;\n        prod_ *= i;\n    }\n    (sum_, prod_)\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum_ = 0;\n    let mut product_ = 1;\n    for\
    \ n in numbers {\n        sum_ += n;\n        product_ *= n;\n    }\n    (sum_,\
    \ product_)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), i| {\n\
    \        sum.0 + (*i) * product;\n        (sum.0, product.0)\n    })\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmpr02wn5xf.rs:9:13\n  |\n9 |         sum.0 + (*i) * product;\n  |\
    \             ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpr02wn5xf.rs:10:14\n   |\n10 |         (sum.0, product.0)\n\
    \   |              ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpr02wn5xf.rs:10:25\n   |\n10 |         (sum.0,\
    \ product.0)\n   |                         ^\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0, 0)\n    } else\
    \ {\n        let mut sum = 0;\n        let mut product = 1;\n        let mut i\
    \ = 0;\n        while i < numbers.len() {\n            sum += numbers[i];\n  \
    \          product *= numbers[i];\n            i += 1;\n        }\n        (sum,\
    \ product)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp80jqjcio.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers[0];\n    let mut product = 1;\n\
    \    for x in numbers {\n        sum += x;\n        product *= x;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp3v04gk37.rs:8:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n\n    for n in numbers {\n        sum += n;\n        product *= n;\n \
    \   }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 0), |(sum, product), number|\
    \ {\n        (sum + number, product * number)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp9hr36mjf.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n\n    for\
    \ num in numbers {\n        sum = sum + num;\n        product = product * num;\n\
    \    }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers.iter().fold(0, |mut acc, x| acc\
    \ + x);\n    let mut product = numbers.iter().fold(1, |mut acc, x| acc * x);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (isize, isize),\n   \
    \     (|sum, num| {\n            (sum + num, num);\n        }),\n    )\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n --> /tmp/tmpvafr01e0.rs:9:10\n\
    \  |\n9 |         (isize, isize),\n  |          ^^^^^ not a value\n\nerror[E0423]:\
    \ expected value, found builtin type `isize`\n --> /tmp/tmpvafr01e0.rs:9:17\n\
    \  |\n9 |         (isize, isize),\n  |                 ^^^^^ not a value\n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmpvafr01e0.rs:10:9\n\
    \   |\n10 |         (|sum, num| {\n   |         ^\n11 |             (sum + num,\
    \ num);\n12 |         }),\n   |          ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n10 ~         |sum, num|\
    \ {\n11 |             (sum + num, num);\n12 ~         },\n   |\n\nerror[E0369]:\
    \ cannot add `&isize` to `(isize, isize)`\n  --> /tmp/tmpvafr01e0.rs:11:18\n \
    \  |\n11 |             (sum + num, num);\n   |              --- ^ --- &isize\n\
    \   |              |\n   |              (isize, isize)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvafr01e0.rs:10:21\n   |\n10 |           (|sum, num| {\n\
    \   |  _____________________^\n11 | |             (sum + num, num);\n12 | |  \
    \       }),\n   | |_________^ expected tuple, found `()`\n   |\n   = note:  expected\
    \ tuple `(isize, isize)`\n           found unit type `()`\n\nerror: aborting due\
    \ to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0423.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut product_of_sum = 1;\n    let mut sum_of_numbers = numbers[0];\n\
    \    for number in numbers.iter() {\n        sum_of_numbers += number;\n     \
    \   product_of_sum *= number;\n    }\n\n    (sum_of_numbers, product_of_sum)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(4, 1)`,\n right: `(3, 1)`', /tmp/tmp43juhpvw.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (1, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1, 1)`,\n right: `(0, 1)`', /tmp/tmppgx_n7b3.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers.iter() {\n        sum += *n;\n        product *= *n;\n    }\n \
    \   (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut s = numbers.iter().sum();\n    let mut prod = 1;\n\n    for\
    \ num in numbers {\n        s += num;\n        prod *= num;\n    }\n\n    (s,\
    \ prod)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(6, 1)`,\n right: `(3, 1)`', /tmp/tmpbp5wem9z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum = sum + n;\n        product = product * n;\n   \
    \ }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut product_sum = 1;\n    let mut sum_of_numbers = numbers.iter().sum();\n\
    \    for number in numbers {\n        sum_of_numbers += number;\n        product_sum\
    \ *= number;\n    }\n\n    (sum_of_numbers, product_sum)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(6, 1)`,\n right: `(3, 1)`', /tmp/tmpy2nhid_1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += *n;\n        product *= *n;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpy351_l3s.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpy351_l3s.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ (i, &num) in numbers.iter().enumerate() {\n        sum += num;\n        product\
    \ *= i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcystsyp_.rs:14:11\n   |\n\
    14 |     (sum, product)\n   |           ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     (sum, product.try_into().unwrap())\n   | \
    \                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ &n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqodvvra0.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n\n    let mut running_sum = 0;\n    let mut running_product = 1;\n\n  \
    \  for &n in numbers {\n        running_sum += n;\n        running_product *=\
    \ n;\n    }\n\n    return (running_sum, running_product);\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpngnvnbzl.rs:15:9\n   |\n\
    15 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum_: isize = 0;\n    let mut product_: isize\
    \ = 1;\n    for n in numbers {\n        sum_ += n;\n        product_ *= n;\n \
    \   }\n    (sum_, product_)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((isize::zero(), isize::one()),\
    \ |(sum, product), i| {\n        (sum + i, product * i)\n    })\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `zero` found for type\
    \ `isize` in the current scope\n --> /tmp/tmp5866vwlj.rs:8:33\n  |\n8 |     numbers.iter().fold((isize::zero(),\
    \ isize::one()), |(sum, product), i| {\n  |                                 ^^^^\
    \ function or associated item not found in `isize`\n\nerror[E0599]: no function\
    \ or associated item named `one` found for type `isize` in the current scope\n\
    \ --> /tmp/tmp5866vwlj.rs:8:48\n  |\n8 |     numbers.iter().fold((isize::zero(),\
    \ isize::one()), |(sum, product), i| {\n  |                                  \
    \              ^^^ function or associated item not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0,0);\n  \
    \  }\n    let mut sum = 0;\n    let mut prod = 1;\n    for n in numbers {\n  \
    \      sum += n;\n        prod *= n;\n    }\n    (sum, prod)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp3l55xq58.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(0, |sum, number| {\n        match\
    \ number {\n            0 => sum,\n            _ => sum + number,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8fsef9op.rs:8:25\n  |\n8 |\
    \     numbers.iter().fold(0, |sum, number| {\n  |                         ^ expected\
    \ tuple, found integer\n  |\n  = note: expected tuple `(isize, isize)`\n     \
    \         found type `{integer}`\n\nerror[E0369]: cannot add `&isize` to `(isize,\
    \ isize)`\n  --> /tmp/tmp8fsef9op.rs:11:22\n   |\n11 |             _ => sum +\
    \ number,\n   |                  --- ^ ------ &isize\n   |                  |\n\
    \   |                  (isize, isize)\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum_product = numbers[0];\n    for number in numbers.iter().skip(1)\
    \ {\n        sum_product += number;\n    }\n\n    (sum_product, numbers[0])\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(100, 100)`,\n right: `(100, 0)`', /tmp/tmp7t7vhm_s.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.into_iter().fold(\n        (0, 1),\n      \
    \  |sum, number| {\n            (sum + number, sum * number)\n        }\n    )\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `(isize, isize)`\n  --> /tmp/tmprirmtbfd.rs:11:18\n\
    \   |\n11 |             (sum + number, sum * number)\n   |              --- ^\
    \ ------ isize\n   |              |\n   |              (isize, isize)\n\nerror[E0369]:\
    \ cannot multiply `(isize, isize)` by `isize`\n  --> /tmp/tmprirmtbfd.rs:11:32\n\
    \   |\n11 |             (sum + number, sum * number)\n   |                   \
    \         --- ^ ------ isize\n   |                            |\n   |        \
    \                    (isize, isize)\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    numbers.iter().fold(0, |sum, number| sum + number).map(|sum| {\n  \
    \      sum * numbers.len() as isize\n    });\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmp4s1wp9w4.rs:11:56\n\
    \   |\n11 |     numbers.iter().fold(0, |sum, number| sum + number).map(|sum| {\n\
    \   |                                                        ^^^ `isize` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: Iterator`\n           which is required by `&mut isize: Iterator`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp4s1wp9w4.rs:7:40\n  |\n7 | fn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n  |    -----------                        \
    \ ^^^^^^^^^^^^^^ expected tuple, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note:  expected\
    \ tuple `(isize, isize)`\n          found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ &i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi0xcglsv.rs:10:9\n   |\n\
    10 |     for &i in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (0,1),\n        |(sum,\
    \ product), x| {\n            assert!(x > 0);\n            (sum + x, product *\
    \ x),\n        }\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpd_py50zx.rs:12:35\n   |\n12 |             (sum + x, product * x),\n\
    \   |                                   ^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_py50zx.rs:11:25\n\
    \   |\n11 |             assert!(x > 0);\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&0`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut product = 1;\n    let mut sum = 0;\n    for n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0,1)\n    } else\
    \ {\n        let mut product = 1;\n        let mut sum = 0;\n\n        numbers.iter().for_each(|num|{\n\
    \            sum = sum + num;\n            product = product*num;\n        });\n\
    \        (sum, product)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers\n        .iter()\n        .cloned()\n     \
    \   .fold((0, 1))\n        .unwrap_or_else(|| panic!(\"Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\"))\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp1eqowary.rs:11:10\n     |\n11   |         .fold((0, 1))\n   \
    \  |          ^^^^ ------ supplied 1 argument\n     |          |\n     |     \
    \     expected 2 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0,0);\n  \
    \  }\n    let mut sum = numbers.iter().sum();\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum *= num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpsz7mkaml.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0isize, 1isize)\n\
    \    } else {\n        let mut sum = 0isize;\n        let mut product = 1isize;\n\
    \n        for &num in &numbers {\n            sum += num;\n            product\
    \ *= num;\n        }\n\n        (sum, product)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (isize, isize),\n   \
    \     |(sum_so_far, product_so_far), (num)| {\n            (sum_so_far + num,\
    \ product_so_far * num);\n        },\n    )\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n --> /tmp/tmp1tm_54tm.rs:9:10\n\
    \  |\n9 |         (isize, isize),\n  |          ^^^^^ not a value\n\nerror[E0423]:\
    \ expected value, found builtin type `isize`\n --> /tmp/tmp1tm_54tm.rs:9:17\n\
    \  |\n9 |         (isize, isize),\n  |                 ^^^^^ not a value\n\nwarning:\
    \ unnecessary parentheses around pattern\n  --> /tmp/tmp1tm_54tm.rs:10:40\n  \
    \ |\n10 |         |(sum_so_far, product_so_far), (num)| {\n   |              \
    \                          ^   ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n10 -         |(sum_so_far,\
    \ product_so_far), (num)| {\n10 +         |(sum_so_far, product_so_far), num|\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tm_54tm.rs:10:47\n\
    \   |\n10 |           |(sum_so_far, product_so_far), (num)| {\n   |  _______________________________________________^\n\
    11 | |             (sum_so_far + num, product_so_far * num);\n   | |         \
    \                                            - help: remove this semicolon\n12\
    \ | |         },\n   | |_________^ expected tuple, found `()`\n   |\n   = note:\
    \  expected tuple `(isize, isize)`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0308, E0423.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (1, 1)\n    } else\
    \ {\n        let mut sum = 0;\n        let mut product = 1;\n        for n in\
    \ numbers {\n            sum += n;\n            product *= n;\n        }\n   \
    \     (sum, product)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1, 1)`,\n right: `(0, 1)`', /tmp/tmpx433w_p3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers[0] + numbers[1], numbers[0] * numbers[1])\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpz3ha02bl.rs:8:6\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum: isize = 0;\n    let mut product: isize = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = numbers[0];\n    let mut product = 1;\n    for (i,\
    \ &num) in numbers.iter().enumerate() {\n        sum += num;\n        product\
    \ *= i;\n    }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9k5nw2nn.rs:19:11\n   |\n\
    19 |     (sum, product)\n   |           ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     (sum, product.try_into().unwrap())\n   | \
    \                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers[0];\n    let mut product = 1;\n\
    \    for i in numbers.iter() {\n        sum += i;\n        product *= i;\n   \
    \ }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpxce2t9_b.rs:8:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().cloned().fold(\n        (0,1),\n   \
    \     |(sum, product), num| {\n            (sum + num, product * num)\n      \
    \  }\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers.iter().sum();\n    let mut product\
    \ = numbers.iter().product();\n    product = product.rev();\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp5bvckn3t.rs:10:15\n\
    \   |\n9  |     let mut product = numbers.iter().product();\n   |         -----------\
    \ consider giving `product` a type\n10 |     product = product.rev();\n   |  \
    \             ^^^^^^^ cannot infer type\n   |\n   = note: type must be known at\
    \ this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp2tbt_fpp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().map(|x| x * x).sum::<isize>() + (numbers[0],\
    \ 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `(isize, {integer})` to `isize`\n --> /tmp/tmpr7_r2mxx.rs:8:50\n\
    \  |\n8 |     numbers.iter().map(|x| x * x).sum::<isize>() + (numbers[0], 1)\n\
    \  |                                                  ^ no implementation for\
    \ `isize + (isize, {integer})`\n  |\n  = help: the trait `Add<(isize, {integer})>`\
    \ is not implemented for `isize`\n  = help: the following other types implement\
    \ trait `Add<Rhs>`:\n            <&'a f32 as Add<f32>>\n            <&'a f64 as\
    \ Add<f64>>\n            <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n\
    \            <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n      \
    \      <&'a i8 as Add<i8>>\n            <&'a isize as Add<isize>>\n          and\
    \ 48 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n    for n in numbers\
    \ {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for n in numbers {\n        sum += *n;\n        product *= *n;\n \
    \   }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp8823drmc.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp8823drmc.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut product = 1;\n    let mut sum = 0;\n    for i in numbers\
    \ {\n        sum += i;\n        product *= i;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |sum, number| {\n     \
    \   (sum + number, sum * number)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&isize` to `(isize, isize)`\n --> /tmp/tmp3foe7j2f.rs:9:14\n\
    \  |\n9 |         (sum + number, sum * number)\n  |          --- ^ ------ &isize\n\
    \  |          |\n  |          (isize, isize)\n\nerror[E0369]: cannot multiply\
    \ `(isize, isize)` by `&isize`\n --> /tmp/tmp3foe7j2f.rs:9:28\n  |\n9 |      \
    \   (sum + number, sum * number)\n  |                        --- ^ ------ &isize\n\
    \  |                        |\n  |                        (isize, isize)\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers\n        .iter()\n        .map(|x| x * x)\n\
    \        .sum()\n        .cloned()\n        .unwrap()\n        .cloned()\n   \
    \     .product()\n        .cloned()\n        .unwrap()\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpinoezo52.rs:11:10\n\
    \   |\n11 |         .sum()\n   |          ^^^ cannot infer type for type parameter\
    \ `S` declared on the associated function `sum`\n   |\n   = note: type must be\
    \ known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n11 |         .sum::<S>()\n   |             +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(0, |mut sum, number| sum + number)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvkk6yxsw.rs:8:25\n  |\n8 |\
    \     numbers.iter().fold(0, |mut sum, number| sum + number)\n  |            \
    \             ^ expected tuple, found integer\n  |\n  = note: expected tuple `(isize,\
    \ isize)`\n              found type `{integer}`\n\nerror[E0369]: cannot add `&isize`\
    \ to `(isize, isize)`\n --> /tmp/tmpvkk6yxsw.rs:8:50\n  |\n8 |     numbers.iter().fold(0,\
    \ |mut sum, number| sum + number)\n  |                                       \
    \       --- ^ ------ &isize\n  |                                             \
    \ |\n  |                                              (isize, isize)\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum_num = 0;\n    let mut prod = 1;\n    for i in numbers {\n\
    \        sum_num += i;\n        prod *= i;\n    }\n    (sum_num, prod)\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut sum = numbers.iter().sum();\n    let mut product = numbers.iter().product();\n\
    \    if product > 0 {\n        product = 1;\n    }\n    if sum > 0 {\n       \
    \ sum = 1;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpt9qjtt45.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpycjw58po.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for i in numbers\
    \ {\n        sum += i;\n        product *= i;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += *n;\n        product *= *n;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpibn23lgc.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpibn23lgc.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for &n in numbers {\n\
    \        sum += n;\n        product *= n;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk18a819l.rs:13:9\n   |\n\
    13 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().rev().sum(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpotysrigb.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0)\n  \
    \  }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for i in numbers\
    \ {\n        sum += i;\n        product *= i;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp2focxvy9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers.iter() {\n        sum += n;\n        product *= n;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (vec!(0), 1),\n     \
    \   |(sum, product), x| {\n            (sum.iter().skip(x).fold(\n           \
    \     product,\n                |mut sum, mut product| {\n                   \
    \ sum.push(x);\n                    product * x\n                }),\n       \
    \     sum.iter().sum())\n        }\n    )\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbfjljepj.rs:9:10\n  |\n9 |\
    \         (vec!(0), 1),\n  |          ^^^^^^^ expected `isize`, found struct `Vec`\n\
    \  |\n  = note: expected type `isize`\n           found struct `Vec<{integer}>`\n\
    \  = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `iter` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpbfjljepj.rs:11:18\n   |\n\
    11 |             (sum.iter().skip(x).fold(\n   |                  ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `iter` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpbfjljepj.rs:17:17\n   |\n17 |  \
    \           sum.iter().sum())\n   |                 ^^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = isize::ZERO;\n    let mut product = isize::ONE;\n\
    \    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `ZERO` found for type `isize` in\
    \ the current scope\n --> /tmp/tmpgs9vewk8.rs:8:26\n  |\n8 |     let mut sum =\
    \ isize::ZERO;\n  |                          ^^^^ associated item not found in\
    \ `isize`\n\nerror[E0599]: no associated item named `ONE` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpgs9vewk8.rs:9:30\n  |\n9 |     let mut product\
    \ = isize::ONE;\n  |                              ^^^ associated item not found\
    \ in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut result = 0;\n    let mut product = 1;\n\n \
    \   for n in numbers.iter() {\n        result = result + n;\n        product *=\
    \ n;\n    }\n    (result, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), number|\
    \ {\n        (sum + number, product * number)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers[0], numbers.iter().product())\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpjlrm9w22.rs:8:6\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut product = 1;\n    let mut sum = 0;\n    for n in numbers {\n\
    \        sum = sum + n;\n        product = product * n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ &x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp_lf1oql.rs:10:9\n   |\n\
    10 |     for &x in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (1, 0);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for x in numbers {\n\
    \        sum += x;\n        product *= x;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1, 0)`,\n right: `(0, 1)`', /tmp/tmpj_e6c8yt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum = sum + num;\n        product *= num;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers.size() > 0);\n    let mut sum = 0;\n\
    \    let mut product = 1;\n\n    for i in numbers.iter() {\n        sum += i;\n\
    \        product *= i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<isize>` in the\
    \ current scope\n --> /tmp/tmpj8hnu2hy.rs:8:21\n  |\n8 |     assert!(numbers.size()\
    \ > 0);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers.iter() {\n        sum += n;\n        product *= n;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for n in numbers {\n        sum += *n;\n        product *= *n;\n \
    \   }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpnpq5j0k1.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpnpq5j0k1.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum_product = numbers[0] as isize;\n    let mut product = 1;\n\
    \    for n in numbers {\n        sum_product += n;\n        product *= n;\n  \
    \  }\n    (sum_product, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(4, 1)`,\n right: `(3, 1)`', /tmp/tmp5qvat6tz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = isize::zero();\n    let mut product =\
    \ isize::one();\n    for n in numbers {\n        sum += *n;\n        product *=\
    \ *n;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `zero` found for type\
    \ `isize` in the current scope\n --> /tmp/tmpnjybm9zk.rs:8:26\n  |\n8 |     let\
    \ mut sum = isize::zero();\n  |                          ^^^^ function or associated\
    \ item not found in `isize`\n\nerror[E0599]: no function or associated item named\
    \ `one` found for type `isize` in the current scope\n --> /tmp/tmpnjybm9zk.rs:9:30\n\
    \  |\n9 |     let mut product = isize::one();\n  |                           \
    \   ^^^ function or associated item not found in `isize`\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpnjybm9zk.rs:11:16\n   |\n11 |\
    \         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpnjybm9zk.rs:12:20\n   |\n12 |         product\
    \ *= *n;\n   |                    ^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 0);\n \
    \   }\n    let mut product_sum = 0;\n    let mut product_product = 1;\n    for\
    \ (i, number) in numbers.iter().enumerate() {\n        product_sum += number;\n\
    \        product_product *= number;\n    }\n    (product_sum, product_product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp7yewuq0i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum_mut_temp = 0;\n    let mut product_mut_temp\
    \ = 1;\n    for number in numbers {\n        sum_mut_temp += number;\n       \
    \ product_mut_temp *= number;\n    }\n    (sum_mut_temp, product_mut_temp)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum: isize = 0;\n    let mut product: isize = 1;\n    for n\
    \ in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut total = 0;\n    let mut product = 1;\n    for n in numbers\
    \ {\n        total += n;\n        product *= n;\n    }\n    (total, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), n| {\n\
    \        (sum + n, product * n)\n    })\n}\n\nfn main() {\n    let candidate =\
    \ sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (isize, 1),\n       \
    \ |acc, n| {\n            (acc * n, acc * n + (*n as isize))\n        }\n    )\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n --> /tmp/tmpdfla29z_.rs:9:10\n\
    \  |\n9 |         (isize, 1),\n  |          ^^^^^ not a value\n\nerror[E0369]:\
    \ cannot multiply `(isize, isize)` by `&isize`\n  --> /tmp/tmpdfla29z_.rs:11:18\n\
    \   |\n11 |             (acc * n, acc * n + (*n as isize))\n   |             \
    \ --- ^ - &isize\n   |              |\n   |              (isize, isize)\n\nerror[E0369]:\
    \ cannot multiply `(isize, isize)` by `&isize`\n  --> /tmp/tmpdfla29z_.rs:11:27\n\
    \   |\n11 |             (acc * n, acc * n + (*n as isize))\n   |             \
    \          --- ^ - &isize\n   |                       |\n   |                \
    \       (isize, isize)\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0423.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n\n    for number in numbers {\n        sum += number;\n        product\
    \ *= number;\n    }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers.iter().sum();\n    let mut product\
    \ = numbers.iter().product();\n    if sum == 0 {\n        sum = product;\n   \
    \     product = 1;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1, 1)`,\n right: `(0, 1)`', /tmp/tmpqrsl0m_5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (0, 1),\n        |mut\
    \ sum, number| {\n            sum += number;\n            (sum, sum * number)\n\
    \        }\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `(isize, isize)`\n  --> /tmp/tmpi97y_bkw.rs:11:13\n   |\n11 |             sum\
    \ += number;\n   |             ---^^^^^^^^^^\n   |             |\n   |       \
    \      cannot use `+=` on type `(isize, isize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi97y_bkw.rs:12:14\n   |\n12 |             (sum, sum * number)\n\
    \   |              ^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `(isize, isize)`\n\nerror[E0369]: cannot\
    \ multiply `(isize, isize)` by `&isize`\n  --> /tmp/tmpi97y_bkw.rs:12:23\n   |\n\
    12 |             (sum, sum * number)\n   |                   --- ^ ------ &isize\n\
    \   |                   |\n   |                   (isize, isize)\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n   \
    \ }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(!numbers.is_empty());\n    (numbers.iter().sum(),\
    \ numbers.iter().product())\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: !numbers.is_empty()', /tmp/tmpkh_7iy25.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers[0];\n    let mut product = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        sum += numbers[i];\n        product\
    \ *= numbers[i];\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp97bcwv_0.rs:8:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold(\n        (0, 1),\n        |mut\
    \ sum, number| {\n            *sum += number;\n            *sum\n        },\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `(isize, isize)` cannot be dereferenced\n  --> /tmp/tmpk8eab81l.rs:11:13\n\
    \   |\n11 |             *sum += number;\n   |             ^^^^\n\nerror[E0614]:\
    \ type `(isize, isize)` cannot be dereferenced\n  --> /tmp/tmpk8eab81l.rs:12:13\n\
    \   |\n12 |             *sum\n   |             ^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += *n;\n        product *= *n;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp55x3hrta.rs:11:16\n\
    \   |\n11 |         sum += *n;\n   |                ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp55x3hrta.rs:12:20\n   |\n12 |        \
    \ product *= *n;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut total = 0;\n    let mut product = 1;\n    for num in numbers\
    \ {\n        total += num;\n        product *= num;\n    }\n    (total, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), value|\
    \ {\n        (sum + value, product * value)\n    });\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ujqz6yu.rs:7:40\n   |\n\
    7  | fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n   |    -----------\
    \                         ^^^^^^^^^^^^^^ expected tuple, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n10 |     });\n   |       - help: remove this semicolon\n   |\n   = note:\
    \  expected tuple `(isize, isize)`\n           found unit type `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0,0);\n  \
    \  }\n    let mut product = 1;\n    let mut sum = 0;\n    for number in numbers.iter()\
    \ {\n        sum += number;\n        product *= number;\n    }\n    return (sum,\
    \ product);\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpi7blawxk.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum: isize = 0;\n    let mut product: isize\
    \ = 1;\n\n    for n in numbers {\n        sum += n;\n        product *= n;\n \
    \   }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(numbers.len() == 2);\n    let mut sum = 0;\n\
    \    let mut product = 1;\n    for i in numbers {\n        sum += i;\n       \
    \ product *= i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: numbers.len() == 2', /tmp/tmp3hsgjyum.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0, 0)\n    } else\
    \ {\n        let mut product = 1;\n        let mut sum = 0;\n\n        for number\
    \ in numbers.iter() {\n            sum += number;\n            product *= number;\n\
    \        }\n\n        (sum, product)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp3e9rfn1o.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        (0, 1)\n    } else\
    \ {\n        let mut product = 1;\n        let mut sum = 0;\n        for x in\
    \ numbers {\n            sum += x;\n            product *= x;\n        }\n   \
    \     (sum, product)\n    }\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    assert!(!numbers.is_empty());\n\n    let mut sum =\
    \ numbers[0] as isize;\n    let mut product = numbers[0] as isize;\n    for n\
    \ in numbers {\n        sum += n;\n        product *= n;\n    }\n\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: !numbers.is_empty()', /tmp/tmpec7xnrx5.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = numbers[0];\n    let mut product = numbers[0];\n\
    \n    for number in numbers {\n        sum += number;\n        product *= number;\n\
    \    }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp30n6bljt.rs:8:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
