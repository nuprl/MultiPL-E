name: HumanEval_55_fib
language: rust
prompt: "/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n\
  /// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10),\
  \ 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n  \
  \  assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"
completions: ["    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n      \
    \  return 1;\n    }\n    fib(n-1).add(fib(n-2))", "    let mut a = 0;\n    let\
    \ mut b = 1;\n    while n > 0 {\n        n -= 1;\n        a += b;\n        b =\
    \ a;\n    }\n    a", "    let mut n1 = 0, n2 = 1, next_n = (n1 + n2) as isize;\n\
    \    while next_n <= n {\n        (&mut n1, &mut n2) = (n2, n1 + n2);\n      \
    \  next_n = (n1 + n2) as isize;\n    }\n    return n2;", "    let mut f = 0;\n\
    \    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let c =\
    \ a + b;\n        a = b;\n        b = c;\n    }\n    b", "    let mut a = 1;\n\
    \    let mut b = 1;\n    for _ in 0..n {\n        (a, b) = (b, a + b);\n    }\n\
    \    b", "    use std::mem::size_of;\n\n    if n < 2 { return n }\n    fib(n +\
    \ 1) if n % 2 == 0 { fib(n - 1) }\n    fib(n + 2) if n % 2 == 1 { fib(n - 2) }\n\
    \    n", "    fn rec(acc: isize, n: isize) -> isize {\n        if n == 0 {\n \
    \           acc\n        } else {\n            rec(acc + fib(n - 1), n - 2)\n\
    \        }\n    }\n    rec(0, n)", "    if n == 0 { return 1 }\n    if n == 1\
    \ { return 0 }\n    fib(n-1) + fib(n-2)", "    let mut cache: Vec<isize> = vec![0;\
    \ 2];\n    cache[1] = cache[0] = 0;\n    for i in 1..n {\n        let sum = cache[2*i]\
    \ + cache[2*i+1];\n        cache[i] = sum;\n    }\n    cache[n]", "    use std::mem;\n\
    \n    let mut a = 0;\n    let mut b = 1;\n\n    while n != 0 {\n        let c\
    \ = mem::replace(&mut a, b);\n        b = mem::replace(&mut b, a + b);\n     \
    \   a = mem::replace(&mut a, c);\n        n -= 1;\n    }\n\n    a", "    if n\
    \ < 2 {\n        return 1;\n    }\n\n    return fib(n - 1) + fib(n - 2);", " \
    \   if n < 2 {\n        return n;\n    }\n\n    fib(n + 1) + fib(n + 2)", "  \
    \  if n < 2 {\n        return n;\n    }\n\n    return fib(n-1) + fib(n-2);", " \
    \   // Base case.\n    if n < 2 {\n        return n;\n    }\n    // Recursive\
    \ case.\n    fib_rec(n - 1, n - 2);", "    match n {\n        0 => 0,\n      \
    \  1 => 1,\n        _ => fib(n - 1) + fib(n - 2)\n    }", "    if n == 0 {\n \
    \       return 0;\n    } else if n == 1 {\n        return 1;\n    } else {\n \
    \       return fib(n - 1) + fib(n - 2);\n    }", "    if n < 2 {\n        return\
    \ n;\n    }\n\n    let mut a = 1usize;\n    let mut b = 2usize;\n    for i in\
    \ 0..n - 1 {\n        let tmp_a = a;\n        let tmp_b = b;\n        a = b;\n\
    \        b = tmp_a + tmp_b;\n    }\n\n    a", "    if n <= 2 {\n        return\
    \ n;\n    }\n\n    fib(n + 1)", "    if n < 2 {\n        return n;\n    }\n  \
    \  fib(n + 1)", "    if n <= 2 { return n }\n    fib(n-1) + fib(n-2)", "    let\
    \ a = 1;\n    let b = 1;\n    while n > 2 {\n        let t = a;\n        a = b;\n\
    \        b = t + a;\n        n -= 1;\n    }\n    return a;", "    if n <= 0 {\n\
    \        0\n    } else {\n        fib(n - 2) + fib(n - 1)\n    }", "    fn fib_i(i:\
    \ usize) -> isize {\n        if i <= 1 {\n            i\n        } else {\n  \
    \          fib_i(i-1) + fib_i(i-2)\n        }\n    }\n\n    match n {\n      \
    \  0 => 1,\n        1 => 1,\n        _ => fib_i(n),\n    }", "    // use std::mem::swap;\n\
    \    // use std::cmp::PartialOrd;\n    let mut mem = Vec::new();\n    if n <=\
    \ 0 {\n        mem[0] = 0;\n        mem[1] = 1;\n        return 1;\n    }\n  \
    \  if n == 2 {\n        mem[0] = 2;\n        mem[1] = 1;\n        return 2;\n\
    \    }\n    for _ in 1..n {\n        mem.push(0);\n        mem.push(1);\n    }\n\
    \    mem.swap(1);\n    if n == 2 {\n        mem[0] = 2;\n        mem[1] = 1;\n\
    \        return 2;\n    }\n    for ii in 2..n {\n        mem[ii] += mem[ii-1];\n\
    \    }\n    mem[0] += mem[1];\n    mem[1] += mem[0];\n    return mem[1];", " \
    \   if n <= 1 {\n        1\n    } else {\n        fib(n-1) + fib(n-2)\n    }",
  "    use std::mem;\n    if n < 2 {\n        return n;\n    }\n\n    let mut prev:\
    \ isize = 0;\n    let mut curr = 1;\n    for _ in 0..n {\n        curr = curr\
    \ + prev;\n        prev = curr - prev;\n    }\n    mem::forget(prev);\n\n    curr",
  "    if n < 0 {\n        panic!(\"Invalid fib{}\", n);\n    }\n    if n == 2 ||\
    \ n == 0 {\n        return n;\n    }\n    fib_rec(n - 1, n - 2)", "    let mut\
    \ current = 1;\n    let mut previous = 0;\n    while n > 1 {\n        current\
    \ += previous;\n        previous = current;\n        n -= 1;\n    }\n    current",
  "    if n < 2 {\n        return 1;\n    }\n\n    let mut result = fib(n - 2) + fib(n\
    \ - 1);\n    result", "    if n < 2 {\n        return n;\n    }\n    return fib(n\
    \ - 1) + fib(n - 2);", "    fib::memoize_inner {\n        let mut fib: isize =\
    \ 0;\n        let mut a: isize = 0;\n        for _ in 0..n {\n            fib\
    \ += a;\n            a = fib;\n        }\n        fib\n    }", "    if n < 0 {\n\
    \        0\n    } else {\n        if n == 0 || n == 1 {\n            return 1;\n\
    \        }\n        let mut a = 1;\n        let mut b = 1;\n        for _ in 0..n\
    \ {\n            let c = a + b;\n            a = b;\n            b = c;\n    \
    \    }\n        b\n    }", "    if n < 2 {\n        return 1;\n    }\n    let\
    \ mut f1 = 1;\n    let mut f2 = 1;\n    let mut c = 1;\n    while n > 0 {\n  \
    \      (c, f) = (c + f1, f + f2);\n        n -= 1;\n    }\n    c", "    debug_assert!(n\
    \ >= 0);\n    if n == 0 {\n        return 1;\n    }\n    fib(n-1)+fib(n-2)", " \
    \   if n < 2 {\n        return 1;\n    }\n    if n == 2 {\n        return 1;\n\
    \    }\n    if n == 3 {\n        return 2;\n    }\n    let mut f1 = 1;\n    let\
    \ mut f2 = 1;\n    for i in 3..n {\n        let tmp = f2;\n        f2 = f1;\n\
    \        f1 = tmp + f1;\n    }\n    f1", "    use std::io;\n    let mut fib =\
    \ Vec::new();\n    fn aux(n: isize) -> isize {\n        if n == 0 {\n        \
    \    0;\n        } else if n == 1 {\n            1;\n        } else {\n      \
    \      fib[n] = aux(n - 1) + aux(n - 2);\n        }\n        fib[n]\n    }\n \
    \   fib.push(aux(n));\n    fib.push(aux(n - 1));\n    fib.as_slice()", "    //\
    \ check if n > 0\n    if n <= 0 {\n        return 1;\n    }\n\n    fib(n-1) +\
    \ fib(n-2)", '    (1..n).fold(0, |a, i| a + fib(i - 1))', '    (1..=n).fold(0,
    |a, b| a + b)', "    fn iter() -> isize {\n        // Initialisations\n      \
    \  let mut a = 1usize;\n        let mut b = 2usize;\n        let mut c = 3usize;\n\
    \        // Infinite loop\n        while c < n {\n            // Fibonacci numbers\
    \ are consecutive integers starting from 1.\n            a = b;\n            b\
    \ = c + a;\n            c = a + b;\n        }\n        c\n    }\n\n    iter()",
  "    if n < 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n  \
    \      fib(n - 1) + fib(n - 2)\n    }", "    if n < 2 {\n        1\n    } else\
    \ {\n        fib(n-1) + fib(n-2)\n    }", "    fn fib_recur(\n        a: isize,\n\
    \        b: isize,\n        res: isize,\n        mut next: Option<isize>\n   \
    \ ) -> isize {\n        match *next {\n            None => a + b,\n          \
    \  Some(v) => fib_recur(a, v, Some(b), None),\n        }\n    }\n\n    fib_recur(0,\
    \ 1, None, Some(n))", "    if n <= 2 {\n        return n;\n    }\n\n    fib(n-1)\
    \ + fib(n-2)", "    fn fib_impl(n: isize) -> isize {\n        if n < 2 {\n   \
    \         return n\n        }\n        fib_impl(n - 1) + fib_impl(n - 2)\n   \
    \ }\n\n    fib_impl(n)", "    match n {\n        0 | 1 | 2 => n,\n        _ =>\
    \ fib(n-1) + fib(n-2),\n    }", "    use std::mem::swap;\n\n    let mut a = 0;\n\
    \    let mut b = 1;\n    for i in 0..n {\n        swap(&mut a, &mut b);\n    }\n\
    \    b", "    if n < 2 {\n        return n;\n    }\n    return fib(n-1) + fib(n-2);",
  "    let mut a = 1;\n    let mut b = 1;\n    if n > 0 {\n        let mut c = 1;\n\
    \        while n != 0 {\n            let t = a;\n            a = b;\n        \
    \    b = c;\n            c = t;\n            n -= 1;\n        }\n    }\n    b",
  "    let mut a = 0;\n    let mut b = 1;\n    while n > 0 {\n        (a, b) = (b,\
    \ a + b);\n        n -= 1;\n    }\n    b", "    fn fibo(mut fib: isize, f: isize,\
    \ s: isize) -> isize {\n        if f < 0 { return fib; }\n        if s == 0 {\
    \ return f; }\n        return fibo(fib, f - 1, s - 1) + fibo(fib, f - 1, s);\n\
    \    }\n\n    fibo(1, 1, n)", "    // Simplify the expressions ...\n    // (n\
    \ + 2) / 3\n    // n + (n / 3)\n    let mut x = 1;\n    let mut y = 1;\n    for\
    \ i in 0..n {\n        (x, y) = (x + y, x);\n    }\n    x", "    // Amortized\
    \ O(1)\n    if n < 2 {\n        return 1;\n    }\n\n    let mut fibs = [0, 1];\n\
    \    for (i, &fib) in fibs.iter_mut().enumerate() {\n        *fib = *fib + fibs[i\
    \ - 1];\n    }\n\n    fibs[n]", "    if n == 0 || n == 1 {\n        return n;\n\
    \    }\n\n    fib(n-1) + fib(n-2)", "    if n == 0 {\n        return 0;\n    }\n\
    \    fn fib_tail(n: isize, acc: isize) -> isize {\n        if n == 1 {\n     \
    \       return acc;\n        }\n        return fib_tail(n - 1, acc + n);\n   \
    \ }\n    return fib_tail(n, 0);", "    let mut fib_cache: [isize, isize; 3] =\
    \ [1, 0, 1];\n    let mut prev = 0;\n    let mut curr = 1;\n    while n > 2 {\n\
    \        fib_cache[0] = prev;\n        fib_cache[1] = curr;\n        let tmp =\
    \ fib_cache[1];\n        prev = curr;\n        curr = tmp + fib_cache[0] + fib_cache[2];\n\
    \        n -= 1;\n    }\n    fib_cache[2]", "    let mut a: i32 = 0;\n    let\
    \ mut b: i32 = 1;\n    while n != 0 {\n        let tmp = &mut a;\n        a =\
    \ b;\n        b = tmp + b;\n        n = n - 1;\n    }\n    b", "    use std::mem::replace;\n\
    \    if n < 0 {\n        panic!(\"Fibonacci number index out of range\")\n   \
    \ }\n    if n < 2 {\n        return 1;\n    }\n    let mut fib1 = 1;\n    let\
    \ mut fib2 = 1;\n    for i in 1..n {\n        fib1 = fib2;\n        fib2 = replace(fib2,\
    \ fib1 + fib2);\n    }\n    fib2", "    fn fib_rec(_: isize, a: isize, b: isize)\
    \ -> isize {\n        a + b\n    }\n\n    fib_rec(n - 2, 0, 1)", "    if n <=\
    \ 2 {\n        return n;\n    }\n\n    fib(n + 1).unwrap()", "    fn fib(n: isize)\
    \ -> (isize, isize) {\n        if n < 2 {\n            (n, n)\n        } else\
    \ {\n            fib(n - 1) + fib(n - 2)\n        }\n    }\n\n    fib(n).0", " \
    \   if n <= 2 {\n        1\n    } else {\n        fib(n-1) + fib(n-2)\n    }",
  "    fn fib_iter(a: isize, mut b: isize) -> isize {\n        while b < 2 {\n   \
    \         (a, b) = (b, a + b);\n        }\n        (b, b)\n    }\n    if n < 0\
    \ {\n        panic!(\"fib({}): negative number\", n);\n    }\n    if n <= 1 {\n\
    \        return n;\n    }\n    if n == 2 {\n        return 1;\n    }\n    fib_iter(1,\
    \ 0)\n        .take_while(|&x| x <= n)\n        .next_back()\n        .map(|&x|\
    \ x * fib_iter(n - x, x))\n        .collect()", "    if n == 0 {\n        return\
    \ 0;\n    }\n    fib_rec(n - 1, fib_rec(n - 2, n))", "    if n <= 1 {\n      \
    \  return n;\n    }\n\n    fib(n-1)+fib(n-2)", "    fn fibonacci(n: isize) ->\
    \ isize {\n        if n < 2 {\n            n\n        } else {\n            fibonacci(n-1)\
    \ + fibonacci(n-2)\n        }\n    }\n    fibonacci(n)", "    let mut f1 = 1;\n\
    \    let mut f2 = 1;\n    for i in 1..n {\n        let sum = &f1 + &f2;\n    \
    \    f1 = f2;\n        f2 = sum;\n    }\n    &f2", "    if (n == 0) {\n      \
    \  return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    return\
    \ fib(n-1) + fib(n-2);", "    if n <= 2 {\n        return 1\n    }\n    else {\n\
    \        return fib(n-1) + fib(n-2)\n    }", "    if n < 2 {\n        return n;\n\
    \    }\n\n    let mut n1 = 1;\n    let mut n2 = 1;\n\n    while n2 < n {\n   \
    \     n1 = n2;\n        n2 = n1 + n2;\n    }\n\n    n1", "    if n < 2 {\n   \
    \     return n;\n    }\n    fib(n + 1).clone()", "    match n {\n        0 =>\
    \ 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if\
    \ n <= 2 {\n        return n;\n    }\n    return fib(n-2) + fib(n-1);", "    use\
    \ std::cmp::Ordering;\n    use std::cmp::PartialOrd;\n    use std::ops::Add;\n\
    \    let mut a = 1;\n    let mut b = 1;\n    let mut i = 2;\n    while i < n {\n\
    \        let y = a + b;\n        a = b;\n        b = y;\n        i += 1;\n   \
    \ }\n    b", "    fn fib(num: isize) -> isize {\n        if num == 0 {\n     \
    \       return 0;\n        }\n        if num == 1 {\n            return 1;\n \
    \       }\n        return fib(num - 1) + fib(num - 2);\n    }\n    fib(n as isize)",
  "    if n < 2 {\n        return n;\n    }\n    let mut first = 1;\n    let mut second\
    \ = 1;\n    for i in 2..=n {\n        let tmp = first;\n        first = second;\n\
    \        second = tmp + second;\n    }\n    first", "    fn fib_aux(n: isize)\
    \ -> isize {\n        if n <= 1 {\n            return n;\n        }\n        fib_aux(n-1)\
    \ + fib_aux(n-2)\n    }\n    fib_aux(n)", "    let mut f1 = 1;\n    let mut f2\
    \ = 1;\n\n    if n < 2 {\n        return n;\n    }\n\n    for _ in 0..(n-2) {\n\
    \        let tmp = &f1;\n        f1 = &f2;\n        f2 = tmp + &f2;\n    }\n\n\
    \    f2", "    if n == 0 || n == 1 {\n        return n;\n    }\n    let mut a:\
    \ isize = 0;\n    let mut b: isize = 1;\n    let mut c: isize = 0;\n    for i\
    \ in 0..n {\n        let tmp = c;\n        c = a + b;\n        a = b;\n      \
    \  b = tmp;\n    }\n    return c;", "    match n {\n        0 => 0,\n        1\
    \ => 1,\n        _ => fib(n - 1) + fib(n - 2)\n    }", "    let mut a = 1;\n \
    \   let mut b = 1;\n    loop {\n        let mut c = a + b;\n        a = b;\n \
    \       b = c;\n        if n == 0 {\n            break;\n        }\n        n\
    \ -= 1;\n    }\n    b", "    if n == 0 {\n        return 0;\n    } else if n ==\
    \ 1 {\n        return 1;\n    }\n\n    let mut a = 1;\n    let mut b = 1;\n  \
    \  for _ in 0..n {\n        let c = a + b;\n        a = b;\n        b = c;\n \
    \   }\n    b", "    if n <= 1 {\n        return n;\n    }\n    return fib(n -\
    \ 2) + fib(n - 1);", "    fn fib(n: isize) -> isize {\n        if n < 2 { n }\n\
    \        else {\n            fib(n-1) + fib(n-2)\n        }\n    }\n    fib(n)",
  "    if n < 2 {\n        return n;\n    }\n    return fib(n - 2) + fib(n - 1);",
  "    match n {\n        0 | 1 => n,\n        n if n <= 2 => n,\n        _ => fib(n\
    \ - 2) + fib(n - 1),\n    }", "    // base case\n    if n == 0 || n == 1 {\n \
    \       return n;\n    }\n\n    // recursion step\n    let result = fib(n - 2)\
    \ + fib(n - 1);\n    \n    // base case\n    if result >= n {\n        return\
    \ result;\n    }\n\n    // recursion step\n    let result = fib(n - 1) + fib(n\
    \ - 2);\n\n    // base case\n    if result >= n {\n        return result;\n  \
    \  }\n\n    // recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n \
    \   // base case\n    if result >= n {\n        return result;\n    }\n\n    //\
    \ recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n    // base case\n\
    \    if result >= n {\n        return result;\n    }\n\n    // recursion step\n\
    \    let result = fib(n - 1) + fib(n - 2);\n\n    // base case\n    if result\
    \ >= n {\n        return result;\n    }\n\n    // recursion step\n    let result\
    \ = fib(n - 1) + fib(n - 2);\n\n    // base case\n    if result >= n {\n     \
    \   return result;\n    }\n\n    // recursion step\n    let result = fib(n - 1)\
    \ + fib(n - 2);\n\n    // base case\n    if result >= n {\n        return result;\n\
    \    }\n\n    // recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n\
    \    // base case\n    if result >= n {\n        return result;\n    }\n\n   \
    \ // recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n    // base\
    \ case\n    if result >= n {\n        return result;\n    }\n\n    // recursion\
    \ step\n    let result = fib(n - 1) + fib(n - 2);\n\n    // base case\n    if\
    \ result >= n {\n        return result;\n    }\n\n    // recursion step\n    let\
    \ result = fib(n - 1) + fib(n - 2);\n\n    // base case\n    if result >= n {\n\
    \        return result;\n    }\n\n    // recursion step\n    let result = fib(n\
    \ - 1) + fib(n - 2);\n\n    // base case\n    if result >= n {\n        return\
    \ result;\n    }\n\n    // recursion step\n    let result = fib(n - 1) + fib(n\
    \ - 2);\n\n    // base case\n    if result >= n {\n        return result;\n  \
    \  }\n\n    // recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n \
    \   // base case\n    if result >= n {\n        return result;\n    }\n\n    //\
    \ recursion step\n    let result = fib(n - 1) + fib(n - 2);\n\n    // base case\n\
    \    if result >= n {\n        return result;\n    }\n\n    // recursion step\n\
    \    let result = fib(n - 1) + fib(n - 2);\n\n    // base case\n    if result\
    \ >= n {\n        return result;\n    }", "    fn fib_tail(a: isize, mut b: isize)\
    \ -> isize {\n        b += a;\n        a + b\n    }\n\n    if n < 2 {\n      \
    \  return n;\n    }\n\n    if n > 2 {\n        fib_tail(fib(n - 1), fib(n - 2))\n\
    \    } else {\n        fib_tail(0, 1) // unreachable\n    }", "    assert!(n >\
    \ 0);\n    if n < 2 { return n }\n\n    let mut a = 1;\n    let mut b = 1;\n\n\
    \    for _ in 0..n {\n        (a, b) = (b, a + b);\n    }\n\n    a", "    if n\
    \ == 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n\
    \    return fib(n-1) + fib(n-2)", "    if n == 0 || n == 1 {\n        return n;\n\
    \    }\n\n    return fib(n-1) + fib(n-2);", "    if n <= 2 {\n        return 1;\n\
    \    }\n    fib(n).wrapping_add(fib(n - 1))", "    if n <= 2 {\n        return\
    \ n;\n    }\n    fib(n + 1).clone()", "    if n < 2 {\n        1\n    } else {\n\
    \        fib(n - 1) + fib(n - 2)\n    }", "    if n <= 2 {\n        return n;\n\
    \    }\n    fib2(n - 1, n - 2);", "    if n <= 2 {\n        return n;\n    }\n\
    \n    let mut a = fib(n-1);\n    let mut b = fib(n-2);\n    while a < b {\n  \
    \      if a < b {\n            a *= 2;\n        } else {\n            b *= 3;\n\
    \        }\n    }\n    return b;", "    if n <= 0 {\n        return 0;\n    }\n\
    \    fn fib_aux(a: isize, mut b: isize) -> isize {\n        let mut res = a;\n\
    \        if b <= 2 {\n            res = b;\n        }\n        else {\n      \
    \      *a += b;\n            fib_aux(a, *b);\n        }\n        res\n    }\n\
    \    fib_aux(0, 1);", "    let mut a = 1;\n    let mut b = 1;\n    for _ in 0..n\
    \ {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n    b", " \
    \   let mut n2: isize = 1;\n    let mut n3: isize = 2;\n\n    for _ in 0..(n-2)\
    \ {\n        n2 += n3;\n        n3 = n2;\n    }\n\n    n2", "    if n == 0 {\n\
    \        return 0;\n    }\n    fib(n-1) + fib(n-2)", "    if n < 2 {\n       \
    \ return n\n    }\n    return fib(n-1) + fib(n-2)", "    if n < 2 {\n        1\n\
    \    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    if n <= 1 { return\
    \ n; }\n    fib(n-1)+fib(n-2)", "    if n < 2 {\n        return n;\n    }\n  \
    \  fib(n-1)+fib(n-2)", "    if n < 2 {\n        n\n    } else {\n        fib(n-1)\
    \ + fib(n-2)\n    }", "    if n <= 2 {\n        return n;\n    }\n\n    let mut\
    \ a = 1;\n    let mut b = 1;\n    let mut c = 1;\n\n    for i in 2..n {\n    \
    \    let tmp = a;\n        a = b;\n        b = c;\n        c = tmp + b;\n    }\n\
    \n    return c;", "    let a = 1;\n    let b = 1;\n\n    for i in 1..n {\n   \
    \     let c = a + b;\n        a = b;\n        b = c;\n    }\n\n    b", "    if\
    \ n <= 2 {\n        return n;\n    }\n\n    fib(n + 1) + fib(n + 2)", "    if\
    \ n <= 1 {\n        return n;\n    }\n\n    let mut a = 1;\n    let mut b = 1;\n\
    \    for _ in 0..n {\n        let c = a + b;\n        a = b;\n        b = c;\n\
    \    }\n    b", "    if n < 2 {\n        return n;\n    }\n    fib_rec(n - 1,\
    \ n - 2)", "    fn fib_impl(_n: usize) -> isize {\n        if _n == 0 {\n    \
    \        return 1;\n        }\n        if _n == 1 {\n            return 1;\n \
    \       }\n        let a = fib_impl(_n - 1);\n        let b = fib_impl(_n - 2);\n\
    \        a * a + b * b\n    }\n    fib_impl(n).unwrap()", "    let mut a: isize\
    \ = 0, b: isize = 1;\n    for _ in 0..n {\n        (a, b) = (b, a + b);\n    }\n\
    \    b", "    if n == 0 {\n        return 0;\n    } else if n == 1 {\n       \
    \ return 1;\n    }\n    fib(n-1).add(fib(n-2))", "    let mut a = 0;\n    let\
    \ mut b = 1;\n    while n > 1 {\n        let tmp = a + b;\n        a = b;\n  \
    \      b = tmp;\n        n -= 1;\n    }\n    a", "    match n {\n        0 =>\
    \ 0,\n        1 => 1,\n        2 => 1,\n        _ => fib(n - 2) + fib(n - 1),\n\
    \    }", "    let mut a = 1;\n    let mut b = 1;\n    for i in 1..n {\n      \
    \  let tmp_a = a;\n        let tmp_b = b;\n        a = b;\n        b = tmp_a +\
    \ tmp_b;\n    }\n    a", "    if n <= 2 { return 1 }\n    fib(n-2) + fib(n-1)",
  '    (0..n).fold(1, |a, b| a + b)', "    if n < 2 {\n        n\n    } else {\n \
    \       fib(n-1) + fib(n-2)\n    }", "    if n < 2 {\n        return n;\n    }\n\
    \    let mut a = 1;\n    let mut b = 1;\n    for i in 1..n {\n        let tmp\
    \ = a;\n        a = b;\n        b = tmp + b;\n    }\n    a", "    if n < 2 {\n\
    \        return n;\n    }\n    fib(n + 1).partial_cmp(&fib(n))", "    if n <=\
    \ 2 {\n        return n;\n    }\n    let mut a: isize = 0;\n    let mut b: isize\
    \ = 1;\n    for _ in 0..n {\n        let tmp = a;\n        a = b;\n        b =\
    \ tmp + b;\n    }\n    a", "    if n < 2 {\n        n\n    } else {\n        fib(n\
    \ - 1) + fib(n - 2)\n    }", "    if n == 0 {\n        return 0;\n    }\n    fib(n\
    \ * 2 + 1).try_into().unwrap()", "    use std::mem;\n    mem::swap(mem::replace(mem::replace(mem::replace::<isize>(fib_0(),\
    \ fib_1()), fib_2()), fib_3()), fib_4());\n    let mut sum = 1;\n    for _ in\
    \ 0..(n + 1) {\n        sum = fib_5(sum);\n    }\n    mem::swap(fib_6(), fib_7());\n\
    \    sum", "    use std::cmp::min;\n\n    if n <= 0 {\n        return 0;\n   \
    \ }\n\n    let mut result = fib(n - 2) + fib(n - 1);\n    if n % 2 == 0 {\n  \
    \      result = result / 2;\n    }\n\n    result", "    if n < 2 {\n        return\
    \ n;\n    }\n    let mut a = 1;\n    let mut b = 1;\n    for i in 2..n {\n   \
    \     let mut tmp_a = a;\n        let mut tmp_b = b;\n        a = b;\n       \
    \ b = tmp_a + tmp_b;\n    }\n    b", "    if n == 0 || n == 1 {\n        return\
    \ n;\n    }\n    fib(n-1) + fib(n-2)", "    if n <= 2 {\n        return n;\n \
    \   }\n\n    fib(n-1)+fib(n-2)", '    (n <= 1) ? 1 : fib(n-1) + fib(n-2)', " \
    \   if n <= 1 {\n        return n;\n    }\n    fib(n - 1) + fib(n - 2)", "   \
    \ match (&n)\n    {\n        (isize::MAX,) => {\n            assert!(n == 0);\n\
    \            return 1;\n        }\n        (0,) => 1,\n        (n, _) => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    if n <= 2 {\n        return 1\n    }\n    return\
    \ fib(n - 2) + fib(n - 1)", "    if n < 2 {\n        return n;\n    }\n    return\
    \ fib(n-1) + fib(n-2);", "    if n <= 2 {\n        1\n    } else {\n        fib(n\
    \ - 1) + fib(n - 2)\n    }", "    if n < 2 {\n        return n;\n    }\n    fib(n\
    \ + 1) + (fib(n) + fib(n + 2))", "    if n == 0 || n == 1 {\n        return n;\n\
    \    }\n    fib(n-2) + fib(n-1)", "    if n < 2 {\n        return 1;\n    }\n\
    \    fib(n-1).add(fib(n-2))", "    // http://programmingpraxis.com/2009/02/12/fibonacci-number-program-in-ocaml/\n\
    \    let mut n1, n2, n3, n4, n5, n6, n7, n8, n9;\n    n1 = n2 = n3 = n4 = n5 =\
    \ n6 = n7 = n8 = n9 = n;\n    while n9 > 0 {\n        let mut c = n1;\n      \
    \  n1 += n2;\n        n2 += n3;\n        n3 += n4;\n        n4 += n5;\n      \
    \  n5 += n6;\n        n6 += n7;\n        n7 += n8;\n        n8 += n9;\n      \
    \  n9 -= c;\n    }\n    n9", "    if n < 2 {\n        return n;\n    }\n\n   \
    \ return fib(n-1) + fib(n-2);", "    if n == 0 {\n        return 0\n    }\n  \
    \  \n    fn fib1(n: isize) -> isize {\n        if n == 0 {\n            return\
    \ 1\n        }\n        fib1(n - 1) + fib1(n - 2)\n    }\n    \n    return fib1(n\
    \ - 1) + fib1(n - 2)", "    use std::cmp::Ordering;\n    let mut a = 1;\n    let\
    \ mut b = 1;\n    let mut i = 0;\n\n    while i < n {\n        let tmp = a + b;\n\
    \        a = b;\n        b = tmp;\n        i += 1;\n    }\n\n    return b;", " \
    \   fn fib_recursive(n: isize) -> isize {\n        if n == 0 || n == 1 {\n   \
    \         return 1;\n        }\n\n        return fib_recursive(n - 1) + fib_recursive(n\
    \ - 2);\n    }\n    fib_recursive(n)", "    assert!(n >= 0);\n\n    if n < 2 {\n\
    \        return n;\n    }\n\n    if n == 2 {\n        return 1;\n    }\n\n   \
    \ let mut sum = 0;\n    let mut cur = 2;\n    while cur < n {\n        sum +=\
    \ cur;\n        cur += 1;\n    }\n\n    sum", "    if n == 0 || n == 1 {\n   \
    \     return n;\n    }\n    fib(n-1) + fib(n-2)", "    if n < 2 {\n        return\
    \ n;\n    }\n\n    fib(n-1).clone()\n        + fib(n - 2).clone()", "    assert!(n\
    \ > 0 && n <= 20, \"Invalid number for Fibonacci sequence\");\n    fn fib_aux(x:\
    \ isize) -> isize {\n        if x == 0 {\n            return 1;\n        }\n \
    \       if x == 1 {\n            return x;\n        }\n        let y = fib_aux(x\
    \ - 1) + fib_aux(x - 2);\n        y.0\n    }\n    fib_aux(n)", "    use std::cmp::Ordering;\n\
    \    let mut current = 1;\n    let mut next = 2;\n\n    loop {\n        current\
    \ += next;\n        next += current;\n\n        if next > n {\n            break;\n\
    \        }\n    }\n\n    current", "    let mut a = 0, b = 1;\n    for _ in 0..n\
    \ {\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    a",
  "    if n < 2 {\n        return n;\n    }\n\n    return fib(n-1) + fib(n-2);", " \
    \   assert!(n >= 0, \"Invalid Fibonacci number: negative numbers are not allowed\"\
    );\n    assert!(n <= 4, \"Invalid Fibonacci number: number must be <= 4\");\n\
    \    match n {\n        1 => 1,\n        2 => 1,\n        3 => 2,\n        _ =>\
    \ fib(n - 1) + fib(n - 2)\n    }", "    use std::mem;\n    mem::transmute((*const\
    \ fn +)(n)).0", "    match (n - 2).checked_add(n - 1) { // O(n)\n        // Base\
    \ cases: n == 0 || n == 1\n        0 | 1 => 0,\n        // Recursive cases: n\
    \ > 0\n        n => fib(n - 1) + fib(n - 2)\n    }", "    if n == 0 || n == 1\
    \ {\n        return n;\n    }\n    fib(n + 1).clone() + fib(n).clone()", "   \
    \ if n < 2 {\n        return n;\n    }\n    fib(n + 1) + fib(n + 2)", "    if\
    \ n < 2 {\n        return n;\n    }\n\n    let mut a = 1;\n    let mut b = 1;\n\
    \    for i in 0..n {\n        let tmp = a + b;\n        a = b;\n        b = tmp;\n\
    \    }\n    b", "    let mut n1: isize = n.checked_add((n - 1) / 2) as isize;\n\
    \    let mut n2: isize = n.checked_add((n - 2) / 2) as isize;\n    loop {\n  \
    \      if n1 < 2 {\n            n1 += 1;\n        } else {\n            n2 +=\
    \ 1;\n        }\n        if n2 < 2 {\n            n2 += 1;\n        }\n      \
    \  if n1 == n2 {\n            break;\n        }\n    }\n    n1", "    if n < 2\
    \ {\n        return n;\n    }\n\n    fib(n + 1) + fib(n + 2)", "    if n <= 1\
    \ {\n        return n;\n    }\n    return fib(n-1) + fib(n-2);", "    let mut\
    \ n1: isize = 0;\n    let mut n2: isize = 1;\n\n    for _ in 0..n {\n        if\
    \ n1 < n2 {\n            n1 += 1;\n        }\n        else {\n            n2 +=\
    \ 1;\n        }\n    }\n\n    n2", "    if n <= 1 {\n        return n\n    }\n\
    \n    fib(n-1) + fib(n-2)", "    if n <= 2 {\n        return n;\n    }\n\n   \
    \ if n > 2 {\n        return fib(n - 1) + fib(n - 2);\n    }", '    n <= 2 ? 1
    : (fib(n - 2) + fib(n - 1))', "    let mut f0 = 1;\n    let mut f1 = 1;\n    let\
    \ mut f2 = 1;\n    if n > 2 {\n        f0 = 0;\n        f1 = 1;\n        f2 =\
    \ 1;\n        for _ in 0..n - 2 {\n            let f = f0 + f1;\n            f1\
    \ = f2;\n            f2 = f;\n        }\n    }\n    f2", "    if n < 2 {\n   \
    \     return 1;\n    }\n\n    // If n is odd, multiply by fib(n - 2) + fib(n -\
    \ 1).\n    // Else return fib(n - 1) + fib(n - 2).\n    let result = (n - 2) *\
    \ fib(n - 1) + fib(n - 2);\n    if n % 2 == 1 {\n        result\n    } else {\n\
    \        result\n    }", "    let mut a = 0;\n    let mut b = 1;\n    for i in\
    \ 0..n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n\
    \    b", "    if n == 0 || n == 1 {\n        return n;\n    }\n\n    fib(n) +\
    \ fib(n - 1)", "    if n < 2 {\n        return n\n    }\n\n    fib(n-1) + fib(n-2)",
  "    if n <= 2 {\n        return n;\n    }\n    fib_rec(n - 1, n - 2);", "    //\
    \ Special case for n = 0 --> 0 fib\n    if n == 0 {\n        return 0;\n    }\n\
    \n    // Special case for n = 1 --> 1 fib\n    if n == 1 {\n        return 1;\n\
    \    }\n\n    // Use recursion to calculate fibonacci number\n    // when n is\
    \ greater than 2\n    return fib_recur(n);", "    if n < 2 {\n        return n;\n\
    \    }\n    fib(n + 1).clone()", "    use std::cmp::Ordering;\n    if n <= 2 {\n\
    \        return n;\n    }\n\n    fn compute(mut n: isize) -> isize {\n       \
    \ if n < 2 {\n            return n;\n        }\n\n        n -= 1;\n        compute(n\
    \ - 2) + compute(n - 1);\n    }\n\n    compute(n);", '    fib(n, 1).0', "    if\
    \ n == 0 || n == 1 {\n        return n;\n    }\n    return fib(n-2) + fib(n-1);",
  "    debug_assert!(n > 0);\n    if n <= 1 {\n        return n;\n    }\n    fib(n\
    \ + 1).call(0)", "    assert!(n >= 0);\n    assert!(n <= 31);\n\n    let mut a\
    \ = 0;\n    let mut b = 1;\n    let mut fib: isize = 0;\n\n    for i in 0..n {\n\
    \        fib += a;\n        (a, b) = (b, a + b);\n    }\n    fib", "    fn next()\
    \ -> (isize, isize) {\n        let (a, b) = (2, 1);\n        if n == 0 { 0 }\n\
    \        else if n < 2 { b }\n        else { let (a, b) = (b, a + b) }\n    }\n\
    \    loop {\n        match next() {\n            (0, 0) => break,\n          \
    \  (mut a, b) => a,\n        }\n    }\n    a", "    assert!(n >= 0 && n < 100000);\n\
    \    if n==0 || n==1 {\n        return n;\n    }\n    fib(n-1) + fib(n-2)", " \
    \   // use std::cmp::min;\n    let mut f0 = 1;\n    let mut f1 = 1;\n    for i\
    \ in 0..n {\n        let new_f0 = f0;\n        let new_f1 = f1;\n        f0 =\
    \ new_f1;\n        f1 = new_f0 + new_f1;\n    }\n    f0", "    if n <= 0 {\n \
    \       return 0;\n    }\n    fib(n-1) + fib(n-2)", '    (1..n).fold(0, |a, b|
    a + b)', "    if n <= 1 {\n        return n;\n    }\n    return fib(n - 1) + fib(n\
    \ - 2);", "    if n < 2 {\n        n\n    } else {\n        fib(n - 1) + fib(n\
    \ - 2)\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n        _ =>\
    \ fib(n - 1) + fib(n - 2)\n    }", "    // special cases\n    if n < 2 {\n   \
    \     return n;\n    }\n\n    if n == 2 {\n        return 1;\n    }\n\n    let\
    \ mut a = 0;\n    let mut b = 1;\n    while n > 2 {\n        let c = a + b;\n\
    \        a = b;\n        b = c;\n        n -= 1;\n    }\n    b", "    if n <=\
    \ 1 {\n        return n;\n    }\n    return fib(n-1) + fib(n-2);", "    if (n\
    \ < 2) => 1\n    else => fib(n-1) + fib(n-2)", "    if n < 2 {\n        return\
    \ n;\n    }\n    return fib(n-1) + fib(n-2);", "    // use 'return' statement\
    \ instead of 'return' to avoid return value optimization on ARM processors\n \
    \   if n == 0 {\n        return 0;\n    }\n    if n == 1 || n == 2 {\n       \
    \ return 1;\n    }\n    return fib(n - 1) + fib(n - 2);", "    if n == 0 || n\
    \ == 1 {\n        return n;\n    }\n    return fib(n-1) + fib(n-2);", "    assert!(n\
    \ > 0);\n\n    let mut f1 = 1;\n    let mut f2 = 1;\n\n    for _ in 0..n {\n \
    \       let f3 = f1 + f2;\n        f1 = f2;\n        f2 = f3;\n    }\n\n    f2",
  "    if n <= 1 {\n        return n;\n    }\n    fib(n + 1) + fib(n-1)", "    use\
    \ std::mem;\n\n    fn cache() -> isize {\n        let mut value = mem::uninitialized();\n\
    \        let mut cache = [0, 1];\n        for _ in 0..n {\n            value =\
    \ cache[0 % 2];\n            cache[1 %= 2] = value;\n        }\n        value\n\
    \    }\n\n    cache() * cache() + 1", "    let mut f1 = 1;\n    let mut f2 = 1;\n\
    \    let mut c = 1;\n    while n > 2 {\n        let p = f1;\n        let q = f2;\n\
    \        f1 = f2;\n        f2 = p;\n        c = p + q + c;\n        n = n - 1;\n\
    \    }\n    return c;", "    if n < 2 {\n        return n;\n    }\n    let mut\
    \ first = 0;\n    let mut second = 1;\n    let mut fib_sum = first;\n    for i\
    \ in 1..n {\n        fib_sum += second;\n        first = second;\n        second\
    \ = fib_sum;\n    }\n    fib_sum", "    if n < 2 {\n        n\n    } else {\n\
    \        fib(n - 1) + fib(n - 2)\n    }", "    if n <= 2 {\n        return n;\n\
    \    }\n\n    fib(n * 2 + 1) as isize", "    let mut a1 = 1;\n    let mut a2 =\
    \ 1;\n    for i in 0..n {\n        a1 = a1 + a2;\n        a2 = a1;\n    }\n  \
    \  a1", "    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n-1)\
    \ + fib(n-2),\n    }", "    let mut a = 1;\n    let mut b = 1;\n    for i in 1..n\
    \ {\n        (a, b) = (b, a+b);\n    }\n    a"]
stop_tokens:
- "\n}"
