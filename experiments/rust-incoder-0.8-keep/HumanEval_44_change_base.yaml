name: HumanEval_44_change_base
language: rust
prompt: "/// Change numerical base of input number x to base.\n/// return string representation\
  \ after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8,\
  \ 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n/// >>> change_base(7, 2)\n\
  /// '111'\nfn change_base(x: isize, base: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
  \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
  ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
  \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
  1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
  \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
  ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
  \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
  ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
completions: ["    let mut digits = vec![];\n    let mut base = base;\n    while x\
    \ >= base {\n        digits.push((x % base).to_string());\n        x = x / base;\n\
    \    }\n    digits.push((x).to_string());\n    digits.reverse()\n        .iter()\n\
    \        .fold(String::new(), |mut acc, digit| {\n            acc.push_str(digit);\n\
    \            acc.push('0');\n            acc\n        })", "    let mut s = String::new();\n\
    \    let mut tmp = 0;\n    let mut base10 = 1;\n    let mut tmp10 = 0;\n    while\
    \ base10 < base {\n        tmp = x.pow(base10).unwrap();\n        tmp10 = tmp\
    \ % base10;\n        s = s.concat(tmp10 + '0');\n        base10 *= base;\n   \
    \ }\n    if x.pow(base).unwrap() != x {\n        s = s.concat('1');\n    }\n \
    \   s", "    let mut digits = x.to_digits();\n    digits.reverse();\n    for i\
    \ in 0..digits.get(base) {\n        digits.insert(i, base);\n    }\n    String::from_digits(digits,\
    \ base).to_string()", "    let mut result = String::new();\n    let mut counter\
    \ = 1;\n    let mut digits = (0..x).collect::<Vec<_>>();\n    for digit in &digits\
    \ {\n        let mut remainder = (*digit).mod(base);\n        digit = match remainder\
    \ {\n            0 => digit,\n            1 => base,\n            2 => base /\
    \ 2,\n            _ => base,\n        };\n        if digit != 0 {\n          \
    \  if remainder == 1 {\n                result.push((*digit).to_string());\n \
    \           } else {\n                result.push((*digit).to_string());\n   \
    \             result.push((*remainder).to_string());\n            }\n        \
    \    counter += 1;\n        }\n    }\n    if counter == 0 {\n        result.push((*x).to_string());\n\
    \    }\n    result", "    let mut s = String::new();\n    let mut base = base;\n\
    \n    while x > 0 {\n        let tmp = x % base;\n        s += String::from(\"\
    0123456789abcdef\".chars()[tmp].to_string());\n        x = x / base;\n       \
    \ base = base * 10;\n    }\n    if base > 10 {\n        let tmp = x % base;\n\
    \        s += String::from(\"0123456789abcdef\".chars()[tmp].to_string());\n \
    \   }\n    s", "    let mut x = x.to_digits(base, 10);\n    x.reverse();\n   \
    \ let mut result = String::new();\n    for i in x {\n        result.append(&i\
    \ + '0');\n    }\n    result", "    let mut digits = String::new();\n    while\
    \ x > 0 {\n        let digit = x % base;\n        x = x / base;\n        if digits\
    \ != \"0\".to_owned() + &digit + &digits[1..] {\n            digits += &digit;\n\
    \        }\n    }\n    return digits.to_string();", "    let mut res = String::new();\n\
    \    while x >= base {\n        res.insert(0, &x.to_string().rjust(base, '0'));\n\
    \        x = x / base;\n    }\n    res.insert(0, &x.to_string());\n    res", " \
    \   let mut y = x;\n    let mut base: char;\n\n    // Check that the base is indeed\
    \ valid for this number\n    assert!(base >= 2 && base <= 10);\n\n    // Convert\
    \ from base to radix\n    base = base as char;\n\n    // Check for overflow\n\
    \    if y > i32::MAX as isize {\n        y = i32::MAX as isize;\n        base\
    \ += 'a' - '0';\n    }\n\n    // Convert to binary\n    let mut bin: String;\n\
    \    if base == 10 {\n        bin = format!(\"{:b}\", y);\n    } else if base\
    \ == 8 {\n        bin = format!(\"{:o}\", y);\n    } else if base == 5 {\n   \
    \     bin = format!(\"{:x}\", y);\n    } else {\n        bin = format!(\"{:#o}\"\
    , y);\n    }\n    // Add prefix if necessary\n    let mut prefix: String;\n  \
    \  let mut prefix_len = 1;\n\n    // Count leading zeros\n    let mut leading_zeros:\
    \ usize = 0;\n    while y < i32::MAX as usize {\n        leading_zeros += 1;\n\
    \        y /= base;\n    }\n    // Prefix leading zeros\n    let mut prefix =\
    \ String::new();\n    for _ in 0..leading_zeros {\n        prefix.push(0);\n \
    \   }\n    // Add radix char\n    prefix.push(base);\n\n    // Add prefix, if\
    \ needed\n    if prefix.len() > prefix_len {\n        bin = prefix + bin;\n  \
    \  }\n    // Convert to string\n    bin.to_string()", "    if base > 10 {\n  \
    \      Err(format!(\"Invalid base: {}.\", base))\n    } else if base < 2 {\n \
    \       Err(format!(\"Invalid base: {}.\", base))\n    } else {\n        let mut\
    \ xs: Vec<String> = x.to_string().chars().map(|c| c.to_string()).collect();\n\
    \        xs[x.len() - 1] += match xs[x.len() - 1] {\n            \"0\" => \"i\"\
    ,\n            \"1\" => \"j\",\n            \"2\" => \"k\",\n            _ =>\
    \ panic!(\"Invalid base\"),\n        };\n        xs.into_iter().fold(String::new(),\
    \ |mut acc, x| {\n            acc.push_str(x);\n            acc.push_str(&mut\
    \ x[x.len() - 1]);\n            acc\n        })\n    }", '    format!("{}", x.to_digits(base).unwrap().to_digits(base).unwrap())',
  "    let mut x = x;\n    let mut base = base;\n    if x <= 10 {\n        base =\
    \ base * 10 + x;\n        x = x;\n    }\n    let mut str = \"\";\n    for &n in\
    \ &x {\n        let mut x = n;\n        for &b in &base {\n            x = x *\
    \ b;\n        }\n        str += &n.to_string();\n    }\n    str", "    let mut\
    \ res = String::new();\n    let mut num_str = x.to_string();\n    while num_str.len()\
    \ >= base {\n        num_str = num_str[..base].to_string();\n        res.insert(0,\
    \ &num_str);\n    }\n    \n    return res.to_string();", "    if base < 1 || base\
    \ > 10 {\n        panic!(\"invalid base\")\n    }\n    let mut digits: Vec<String>\
    \ = vec![];\n    let mut divisor = base;\n    while divisor > 0 {\n        digits.insert(0,\
    \ x % divisor);\n        divisor /= base;\n    }\n    digits.reverse();\n    digits.join(\"\
    0\")", "    match base {\n        2 => {\n            if x == 0 {\n          \
    \      \"0\"\n            } else {\n                format!(\"{:0>3}\", x / base)\n\
    \            }\n        }\n        3 => {\n            if x == 0 {\n         \
    \       \"0\"\n            } else {\n                format!(\"{:0>5}\", x / base)\n\
    \            }\n        }\n        4 => {\n            if x == 0 {\n         \
    \       \"0\"\n            } else {\n                format!(\"{:0>7}\", x / base)\n\
    \            }\n        }\n        _ => format!(\"{:#0>#}\", x, base),\n    }",
  "    use num_traits::FromPrimitive;\n    let number = FromPrimitive::from_i64(x);\n\
    \    let mut result = String::new();\n    let mut i = 0;\n    let mut rem = number;\n\
    \    while rem != 0 {\n        rem /= base;\n        if i == 0 {\n           \
    \ result.resize(i, 0);\n        }\n        result[i] += char::from_integer(rem\
    \ % base);\n        i += 1;\n    }\n    result", "    let mut buf = [0isize; 5];\n\
    \    let mut b = [1isize; 5];\n    let mut x = x as usize;\n    loop {\n     \
    \   buf[base as usize + 1] = x\n            & b[base as usize]\n            as\
    \ usize\n            .checked_mul(base)\n            .unwrap();\n        buf[base\
    \ as usize] = x >> (base as usize);\n        x = x;\n        base = base.checked_add(1);\n\
    \        if base == 5 {\n            break;\n        }\n    }\n    format!(\"\
    {}\", buf[base as usize].to_le_bytes())", "    let mut s = String::new();\n  \
    \  let mut b = base;\n    while b >= 10 {\n        *s.push_str(&format!(\"{}\"\
    , x%b));\n        s +=\n            to_base(&x, b as usize).to_string();\n   \
    \     x /= b;\n        b *= base;\n    }\n    *s.push_str(&format!(\"{}\", x))",
  "    let mut s = String::new();\n    let mut number = x;\n    while number != 0\
    \ {\n        if number % base == 0 {\n            s.push('0');\n        }\n  \
    \      s.push('1');\n        number /= base;\n    }\n    s[s.len() - 1].to_string()",
  "    let mut s = format!(\"{}\", x);\n    match base {\n        10 | 2 | 8 => s.chars().collect::<Vec<_>>().to_owned(),\n\
    \        _ => {\n            let mut i = 0;\n            for c in s.chars().collect::<Vec<_>>()\
    \ {\n                i <<= 1;\n                i |= c - '0';\n            }\n\
    \            i\n        }\n    }", "    match base {\n        2 => String::from_str(x.to_string(),\
    \ \"base2\").unwrap().to_string(),\n        3 => String::from_str(x.to_string(),\
    \ \"base3\").unwrap().to_string(),\n        4 => String::from_str(x.to_string(),\
    \ \"base4\").unwrap().to_string(),\n        5 => String::from_str(x.to_string(),\
    \ \"base5\").unwrap().to_string(),\n        6 => String::from_str(x.to_string(),\
    \ \"base6\").unwrap().to_string(),\n        7 => String::from_str(x.to_string(),\
    \ \"base7\").unwrap().to_string(),\n        _ => panic!(\"Unsupported base.\"\
    ),\n    }", "    let mut result: String = String::new();\n    let mut digits =\
    \ vec![0; base];\n    let mut x: isize = x;\n    let mut base: isize = base;\n\
    \    let mut remainder: isize = 0;\n    while x >= base {\n        remainder =\
    \ x % base;\n        digits[base] = remainder;\n        x = x / base;\n      \
    \  base = base * 10;\n    }\n    digits[base] = x;\n    digits.reverse();\n  \
    \  for digit in digits {\n        result = format!(\"{}\", result) + format!(\"\
    {}\", digit);\n    }\n    result", "    let mut buff = String::new();\n    let\
    \ mut tmp = x;\n    let mut bpow = 1;\n    while tmp >= base {\n        tmp =\
    \ tmp / base;\n        bpow = *bpow * base;\n    }\n    while tmp > 0 {\n    \
    \    buff.push(format!(\"{:?}\", tmp % base));\n        tmp = tmp / base;\n  \
    \  }\n    buff.push(bpow);\n    buff", "    let mut res = String::new();\n   \
    \ let mut digits = x;\n    while digits > 0 {\n        let next = digits % base;\n\
    \        res.insert(0, digits_table[next].to_string());\n        digits /= base;\n\
    \    }\n    res.insert(0, digits_table[x].to_string());\n    res", "    let mut\
    \ digits: Vec<usize> = vec![];\n    let mut digits_digits: Vec<usize> = vec![];\n\
    \    loop {\n        let y = x % base;\n        digits.push(y);\n        x = x\
    \ / base;\n        let digit = digits.last().unwrap();\n        digits_digits.push(digit);\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    let mut digits_digits_len\
    \ = digits_digits_digits.len();\n    let mut digits_len = digits.len();\n    let\
    \ mut result = String::with_capacity(digits_digits.len() * 2);\n    if base >\
    \ 10 {\n        for &digit in &digits_digits {\n            if digit < 10 {\n\
    \                result.push_str(&to_string(*digit).as_str());\n             \
    \   result.push_str(&to_string(digit).as_str());\n            } else {\n     \
    \           result.push_str(&to_string(digit % 10).as_str());\n              \
    \  result.push_str(&to_string(digit / 10).as_str());\n            }\n        }\n\
    \        result.push_str(&to_string(digits_len).as_str());\n        result.push_str(&to_string(digits_digits_len).as_str());\n\
    \    } else {\n        for &digit in &digits_digits {\n            result.push_str(&to_string(digit\
    \ as i32).as_str());\n            result.push_str(&to_string(digit % 10).as_str());\n\
    \        }\n        result.push_str(&to_string(digits_len).as_str());\n      \
    \  result.push_str(&to_string(digits_digits_len).as_str());\n    }\n    result",
  "    let mut base = BASES[base];\n    if base == 0 {\n        panic!(\"invalid base\"\
    );\n    }\n    let mut val = x;\n    let mut digits = 1;\n    while val > base\
    \ {\n        val /= base;\n        digits += 1;\n    }\n    while val > 1 {\n\
    \        val /= 10;\n        digits += 1;\n    }\n    let mut result = String::new();\n\
    \    while digits > 0 {\n        let next = val % (base * 10);\n        result.push(BASES[base].to_string());\n\
    \        val /= base;\n        digits -= 1;\n    }\n    result.reverse();\n  \
    \  result", "    use std::fmt::{Display, Formatter};\n    let mut num_str = format!(\"\
    {}\", x);\n    let mut base_str = format!(\"{}\", base);\n    while base_str.len()\
    \ <= 3 {\n        base_str += base_str.len() > 2 ? base - base_str.len() + 1 :\
    \ base;\n    }\n    base_str.to_string()", "    let mut res = String::new();\n\
    \    for i in 0..base.pow(x.as_u128() % base.pow(base).unwrap()) {\n        if\
    \ i > 0 {\n            res.insert(0, ('0' + i));\n        } else {\n         \
    \   res.insert(0, i.to_string());\n        }\n    }\n    res", "    let mut s\
    \ = String::with_capacity(x.to_string(base).len());\n    x.to_string_into(base).for_each(|v|\
    \ s.push_str(&v.to_string()));\n    s", "    let mut string: String = \"\".to_string();\n\
    \    let mut numerator = x::to_digits(base);\n    let mut denominator: isize =\
    \ 10::to_digits(base);\n\n    numerator.iter().take(numerator.len() % base).for_each(|x|\
    \ {\n        string += &x.to_string();\n    });\n\n    numerator.iter().take(numerator.len()\
    \ / base).for_each(|x| {\n        *string += &x.to_string();\n    });\n\n    denominator\
    \ = numerator.len() / base;\n\n    for d in numerator.iter().take(denominator)\
    \ {\n        string += &d.to_string();\n    }\n\n    string", "    let mut s =\
    \ String::new();\n    for i in x.digits() {\n        let mut b = i / base;\n \
    \       let mut e = i as usize / base;\n        if e != 0 {\n            *b +=\
    \ 1;\n        }\n        s.append(&format!(\"{}\", b));\n    }\n    s[s.len()\
    \ - 1]", "    let mut result = String::new();\n    let mut counter = 0;\n    while\
    \ counter < x {\n        if let Some(ref b) = bases[base] {\n            result\
    \ += \"0123456789abcdefghijklmnopqrstuvwxyz\".to_chars().nth(b as usize + 1).unwrap();\n\
    \        } else {\n            panic!(\"invalid base number: {}\", base);\n  \
    \      }\n        counter += 1;\n    }\n    result", "    match x {\n        1\
    \ => \"1\",\n        2 => \"10\",\n        3 => \"100\",\n        4 => \"1000\"\
    ,\n        5 => \"10000\",\n        6 => \"100000\",\n        7 => \"1000000\"\
    ,\n        8 => \"10000000\",\n        _ => String::from_str(&format!(\"{}{}\"\
    , x / base, base_digits[base]) * base).unwrap(),\n    }", "    if base < 2 {\n\
    \        panic!(\"Changing base to less than 2 from {:?}\", base);\n    }\n  \
    \  if base < 10 {\n        return format!(\"{}\", x as i32 / base) as String;\n\
    \    }\n    // base is greater than 10\n    let mut x = x as i32;\n    let mut\
    \ x_div = x / base;\n    let mut res = String::new();\n    while x_div > 0 {\n\
    \        res.push_str(&x_div % base);\n        x_div = x_div / base;\n    }\n\
    \    x.to_string().to_string().pad(base, ' ').push_str(&res);", "    let mut base10\
    \ = base10.to_string(10);\n    if base == 10 {\n        base10.pop();\n    }\n\
    \    let mut result = format!(\"{}{}\", x, base10);\n    if base < 10 {\n    \
    \    result = result.chars().collect::<String>().reverse().join('');\n    }\n\
    \    result", "    let mut result = String::from(\"0\");\n    while x != 0 {\n\
    \        let remainder = x % base;\n        result += '0' + remainder;\n     \
    \   x /= base;\n    }\n    result", '    x.checked_mul(base).expect("invalid number")',
  "    if x > base || base < 10 {\n        return format!(\"{}\", x);\n    }\n\n \
    \   let mut tmp = x as isize;\n    let mut carry = 0;\n\n    while tmp > 0 {\n\
    \        let tmp = tmp / base;\n        carry = tmp as usize;\n        tmp -=\
    \ carry * base;\n    }\n\n    if carry > 0 {\n        &format!(\"{}{}\", x, base).to_string()\n\
    \    } else {\n        format!(\"{}\", x).to_string()\n    }", "    let mut res\
    \ = String::new();\n    res.push_str(x.to_digits(base).collect::<Vec<_>>().to_owned());\n\
    \    res", "    let mut result = String::new();\n    let mut x = x as usize;\n\
    \    while x > base as usize {\n        result.push((x - base as usize) as char);\n\
    \        x = x / base as usize;\n    }\n    result.push((x - base as usize) as\
    \ char);\n    result", "    let mut result = String::with_capacity(x.to_string().len()\
    \ * 2);\n    let mut remainder = x;\n    for _ in 0..(base as usize) {\n     \
    \   match remainder % base {\n            0 => result.push_str(&mut format!(\"\
    {}\", remainder / base) as String),\n            d | d > base => {\n         \
    \       result.push_str(&mut format!(\"{}{}\", remainder / base, d as char) as\
    \ String);\n                remainder %= base;\n            },\n        };\n \
    \   }\n    result.push_str(&mut format!(\"{}\", remainder) as String);\n    result",
  "    let mut result = String::new();\n    loop {\n        let n = x * base % 10;\n\
    \        result.push_str(n.to_string());\n        if x == 0 {\n            break;\n\
    \        }\n        x /= base;\n    }\n    result", "    let mut s = String::new();\n\
    \    for i in 0..x {\n        s += (i % base) as char;\n    }\n    s", "    let\
    \ mut buf = [0u8; 3];\n    let mut digits = x;\n    let mut new_digits = x;\n\
    \    let mut base = base - 1;\n    while new_digits > 0 {\n        // Get last\
    \ digit in the right base.\n        let digit = digits;\n        if base > 0 {\n\
    \            digit = digit / base;\n        }\n\n        // Keep last digit and\
    \ add it to the next digit.\n        digits = (digit % base) + digits;\n\n   \
    \     // Set last digit to the new base.\n        // If the last digit was in\
    \ base 10 and the new base is 10^k, then the new digit\n        // will be k*10^(k-1).\n\
    \        let mut k = digits % base;\n        if base == 10 {\n            if k\
    \ > 1 {\n                k = k - 1;\n            }\n        } else {\n       \
    \     if k > 2 {\n                k = k - 2;\n            }\n        }\n     \
    \   let digit = k + 10;\n        buf[0] = digit;\n        buf[1] = (digits % base)\
    \ as u8;\n        buf[2] = digit as u8;\n\n        // If last digit was in base\
    \ 10, then multiply by the new base.\n        let last_digit = buf[1..2];\n  \
    \      if base == 10 {\n            new_digits *= base;\n        }\n\n       \
    \ // Divide last digit by new base.\n        new_digits /= base;\n\n        //\
    \ If last digit was in base 10, then subtract it from the new digits.\n      \
    \  if base == 10 {\n            new_digits -= last_digit;\n        }\n    }\n\
    \    String::from_utf8(buf).unwrap()", "    use std::cmp::Ordering;\n\n    let\
    \ x = to_uint(x as isize);\n    let base = to_uint(base as isize);\n\n    if base\
    \ > 10 {\n        panic!(format!(\"Invalid base number for {} value!\", base));\n\
    \    }\n\n    if x == 0 {\n        return String::new();\n    }\n\n    if x >\
    \ base {\n        panic!(\"Invalid base number!\");\n    }\n\n    let mut num\
    \ = x;\n    let mut digit = base.clone();\n\n    while num != 0 {\n        digit--;\n\
    \        num = num / base;\n    }\n\n    let mut string = String::new();\n\n \
    \   for i in 0..digit {\n        string.push(&format!(\"{:0{}b}\", i).chars().collect::<Vec<_>>().to_string());\n\
    \    }\n\n    string += format!(\"{:0{}b}\", num, digit);\n\n    string", "  \
    \  let mut digits = String::new();\n    let mut ten_power = base as isize;\n \
    \   while x > 0 {\n        let mut remaining = x % ten_power;\n        digits.push_str(&format!(\"\
    {}\", remaining));\n        x /= ten_power;\n        ten_power /= base;\n    }\n\
    \    digits", "    assert!(base < 10);\n    let mut xs = to_string(x);\n    let\
    \ mut ans = String::new();\n    while xs.len() > 0 {\n        let mut last_digit\
    \ = xs.chars().nth(-1).unwrap();\n        let mut digit = 1;\n        let mut\
    \ carry = 0;\n        while digit < base {\n            let digit = last_digit\
    \ * 10 + digit;\n            ans.push_str(&to_string(digit + carry));\n      \
    \      digit += 1;\n            carry = digit / base;\n            digit = digit\
    \ % base;\n        }\n        if carry > 0 {\n            ans.push_str(&to_string(digit\
    \ + carry));\n        }\n        xs = &xs[..xs.len() - 1];\n    }\n    ans", " \
    \   let mut s = String::new();\n    let mut base10 = base::pow(10).unwrap();\n\
    \n    for i in x.0..(x.0 as usize) {\n        let b = i as usize;\n        let\
    \ n = base10.trunc(b as u64);\n\n        s.push('0' + n);\n        base10 = base10\
    \ / base;\n    }\n    String::from(s)", "    // TODO: Add tests for valid input\n\
    \    if base == 10 {\n        let mut res = String::new();\n        for x in 0..x\
    \ {\n            res.push_str(format!(\"{:#}\", x as u32));\n        }\n     \
    \   res\n    } else {\n        let mut res = String::new();\n        for x in\
    \ 0..x {\n            res.push_str(format!(\"{:#}\", x as i64 as u64 / base));\n\
    \        }\n        res\n    }", "    use std::cmp::Ordering;\n    use std::str::FromStr;\n\
    \n    use biguint::*;\n\n    let mut x = BigUint::parse_bytes(&x, base)\n    \
    \    .expect(\"cannot parse big int\");\n    let y = x.into();\n    x.divmodq(base);\n\
    \    let z = x.into();\n    let y = y.add(&z).divq(base);\n    let y = y.into_bytes();\n\
    \    x.copy_bytes(&y);\n    x.to_string()", "    let mut res: Vec<String> = vec![];\n\
    \    while x != 0 {\n        let mut div = x % base;\n        res.push(div.to_string());\n\
    \        x /= base;\n    }\n    if res.len() == 0 {\n        res.push(\"\".to_string());\n\
    \    }\n    res.reverse();\n    format!(\"{}\", res.join(\"\"))", "    let mut\
    \ num = x % base;\n    let mut out = [0u8; base.pow3()];\n    while num > 0 {\n\
    \        out.push(num % base);\n        num /= base;\n    }\n    out.reverse();\n\
    \    let mut s = String::new();\n    for i in out {\n        s.push(i.to_string());\n\
    \    }\n    s", "    let mut res = String::new();\n    while x != 0 {\n      \
    \  let digit = x % base;\n        res.push_str(&digit.to_string());\n        x\
    \ /= base;\n    }\n    if res == \"\" {\n        res.push_str(\"0\");\n    }\n\
    \    res", "    let mut res = String::with_capacity(2 * base);\n    let mut num:\
    \ isize = x;\n    for _ in 0..base {\n        res.push_str(num.to_string());\n\
    \        num /= base;\n    }\n    res.push_str(num.to_string());\n    res", " \
    \   let mut v = x.to_string();\n    let mut digits: Vec<usize> = v.chars().map(|c|\
    \ c as usize).collect();\n    let mut new_base: isize = 1;\n    let mut quotient:\
    \ isize = 0;\n    let mut remainder: isize = 0;\n    while quotient < 10 {\n \
    \       let new_digit = (digits.last() + remainder) % 10;\n        remainder =\
    \ digits.last() + new_digit;\n        digits.last_mut().unwrap() = new_digit;\n\
    \        quotient += 1;\n    }\n    if remainder > 0 {\n        let new_digit\
    \ = (digits.last() + remainder) % 10;\n        digits.last_mut().unwrap() = new_digit;\n\
    \        quotient += 1;\n    }\n    if quotient > base {\n        while quotient\
    \ > base {\n            let remainder = digits.last().unwrap() % base;\n     \
    \       digits.last_mut().unwrap() = remainder;\n            quotient -= 1;\n\
    \        }\n        digits.last_mut().unwrap() = (digits.last().unwrap() + quotient)\
    \ % base;\n    }\n    digits.iter().map(|c| char::from_u32(*c)).collect()", " \
    \   let mut string: String = \"\".to_string();\n    for i in x.checked_mul(base.checked_div(10).unwrap()).unwrap().checked_digits(base)\
    \ {\n        string = format!(\"{}{}\", string, i);\n    }\n    string", '    format!("{}",
    x / base)', "    if x >= base {\n        unimplemented!()\n    }\n\n    if base\
    \ == 10 {\n        format!(\"{}\", x)\n    } else {\n        let mut v = x;\n\
    \        let mut base = base;\n        let mut i = 1;\n\n        while v % base\
    \ != 0 {\n            v /= base;\n            i += 1;\n        }\n\n        format!(\"\
    {}{}\", i, change_base(v as usize, base))\n    }", "    let mut s = String::new();\n\
    \    let mut n = 0;\n    while n > 0 {\n        let rem = x % base;\n        if\
    \ rem < 10 {\n            s.push(rem.to_string());\n        } else {\n       \
    \     s.push((rem / 10 + 1).to_string());\n        }\n        x = x / base;\n\
    \    }\n    s", "    let mut s = String::new();\n    let mut exp = base;\n   \
    \ while exp > 0 {\n        // shift right the given number by exp\n        let\
    \ mut x = x >> exp;\n        // convert the given number into string\n       \
    \ match x {\n            0 => s.push_str(\"0\"),\n            _ => s.push_str(char::from_u32(x)?),\n\
    \        }\n        // decrement the given number\n        exp = exp >> 1;\n \
    \   }\n    s", "    let mut res = String::from(\"0\");\n    fn inc(x: isize) ->\
    \ isize {\n        let mut i = 0;\n        let mut y = x;\n        while y < 10\
    \ {\n            i += 1;\n            y = y * base + x;\n        }\n        y\n\
    \    }\n    if x > base {\n        for i in 0..((x + base) / base) {\n       \
    \     res.push_str(&i.to_string());\n        }\n        for i in (x - base..x).rev()\
    \ {\n            res.push_str(&i.to_string());\n        }\n    } else {\n    \
    \    res.push_str(&x.to_string());\n    }\n    res.push_str(&base);\n    res",
  "    let mut result = String::new();\n    let mut digits = x.to_digits();\n    let\
    \ mut base = base.to_digits();\n    for &d in &digits {\n        result.append(format!(\"\
    {}\", base[&d as usize]));\n    }\n    result", "    let mut digits = Vec::new();\n\
    \n    while x != 0 {\n        let remainder = x % base;\n        digits.push(base);\n\
    \        x = x / base;\n    }\n\n    digits.reverse();\n    digits.join(\"\")",
  "    let mut x: isize = x.into();\n    let mut base: isize = base.into();\n    let\
    \ mut y: String = \"\";\n    let mut pow: isize = base;\n    while x >= 10 {\n\
    \        x = x / 10;\n        base = base - 1;\n        pow = pow * 10;\n    }\n\
    \    y += to_digit(x as u8) * pow;\n    if base > 0 {\n        y += to_digit(base\
    \ as u8) * pow;\n    }\n    y", "    let mut result: String = \"\".to_string();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > base {\n      \
    \  digits = &digits[..base];\n        result += '0'.repeat(base - digits.len());\n\
    \    }\n    result += digits;\n    result", "    let mut res = String::new();\n\
    \    while x >= base {\n        res.append(x%base);\n        x = x/base;\n   \
    \ }\n    res.reverse();\n    res.push_str(&*x);\n    return res;", "    if base\
    \ < 2 {\n        let mut result = format!(\"{}\", x);\n        if base < 10 {\n\
    \            while result.len() < base.to_string().len() {\n                result\
    \ = &format!(\"0{}\", result);\n            }\n        } else {\n            while\
    \ result.len() > base.to_string().len() {\n                result = &result[..(base.to_string().len()\
    \ - 1)] + \"0\";\n            }\n        }\n        result\n    } else {\n   \
    \     let mut result = x.to_string();\n        if base < 10 {\n            if\
    \ base == 2 {\n                while result.len() > 2 {\n                    result\
    \ = &result[2..] + \"0\";\n                }\n            } else {\n         \
    \       while result.len() > base.to_string().len() {\n                    result\
    \ = &result[..(base.to_string().len() - 1)] + \"0\";\n                }\n    \
    \        }\n        } else {\n            if base == 2 {\n                while\
    \ result.len() > 2 {\n                    result = &result[2..] + \"0\";\n   \
    \             }\n            } else {\n                while result.len() > base.to_string().len()\
    \ {\n                    result = &result[..(base.to_string().len() - 1)] + \"\
    0\";\n                }\n            }\n        }\n        result\n    }", " \
    \   let mut s = String::new();\n    for digit in x.to_string().chars() {\n   \
    \     let d = digit as char;\n        if base == 10 {\n            if d == '0';\n\
    \            else if d == '1';\n            else {\n                s.push_str(&d);\n\
    \                continue;\n            }\n        }\n        let base = digit_to_base_digit(digit,\
    \ base);\n        let mut new = s.clone();\n        if base != 1 {\n         \
    \   new.push_str(&base.to_string());\n        }\n        new.push_str(&d);\n \
    \       s = new;\n    }\n    s", '    format!("{:0{}b}", x, base)', "    if base\
    \ < 2 {\n        if base < 10 {\n            let mut s = format!(\"{}\", x);\n\
    \            s = s.parse::<usize>().unwrap();\n            format!(\"{}\", s *\
    \ base)\n        } else {\n            format!(\"{}\", x * base)\n        }\n\
    \    } else {\n        String::from(\"0\") // base < 2\n    }", "    let mut res\
    \ = String::with_capacity(x as usize * base);\n    for i in 0..x {\n        let\
    \ mut s = String::new();\n        for j in 0..base {\n            if i == 0 {\n\
    \                s.push('0');\n            }\n            s.push('1');\n     \
    \   }\n        res.push_str(&s);\n    }\n    res", "    if base < 10 {\n     \
    \   String::from(format!(\"{}\", x / base))\n    } else {\n        let mut ret:\
    \ Vec<u8> = vec![0; base];\n        let mut quotient = x;\n        let mut counter\
    \ = 0;\n        while counter < base.len() {\n            quotient = quotient\
    \ / base;\n            for b in &mut ret[counter..].iter_mut() {\n           \
    \     if quotient < 0 {\n                    *b = (quotient % base) as u8;\n \
    \               } else {\n                    *b = quotient % base as u8;\n  \
    \              }\n            }\n            counter = counter + 1;\n        }\n\
    \        String::from_utf8(ret).unwrap()\n    }", "    if base == 1 {\n      \
    \  return format!(\"{:b}\", x);\n    }\n    let mut num = x;\n    let mut remain\
    \ = base;\n    let mut result = String::new();\n    while remain > 0 {\n     \
    \   let quotient = num % base;\n        remain = remain - base;\n        result\
    \ = format!(\"{}{}\", result, (quotient as char).to_string());\n        num =\
    \ num / base;\n    }\n    result", '    x.to_digits(base, 10).to_string()', " \
    \   if base < 10 {\n        return format!(\"{}\", x);\n    }\n    let mut result:\
    \ String = \"\";\n    let mut digits = [0; base];\n    for &digit in x.to_digits().iter()\
    \ {\n        let mut digit = *digit - '0'; // digit := digit - '0'\n        if\
    \ digit < 0 {\n            digit += base;\n        }\n        digits[digits.len()\
    \ - 1 + digit] |= 1 << (digit as usize);\n    }\n    for i in (0..digits.len()\
    \ - 1).rev() {\n        result += format!(\"{}\", digits[i]);\n    }\n    result",
  '    x.to_string().parse::<isize>().unwrap().pow(base).to_string()', "    let mut\
    \ res = String::new();\n    for i in 0..x {\n        let base = itoa(base);\n\
    \        let x = itoa(i);\n        res += x.split_ascii_lowercase().filter(|c|\
    \ c != 'a').join();\n        res += base.split_ascii_lowercase().filter(|c| c\
    \ != 'a').join();\n    }\n    res", "    let mut buffer = String::new();\n   \
    \ let mut remainder = 0;\n    buffer.push_str(&to_string(x / base));\n\n    while\
    \ x % base > 0 {\n        buffer.push('_');\n        x %= base;\n        remainder\
    \ += 1;\n    }\n    buffer.push('_');\n    buffer.push_str(&to_string(remainder));\n\
    \    buffer", "    let mut res = \"0\";\n    while x > 0 {\n        if x % base\
    \ == 0 {\n            res.insert(0, base.to_string());\n            x /= base;\n\
    \        }\n        else {\n            res.insert(0, x.to_string());\n      \
    \      break;\n        }\n    }\n    res.trim_end();\n    res", "    let mut result:\
    \ String = String::new();\n    let mut digits: Vec<isize> = vec![0; base + 1];\n\
    \    let mut remainder: isize = 0;\n    while let Some(digit) = x.to_digit(base)\
    \ {\n        remainder += digit;\n        digits.insert((base - remainder) as\
    \ usize, digit);\n    }\n    for i in 0..digits.len() {\n        let digit = digits[i];\n\
    \        if i < digits.len() - 1 {\n            result.push_str(&format!(\"{:0{}}\"\
    , digit, i));\n        } else {\n            result.push_str(&format!(\"{}\",\
    \ digit));\n        }\n    }\n    result", "    if base == 0 {\n        return\
    \ String::from(x);\n    }\n\n    let mut x = x as u64;\n    let mut base = 10_u32.pow((base\
    \ as i32).checked_div(10).unwrap());\n    let mut x = x as u64;\n    loop {\n\
    \        let ret = format!(\"{}\", x / base);\n        if *ret < '0' || *ret >\
    \ '9' {\n            break;\n        }\n        x = x.checked_mul(base).unwrap()\
    \ as isize;\n        base = base as usize;\n    }\n    format!(\"{}\", x)", " \
    \   let mut s = String::new();\n    if base < 2 {\n        for i in x.to_digits().unwrap()\
    \ {\n            if base == 10 {\n                s.push(i);\n               \
    \ break;\n            }\n            if i < (base as usize) as usize {\n     \
    \           s.push((*i as char).to_string());\n            } else {\n        \
    \        s.push(format!(\"0{}\", i).to_string());\n            }\n        }\n\
    \    } else {\n        let mut b = base as usize;\n        let mut i = 0;\n  \
    \      for i in x.to_digits().unwrap().rev() {\n            if base == 10 {\n\
    \                s.push(i);\n                break;\n            }\n         \
    \   let mut v = b as usize;\n            v -= i as usize;\n            if v ==\
    \ 0 {\n                s.push((*i as char).to_string());\n            } else {\n\
    \                s.push(format!(\"0{}\", v).to_string());\n            }\n   \
    \         i += 1;\n        }\n    }\n    s", "    let mut y = x.to_digits();\n\
    \    let mut z = base;\n    for v in y.iter_mut() {\n        *v = *z % 10;\n \
    \       z /= 10;\n    }\n    format!(\"{}\", y)", "    if base < 2 {\n       \
    \ return format!(\"{}\", x).to_string();\n    }\n\n    let mut out = String::new();\n\
    \    let mut digits: Vec<usize> = vec![];\n    let mut counter = x;\n    let mut\
    \ i = 0;\n    while counter > 0 {\n        let digit = counter % base;\n     \
    \   digits.push(digit);\n        counter /= base;\n        i += 1;\n    }\n  \
    \  let (sign, digit) = if x < 0 { (-1, 0) } else if x == 0 { (0, 1) } else { (1,\
    \ 0) };\n    out += &digits[digits.len() - i - 1].to_string();\n    for digit\
    \ in digits {\n        out.push('-');\n        out.push(digit.to_string());\n\
    \    }\n    out += &format!(\"{}\", digit);\n    out.push_str(sign);\n    out",
  "    if base < 2 {\n        return format!(\"{}\", x);\n    }\n    let mut x = x;\n\
    \    let mut i = 0;\n    while x <= base * base {\n        i += 1;\n        x\
    \ = (x / base).powf(2);\n    }\n    let mut result = x.to_string();\n    if i\
    \ == 0 {\n        result = result.to_string();\n    }\n    for i in 1..(i - 1).rev()\
    \ {\n        let mut n = result.to_string();\n        if n[..1] == '0' {\n   \
    \         n = &n[1..];\n        }\n        let mut n = n.to_string();\n      \
    \  if i == 0 {\n            n = '0' + n;\n        } else {\n            n = '1'\
    \ + n;\n        }\n        result = &n[..];\n    }\n    result", "    use std::mem;\n\
    \n    let mut new_base = base;\n    let mut string = \"\".to_string();\n    loop\
    \ {\n        let rem = x % base;\n        if rem == 0 {\n            string +=\
    \ &format!(\"{}\", new_base);\n            break;\n        }\n        new_base\
    \ += 1;\n        string += &format!(\"{}\", rem);\n        x = x;\n    }\n   \
    \ return string;", "    let mut s = String::new();\n    s.push_str(x.to_string());\n\
    \    let mut base = base.to_string();\n    while base.len() < x.len() {\n    \
    \    base.push('_');\n    }\n    while base.len() < s.len() {\n        s.push_str(base.clone());\n\
    \    }\n    s", "    let mut s = String::new();\n    for i in x.to_string().chars().rev()\
    \ {\n        let mut c = i;\n        if base == 2 {\n            c /= base;\n\
    \        }\n        let digit = if c >= 10 && c < 100 {\n            c\n     \
    \   } else {\n            base * c.checked_add(10).unwrap()\n        };\n    \
    \    s.push(cchar::to_string(digit).unwrap());\n    }\n    s", "    let mut num\
    \ = x.to_string();\n    if num.len() < base.to_string().len() {\n        num.resize(base.to_string().len(),\
    \ '0');\n    }\n    num.swap_to_string(base);\n    num", "    let mut str = String::new();\n\
    \    let mut carry = 0;\n    for &c in str {\n        match x {\n            0\
    \ => break,\n            n => {\n                let mut rem = x.to_digits() +\
    \ base;\n                let mut i = rem;\n                let mut b = (rem[0]\
    \ as usize) as usize;\n                while i < base {\n                    if\
    \ i < base {\n                        i += 1;\n                        rem -=\
    \ 1;\n                    } else {\n                        i += 2;\n        \
    \                rem -= 2;\n                    }\n                    *c = i\
    \ as char;\n                    b += 1;\n                    carry = 0;\n    \
    \            }\n                *c = i as char;\n                *c = if b < base\
    \ { base as char } else { 0 };\n            }\n        }\n    }\n    str", " \
    \   let mut s = String::new();\n    let mut i = 0;\n    for digit in x.to_string().chars().filter(|c|\
    \ c >= '0' && c <= '9') {\n        if digit == char::from_u32(*i).unwrap() {\n\
    \            continue;\n        }\n        if digit > char::from_u32(*i).unwrap()\
    \ {\n            i += 1;\n        }\n        else {\n            let digit = char::to_u32(*i).unwrap();\n\
    \            i += 1;\n            s.push_str(&digit % base);\n        }\n    }\n\
    \    if i == x.to_string().len() {\n        String::from(\"\")\n    } else {\n\
    \        s + '0'\n    }", "    if base < 2 {\n        String::from(\"\".to_string())\n\
    \    } else {\n        let mut num: isize = x;\n        let mut result = String::from(\"\
    \".to_string());\n        while num > 0 {\n            result = (num % base).to_string().append(result);\n\
    \            num /= base;\n        }\n        result\n    }", "    let mut s =\
    \ x.to_digits();\n    s[..base] = s[..base].map(|x| match x {\n        0 => \"\
    0\",\n        1 => \"1\",\n        _ => String::from(\"0\"),\n    });\n    s.to_owned()",
  "    let mut x = x.to_string();\n    let mut base = base.to_string();\n    base\
    \ = format!(\"{}\", base);\n    let mut power = base;\n    let mut ret: String;\n\
    \    let mut digits: Vec<isize>;\n    loop {\n        power = power.remove(1);\n\
    \        let digit = x.remove(0);\n        if digit < base {\n            break;\n\
    \        }\n        let num = digit - base;\n        ret += num.to_string() +\
    \ power;\n    }\n    ret = ret.remove(0);\n    ret", "    let mut result = String::new();\n\
    \    loop {\n        if base < 2 {\n            result.push('-');\n          \
    \  base -= 1;\n        }\n        result.push_str(num2str(x / base).to_string());\n\
    \        if x > 0 {\n            x /= base;\n        } else {\n            return\
    \ result;\n        }\n    }", "    let mut res = String::with_capacity(x);\n \
    \   loop {\n        if x >= base {\n            res.push_str(&format!(\"{}\",\
    \ x % base));\n            x /= base;\n        } else {\n            res.push_str(&format!(\"\
    {}\", x));\n            break;\n        }\n    }\n    res", "    if base < 2 {\n\
    \        return String::from(\"0\".to_string());\n    }\n    let mut s = String::from(\"\
    0\".to_string());\n    let mut xdigits = &mut s[1..];\n    let mut remain = x;\n\
    \    while remain > 0 {\n        let mut digit = remain;\n        remain = remain/base;\n\
    \        if remain < base {\n            digit = base;\n        }\n        xdigits\
    \ = &mut xdigits[digit..];\n    }\n    s", "    let mut y = String::new();\n \
    \   let mut num = x as isize;\n    let mut place = base as isize;\n    while num\
    \ >= base as isize {\n        num = num - place as isize;\n        y.push(num\
    \ % base as char);\n    }\n    y.push(num % base as char);\n    y", "    // let\
    \ mut bases_len = bases.len();\n    let mut result = String::new();\n    loop\
    \ {\n        let mut current_digit = x * (base as usize) as usize;\n        if\
    \ current_digit < 0 {\n            current_digit = -current_digit;\n        }\n\
    \        if current_digit == 0 {\n            break;\n        }\n        match\
    \ base_digit(current_digit as usize) {\n            None => {}\n            Some(digit)\
    \ => {\n                result.push((digit as char).to_string());\n          \
    \  }\n        }\n        current_digit /= base;\n    }\n    result", '    format!("{:0>{base}}",
    x, base=base)', "    let mut output = String::new();\n    let mut base = String::new();\n\
    \    let mut number = String::new();\n    if x == 0 {\n        return \"\";\n\
    \    }\n    if base < 10 {\n        base = &format!(\"0{}\", base);\n    }\n \
    \   while x != 0 {\n        number.push((x % base) as char);\n        x /= base;\n\
    \    }\n    output = &number[..];\n    if let Some(digit) = base {\n        output\
    \ += &digit;\n    }\n    output", "    let mut s = String::new();\n    while x\
    \ > 0 {\n        x /= base;\n        s += *b'0' + &*(b'0'.repeat(x % base));\n\
    \    }\n    s", "    let mut xdigits: Vec<isize> = x.to_string().chars().collect();\n\
    \    let mut base = base;\n    loop {\n        xdigits.pop();\n        let mut\
    \ digit = xdigits.len() as isize;\n        if digit > base {\n            xdigits.resize(digit\
    \ - base);\n        }\n        if digit == 0 {\n            break;\n        }\n\
    \        xdigits[digit as usize] %= base;\n    }\n    format!(\"{}\", xdigits).to_string()",
  "    match base {\n        1 => \"0\".to_string(),\n        2 => \"10\".to_string(),\n\
    \        _ => panic!(\"base must be 1 or 2\"),\n    }\n    x.to_string().chars().map(|c|\
    \ if *c >= base*10 as isize { c % base } else { c + base }).collect()", "    let\
    \ mut s = String::new();\n    if x > 0 {\n        if base < 10 {\n           \
    \ s.push_str(&format!(\"{:0{}}\", x, base));\n        } else {\n            s.push_str(&format!(\"\
    {:0{}b}\", x, base));\n        }\n    } else {\n        if base < 10 {\n     \
    \       s.push_str(&format!(\"{:0{}}\", x, base));\n        } else {\n       \
    \     s.push_str(&format!(\"{:0{}b}\", x, base));\n        }\n    }\n    s", " \
    \   let mut result: String = format!(\"{}\", x);\n\n    while result.len() > base\
    \ {\n        let div = result.len() - base;\n        result[..div].parse::<usize>().unwrap()\n\
    \            .to_string()\n            .chars().nth(div).cloned()\n          \
    \  .join(\"\")?;\n    }\n\n    result", '    x.to_string().parse::<usize>().unwrap()
    % base + 1', "    let mut result = x.to_string();\n    for n in &[10, 100, 1000,\
    \ 10000] {\n        let mut i = result.to_string() + base.to_string();\n     \
    \   if n != 2 {\n            i = i.to_string().chars().enumerate().filter(|(_,\
    \ c)| *c <= base).map(|(_, c)| c as isize).sum();\n        }\n        result =\
    \ String::from(i);\n    }\n    result", "    if base < 10 {\n        let mut s\
    \ = String::with_capacity(x);\n        for i in 0..x {\n            s.push_str(&base.to_string());\n\
    \        }\n        s\n    } else {\n        let mut s = String::with_capacity(x\
    \ * 10 + base);\n        for i in 0..x {\n            s.push_str(&base.to_string());\n\
    \        }\n        s\n    }", "    use std::cmp::Ordering;\n    let mut x = x\
    \ as isize;\n    let mut r = String::new();\n    while x != 0 {\n        r = &format!(\"\
    {}{}\", base[(x % base) as usize], r).to_string();\n        x /= base;\n    }\n\
    \    r.reverse()", "    let mut r = String::with_capacity(x as isize);\n    while\
    \ x > 0 {\n        let next = if x % base == 0 {\n            x /= base;\n   \
    \         String::from(\"\")\n        } else {\n            String::from(\"\"\
    )\n        };\n        r += next;\n    }\n    r", "    let mut y = x.to_digits().to_base10();\n\
    \    let mut z = y.clone();\n    let mut x = base.to_digits().to_base10();\n \
    \   z.truncate(x);\n    String::from_digits(&z[..], base.digits())", "    use\
    \ num_bigint::*;\n    use num_traits::ToPrimitive;\n\n    if base < 10 {\n   \
    \     return format!(\"{}\", num::to_digits(x, base));\n    }\n\n    let mut res\
    \ = num::BigInt::new_unsigned_digits(&[]).unwrap();\n    let mut i = 0;\n    let\
    \ mut base = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n    while\
    \ i < x.len() {\n        let mut digits = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n\
    \        let digit = if i >= x.len() {\n            digits.last()\n        } else\
    \ {\n            digits[i]\n        };\n        let digit = if digit >= '0' &&\
    \ digit <= '9' {\n            digit - '0'\n        } else {\n            digit\
    \ - 'A' + 10\n        };\n        res.insert(i, digit);\n        i += 1;\n   \
    \ }\n    num::BigInt::from_digits(&res, base)", "    // Convert to string, convert\
    \ to integer and convert to string using base given.\n    String::from_integer(x\
    \ as u32).to_string(base)", "    if x < base {\n        match x {\n          \
    \  0 => \"0\",\n            i if i > base - 1 => \"10\".to_string(),\n       \
    \     i if i > base - 2 else \"0\".to_string() => i.to_string(),\n           \
    \ _ => panic!(\"input number must be bigger than 0\"),\n        }\n    } else\
    \ {\n        match x {\n            i if i > base - 1 => \"10\".to_string(),\n\
    \            i if i > base - 2 else \"0\".to_string() => i.to_string(),\n    \
    \        _ => x.to_string(),\n        }\n    }", "    let mut res = String::new();\n\
    \    let mut num = x;\n    while num > 0 {\n        let digit = num % base;\n\
    \        res.insert(digit.to_string(), digit.to_string().chars().nth(digit).unwrap());\n\
    \        num /= base;\n    }\n    res.reverse().to_string()", "    match x {\n\
    \        x if x % base == 0 => x.to_string(),\n        x if base > 10 => format!(\"\
    {}\", x).to_string(),\n        x if base < 10 => format!(\"{}{}\", x, base).to_string(),\n\
    \        x => format!(\"{:?}\", x).to_string(),\n    }", "    let mut digits =\
    \ x.to_string();\n    for &d in &mut digits[..base] {\n        if d == '0' {\n\
    \            digits.remove(d);\n        } else {\n            digits[base] = d.to_ascii_lowercase();\n\
    \        }\n    }\n    digits", "    let mut result = x;\n    for i in 0..base\
    \ {\n        result = result / base;\n    }\n    format!(\"{}\", result)", " \
    \   let mut buff = String::new();\n    let mut pow = base;\n    loop {\n     \
    \   if pow == 0 {\n            buff.push(0);\n            break;\n        }\n\
    \        buff.push(x % pow);\n        x = x / pow;\n        pow /= base;\n   \
    \ }\n    buff", "    let mut s: String = String::new();\n    loop {\n        if\
    \ x % base == 0 {\n            s.push('0');\n            x = x / base;\n     \
    \   } else {\n            s.push('1');\n            x = (x % base) + base;\n \
    \       }\n    }\n    String::from(s)", "    let mut result = String::new();\n\
    \    while x > 0 {\n        if x % base == 0 {\n            result += &format!(\"\
    {}\", base);\n        } else {\n            result += &format!(\"{}\", x / base);\n\
    \        }\n        x /= base;\n    }\n    result.into_owned()", "    let mut\
    \ result = String::new();\n    let mut quotient = x;\n    while quotient > 0 {\n\
    \        quotient /= base;\n        result.push((quotient % base) as char);\n\
    \    }\n    result.reverse();\n    result", "    if base < 2 {\n        use std::num::One;\n\
    \        use std::ops::{Add, Sub};\n        (x + One::one()) * (base ** 2)\n \
    \           .checked_add((One::one() * base).unwrap())\n            .unwrap()\n\
    \            .to_string()\n    } else {\n        let mut x = x.to_digits(base);\n\
    \        x.normalize();\n        x.reverse();\n        x.join(\"\").to_string()\n\
    \    }", "    let mut rep = String::new();\n    loop {\n        rep.push_str(&x.to_string().chars().map(|c|\
    \ match c {\n            '0'...'9' => (c - base) as char,\n            'a'...'z'\
    \ => (c - base + 10) as char,\n            _ => c.to_string()\n        }).collect());\n\
    \        if x < base {\n            return rep;\n        }\n        rep.push(\"\
    0\".to_string());\n        x /= base;\n    }", "    use std::fmt::{self, Display};\n\
    \    if x <= base {\n        String::from(\"0\")\n    } else {\n        let mut\
    \ result = String::from(\"0\");\n        for i in 1..base.abs() {\n          \
    \  result += &x.pow(base-i).to_string();\n        }\n        result\n    }", " \
    \   let mut x: String = x.to_string();\n    let mut s = vec![];\n    while x.len()\
    \ > 0 {\n        let mut idx = x.len() - 1;\n        if idx == 0 {\n         \
    \   let mut s = vec![];\n            s.append(x.chars().nth(x.len() - 1));\n \
    \           break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '1' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"0\");\n        } else if c != '0' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"0\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.char", "    let mut x =\
    \ x.to_string();\n    if x >= base {\n        let mut x = x;\n        let mut\
    \ base = base;\n        while x >= base {\n            x -= base;\n          \
    \  base = base_digits[base];\n        }\n        x.to_string() + &base;\n    }\
    \ else {\n        let mut base = base;\n        let mut x = x;\n        while\
    \ x <= base {\n            x += base;\n            base = base_digits[base];\n\
    \        }\n        x.to_string() + &base;\n    }", "    let mut res = String::new();\n\
    \    let mut digits = vec![0; base::digits().len()];\n    while x >= base {\n\
    \        res.extend(&digits[(x % base)..]);\n        x /= base;\n    }\n    res.extend(&digits[0..]);\n\
    \    res.to_string()", "    match base {\n        2 => String::from(\"1000\".to_string()),\n\
    \        3 => String::from(\"1111\".to_string()),\n        4 => String::from(\"\
    10000\".to_string()),\n        5 => String::from(\"100000\".to_string()),\n  \
    \      _ => {\n            let mut s = String::new();\n            for digit in\
    \ x.to_string().chars().skip(base.to_string().len() + 1) {\n                s.push_str(digit.to_string());\n\
    \            }\n            String::from(s)\n        }\n    }", "    match x.checked_mul(base)\
    \ {\n        Some(x) => x.to_string(),\n        None => \"\".to_string(),\n  \
    \  }", "    let mut s = String::new();\n    s.push_str(&x.to_string_radix(base));\n\
    \    s.chars().for_each(|c| {\n        if c >= base {\n            s.push('1');\n\
    \        } else {\n            s.push('0');\n        }\n    });\n    s", "   \
    \ let mut x = x * base as u64;\n    let mut ret: String = String::new();\n   \
    \ while x >= 10 {\n        ret += &format!(\"{}\", x % 10);\n        x /= 10;\n\
    \    }\n    ret += &format!(\"{}\", x);\n    ret", "    if base < 2 {\n      \
    \  panic!(\"Invalid base\");\n    }\n\n    let mut ret: String = \"\";\n    while\
    \ x != 0 {\n        if base == 10 {\n            ret += &x[..1].to_ascii_lowercase()[0];\n\
    \            break;\n        }\n\n        let rem = (x / base) as usize;\n   \
    \     let mul = &x[..rem].to_ascii_lowercase();\n        ret += &mul[..1].to_ascii_lowercase()[0];\n\
    \        x -= rem * base;\n    }\n\n    ret", "    let mut s = String::new();\n\
    \    s.push_str(&x.to_str_radix(base).to_string());\n    s", "    // Find difference\
    \ between base and number base\n    let mut num_base = base;\n    let mut diff\
    \ = num_base - x;\n\n    // Loop for converting to other number base\n    while\
    \ diff > 0 {\n        x = x * num_base + x;\n        diff -= 1;\n    }\n\n   \
    \ // Return string representation\n    format!(\"{}\", x)", "    let mut buff\
    \ = String::new();\n    let mut result = x;\n    let mut remainder = 0;\n    while\
    \ result != 0 {\n        remainder = (result % base);\n        result = result\
    \ / base;\n        buff.push((remainder + '0').to_string());\n    }\n    buff",
  "    use std::fmt;\n    use std::str::FromStr;\n\n    let mut digits = vec![];\n\
    \    let mut carry = false;\n    let mut digits_iter = x.abs();\n    for i in\
    \ digits_iter.cloned() {\n        let d = i as usize;\n        if d < base {\n\
    \            if carry {\n                digits.insert(0, 1);\n            } else\
    \ {\n                digits.push(d);\n            }\n        } else {\n      \
    \      let mut digit = d - base;\n            digit = digit % base;\n        \
    \    if carry {\n                digits.insert(0, digit);\n            } else\
    \ {\n                digits.push(digit);\n            }\n            carry = true;\n\
    \        }\n    }\n    digits.insert(0, 1);\n\n    let mut res = String::new();\n\
    \    for i in digits {\n        if i >= 10 {\n            res.push_str(&format!(\"\
    {}\", i / 10.0));\n        } else {\n            res.push_str(&format!(\"{}\"\
    , i));\n        }\n    }\n    if res == \"\" {\n        res.push_str(\"0\");\n\
    \    }\n    if res.len() < 2 {\n        res.push_str(&format!(\"0{}\", res[1..]));\n\
    \    }\n    res", "    let mut s = String::new();\n    for i in x.checked_div(base).unwrap()\
    \ {\n        if i > '9' {\n            s += '0';\n        }\n        s += char::from(*i).unwrap();\n\
    \    }\n    if base > 10 && x.checked_mod(base).unwrap() > 0 {\n        if s ==\
    \ '0' {\n            s = '1';\n        } else if s.is_empty() {\n            s\
    \ = \"1\";\n        }\n    }\n    s", "    match base {\n        2 => x.to_string(),\n\
    \        3 => x.to_string() + &\"11\",\n        _ => match x.checked_mul(base)\
    \ {\n            Some(m) => m.to_string(),\n            None => x.to_string(),\n\
    \        },\n    }", "    let mut s = String::new();\n    let mut remainder =\
    \ x;\n    let mut i = 1;\n    while remainder >= base {\n        remainder -=\
    \ base;\n        i += 1;\n    }\n    s += i.to_string();\n    while remainder\
    \ > 0 {\n        remainder -= base;\n        i += 1;\n        s += i.to_string();\n\
    \    }\n    s", "    let mut res = String::new();\n    let mut base = [0u8; 16];\n\
    \    base[base] = 1;\n    for &b in &base {\n        if b & 1 != 0 {\n       \
    \     res.push_str(&format!(\"{}\", x));\n            return res;\n        }\n\
    \        res.push_str(&format!(\"{}\", x * b));\n    }\n    res.push_str(&format!(\"\
    {}\", x));\n    return res;", "    let mut buff = String::new();\n    let mut\
    \ num = x as isize;\n    let mut base: i32 = base as i32;\n    while num > 0 {\n\
    \        buff.push(num % base as char);\n        num /= base;\n    }\n    buff",
  "    if base < 2 {\n        format!(\"{}\", x)\n    } else {\n        let mut s\
    \ = format!(\"{}\", x);\n        if s.len() <= base {\n            return s;\n\
    \        }\n\n        let mut base10 = String::new();\n        base10.push_str(\"\
    0\".to_string());\n        base10.push_str(&s[..base]);\n\n        let mut digits\
    \ = String::new();\n        while let Some(digit) = base10.chars().nth(0) {\n\
    \            let d = base10.chars().nth(1).unwrap();\n            if let Some(d)\
    \ = d {\n                if digit > d {\n                    digits.push_str(&digits[..d\
    \ - digit]);\n                    break;\n                } else {\n         \
    \           digits.push_str(&digits[..digit - d]);\n                }\n      \
    \      }\n        }\n        digits.push_str(&base10.chars().nth(base).unwrap());\n\
    \n        s\n    }", "    let mut res = String::new();\n    let mut carry = 0;\n\
    \    let mut cur_base = 1;\n    for &c in x.to_string().chars() {\n        let\
    \ num = c as u32;\n        let digit = num / cur_base;\n        res.push_str(digit.to_string());\n\
    \        res.push_str(\"0123456789ABCDEF\".chars()[digit % base].to_string());\n\
    \        cur_base *= base;\n        carry += cur_base;\n    }\n    if carry >\
    \ 0 {\n        res.push_str(\"1\".chars()[carry % base].to_string());\n    }\n\
    \    res.trim()", '    x.to_string(base)', "    let mut xs = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut xs_len = xs.len();\n    for i in 1..base {\n        xs_len -= i;\n\
    \        xs.truncate(xs_len);\n    }\n    let mut xs_str = xs.iter().map(|x| format!(\"\
    {:0>{}}\", x, i).to_string()).collect::<String>();\n    xs_str.push(xs.last().unwrap());\n\
    \    xs_str.push('0');\n    xs_str.push('0');\n    xs_str.push('1');\n    let\
    \ mut xs_str_result = String::new();\n    xs_str_result.push_str(&xs_str);\n \
    \   xs_str_result", "    let mut num: isize = x;\n    let mut power: isize = 1;\n\
    \    while num > 0 {\n        let mod = num % base;\n        num = (num - mod)\
    \ / base;\n        power *= base;\n    }\n    let mut result = [0; base + 1];\n\
    \    for _ in 0..base {\n        result[result.len() - 1] = (num % base) as u8;\n\
    \        num /= base;\n    }\n    if base < 2 {\n        for _ in 0..(base - 1)\
    \ {\n            result.push(0);\n        }\n    }\n    format!(\"{}\", &result[base..]).to_string()",
  "    let mut x = x;\n    let mut base = 10;\n\n    while x >= base {\n        x\
    \ -= base;\n    }\n\n    while x >= 10 {\n        x /= 10;\n        x += 1;\n\
    \    }\n\n    let mut y = x;\n    while y > base {\n        y -= base;\n    }\n\
    \n    format!(\"{}\", y)", "    if base < 10 {\n        format!(\"{:0>3o}\", x\
    \ * base).to_string()\n    } else {\n        format!(\"{:0>4o}\", x).to_string()\n\
    \    }", "    let mut result = String::new();\n    let mut i = x;\n\n    while\
    \ i > 0 {\n        result += format!(\"{}\", i / base);\n        i %= base;\n\
    \    }\n\n    result", "    let mut res = String::new();\n    fn to_base(base:\
    \ isize, num: isize) -> String {\n        let mut s = String::new();\n       \
    \ let mut n = num;\n        loop {\n            if n == 0 {\n                break;\n\
    \            }\n            s.push_str(&(n % base).to_string());\n           \
    \ n /= base;\n        }\n        s\n    }\n    while x > 0 {\n        let mut\
    \ s = to_base(base, x);\n        res.push_str(&s);\n        x /= base;\n    }\n\
    \    res", "    let mut res = String::new();\n    let mut remaining = x;\n\n \
    \   while remaining > 0 {\n        if remaining >= base {\n            res +=\
    \ &format!(\"{}\", remaining / base);\n            res += &format!(\"{}\", remaining\
    \ % base);\n            res += &format!(\".\");\n        } else {\n          \
    \  res += &format!(\"{}\", remaining);\n        }\n\n        remaining -= base;\n\
    \    }\n\n    res", "    let mut result = String::new();\n    let mut temp = 1;\n\
    \    while x > 0 {\n        let digit = x % base;\n        temp = temp * base\
    \ + digit;\n        x = x / base;\n        result.push(digit as char);\n    }\n\
    \    result.push((temp % base) as char);\n    result", "    if base < 10 {\n \
    \       return format!(\"{}\", x%base) as String;\n    }\n\n    let mut digits\
    \ = Vec::new();\n    digits.reserve(10);\n    for digit in base..10 {\n      \
    \  let mut remainder = x % digit;\n        if remainder > 0 {\n            digits.insert(0,\
    \ remainder);\n        }\n        x = x / digit;\n    }\n    if x != 0 {\n   \
    \     digits.insert(0, x);\n    }\n    digits.into_iter().map(|x| format!(\"{}\"\
    , x)).collect::<String>()", "    let mut result = String::new();\n    let mut\
    \ number = x;\n    let mut base = 10;\n    while number > 0 {\n        let digit\
    \ = number % base;\n        number /= base;\n        result.push((digit + '0')\
    \ as char);\n    }\n    if number < base {\n        let mut digits = base.to_string();\n\
    \        digits.push(digits[digits.len() - 1] + '1');\n        result.push_str(&digits[..]);\n\
    \    } else {\n        result.push_str(&'0');\n    }\n    result", "    let mut\
    \ result = String::new();\n    let mut base = base;\n    let mut x = x; // don't\
    \ mutate x in case it needs more digits\n    loop {\n        if x >= base {\n\
    \            result.push((base as char).to_string());\n            base += 1;\n\
    \            x = x / base;\n        } else {\n            result.push((x % base\
    \ as char).to_string());\n            x = x;\n        }\n        if x == 0 {\n\
    \            break;\n        }\n    }\n    result.reverse();\n    result.to_string()",
  "    if x != 0 && base > 9 {\n        panic!(\"change base must not exceed base\
    \ 9\");\n    }\n\n    let mut result: String = String::new();\n    let mut xdigits\
    \ = x % base;\n\n    // Loop to build up result string\n    while xdigits != 0\
    \ {\n        if xdigits >= base {\n            result.push((xdigits as u8) + base);\n\
    \            xdigits = xdigits - base;\n        } else {\n            result.push(xdigits);\n\
    \        }\n    }\n\n    result", "    assert!((base < 10) && (base > 0));\n \
    \   let mut res = String::new();\n    while x > 0 {\n        if x % base == 0\
    \ {\n            res += '0';\n        } else {\n            res += '1';\n    \
    \    }\n        x /= base;\n    }\n    res", "    if x > 10 {\n        convert_base(x,\
    \ base)\n    } else {\n        x.to_base().to_string()\n    }", "    let mut result\
    \ = String::new();\n    let mut base_str = &[base.to_string()[..]];\n    let mut\
    \ x = x;\n    while x.is_positive() {\n        let r = base_str.chars().nth(x\
    \ as usize).unwrap();\n        if r != '.' {\n            result = result\n  \
    \              .to_string()\n                .to_string()\n                .insert(x\
    \ as usize, r);\n        }\n        x = x * base as isize;\n    }\n    result",
  "    // check base is between 2 and 10\n    let mut result = (x as u64 / (10 as\
    \ u64)) as String;\n\n    // if base is smaller than 2 then append zeroes on right\n\
    \    if base < 2 {\n        result = format!(\"{}0\", &result);\n    }\n\n   \
    \ // convert base to string and append character by character\n    let mut basestr\
    \ = String::new();\n    basestr.push_str(&base);\n\n    let mut result = String::new();\n\
    \    while !result.is_empty() {\n        if result.len() < basestr.len() {\n \
    \           result.push_str(&basestr);\n        } else {\n            result.push_str(&result[..basestr.len()]);\n\
    \            break;\n        }\n    }\n\n    // return result\n    result", " \
    \   let mut result = String::new();\n    for i in base.touclen() {\n        if\
    \ i as usize == 0 {\n            break;\n        }\n        let mut digit = x\n\
    \            % base\n            .pow(i as usize - 1);\n        x /= base;\n \
    \       result.push(digit.to_string());\n    }\n    result", "    let mut result\
    \ = '0';\n    let mut digits = String::new();\n    let mut num = 1;\n    let mut\
    \ pos = 0;\n    while num > 0 {\n        while num % base == 0 && pos < digits.size()\
    \ {\n            result[pos] = '0';\n            pos += 1;\n        }\n      \
    \  if num % base != 0 {\n            result[pos] = char::from_u32(num % base).unwrap();\n\
    \            pos += 1;\n        }\n        num /= base;\n    }\n    while pos\
    \ < digits.size() {\n        result[pos] = '0';\n        pos += 1;\n    }\n  \
    \  result", "    let mut res = String::new();\n    let mut pow = x.pow(base);\n\
    \n    for _ in 0..(pow/x) {\n        res.insert(0, ('0' + x.mod_pow(base, &mut\
    \ pow).unwrap()));\n        pow = pow.mod_mul(&base, &pow).unwrap();\n    }\n\
    \    res.insert(0, x.mod_pow(base, &mut pow).unwrap());\n    res", "    let mut\
    \ y = x.to_dec().unwrap();\n    if base > 10 {\n        y /= base;\n    }\n  \
    \  String::from_dec(x).unwrap() * &base + &y", '    format!("{}{}", &x.to_digits(base).collect::<Vec<String>>().join(""),
    &base)', "    let mut result = String::new();\n    let mut digits = Vec::new();\n\
    \    for i in x.to_digits(base).rev() {\n        if i > 0 {\n            result.append(&digits[i\
    \ - 1]);\n        }\n        result.append(&i.to_string());\n    }\n    result",
  "    let mut result = String::from(\"0\");\n\n    for i in 1..base {\n        result\
    \ = format!(\"{}{}\", result.clone(), x.to_string());\n    }\n\n    result", " \
    \   let mut string = \"\";\n    let mut remainder = x;\n    let mut new_remainder\
    \ = 0;\n    let mut power = 1;\n    while remainder != 0 {\n        new_remainder\
    \ *= base;\n        new_remainder += remainder % base;\n        remainder = (remainder\
    \ / base).into();\n        power = 1;\n        while power < base {\n        \
    \    string.append(&format!(\"{}\", new_remainder));\n            new_remainder\
    \ *= base;\n            power = power + 1;\n        }\n    }\n    string", " \
    \   let mut s = String::new();\n    let mut v = x;\n    loop {\n        if v ==\
    \ 0 { break; }\n        match v % base {\n            0 => s += &'0',\n      \
    \      1 => s += &'1',\n            _ => {\n                let i = v / base;\n\
    \                v = v;\n                s += &(i as isize).to_string();\n   \
    \         }\n        }\n    }\n    s", "    let mut result = String::with_capacity(x.to_string().len()\
    \ * base.to_string().len());\n    let mut i = x.to_digits();\n    let mut j =\
    \ base.to_digits();\n\n    while i.len() > 0 && j.len() > 0 {\n        if i.pop()\
    \ > j.pop() {\n            result += &base[j.len() - 1];\n        } else {\n \
    \           result += &base[i.len() - 1];\n        }\n    }\n\n    for i in i\
    \ {\n        result += &base[i];\n    }\n\n    result.to_owned()", "    let mut\
    \ s = String::new();\n    for i in x.iter() {\n        if i == 0 {\n         \
    \   s += \"0\";\n        } else {\n            match i {\n                0 =>\
    \ s += \"0\",\n                1 => s += \"1\",\n                _ => s += String::from_str(&format!(\"\
    {:?}\", i).as_str()).unwrap().to_uppercase(),\n            }\n        }\n    }\n\
    \    &s[..]\n        .to_string(base)\n        .to_string()\n        .replacen(\n\
    \            &s[..],\n            \"0\",\n            &format!(\"{:?}\", x).as_str(),\n\
    \            |m| m.chars().next().unwrap().to_string(),\n        );", "    let\
    \ mut res = String::from(\"0\");\n    for i in 0..base {\n        let n = x %\
    \ base;\n        res.insert(0, char::from_u32(n).unwrap().to_string());\n    \
    \    x = x / base;\n    }\n    res.insert(0, x);\n    res", "    let mut res =\
    \ String::new();\n    let mut cur = x;\n    let mut tmp = base as isize;\n   \
    \ while tmp > 0 {\n        res.push_str(&to_base(&cur, &tmp));\n        cur /=\
    \ tmp;\n        tmp = base as isize;\n    }\n    res.push_str(&to_base(&cur, &tmp));\n\
    \    res", "    let mut res = String::from(\"0\");\n    let mut num_x = x;\n \
    \   let mut num_base = base;\n    while num_x > 0 {\n        if num_base < 10\
    \ {\n            res[res.len()-num_base.clone() as usize] = '0' + num_base.to_digit(10).unwrap();\n\
    \        } else {\n            res[res.len()-num_base.clone() as usize] = '0'\
    \ + num_base.to_digit(10).unwrap();\n        }\n        num_x -= num_base;\n \
    \       num_base /= base;\n    }\n    res", "    let mut s = String::new();\n\
    \    while x > 0 {\n        s.push((x % base).to_string());\n        x /= base;\n\
    \    }\n    s.push((x % base).to_string());\n    s", "    let mut res = String::with_capacity(x.to_string().len()\
    \ * base.to_string().len());\n    for x in x.to_string().chars().iter() {\n  \
    \      if *x != '0' {\n            match res {\n                Some(ref mut res)\
    \ => res += *x,\n                None => res += *x,\n            }\n        }\
    \ else {\n            if base > 2 {\n                match res {\n           \
    \         Some(ref mut res) => res += '0',\n                    None => res +=\
    \ '0',\n                }\n            } else {\n                match res {\n\
    \                    Some(ref mut res) => res += '1',\n                    None\
    \ => res += '1',\n                }\n            }\n        }\n    }\n    if base\
    \ > 2 {\n        res\n    } else {\n        res.reverse()\n    }", "    if base\
    \ < 2 {\n        \"\".to_string()\n    } else {\n        let mut buff = String::new();\n\
    \        let mut tmp = x;\n        let mut i = 0; // offset of next digit\n  \
    \      // Loop for every digit (except last) to be converted.\n        while i\
    \ != base {\n            tmp = tmp / base;\n            buff.push(String::from_utf8_lossy(&(tmp\
    \ % base)).unwrap());\n            i += 1;\n        }\n        // add last digit\n\
    \        buff.push(String::from_utf8_lossy(&tmp).unwrap());\n        buff\n  \
    \  }", "    if x < base {\n        let mut buff = String::new();\n        let\
    \ mut digits: Vec<String> = vec![\"\".to_string()];\n        while x >= base {\n\
    \            digits.push(format!(\"{}\", x / base).to_string());\n           \
    \ x -= base;\n        }\n        for (i, d) in digits.iter().enumerate() {\n \
    \           buff.push(d);\n            if i < digits.len() - 1 {\n           \
    \     buff.push('-');\n            }\n        }\n        buff.push(\"0\".to_string());\n\
    \        return buff;\n    }\n    let mut buff = String::new();\n    let mut digits:\
    \ Vec<String> = vec![\"\".to_string()];\n    let mut rem = x;\n    while rem >\
    \ 0 {\n        digits.push(rem % base);\n        rem = rem / base;\n    }\n  \
    \  for (i, d) in digits.iter().enumerate() {\n        buff.push(d);\n        if\
    \ i < digits.len() - 1 {\n            buff.push('-');\n        }\n    }\n    buff.push(\"\
    0\".to_string());\n    return buff;", "    if base < 2 {\n        0..=base\n \
    \           .pow(base)\n            .to_string()\n            .chars()\n     \
    \       .map(|i| '0' + i as char).collect::<String>()\n    } else {\n        x.to_string().chars().map(|i|\
    \ '0' + i as char).collect::<String>()\n    }", "    let mut buf = [0u8; 32];\n\
    \    let mut v = x;\n    buf[base] = v;\n    for digit in &buf[1..base.trunc_div()]\
    \ {\n        v = (v * base) % 11;\n        buf[digit as usize] = v;\n    }\n \
    \   let digits: Vec<&'static str> = buf.iter().map(|x| x.to_string()).collect();\n\
    \    digits.reverse();\n    String::from_utf8(digits.as_slice()).unwrap()", " \
    \   use self::Num::*;\n    let mut res = String::with_capacity(x);\n    while\
    \ x != 0 {\n        let remain = x % base;\n        res.insert(0, base.chars().nth(remain\
    \ as usize).unwrap());\n        x /= base;\n    }\n    res", "    assert!(base\
    \ > 0 && base < 10);\n    String::from_utf8(x.to_bytes(x.bits() * base, LittleEndian))\n\
    \        .unwrap()\n        .to_string(base)\n        .unwrap()", '    format!("{}",
    x / (base ** 2))', "    let mut xnum = x as isize;\n    let mut bnum = base;\n\
    \    while xnum / bnum >= 10 {\n        xnum = (xnum / bnum) as isize;\n     \
    \   bnum *= base;\n    }\n    format!(\"{}\", xnum / bnum as u64.to_string())",
  "    // base cannot be 0\n    let base_digits = base::digits() - 1;\n    // calculate\
    \ x modulo base\n    let x_digits = x::digits() - 1;\n    let x_mod10 = x\n  \
    \      .div_rem(base::from(base_digits))\n        .unwrap_or(Some(x));\n    //\
    \ calculate y modulo base\n    let mut x_mod10_remainder = x_mod10.clone(); //\
    \ start off with same value\n    x_mod10_remainder\n        .mod_exp(base::from(base_digits),\
    \ &base::from(x_digits))\n        .unwrap()\n        .ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x)))\n        .and_then(|y| y.checked_mul(base::from(base_digits)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x))));\n    // calculate remainder after multiplying\
    \ by base\n    let x_mod10_remainder = x_mod10_remainder.checked_add(&x_mod10).unwrap();\n\
    \    // if the remainder is 0, subtract 1 from x and convert to string using base\
    \ 10\n    if x_mod10_remainder.is_zero() {\n        // subtract 1 from x, convert\
    \ to string using base 10, then add 1 to base to get new base\n        let new_base\
    \ = base::from(base_digits) - 1 + base::from(x_digits);\n        x_mod10_remainder.checked_add(&base::from(x_digits)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x)))\n            .and_then(|remainder| remainder.checked_mul(base::from(new_base)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x))));\n    }\n    x_mod10_remainder.to_string()",
  "    use std::cmp::Ordering;\n    if base < 2 || base > 10 {\n        panic!(\"\
    Invalid base number: {}\", base);\n    }\n    if x <= 0 {\n        format!(\"\
    {}\", x)\n    } else {\n        let mut new_string = String::new();\n        let\
    \ mut digits = String::new();\n        let mut base = base;\n        let mut x\
    \ = x;\n        while x >= base {\n            digits.push_str(&x.to_string()[..]);\n\
    \            x /= base;\n        }\n        if x > 0 {\n            new_string.push_str(&format!(\"\
    {}\", x));\n        } else {\n            while x >= 10 {\n                new_string.push_str(&format!(\"\
    {}\", x));\n                x /= 10;\n            }\n            new_string.push_str(&digits.to_string());\n\
    \        }\n        new_string\n    }", "    let mut new_base = base;\n    let\
    \ mut digits = String::new();\n    while x >= base {\n        x = x / base;\n\
    \        new_base += 1;\n    }\n    while x < base {\n        digits.push(format!(\"\
    {}\", x%base));\n        x = x / base;\n    }\n    if new_base == base {\n   \
    \     digits\n    } else {\n        digits.push(format!(\"{}\", x%base))\n   \
    \ }", "    // convert from binary to decimal and divide by base\n    let mut result\
    \ = String::from(\"\".to_string());\n    while x != 0 {\n        let rem = x %\
    \ base;\n        result = format!(\"{:0>5}\", rem) + &result;\n        x = x /\
    \ base;\n    }\n\n    if base == 10 {\n        result = format!(\"{}\", x)\n \
    \   } else {\n        result = format!(\"{}b\", x)\n    }\n    result", "    match\
    \ base {\n        2 => {\n            let mut res = String::new();\n         \
    \   while x < 10 {\n                res.push((x / 10).to_string());\n        \
    \        x = x % 10;\n            }\n            if x > 0 {\n                res.push((x\
    \ / 10).to_string());\n                res.push((x % 10).to_string());\n     \
    \       } else {\n                res.push((x % 10).to_string());\n          \
    \  }\n            res\n        }\n        3 | 5 => format!(\"{}{:b}\", x / 10.0,\
    \ x / 10.0 % 10.0, x % 10),\n        7 | 9 => format!(\"{}{:b}\", x / 10.0, (x\
    \ % 10) * (x / 10.0 % 10.0)),\n        _ => format!(\"{}{:b}\", x / 10.0, (x %\
    \ 10) * (x / 10.0 % 10.0))\n    }", "    let mut s = String::new();\n    if x\
    \ < 10 {\n        s.push_str(&format!(\"{:0>2}\", x));\n    } else {\n       \
    \ match base {\n            0 => {\n                s.push_str(&format!(\"{:0>5}\"\
    , x));\n            }\n            1 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 10));\n                s.push_str(&format!(\"{:0>5}\", x % 10));\n\
    \            }\n            2 => {\n                s.push_str(&format!(\"{:0>5}\"\
    , x / 100));\n                s.push_str(&format!(\"{:0>5}\", x % 100));\n   \
    \             s.push_str(&format!(\"{:0>5}\", x % 10));\n            }\n     \
    \       3 => {\n                s.push_str(&format!(\"{:0>5}\", x / 1000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 1000));\n               \
    \ s.push_str(&format!(\"{:0>5}\", x % 100));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 10));\n            }\n            4 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 10000));\n                s.push_str(&format!(\"{:0>5}\", x % 10000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 1000));\n               \
    \ s.push_str(&format!(\"{:0>5}\", x % 100));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 10));\n            }\n            5 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 100000));\n                s.push_str(&format!(\"{:0>5}\", x % 100000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 10000));\n              \
    \  s.push_str(&format!(\"{:0>5}\", x % 1000));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 100));\n                s.push_str(&format!(\"{:0>5}\", x % 10));\n\
    \            }\n            6 => {\n                s.push_str(&format!(\"{:0>5}\"\
    , x / 1000000));\n                s.push_str(&format!(\"{:0>5}\", x % 1000000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 100000));\n             \
    \   s.push_str(&format!(\"{:0>5", "    if base < 10 {\n        return format!(\"\
    {}\", x).to_string();\n    }\n    let mut num: usize = 0;\n    let mut rem = x;\n\
    \    loop {\n        if rem < base {\n            num += 1;\n            rem /=\
    \ base;\n        } else {\n            num %= base;\n            rem -= base;\n\
    \        }\n        if num == 0 {\n            return format!(\"{}\", rem).to_string();\n\
    \        }\n    }", "    match (base.to_digits() as u8).cmp(&base) {\n       \
    \ Ordering::Less => {\n            match (x.to_digits() as u8).cmp(&base) {\n\
    \                Ordering::Less => {\n                    let mut res = String::with_capacity(x.to_digits()\
    \ * base.to_digits() + 1);\n                    while x.to_digits() > 0 {\n  \
    \                      if x % base == 0 {\n                            res +=\
    \ &base;\n                        } else {\n                            res +=\
    \ &x;\n                            x /= base;\n                        }\n   \
    \                 }\n                    res\n                }\n            \
    \    Ordering::Greater => panic!(\"base must not be larger than the highest digit\"\
    ),\n                Ordering::Equal => panic!(\"base must not be equal to any\
    \ digit\"),\n            }\n        }\n        Ordering::Greater => panic!(\"\
    base must not be larger than the highest digit\"),\n        Ordering::Equal =>\
    \ panic!(\"base must not be equal to any digit\"),\n    }", "    use num_bigint::BigInt;\n\
    \    let mut r = BigInt::new(0);\n    let mut x_n = BigInt::new(x);\n    while\
    \ x_n.is_power_of_two() {\n        let b = x_n.clone();\n        let r = r.mul(base);\n\
    \        if r.is_power_of_two() {\n            r.add(b);\n        } else {\n \
    \           r.add(&b[..]);\n        }\n        x_n = r.clone() % base;\n    }\n\
    \    r.to_string(base)", "    let mut x = x.to_digits();\n    let mut base = 10;\n\
    \    while *x <= base {\n        *x = *x + base;\n        base = base * 10;\n\
    \    }\n    x.to_ascii_uppercase()\n        .collect::<Vec<_>>()\n        .join(\"\
    \".to_string())\n        .to_string()", "    let mut s = String::new();\n    if\
    \ base < 10 {\n        s.push_str(&to_base(x, base));\n    } else {\n        //\
    \ base is greater than 10\n        let mut num = 1;\n        for digit in to_base(x,\
    \ base) {\n            num *= base;\n            s.push_str(&to_base(num, base));\n\
    \            num += digit;\n        }\n    }\n    s", "    let mut numer = x /\
    \ base;\n    let remainder = x % base;\n    if remainder != 0 {\n        numer\
    \ = numer + 1;\n    }\n\n    let mut result = String::new();\n    for i in &[numer...]\
    \ {\n        result.push(i);\n    }\n    result", "    // Convert number to string\
    \ representation in base base\n    let mut string_representation = String::new();\n\
    \    let mut remainder = x as i32;\n    for i in 0..base.abs() {\n        let\
    \ mut remainder_new = remainder;\n        if i as i32 >= base as i32 {\n     \
    \       remainder_new /= base as i32;\n        } else {\n            remainder_new\
    \ *= base as i32;\n        }\n        string_representation.push_str(&format!(\"\
    {:0{}b}\", remainder_new, base));\n        remainder -= remainder_new;\n    }\n\
    \    if remainder != 0 {\n        let mut remainder_new = remainder;\n       \
    \ string_representation.push_str(&format!(\"{:0{}b}\", remainder_new, base));\n\
    \    }\n    return string_representation;", "    let mut s: Vec<u8> = Vec::new();\n\
    \    let mut i = 0;\n    let mut carry = 0;\n\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    for &digit in digits {\n        let base10 = digit as isize;\n        if\
    \ base10 >= base {\n            let mut next_digit = digit as usize;\n       \
    \     while carry++ < base10 {\n                next_digit += carry;\n       \
    \     }\n            i += next_digit as u8;\n        }\n        i += digit as\
    \ i8;\n    }\n    String::from_utf8(s.as_slice()).to_string()"]
stop_tokens:
- "\n}"
