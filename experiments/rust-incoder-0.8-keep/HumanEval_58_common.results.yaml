name: HumanEval_58_common
language: rust
results:
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c = vec![];\n    let mut a = l1[0];\n    let mut b\
    \ = l2[0];\n    for val in l1 {\n        if val == b {\n            continue;\n\
    \        }\n        let mut i = 0;\n        while i < c.len() && c[i] == val {\n\
    \            i += 1;\n        }\n        if i == c.len() {\n            c.push(b);\n\
    \        }\n        else {\n            c.splice(i, 1);\n        }\n        a\
    \ = val;\n        i += 1;\n    }\n    if b.is_some() && c.len() > 0 {\n      \
    \  c.push(b);\n    }\n    if c.len() == 1 {\n        c\n    } else {\n       \
    \ c.iter().cloned()\n    }\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: RangeBounds<usize>` is not satisfied\n\
    \    --> /tmp/tmpwynn1xs5.rs:22:22\n     |\n22   |             c.splice(i, 1);\n\
    \     |               ------ ^ the trait `RangeBounds<usize>` is not implemented\
    \ for `usize`\n     |               |\n     |               required by a bound\
    \ introduced by this call\n     |\n     = help: the following other types implement\
    \ trait `RangeBounds<T>`:\n               (Bound<&'a T>, Bound<&'a T>)\n     \
    \          (Bound<T>, Bound<T>)\n               RangeFrom<&T>\n              \
    \ RangeFrom<T>\n               RangeFull\n               RangeInclusive<&T>\n\
    \               RangeInclusive<T>\n               RangeTo<&T>\n             and\
    \ 5 others\nnote: required by a bound in `Vec::<T, A>::splice`\n\nerror[E0277]:\
    \ `{integer}` is not an iterator\n  --> /tmp/tmpwynn1xs5.rs:22:25\n   |\n22 |\
    \             c.splice(i, 1);\n   |               ------    ^ `{integer}` is not\
    \ an iterator\n   |               |\n   |               required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Iterator` is not implemented for `{integer}`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    note: required by a bound in `Splice`\n\nerror[E0599]: no method named `is_some`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpwynn1xs5.rs:27:10\n\
    \   |\n27 |     if b.is_some() && c.len() > 0 {\n   |          ^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwynn1xs5.rs:33:9\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n33 |         c.iter().cloned()\n   |         ^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return l1;\n\
    \    }\n    let mut l3 = vec![];\n    let mut l4 = vec![];\n    for i in 0..(l1.len()\
    \ + l2.len() - 1) {\n        if l1.len() > 0 && l2.len() > 0 && l1[0] == l2[0]\
    \ {\n            l3.push(l1[0]);\n            l2.remove(0);\n            l3.push(l2[0]);\n\
    \            l4.append(l2[0]);\n        } else {\n            l3.push(l1[0]);\n\
    \            l4.append(l1[0]);\n            l3.push(l2[0]);\n        }\n    }\n\
    \    l3.extend(l4);\n    return l3;\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrr1gan8.rs:17:23\n   |\n\
    17 |             l4.append(l2[0]);\n   |                       ^^^^^ expected\
    \ `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvrr1gan8.rs:20:23\n   |\n20 |             l4.append(l1[0]);\n\
    \   |                       ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                       \
    \    found type `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = l1.len();\n    let mut j = l2.len();\n    let\
    \ mut u = 0;\n    let mut v = 0;\n    while i > 0 || j > 0 {\n        if i > \
    \ j {\n            i -= v;\n            u += 1;\n            v = 0;\n        }\
    \ else {\n            j -= u;\n            v += 1;\n            u = 0;\n     \
    \   }\n        if i >  j {\n            i -= v;\n            u += 1;\n       \
    \     v = 0;\n        } else {\n            j -= u;\n            v += 1;\n   \
    \         u = 0;\n        }\n        if i == 0 && j == 0 {\n            break;\n\
    \        }\n        let mut x = l1[i];\n        let mut y = l2[j];\n        if\
    \ x < y {\n            i -= v;\n            u += 1;\n            v = 0;\n    \
    \    } else {\n            j -= u;\n            v += 1;\n            u = 0;\n\
    \        }\n        if x < y {\n            i -= v;\n            u += 1;\n   \
    \         v = 0;\n        } else {\n            j -= u;\n            v += 1;\n\
    \            u = 0;\n        }\n        if i == 0 && j == 0 {\n            break;\n\
    \        }\n        if x < y {\n            i -= v;\n            u += 1;\n   \
    \         v = 0;\n        } else {\n            j -= u;\n            v += 1;\n\
    \            u = 0;\n        }\n    }\n    l1.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmpi6fsqpu1.rs:33:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    l1.iter().cloned().sort_unstable_by_key(|&x|\
    \ x).dedup();\n    l2.iter().cloned().sort_unstable_by_key(|&x| x).dedup();\n\
    \    for i in l1.iter().cloned().zip(l2.iter().cloned()) {\n        if *i == (None,\
    \ None)? true : *i == *i {\n            result.push(i);\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected mut or const in raw pointer type\n  --> /tmp/tmpsp0eijf2.rs:11:39\n\
    \   |\n11 |         if *i == (None, None)? true : *i == *i {\n   |           \
    \                            ^ expected mut or const in raw pointer type\n   |\n\
    \   = help: use `*mut T` or `*const T` as appropriate\n\nerror: expected one of\
    \ `,` or `}`, found `.`\n  --> /tmp/tmpsp0eijf2.rs:12:19\n   |\n11 |         if\
    \ *i == (None, None)? true : *i == *i {\n   |                                \
    \     -        - while parsing this struct\n   |                             \
    \        |\n   |                                     tried to parse a type due\
    \ to this\n12 |             result.push(i);\n   |                   ^ expected\
    \ one of `,` or `}`\n\nerror: expected `{`, found keyword `true`\n  --> /tmp/tmpsp0eijf2.rs:11:32\n\
    \   |\n11 |         if *i == (None, None)? true : *i == *i {\n   |         --\
    \                     ^^^^ expected `{`\n   |         |\n   |         this `if`\
    \ expression has a condition, but no block\n   |\nhelp: try placing this code\
    \ inside a block\n   |\n11 ~         if *i == (None, None)? { true : *i == *i\
    \ {\n12 |             result.push(i);\n13 ~         } }\n   |\n\nerror[E0599]:\
    \ no method named `sort_unstable_by_key` found for struct `Cloned` in the current\
    \ scope\n --> /tmp/tmpsp0eijf2.rs:8:24\n  |\n8 |     l1.iter().cloned().sort_unstable_by_key(|&x|\
    \ x).dedup();\n  |                        ^^^^^^^^^^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `sort_unstable_by_key`\
    \ found for struct `Cloned` in the current scope\n --> /tmp/tmpsp0eijf2.rs:9:24\n\
    \  |\n9 |     l2.iter().cloned().sort_unstable_by_key(|&x| x).dedup();\n  |  \
    \                      ^^^^^^^^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n    for el1 in l1 {\n\
    \        for el2 in l2 {\n            if el1 == el2 {\n                continue;\n\
    \            }\n            let cmp = if el1 < el2 { -1 } else { 1 };\n      \
    \      if ret.len() > 0 {\n                let mut el = ret.iter().cmp(&cmp).unwrap();\n\
    \                if el == cmp {\n                    continue;\n             \
    \   }\n            }\n            ret.push(el1);\n        }\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&{integer}` is not an iterator\n    --> /tmp/tmpm7suicsx.rs:15:45\n\
    \     |\n15   |                 let mut el = ret.iter().cmp(&cmp).unwrap();\n\
    \     |                                         --- ^^^^ `&{integer}` is not an\
    \ iterator\n     |                                         |\n     |         \
    \                                required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Iterator` is not implemented for `&{integer}`\n\
    \     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&{integer}`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\n\
    error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmpm7suicsx.rs:15:51\n   |\n15 |             \
    \    let mut el = ret.iter().cmp(&cmp).unwrap();\n   |                       \
    \                            ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return l1.clone();\n\
    \    }\n\n    let mut l3 = l1.clone();\n    l3.sort();\n    l3.dedup();\n\n  \
    \  let mut l4 = l2.clone();\n    l4.sort();\n    l4.dedup();\n\n    let mut l5\
    \ = l3.clone();\n    l5.sort();\n    l5.dedup();\n\n    let mut l6 = l4.clone();\n\
    \    l6.sort();\n    l6.dedup();\n\n    while l1.len() != 0 || l2.len() != 0 ||\
    \ l3.len() != 0 || l4.len() != 0 || l5.len() != 0 || l6.len() != 0 {\n       \
    \ if l5.len() == 0 {\n            if l6.len() == 0 {\n                return l3.clone();\n\
    \            }\n\n            l4 = l6.clone();\n            l4.sort();\n     \
    \       l4.dedup();\n        } else if l4.len() == 0 {\n            l5 = l5.clone();\n\
    \            l5.sort();\n            l5.dedup();\n        }\n\n        if l1.len()\
    \ == 0 {\n            if l3.len() == 0 || l4.len() == 0 {\n                return\
    \ l2.clone();\n            }\n\n            l3 = l4.clone();\n            l3.sort();\n\
    \            l3.dedup();\n        } else if l3.len() == 0 {\n            l2 =\
    \ l3.clone();\n            l2.sort();\n            l2.dedup();\n        }\n  \
    \  }\n\n    l6\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `l2`\n  --> /tmp/tmpfcoquscb.rs:51:13\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                         -- help: consider making this binding mutable: `mut\
    \ l2`\n...\n51 |             l2 = l3.clone();\n   |             ^^ cannot assign\
    \ to immutable argument\n\nerror[E0596]: cannot borrow `l2` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpfcoquscb.rs:52:13\n   |\n6  | fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \ -- help: consider changing this to be mutable: `mut l2`\n...\n52 |         \
    \    l2.sort();\n   |             ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `l2` as mutable, as it is not declared as mutable\n  --> /tmp/tmpfcoquscb.rs:53:13\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                         -- help: consider changing this to be mutable: `mut\
    \ l2`\n...\n53 |             l2.dedup();\n   |             ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0384, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"Vectors lengths\
    \ do not match\");\n    }\n\n    let mut common: Vec<isize> = Vec::new();\n\n\
    \    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n            if l1[i]\
    \ == l2[j] {\n                common.push(l1[i]);\n                break;\n  \
    \          }\n        }\n    }\n\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp89q8gsk5.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpfap8w02l.rs:7:54\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    \     |                                                      ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted_l1 = l1.iter().cloned().sorted();\n    let\
    \ mut sorted_l2 = l2.iter().cloned().sorted();\n    let mut found = false;\n \
    \   let mut common_items = Vec::new();\n    while !found && sorted_l1.any() ||\
    \ sorted_l2.any() {\n        let mut a = sorted_l1\n            .next()\n    \
    \        .unwrap_or_else(|| std::iter::empty());\n        let mut b = sorted_l2\n\
    \            .next()\n            .unwrap_or_else(|| std::iter::empty());\n  \
    \      if a < b {\n            common_items.push(a);\n            sorted_l1.next();\n\
    \        } else {\n            common_items.push(b);\n            sorted_l2.next();\n\
    \        }\n        found = sorted_l1\n            .next()\n            .unwrap_or_else(||\
    \ false)\n            || sorted_l2\n            .next()\n            .unwrap_or_else(||\
    \ false);\n    }\n    common_items\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmpup4uk9iy.rs:7:44\n  |\n7 |     let mut sorted_l1\
    \ = l1.iter().cloned().sorted();\n  |                                        \
    \    ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Cloned` in the current scope\n -->\
    \ /tmp/tmpup4uk9iy.rs:8:44\n  |\n8 |     let mut sorted_l2 = l2.iter().cloned().sorted();\n\
    \  |                                            ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    let mut it = l2.iter().cloned();\n\
    \    while let Some(i) = it.next() {\n        if result.contains(i) {\n      \
    \      result = result.clone();\n        }\n        result.push(i);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkanaxxu5.rs:10:28\n   |\n\
    10 |         if result.contains(i) {\n   |                            ^\n   |\
    \                            |\n   |                            expected `&isize`,\
    \ found `isize`\n   |                            help: consider borrowing here:\
    \ `&i`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut seen = HashSet::new();\n    let mut union = vec![];\n\
    \n    for x in l1 {\n        if !seen.contains(&x) {\n            union.push(x);\n\
    \            seen.insert(x);\n        }\n    }\n    for x in l2 {\n        if\
    \ !seen.contains(&x) {\n            union.push(x);\n            seen.insert(x);\n\
    \        }\n    }\n    union\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpg5atf0fb.rs:7:20\n  |\n7 |     let mut seen = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2).filter(|(a, b)| a == b).collect::<Vec<(isize,\
    \ isize)>>()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmp5gqzgrd_.rs:7:41\n\
    \  |\n7 |     l1.iter().zip(l2).filter(|(a, b)| a == b).collect::<Vec<(isize,\
    \ isize)>>()\n  |                                         ^^ no implementation\
    \ for `&isize == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n  = note: required because of the requirements on the impl of `PartialEq<&isize>`\
    \ for `&&isize`\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot\
    \ be built from an iterator over elements of type `(&isize, isize)`\n    --> /tmp/tmp5gqzgrd_.rs:7:47\n\
    \     |\n7    |     l1.iter().zip(l2).filter(|(a, b)| a == b).collect::<Vec<(isize,\
    \ isize)>>()\n     |                                               ^^^^^^^ value\
    \ of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, isize)>` is\
    \ not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5gqzgrd_.rs:7:5\n  |\n6 | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  |                                       \
    \       ---------- expected `Vec<isize>` because of return type\n7 |     l1.iter().zip(l2).filter(|(a,\
    \ b)| a == b).collect::<Vec<(isize, isize)>>()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(isize, isize)>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect();\n    let mut l2\
    \ = l2.iter().cloned().collect();\n\n    while l1.len() != l2.len() {\n      \
    \  common::find_first::<isize>(&mut l1, &mut l2);\n    }\n\n    l1.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `common`\n\
    \  --> /tmp/tmpygjtcoit.rs:11:9\n   |\n11 |         common::find_first::<isize>(&mut\
    \ l1, &mut l2);\n   |         ^^^^^^ use of undeclared crate or module `common`\n\
    \nerror[E0282]: type annotations needed\n  --> /tmp/tmpygjtcoit.rs:10:11\n   |\n\
    7  |     let mut l1 = l1.iter().cloned().collect();\n   |         ------ consider\
    \ giving `l1` a type\n...\n10 |     while l1.len() != l2.len() {\n   |       \
    \    ^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1_set: HashSet<isize> = HashSet::new();\n    let\
    \ mut l2_set: HashSet<isize> = HashSet::new();\n    for v in l1 {\n        if\
    \ !l1_set.insert(v) {\n            break;\n        }\n    }\n    for v in l2 {\n\
    \        if !l2_set.insert(v) {\n            break;\n        }\n    }\n    l1_set.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpwg9g1xfu.rs:7:21\n\
    \  |\n7 |     let mut l1_set: HashSet<isize> = HashSet::new();\n  |          \
    \           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpwg9g1xfu.rs:7:38\n\
    \  |\n7 |     let mut l1_set: HashSet<isize> = HashSet::new();\n  |          \
    \                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n --> /tmp/tmpwg9g1xfu.rs:8:21\n  |\n\
    8 |     let mut l2_set: HashSet<isize> = HashSet::new();\n  |                \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpwg9g1xfu.rs:8:38\n  |\n8 |  \
    \   let mut l2_set: HashSet<isize> = HashSet::new();\n  |                    \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    let mut current = l1;\n    for i\
    \ in l2 {\n        while current.iter().any(|&x| x == i) {\n            current.remove(i);\n\
    \        }\n        current = current.iter().cloned().collect();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg0jb34ru.rs:11:28\n   |\n\
    11 |             current.remove(i);\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |             current.remove(i.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n    let\
    \ mut l3 = l2.clone();\n    l3.sort();\n    while result.len() > 0 && l3.len()\
    \ > 0 {\n        if result[0] != l3[0] {\n            result.swap(0, 0);\n   \
    \     }\n        result.swap(0, 1);\n        l3.swap(0, 1);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1_iter = l1.iter().cloned().collect();\n\
    \    let mut l2_iter = l2.iter().cloned().collect();\n    loop {\n        if l1_iter.len()\
    \ < l2_iter.len() {\n            result.push(l1_iter.next().unwrap());\n     \
    \       continue ;\n        }\n        if l1_iter.len() > l2_iter.len() {\n  \
    \          result.push(l2_iter.next().unwrap());\n            continue ;\n   \
    \     }\n        if l1_iter.len() == l2_iter.len() {\n            result.push(l1_iter.next().unwrap());\n\
    \            result.push(l2_iter.next().unwrap());\n            continue ;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplm1e4p24.rs:11:12\n\
    \   |\n8  |     let mut l1_iter = l1.iter().cloned().collect();\n   |        \
    \ ----------- consider giving `l1_iter` a type\n...\n11 |         if l1_iter.len()\
    \ < l2_iter.len() {\n   |            ^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nwarning: unreachable expression\n  --> /tmp/tmplm1e4p24.rs:25:5\n\
    \   |\n10 | /     loop {\n11 | |         if l1_iter.len() < l2_iter.len() {\n\
    12 | |             result.push(l1_iter.next().unwrap());\n13 | |             continue\
    \ ;\n...  |\n23 | |         }\n24 | |     }\n   | |_____- any code following this\
    \ expression is unreachable\n25 |       result\n   |       ^^^^^^ unreachable\
    \ expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return vec![];\n\
    \    }\n    if l1[0] == l2[0] {\n        return vec![l1[0]];\n    }\n\n    let\
    \ mut lcs = l1;\n    let mut rcs = l2;\n\n    while lcs.len() > 1 || rcs.len()\
    \ > 1 {\n        if lcs[0] == rcs[0] {\n            let mut ls = vec![];\n   \
    \         while lcs.len() > 1 {\n                ls.push(lcs[0]);\n          \
    \      lcs.pop();\n            }\n            ls.push(rcs[0]);\n            rcs\
    \ = ls;\n        } else {\n            let mut rs = vec![];\n            while\
    \ rcs.len() > 1 {\n                rs.push(rcs[0]);\n                rcs.pop();\n\
    \            }\n            lcs = rs;\n        }\n    }\n    lcs.extend(&rcs)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk3bfvfa3.rs:35:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     lcs.extend(&rcs)\n   |     ^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\nnote: method `extend` modifies its receiver in-place\n\
    \  --> /tmp/tmpk3bfvfa3.rs:35:9\n   |\n35 |     lcs.extend(&rcs)\n   |     ---\
    \ ^^^^^^ this call modifies `lcs` in-place\n   |     |\n   |     you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `extend`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    l1.iter().cloned().for_each(|x|\
    \ set.insert(x));\n    l2.iter().cloned().for_each(|x| set.insert(x));\n    set.into_iter().collect().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmprwx1r0lq.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m = vec![];\n    for (v, u) in l1\n        .iter()\n\
    \        .zip(l2.iter())\n        .filter(|&(u1, u2)| u1 == u2)\n        .map(|&(u1,\
    \ u2)| (u1, u2))\n    {\n        if !m.contains(&v) {\n            m.push(v);\n\
    \        }\n    }\n    m\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp06orwnhk.rs:12:15\n   |\n\
    12 |         .map(|&(u1, u2)| (u1, u2))\n   |               ^^^^^^^^-\n   |  \
    \             |       |\n   |               |       expected due to this\n   |\
    \               expected tuple, found reference\n   |\n   = note:  expected tuple\
    \ `(&isize, &isize)`\n           found reference `&_`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = Vec::new();\n    let mut j = Vec::new();\n   \
    \ for i in l1 {\n        j.push(i);\n        if j.len() == 1 {\n            break;\n\
    \        }\n    }\n    for i in l2 {\n        if !i.contains(&mut i) {\n     \
    \       j.push(i);\n            if j.len() == 1 {\n                break;\n  \
    \          }\n        }\n    }\n    j.iter().collect()\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp5oehhurd.rs:16:15\n   |\n16 |         if !i.contains(&mut\
    \ i) {\n   |               ^^^^^^^^ method not found in `isize`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmp5oehhurd.rs:23:14\n     |\n23   |     j.iter().collect()\n\
    \     |              ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_owned();\n    let mut l2 = l2.to_owned();\n\
    \n    if l1.len() != l2.len() {\n        panic!(\"length of two lists does not\
    \ match\");\n    }\n\n    let mut result = vec![];\n\n    while l1.len() > 0 ||\
    \ l2.len() > 0 {\n        // If one list is empty, the other remains\n       \
    \ let mut a = l1.len();\n        let mut b = l2.len();\n        while a > 0 ||\
    \ b > 0 {\n            // The shorter list is exhausted\n            if a > b\
    \ {\n                a -= b;\n            } else if b > a {\n                b\
    \ -= a;\n            } else {\n                // Both lists exhausted\n     \
    \           if a == 0 {\n                    // Both are empty\n             \
    \       break;\n                }\n                if a&1 == b {\n           \
    \         // Lists are identical and equal\n                    break;\n     \
    \           }\n                // Lists are unequal\n                a = a >>\
    \ 1;\n                b = b >> 1;\n            }\n        }\n\n        if b ==\
    \ 0 {\n            result.push(l1.pop());\n        } else {\n            result.push(l2.pop());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw122rbdf.rs:48:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n48 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = vec![];\n    let mut l3 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l4 = l2.iter().cloned().collect::<Vec<_>>();\n    while l3.len()\
    \ > 0 || l4.len() > 0 {\n        if l3.len() == 0 {\n            ret.append(l4.shift());\n\
    \            continue;\n        }\n        if l4.len() == 0 {\n            ret.append(l3.shift());\n\
    \            continue;\n        }\n        if l3[0] == l4[0] {\n            ret.append(l3[0]);\n\
    \            l3.remove(&l3[0]);\n            l4.remove(&l4[0]);\n        } else\
    \ {\n            break;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `shift` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmphu9gjgnv.rs:12:27\n   |\n12 |             ret.append(l4.shift());\n\
    \   |                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `shift` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmphu9gjgnv.rs:16:27\n   |\n16 |             ret.append(l3.shift());\n\
    \   |                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphu9gjgnv.rs:20:24\n   |\n20 |             ret.append(l3[0]);\n\
    \   |                        ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                       \
    \    found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphu9gjgnv.rs:21:23\n\
    \   |\n21 |             l3.remove(&l3[0]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphu9gjgnv.rs:22:23\n\
    \   |\n22 |             l4.remove(&l4[0]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = usize::MAX;\n    let mut j = usize::MAX;\n   \
    \ let mut k = 0;\n    let mut common: Vec<isize> = vec![];\n\n    for i in l1.iter().take(std::cmp::min(l1.len(),\
    \ l2.len())) {\n        j = k + l2.iter().skip(k).count();\n        common.push(i);\n\
    \        common.extend(&l1[i .. j]);\n        k = j;\n    }\n\n    for i in l2.iter().take(std::cmp::min(l1.len(),\
    \ l2.len())) {\n        j = k + l1.iter().skip(k).count();\n        common.push(j);\n\
    \        common.extend(&l2[i .. j]);\n        k = j;\n    }\n\n    common\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn3y2_s9t.rs:14:21\n   |\n\
    14 |         common.push(i);\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \ common.push(*i);\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn3y2_s9t.rs:15:32\n   |\n15 |         common.extend(&l1[i .. j]);\n\
    \   |                                ^ expected `&isize`, found `usize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `std::ops::Range<&isize>`\n  --> /tmp/tmpn3y2_s9t.rs:15:24\n\
    \   |\n15 |         common.extend(&l1[i .. j]);\n   |                        ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<&isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<&isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn3y2_s9t.rs:21:21\n   |\n21 |         common.push(j);\n\
    \   |                     ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n21 |         common.push(j.try_into().unwrap());\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3y2_s9t.rs:22:32\n\
    \   |\n22 |         common.extend(&l2[i .. j]);\n   |                        \
    \        ^ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `std::ops::Range<&isize>`\n  --> /tmp/tmpn3y2_s9t.rs:22:24\n\
    \   |\n22 |         common.extend(&l2[i .. j]);\n   |                        ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<&isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip2(l2.iter().cloned(), |a, b| if a == b { None\
    \ } else { Some(a as i32) }).cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmprwoqn5mc.rs:7:15\n  |\n7 |     l1.iter().zip2(l2.iter().cloned(),\
    \ |a, b| if a == b { None } else { Some(a as i32) }).cloned().collect()\n  | \
    \              ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(&x, &y)| x == y).collect::<Vec<_>>().clone()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp927fapye.rs:7:5\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l1.iter().zip(l2.iter()).filter(|(&x, &y)| x == y).collect::<Vec<_>>().clone()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Vec<(&isize, &isize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| !l2.contains(&x)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpxa4u2yak.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    sort_by_key(l1.iter().zip(l2).map(|pair| pair.0).collect::<Vec<isize>>());\n\
    \    let mut v1 = l1.len();\n    let mut v2 = l2.len();\n    while v1 != 0 ||\
    \ v2 != 0 {\n        let mut i = v1;\n        let mut j = v2;\n        let mut\
    \ found = 0;\n        while i > 0 && j > 0 && (found == 0 || l1[i - 1] < l2[j\
    \ - 1]) {\n            if l1[i - 1] == l2[j - 1] {\n                i += 1;\n\
    \                j += 1;\n                found += 1;\n            } else if l1[i\
    \ - 1] < l2[j - 1] {\n                i += 1;\n            } else {\n        \
    \        j += 1;\n            }\n        }\n        v1 = i;\n        v2 = j;\n\
    \    }\n    l1.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_key` in this scope\n --> /tmp/tmp_nh4o8a4.rs:7:5\n\
    \  |\n7 |     sort_by_key(l1.iter().zip(l2).map(|pair| pair.0).collect::<Vec<isize>>());\n\
    \  |     ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmp_nh4o8a4.rs:7:54\n     |\n7    |     sort_by_key(l1.iter().zip(l2).map(|pair|\
    \ pair.0).collect::<Vec<isize>>());\n     |                                  \
    \                    ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l = l1;\n\
    \    while l.len() != l2.len() {\n        if l.len() < l2.len() {\n          \
    \  l1.push(0);\n        }\n        if l2.len() < l.len() {\n            l2.push(0);\n\
    \        }\n        for elem in l2 {\n            if !l1.contains(elem) {\n  \
    \              l.push(elem);\n                l1.push(elem);\n            }\n\
    \        }\n        for elem in l {\n            if !l2.contains(elem) {\n   \
    \             l2.push(elem);\n            }\n        }\n    }\n    l.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9xtcgpw.rs:18:29\n   |\n\
    18 |             if !l1.contains(elem) {\n   |                             ^^^^\n\
    \   |                             |\n   |                             expected\
    \ `&isize`, found `isize`\n   |                             help: consider borrowing\
    \ here: `&elem`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt9xtcgpw.rs:24:29\n\
    \   |\n24 |             if !l2.contains(elem) {\n   |                        \
    \     ^^^^\n   |                             |\n   |                         \
    \    expected `&isize`, found `isize`\n   |                             help:\
    \ consider borrowing here: `&elem`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1_iter = l1.iter();\n\
    \    let mut l2_iter = l2.iter();\n    let mut l1_ele = l1.len() as usize;\n \
    \   let mut l2_ele = l2.len() as usize;\n    while l1_ele.compare_to(l2_ele) <\
    \ 0 {\n        if l1_ele.compare_to(l2_ele) == 0 {\n            result.push(*l1_iter.next());\n\
    \            l1_ele = l1_iter.rev().next().unwrap();\n        } else {\n     \
    \       result.push(*l2_iter.next());\n            l2_ele = l2_iter.rev().next().unwrap();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `compare_to` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpgfbu8i56.rs:12:18\n   |\n12 |     while l1_ele.compare_to(l2_ele)\
    \ < 0 {\n   |                  ^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `compare_to` found for type `usize` in the current scope\n \
    \ --> /tmp/tmpgfbu8i56.rs:13:19\n   |\n13 |         if l1_ele.compare_to(l2_ele)\
    \ == 0 {\n   |                   ^^^^^^^^^^ method not found in `usize`\n\nerror[E0614]:\
    \ type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpgfbu8i56.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter.next());\n   |                  \
    \       ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgfbu8i56.rs:15:22\n\
    \   |\n10 |     let mut l1_ele = l1.len() as usize;\n   |                    \
    \  ----------------- expected due to this value\n...\n15 |             l1_ele\
    \ = l1_iter.rev().next().unwrap();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0614]: type `Option<&isize>` cannot\
    \ be dereferenced\n  --> /tmp/tmpgfbu8i56.rs:17:25\n   |\n17 |             result.push(*l2_iter.next());\n\
    \   |                         ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgfbu8i56.rs:18:22\n   |\n11 |     let mut l2_ele = l2.len() as\
    \ usize;\n   |                      ----------------- expected due to this value\n\
    ...\n18 |             l2_ele = l2_iter.rev().next().unwrap();\n   |          \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    common_inner(l1, l2, &mut []).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `common_inner` in this scope\n --> /tmp/tmpxuwa3qvl.rs:7:5\n\
    \  |\n7 |     common_inner(l1, l2, &mut []).unwrap()\n  |     ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut j = 0;\n    for\
    \ i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n            result[j]\
    \ = i;\n            j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplsz0kzie.rs:10:36\n   |\n\
    10 |         if l2.iter().any(|&x| x == i) {\n   |                           \
    \         ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n10 |         if l2.iter().any(|&x| x == *i) {\n   |      \
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplsz0kzie.rs:15:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l: Vec<isize> = l1.iter().cloned().collect();\n  \
    \  l.sort_unstable();\n    let mut r: Vec<isize> = l2.iter().cloned().collect();\n\
    \    r.sort_unstable();\n\n    let mut j = 0;\n    let mut i = 0;\n    while i\
    \ != l.len() && j != r.len() {\n        if l[i] == r[j] {\n            l.swap(i,\
    \ j);\n            i += 1;\n            j += 1;\n        } else if l[i] < r[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    while i != l.len() {\n        l.push(i);\n        i += 1;\n    }\n\
    \    while j != r.len() {\n        r.push(j);\n        j += 1;\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv_2slkqq.rs:26:16\n   |\n\
    26 |         l.push(i);\n   |                ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |         l.push(i.try_into().unwrap());\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv_2slkqq.rs:30:16\n   |\n30 |         r.push(j);\n   |             \
    \   ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n30 |        \
    \ r.push(j.try_into().unwrap());\n   |                 ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    sorted_unique(&l1, &l2)\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sorted_unique` in this scope\n -->\
    \ /tmp/tmpvornc8fr.rs:7:5\n  |\n7 |     sorted_unique(&l1, &l2)\n  |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    for i in l2 {\n        while result.contains(&i)\
    \ {\n            result.swap_remove(i);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8oxp4bm.rs:10:32\n   |\n\
    10 |             result.swap_remove(i);\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |           \
    \  result.swap_remove(i.try_into().unwrap());\n   |                          \
    \       ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c: Vec<isize> = l1;\n    let mut d: Vec<isize> = l2;\n\
    \    c.sort_unstable();\n    d.sort_unstable();\n    let mut i: usize = 0;\n \
    \   let mut j: usize = 0;\n    while i < c.len() && j < d.len() {\n        if\
    \ c[i] == d[j] {\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n\
    \            i += 1;\n            i += 1;\n            i += 1;\n            i\
    \ += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n     \
    \       i += 1;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpghq8c9d1.rs:133:3\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                                                         - unclosed delimiter\n\
    ...\n13  |     while i < c.len() && j < d.len() {\n    |                     \
    \                 - unclosed delimiter\n14  |         if c[i] == d[j] {\n    |\
    \                         - this delimiter might not be properly closed...\n...\n\
    125 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    133 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpghq8c9d1.rs:13:5\n\
    \    |\n6   |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  \
    \  |                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n13  | /     while i < c.len() && j < d.len() {\n\
    14  | |         if c[i] == d[j] {\n15  | |             i += 1;\n16  | |      \
    \       i += 1;\n...   |\n132 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n133 | | }\n    | |__^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n    let mut res: Vec<isize>\
    \ = vec![];\n    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n    \
    \        if l1[i] == l2[j] {\n                res.push(l1[i]);\n             \
    \   break;\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpp6p3fez1.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1\n        .iter()\n        .cloned()\n\
    \        .cloned()\n        .collect::<Vec<isize>>();\n    result.sort_unstable();\n\
    \    result.dedup();\n    result.extend(l2.iter().cloned().cloned());\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpmkvb0dnq.rs:10:10\n     |\n10   | \
    \        .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpmkvb0dnq.rs:11:10\n\
    \   |\n11 |           .collect::<Vec<isize>>();\n   |            ^^^^^^^ method\
    \ cannot be called on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Cloned<std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n \
    \          which is required by `Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize>\
    \ as Iterator>::Item == &&_`\n    --> /tmp/tmpmkvb0dnq.rs:14:38\n     |\n14  \
    \ |     result.extend(l2.iter().cloned().cloned());\n     |                  \
    \                    ^^^^^^ expected reference, found `isize`\n     |\n     =\
    \ note: expected reference `&&_`\n                found reference `&isize`\n \
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n \
    \   let mut common = vec![];\n    while l1.len() != l2.len() {\n        let cmp\
    \ = l1.pop().cmp(&l2.pop());\n        if cmp == 0 {\n            common = common.iter_mut().cloned().collect();\n\
    \        } else {\n            if cmp < 0 {\n                l1 = l1.iter().cloned().collect();\n\
    \            } else {\n                l2 = l2.iter().cloned().collect();\n  \
    \          }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7gqhxjba.rs:12:19\n   |\n\
    12 |         if cmp == 0 {\n   |                   ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0271]: type mismatch resolving `<std::slice::IterMut<'_,\
    \ _> as Iterator>::Item == &_`\n    --> /tmp/tmp7gqhxjba.rs:13:40\n     |\n13\
    \   |             common = common.iter_mut().cloned().collect();\n     |     \
    \                                   ^^^^^^ types differ in mutability\n     |\n\
    \     = note:      expected reference `&_`\n             found mutable reference\
    \ `&mut _`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<std::slice::IterMut<'_, _>>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp7gqhxjba.rs:13:49\n    |\n13  |  \
    \             common = common.iter_mut().cloned().collect();\n    |          \
    \                                         ^^^^^^^ method cannot be called on `Cloned<std::slice::IterMut<'_,\
    \ _>>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `<std::slice::IterMut<'_, _> as Iterator>::Item\
    \ = &_`\n            which is required by `Cloned<std::slice::IterMut<'_, _>>:\
    \ Iterator`\n            `Cloned<std::slice::IterMut<'_, _>>: Iterator`\n    \
    \        which is required by `&mut Cloned<std::slice::IterMut<'_, _>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7gqhxjba.rs:15:22\n   |\n15 |\
    \             if cmp < 0 {\n   |                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0271, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = vec![];\n    for (i, e1) in l1.iter().enumerate()\
    \ {\n        if l2.contains(&e1) {\n            ret.push(e1);\n        }\n   \
    \ }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgevz64gg.rs:13:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n13 |     ret\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut a = l1.len();\n    let mut b = l2.len();\n    let\
    \ mut counter = 0;\n    while a > 0 || b > 0 {\n        if a > 0 {\n         \
    \   if l1[a - 1] == l2[b - 1] {\n                a -= 1;\n                b -=\
    \ 1;\n                counter += 1;\n            }\n        }\n        if b >\
    \ 0 {\n            if l1[a - 1] < l2[b - 1] {\n                a -= 1;\n     \
    \       }\n            else {\n                b -= 1;\n            }\n      \
    \      counter += 1;\n        }\n    }\n    vec![l1[0], ..]\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0x9rr4j7.rs:28:17\n   |\n\
    28 |     vec![l1[0], ..]\n   |                 ^^ expected `isize`, found struct\
    \ `RangeFull`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    while l1.len() != 0 || l2.len()\
    \ != 0 {\n        let mut l1 = l1.iter().cloned().collect::<Vec<isize>>();\n \
    \       let mut l2 = l2.iter().cloned().collect::<Vec<isize>>();\n        if l1.len()\
    \ != 0 || l2.len() != 0 {\n            if l1.len() != l2.len() {\n           \
    \     result.push((l1.pop(), l2.pop()));\n                continue 2;\n      \
    \      }\n            while (l1.len() != 0) && (l2.len() != 0) {\n           \
    \     if l1.len() == l2.len() {\n                    result.push((l1.pop(), l2.pop()));\n\
    \                } else {\n                    result.push((l1.pop(), l2.pop()));\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `2`\n\
    \  --> /tmp/tmpjv18666f.rs:14:26\n   |\n14 |                 continue 2;\n   |\
    \                          ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjv18666f.rs:25:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<(Option<isize>,\
    \ Option<isize>)>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    l1.sort_unstable().cloned().forEach(|&x|\
    \ set.insert(x));\n    l2.sort_unstable().cloned().forEach(|&x| set.insert(x));\n\
    \    set.into_iter().filter(|&x| set.count(x) == 1).collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpt2iw587c.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0599]: `()`\
    \ is not an iterator\n --> /tmp/tmpt2iw587c.rs:8:24\n  |\n8 |     l1.sort_unstable().cloned().forEach(|&x|\
    \ set.insert(x));\n  |                        ^^^^^^ `()` is not an iterator\n\
    \  |\n  = note: the following trait bounds were not satisfied:\n          `():\
    \ Iterator`\n          which is required by `&mut (): Iterator`\n\nerror[E0599]:\
    \ `()` is not an iterator\n --> /tmp/tmpt2iw587c.rs:9:24\n  |\n9 |     l2.sort_unstable().cloned().forEach(|&x|\
    \ set.insert(x));\n  |                        ^^^^^^ `()` is not an iterator\n\
    \  |\n  = note: the following trait bounds were not satisfied:\n          `():\
    \ Iterator`\n          which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common: Vec<isize> = Vec::new();\n\n    while l1.len()\
    \ != 0 || l2.len() != 0 {\n        let mut first = true\n        while l1.len()\
    \ != 0 && l2.len() != 0 {\n            if l1.pop() == l2.pop() {\n           \
    \     common.push(l1.pop());\n                if first {\n                   \
    \ first = false;\n                } else {\n                    common = common.iter().cloned().collect();\n\
    \                    l1.pop();\n                    l2.pop();\n              \
    \  }\n            } else {\n                break;\n            }\n        }\n\
    \        if l1.len() != 0 {\n            common = common.iter().cloned().collect();\n\
    \            l1.pop();\n        } else {\n            break;\n        }\n    }\n\
    \    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `while`\n  --> /tmp/tmp2yfz6d6k.rs:10:29\n\
    \   |\n10 |         let mut first = true\n   |                             ^ help:\
    \ add `;` here\n11 |         while l1.len() != 0 && l2.len() != 0 {\n   |    \
    \     ----- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yfz6d6k.rs:13:29\n\
    \   |\n13 |                 common.push(l1.pop());\n   |                     \
    \        ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().cloned().zip(l2.iter().cloned())\n        .map(|(_,\
    \ x)| x).filter(|&x| !x.is_zero()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp5bkm_6rg.rs:8:41\n  |\n8 |         .map(|(_, x)| x).filter(|&x|\
    \ !x.is_zero()).collect()\n  |                                         ^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = l1.iter().cloned().chain(l2.iter().cloned());\n\
    \    let mut s = it.next();\n    let mut u = Vec::new();\n    while let Some(i)\
    \ = (it.next(), s.cloned()) {\n        if i == u {\n            continue;\n  \
    \      }\n        if l1.contains(i) && l2.contains(i) {\n            u.push(i);\n\
    \        }\n        if l1.contains(i) && !l2.contains(i) {\n            u.push(i);\n\
    \        }\n        if !l1.contains(i) && l2.contains(i) {\n            u.push(i);\n\
    \        }\n        if !l1.contains(i) && !l2.contains(i) {\n            u.push(i);\n\
    \        }\n    }\n    u\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<isize>` is not an iterator\n   --> /tmp/tmpwpgrnvp2.rs:10:39\n\
    \    |\n10  |       while let Some(i) = (it.next(), s.cloned()) {\n    |     \
    \                                    ^^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror[E0277]: can't compare `&isize` with `Vec<_>`\n  --> /tmp/tmpwpgrnvp2.rs:11:14\n\
    \   |\n11 |         if i == u {\n   |              ^^ no implementation for `&isize\
    \ == Vec<_>`\n   |\n   = help: the trait `PartialEq<Vec<_>>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwpgrnvp2.rs:27:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 |     u\n   |     ^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = Vec::new();\n    l2.iter().for_each(|e| l3.push(*e\
    \ & l1.iter().filter(|&e| e != e).count()));\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcso9jlwx.rs:8:41\n  |\n8 |\
    \     l2.iter().for_each(|e| l3.push(*e & l1.iter().filter(|&e| e != e).count()));\n\
    \  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: no implementation for `isize\
    \ & usize`\n --> /tmp/tmpcso9jlwx.rs:8:39\n  |\n8 |     l2.iter().for_each(|e|\
    \ l3.push(*e & l1.iter().filter(|&e| e != e).count()));\n  |                 \
    \                      ^ no implementation for `isize & usize`\n  |\n  = help:\
    \ the trait `BitAnd<usize>` is not implemented for `isize`\n  = help: the following\
    \ other types implement trait `BitAnd<Rhs>`:\n            <&'a i128 as BitAnd<i128>>\n\
    \            <&'a i16 as BitAnd<i16>>\n            <&'a i32 as BitAnd<i32>>\n\
    \            <&'a i64 as BitAnd<i64>>\n            <&'a i8 as BitAnd<i8>>\n  \
    \          <&'a isize as BitAnd<isize>>\n            <&'a u128 as BitAnd<u128>>\n\
    \            <&'a u16 as BitAnd<u16>>\n          and 40 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = Vec::new();\n    s.extend_from_slice(l1);\n  \
    \  s.extend_from_slice(l2);\n    s.sort();\n    s\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpa53t67ue.rs:8:25\n  |\n8 |\
    \     s.extend_from_slice(l1);\n  |                         ^^\n  |          \
    \               |\n  |                         expected `&[_]`, found struct `Vec`\n\
    \  |                         help: consider borrowing here: `&l1`\n  |\n  = note:\
    \ expected reference `&[_]`\n                found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpa53t67ue.rs:9:25\n  |\n9 |     s.extend_from_slice(l2);\n\
    \  |                         ^^\n  |                         |\n  |          \
    \               expected `&[_]`, found struct `Vec`\n  |                     \
    \    help: consider borrowing here: `&l2`\n  |\n  = note: expected reference `&[_]`\n\
    \                found struct `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let\
    \ mut c = 0;\n    let mut s = l1.len();\n    let mut u = l2.len();\n    while\
    \ i < s && j < u {\n        if l1[s..].iter().any(|&x| x == l2[j..].iter().any())\
    \ {\n            s += 1;\n            i += 1;\n            j += 1;\n        }\
    \ else {\n            c += 1;\n        }\n    }\n    l1.split_to(s)\n        .iter()\n\
    \        .filter(|x| l2[u..].iter().any(|&y| x == y)).cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmppld2cmvi.rs:13:56\n     |\n13   |         if l1[s..].iter().any(|&x|\
    \ x == l2[j..].iter().any()) {\n     |                                       \
    \                 ^^^- supplied 0 arguments\n     |                          \
    \                              |\n     |                                     \
    \                   expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppld2cmvi.rs:13:41\n  \
    \ |\n13 |         if l1[s..].iter().any(|&x| x == l2[j..].iter().any()) {\n  \
    \ |                                         ^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `bool`\n\nerror[E0599]: no method named `split_to` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmppld2cmvi.rs:21:8\n   |\n21 |     l1.split_to(s)\n\
    \   |        ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `split`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1_len = l1.len();\n\
    \    let mut l2_len = l2.len();\n    while l1_len > 0 && l2_len > 0 {\n      \
    \  let mut left = false;\n        let mut right = false;\n\n        if l1[l1_len\
    \ - 1] > l2[0] {\n            right = true;\n            l1_len -= 1;\n      \
    \  } else {\n            left = true;\n            l2_len -= 1;\n        }\n\n\
    \        if !left || !right {\n            result.push(*l1.pop());\n         \
    \   result.push(*l2.pop());\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmphnfimmtj.rs:23:25\n\
    \   |\n23 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmphnfimmtj.rs:24:25\n   |\n24 |             result.push(*l2.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut iter = l1.iter();\n    let mut it = l2.iter();\n \
    \   let mut res = Vec::new();\n\n    while iter.next().unwrap() != it.next() {\n\
    \        res.push(iter.next().unwrap());\n    }\n\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp6yvb0wef.rs:11:32\n\
    \   |\n11 |     while iter.next().unwrap() != it.next() {\n   |              \
    \                  ^^ no implementation for `&isize == Option<&isize>`\n   |\n\
    \   = help: the trait `PartialEq<Option<&isize>>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6yvb0wef.rs:15:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 |     res\n   |     ^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() < l2.len() {\n        l1.resize(l2.len(), l1.clone());\n\
    \    }\n    l1.iter().chain(l2.iter()).filter(|&x| *x == x).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk1dhkorg.rs:8:29\n  |\n8 |\
    \         l1.resize(l2.len(), l1.clone());\n  |                             ^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n  |\n  = note: expected type `isize`\n\
    \           found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk1dhkorg.rs:10:50\n   |\n10 |     l1.iter().chain(l2.iter()).filter(|&x|\
    \ *x == x).cloned().collect()\n   |                                          \
    \        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n10 |     l1.iter().chain(l2.iter()).filter(|&x| *x == *x).cloned().collect()\n\
    \   |                                                  +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.to_vec();\n\
    \    let mut l2 = l2.to_vec();\n    let mut i = 0;\n    while i < l1.len() &&\
    \ i < l2.len() {\n        if l1[i] < l2[i] {\n            result.push(l1[i]);\n\
    \            i += 1;\n        } else {\n            result.push(l2[i]);\n    \
    \        i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 1, 5, 9, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpzrs7cq8t.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpi4916tyb.rs:7:54\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    \     |                                                      ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common = vec![];\n    let mut last = l1.last().unwrap();\n\
    \    for elt in l2 {\n        if elt == last {\n            continue;\n      \
    \  }\n        let index = l1.iter().position(|x| *x == elt).unwrap();\n      \
    \  if index != Some(0) {\n            common.push(elt);\n        }\n        last\
    \ = elt;\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvyp087hp.rs:10:19\n   |\n\
    10 |         if elt == last {\n   |                   ^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |        \
    \ if elt == *last {\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvyp087hp.rs:14:21\n   |\n14 |         if index != Some(0) {\n \
    \  |                     ^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvyp087hp.rs:17:16\n   |\n8  |\
    \     let mut last = l1.last().unwrap();\n   |                    ------------------\
    \ expected due to this value\n...\n17 |         last = elt;\n   |            \
    \    ^^^\n   |                |\n   |                expected `&isize`, found\
    \ `isize`\n   |                help: consider borrowing here: `&elt`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() > l2.len() {\n        std::iter::repeat_with(||\
    \ {\n            l1.next().unwrap()\n        }).take(l2.len()).cloned()\n    }\
    \ else if l2.len() > l1.len() {\n        std::iter::repeat_with(|| {\n       \
    \     l2.next().unwrap()\n        }).take(l1.len()).cloned()\n    } else {\n \
    \       let mut it = l1.iter();\n        let mut it2 = l2.iter();\n        loop\
    \ {\n            let mut a = it.next();\n            let mut b = it2.next();\n\
    \            if a.is_none() || b.is_none() {\n                break;\n       \
    \     } else if *a < *b {\n                a = it.next();\n            }\n   \
    \         else  {\n                b = it2.next();\n            }\n        }\n\
    \        std::iter::repeat_with(|| {\n            a.unwrap()\n        }).take(l2.len()).cloned()\n\
    \    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `a` in this scope\n  --> /tmp/tmpkkef0hlc.rs:31:13\n\
    \   |\n31 |             a.unwrap()\n   |             ^ not found in this scope\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n --> /tmp/tmpkkef0hlc.rs:9:16\n  |\n9 |             l1.next().unwrap()\n\
    \  |                ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkkef0hlc.rs:8:9\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n7  |     \
    \  if l1.len() > l2.len() {\n8  | /         std::iter::repeat_with(|| {\n9  |\
    \ |             l1.next().unwrap()\n10 | |         }).take(l2.len()).cloned()\n\
    \   | |__________________________________^ expected struct `Vec`, found struct\
    \ `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Cloned<std::iter::Take<RepeatWith<_>>>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkkef0hlc.rs:13:16\n\
    \   |\n13 |             l2.next().unwrap()\n   |                ^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkkef0hlc.rs:12:9\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n12 | /         std::iter::repeat_with(|| {\n13\
    \ | |             l2.next().unwrap()\n14 | |         }).take(l1.len()).cloned()\n\
    \   | |__________________________________^ expected struct `Vec`, found struct\
    \ `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Cloned<std::iter::Take<RepeatWith<_>>>`\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpkkef0hlc.rs:23:23\n   |\n23 |        \
    \     } else if *a < *b {\n   |                       ^^\n\nerror[E0614]: type\
    \ `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpkkef0hlc.rs:23:28\n \
    \  |\n23 |             } else if "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = l1.clone();\n    for x in l2.iter().cloned()\
    \ {\n        for y in &mut ret {\n            if x == y {\n                ret.remove(y);\n\
    \                break;\n            }\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhz5s2qq.rs:10:21\n   |\n\
    10 |             if x == y {\n   |                     ^ expected `isize`, found\
    \ `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |    \
    \         if x == *y {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwhz5s2qq.rs:11:28\n   |\n11 |                 ret.remove(y);\n\
    \   |                            ^ expected `usize`, found `&mut isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.to_vec();\n    l3.sort_unstable();\n    l3.extend(l2.clone());\n\
    \    l3.clone().sort_unstable();\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653, 5, 7, 1, 5, 9, 653, 121]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpmvvrhhhz.rs:16:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // find out the common elements\n    let mut mut_common =\
    \ vec![];\n    let mut mut_i = l1.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut mut_j = l2.iter().cloned().collect::<Vec<_>>();\n    while mut_i.len() !=\
    \ mut_j.len() {\n        let mut i_el = mut_i.iter().next();\n        let mut\
    \ j_el = mut_j.iter().next();\n        if i_el == None || j_el == None {\n   \
    \         break;\n        }\n        let mut_i = i_el.unwrap();\n        let mut\
    \ mut_j = j_el.unwrap();\n        if mut_i != mut_j {\n            mut_common.push(mut_i);\n\
    \            mut_common = &mut_common[..];\n        }\n    }\n    mut_common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnaobxdi3.rs:21:26\n   |\n\
    8  |     let mut mut_common = vec![];\n   |                          ------ expected\
    \ due to this value\n...\n21 |             mut_common = &mut_common[..];\n   |\
    \                          ^^^^^^^^^^^^^^^ expected struct `Vec`, found `&[&isize]`\n\
    \   |\n   = note: expected struct `Vec<&isize>`\n           found reference `&[&isize]`\n\
    help: try using a conversion method\n   |\n21 |             mut_common = (&mut_common[..]).to_vec();\n\
    \   |                          +               ++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnaobxdi3.rs:24:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n24 |  \
    \   mut_common\n   |     ^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return Vec::new();\n\
    \    }\n\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\n   \
    \ while l1.len() != 0 || l2.len() != 0 {\n        let mut i = 0;\n\n        while\
    \ i < l1.len() && l1[i] == l2[i] {\n            i += 1;\n        }\n\n       \
    \ if l1.len() != 0 {\n            l1.remove(0);\n        }\n\n        if l2.len()\
    \ != 0 {\n            l2.remove(0);\n        }\n\n        i += 1;\n    }\n\n \
    \   l1.to_owned()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpmtlaynjg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    itertools::intersect(l1.iter().cloned().collect(), l2.iter().cloned().collect())\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `itertools`\n\
    \ --> /tmp/tmpgb5mfelr.rs:7:5\n  |\n7 |     itertools::intersect(l1.iter().cloned().collect(),\
    \ l2.iter().cloned().collect())\n  |     ^^^^^^^^^ use of undeclared crate or\
    \ module `itertools`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for &x in l1 { result.push(*x);\
    \ }\n    for &x in l2 { result.push(*x); }\n    result.sort_unstable();\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8_uxz4uj.rs:8:9\n  |\n8 |\
    \     for &x in l1 { result.push(*x); }\n  |         ^^    -- this expression\
    \ has type `Option<isize>`\n  |         |\n  |         expected `isize`, found\
    \ reference\n  |         help: you can probably remove the explicit borrow: `x`\n\
    \  |\n  = note:   expected type `isize`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8_uxz4uj.rs:9:9\n  |\n9 |     for &x in l2 {\
    \ result.push(*x); }\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1;\n    let mut l4 = l2;\n    for a in l3 {\n\
    \        for b in l4 {\n            if a == b {\n                l3.remove(a);\n\
    \                l4.remove(b);\n            }\n        }\n    }\n    l3.sort_unstable();\n\
    \    l4.sort_unstable();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl9lw29p1.rs:12:27\n   |\n\
    12 |                 l3.remove(a);\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |                 l3.remove(a.try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl9lw29p1.rs:13:27\n   |\n13 |                 l4.remove(b);\n\
    \   |                           ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n13 |                 l4.remove(b.try_into().unwrap());\n   |    \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1;\n    let mut r = l2;\n    while l.len() >\
    \ r.len() {\n        let (mut i, mut j) = l.iter().cloned().zip(r.iter().cloned()).enumerate().next();\n\
    \        if *i == *j {\n            l.remove(i);\n            r.remove(i);\n \
    \       } else {\n            i += 1;\n            j += 1;\n        }\n    }\n\
    \    l.extend(r);\n    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptb0124nh.rs:10:13\n   |\n\
    10 |         let (mut i, mut j) = l.iter().cloned().zip(r.iter().cloned()).enumerate().next();\n\
    \   |             ^^^^^^^^^^^^^^   -----------------------------------------------------------\
    \ this expression has type `Option<(usize, (isize, isize))>`\n   |           \
    \  |\n   |             expected enum `Option`, found tuple\n   |\n   = note: expected\
    \ enum `Option<(usize, (isize, isize))>`\n             found tuple `(_, _)`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c = 0;\n    let mut len = 0;\n    while c < l1.len()\
    \ {\n        len = l1[c].cmp(&l2[c]);\n        if len == 0 {\n            return\
    \ l1.iter().cloned().take(l1.len() - c).collect();\n        }\n        c = c +\
    \ 1;\n        if len == -1 {\n            c = l1.len() - c;\n        }\n    }\n\
    \    l1.iter().cloned().take(l1.len() - c).collect()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw1gajpkr.rs:10:15\n   |\n\
    8  |     let mut len = 0;\n   |                   - expected due to this value\n\
    9  |     while c < l1.len() {\n10 |         len = l1[c].cmp(&l2[c]);\n   |   \
    \            ^^^^^^^^^^^^^^^^^ expected integer, found enum `std::cmp::Ordering`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"Lists have different\
    \ lengths.\");\n    }\n\n    let mut result = Vec::new();\n\n    for i in l1.iter().cloned()\
    \ {\n        for j in l2.iter().cloned() {\n            if *i == *j {\n      \
    \          continue;\n            }\n\n            result.push(*i);\n        }\n\
    \    }\n\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp052mj4kl.rs:15:16\n\
    \   |\n15 |             if *i == *j {\n   |                ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp052mj4kl.rs:15:22\n   |\n\
    15 |             if *i == *j {\n   |                      ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp052mj4kl.rs:19:25\n   |\n\
    19 |             result.push(*i);\n   |                         ^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n    for i in l1.iter().filter(|x|\
    \ *x == *i) {\n        for j in l2.iter().filter(|x| *x == *i) {\n           \
    \ if *i != *j {\n                ret.push(*i);\n                break;\n     \
    \       }\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n --> /tmp/tmpzrnrw1eu.rs:8:42\n\
    \  |\n8 |     for i in l1.iter().filter(|x| *x == *i) {\n  |                 \
    \                         ^ help: a local variable with a similar name exists:\
    \ `x`\n\nerror[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmpzrnrw1eu.rs:9:42\n\
    \  |\n9 |         for j in l2.iter().filter(|x| *x == *i) {\n  |             \
    \                             ^^ no implementation for `&isize == isize`\n  |\n\
    \  = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n  = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n            f32\n\
    \            f64\n            i128\n            i16\n            i32\n       \
    \     i64\n            i8\n            isize\n          and 6 others\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n \
    \   let mut l5 = l3.clone();\n    let mut l6 = l4.clone();\n    let mut l7 = l5.clone();\n\
    \n    loop {\n        // Find a common element between 2 lists\n        let mut\
    \ indx = l5.iter().position(|&x| *x == *l6).unwrap();\n\n        // If there is\
    \ no common element, return it.\n        if indx == l5.len() {\n            return\
    \ l5\n        }\n\n        // If there is a common element, then remove it from\
    \ 1 of the lists.\n        // First remove it from 1 of the lists, then the other\
    \ list.\n        if indx == l6.len() {\n            l5.remove(indx);\n       \
    \     l6.remove(indx);\n        }\n\n        // If there is no common element,\
    \ return it.\n        if l5.len() == 0 {\n            return l5\n        }\n\n\
    \        // Otherwise, remove it from 1 of the lists, then the other list.\n \
    \       if l6.len() == 0 {\n            l6.remove(indx);\n            l7.remove(indx);\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp2aijxuua.rs:15:48\n\
    \   |\n15 |         let mut indx = l5.iter().position(|&x| *x == *l6).unwrap();\n\
    \   |                                                ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common = vec![];\n    let mut first = true;\n    for\
    \ elt in l1 {\n        if !first {\n            common.push(*elt);\n        }\n\
    \        common.push(*elt);\n        first = false;\n    }\n    let mut first\
    \ = true;\n    for elt in l2 {\n        if !first {\n            common.push(*elt);\n\
    \        }\n        common.push(*elt);\n        first = false;\n    }\n    common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpskr_ez08.rs:11:25\n\
    \   |\n11 |             common.push(*elt);\n   |                         ^^^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpskr_ez08.rs:13:21\n\
    \   |\n13 |         common.push(*elt);\n   |                     ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpskr_ez08.rs:19:25\n   |\n\
    19 |             common.push(*elt);\n   |                         ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpskr_ez08.rs:21:21\n   |\n\
    21 |         common.push(*elt);\n   |                     ^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut len1 = l1.len();\n    let mut len2 = l2.len();\n \
    \   let mut i: usize = 0;\n    let mut j: usize = 0;\n    while i < len1 && j\
    \ < len2 {\n        if l1[i] == l2[j] {\n            i += 1;\n            j +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    len1 -= i;\n\
    \    len2 -= j;\n    len1.cmp(&len2)\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph__3e0a0.rs:21:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n21 |     len1.cmp(&len2)\n   |     ^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found enum `std::cmp::Ordering`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found enum `std::cmp::Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    for a in l1 {\n        for b in\
    \ l2 {\n            if a == b {\n                continue;\n            }\n  \
    \          if !res.contains(&a) && !res.contains(&b) {\n                res.push(&a);\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r1bv7j3.rs:14:26\n   |\n\
    14 |                 res.push(&a);\n   |                          ^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider removing the borrow\n   |\n14\
    \ -                 res.push(&a);\n14 +                 res.push(a);\n   | \n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut i2 = l2.iter().cloned().collect::<Vec<_>>();\n    loop {\n        if\
    \ i1.len() < i2.len() {\n            break;\n        }\n        let mut i1_next\
    \ = i1.clone();\n        let mut i2_next = i2.clone();\n        loop {\n     \
    \       let mut i1_item = i1_next.next();\n            let mut i2_item = i2_next.next();\n\
    \            match i1_item {\n                None => break,\n               \
    \ Some(i1_item1) => match i2_item {\n                    None => break,\n    \
    \                Some(i2_item2) => {\n                        if i1_item1 == i2_item2\
    \ {\n                            i1.remove(i1_item1);\n                      \
    \      i2.remove(i2_item2);\n                        } else {\n              \
    \              break;\n                        }\n                    }\n    \
    \            },\n            };\n        }\n    }\n    i1.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpi8v_ncjt.rs:16:39\n   |\n16 |             let mut\
    \ i1_item = i1_next.next();\n   |                                       ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpi8v_ncjt.rs:17:39\n\
    \   |\n17 |             let mut i2_item = i2_next.next();\n   |              \
    \                         ^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.into_iter().filter(|x| *l2.contains(&x)).collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n --> /tmp/tmpk1kh4886.rs:7:31\n\
    \  |\n7 |     l1.into_iter().filter(|x| *l2.contains(&x)).collect::<Vec<isize>>()\n\
    \  |                               ^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<_> = l1.into_iter().collect();\n    let mut\
    \ l2: Vec<_> = l2.into_iter().collect();\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \    let mut l1: Vec<_> = l1.into_iter().collect();\n    let mut l2: Vec<_> =\
    \ l2.into_iter().collect();\n    while l1.len() != 0 || l2.len() != 0 {\n    \
    \    if l1.len() != 0 && l2.len() != 0 {\n            if l1.first() == l2.first()\
    \ {\n                l1.pop();\n                l2.pop();\n            } else\
    \ if l1.len() > l2.len() {\n                l2.pop();\n            } else {\n\
    \                l1.pop();\n            }\n        } else if l1.len() != 0 {\n\
    \            l1.pop();\n        } else {\n            l2.pop();\n        }\n \
    \   }\n    while l1.len() != 0 {\n        l1.pop();\n    }\n    while l2.len()\
    \ != 0 {\n        l2.pop();\n    }\n    l1\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmps0eq_ckp.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut u1 = HashSet::new();\n    let mut u2 = HashSet::new();\n\
    \    u1.insert(l1.iter().cloned().collect::<Vec<_>>());\n    u2.insert(l2.iter().cloned().collect::<Vec<_>>());\n\
    \    u1.iter().filter(|&x| !u2.contains(&x)).collect()\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpqak4z7fq.rs:7:18\n  |\n7 |     let mut u1 = HashSet::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpqak4z7fq.rs:8:18\n\
    \  |\n8 |     let mut u2 = HashSet::new();\n  |                  ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1;\n    let mut n = l1.len();\n    let mut m\
    \ = l2.len();\n    loop {\n        if n == m {\n            break;\n        }\n\
    \        if n > m {\n            n -= 1;\n            l += 1;\n        }\n   \
    \     else {\n            m -= 1;\n        }\n    }\n    l.sort();\n    l.dedup();\n\
    \    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmp2zr_bs0s.rs:16:13\n   |\n16 |             l += 1;\n\
    \   |             -^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    common::preprocess(l1, l2, HashSet::new(), std::cmp::min)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `common`\n\
    \ --> /tmp/tmpnstcloki.rs:7:5\n  |\n7 |     common::preprocess(l1, l2, HashSet::new(),\
    \ std::cmp::min)\n  |     ^^^^^^ use of undeclared crate or module `common`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpnstcloki.rs:7:32\n\
    \  |\n7 |     common::preprocess(l1, l2, HashSet::new(), std::cmp::min)\n  | \
    \                               ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    itertools::cmp::min(l1.iter().zip(l2.iter()).cloned().collect()).unwrap_or(&l1)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `itertools`\n\
    \ --> /tmp/tmpj62yo39n.rs:7:5\n  |\n7 |     itertools::cmp::min(l1.iter().zip(l2.iter()).cloned().collect()).unwrap_or(&l1)\n\
    \  |     ^^^^^^^^^ use of undeclared crate or module `itertools`\n\nerror[E0271]:\
    \ type mismatch resolving `<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>> as Iterator>::Item == &_`\n    --> /tmp/tmpj62yo39n.rs:7:50\n     |\n\
    7    |     itertools::cmp::min(l1.iter().zip(l2.iter()).cloned().collect()).unwrap_or(&l1)\n\
    \     |                                                  ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpj62yo39n.rs:7:59\n   |\n7  |        itertools::cmp::min(l1.iter().zip(l2.iter()).cloned().collect()).unwrap_or(&l1)\n\
    \   |                                                              ^^^^^^^ method\
    \ cannot be called on `Cloned<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>> as Iterator>::Item = &_`\n           which is required by `Cloned<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>>: Iterator`\n           `Cloned<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut index = 0;\n   \
    \ while index != l1.len() && index != l2.len() {\n        if l1[index] == l2[index]\
    \ {\n            result.push(l1[index]);\n            index += 1;\n        } else\
    \ {\n            while (index != l1.len()) result.push(l1[index]);\n         \
    \   index += 1;\n            while (index != l2.len()) result.push(l2[index]);\n\
    \            index += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `result`\n  --> /tmp/tmpsytpr3fq.rs:14:39\n\
    \   |\n14 |             while (index != l1.len()) result.push(l1[index]);\n  \
    \ |             ----- ------------------- ^^^^^^ expected `{`\n   |          \
    \   |     |\n   |             |     this `while` condition successfully parsed\n\
    \   |             while parsing the body of this `while` expression\n   |\nhelp:\
    \ try placing this code inside a block\n   |\n14 |             while (index !=\
    \ l1.len()) { result.push(l1[index]) };\n   |                                \
    \       +                        +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(el1, el2)| el1 == el2).collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpmksff1er.rs:7:62\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(el1, el2)| el1 == el2).collect::<Vec<isize>>()\n\
    \     |                                                              ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a,b)| *a == *b).map(|&(a,\
    \ b)| *a).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpywdsi3hx.rs:7:60\n  |\n7 |\
    \     l1.iter().zip(l2.iter()).filter(|(a,b)| *a == *b).map(|&(a, b)| *a).collect()\n\
    \  |                                                            ^^^^^^-\n  | \
    \                                                           |     |\n  |     \
    \                                                       |     expected due to\
    \ this\n  |                                                            expected\
    \ tuple, found reference\n  |\n  = note:  expected tuple `(&isize, &isize)`\n\
    \          found reference `&_`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = Set::new();\n    for x in l1 {\n        set.insert(x);\n\
    \    }\n    for x in l2 {\n        set.insert(x);\n    }\n    set\n        .iter()\n\
    \        .filter(|x| l1.contains(x))\n        .cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/tmpuhi6ak4d.rs:7:19\n\
    \  |\n7 |     let mut set = Set::new();\n  |                   ^^^ use of undeclared\
    \ type `Set`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n    for x in l1.iter()\
    \ {\n        if !l2.iter().any(|&y| x == y) {\n            ret.push(x);\n    \
    \    }\n    }\n    return ret;\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmplxz0dfes.rs:9:34\n\
    \  |\n9 |         if !l2.iter().any(|&y| x == y) {\n  |                      \
    \            ^^ no implementation for `&isize == isize`\n  |\n  = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            f32\n           \
    \ f64\n            i128\n            i16\n            i32\n            i64\n \
    \           i8\n            isize\n          and 6 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplxz0dfes.rs:10:22\n   |\n10 |             ret.push(x);\n\
    \   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n10 |             ret.push(*x);\n   |       \
    \               +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            i += 1;\n      \
    \      j += 1;\n        } else {\n            if l1[i] < l2[j] {\n           \
    \     i += 1;\n            } else {\n                j += 1;\n            }\n\
    \        }\n    }\n\n    vec![l1[i], l2[j]]\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 7 but the index\
    \ is 7', /tmp/tmp25pbzys7.rs:23:10\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1;\n    l.extend(l2);\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    while l.len() != 0 {\n        let mut x = l.iter().min().unwrap();\n\
    \        if result.contains(&x) {\n            continue;\n        }\n        result.push(x);\n\
    \        l.remove(x);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvd4bw02o.rs:15:21\n   |\n\
    15 |         result.push(x);\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \ result.push(*x);\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvd4bw02o.rs:16:18\n   |\n16 |         l.remove(x);\n   |      \
    \            ^ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list = l1.clone();\n    list.extend_from_slice(l2);\n\
    \    list.sort();\n    let mut i = 0;\n    let mut j = 1;\n    let mut result\
    \ = vec![];\n    while i < list.len() && j < list.len() {\n        if list[i]\
    \ < list[j] {\n            result.push(list[i]);\n            i += 1;\n      \
    \  } else {\n            result.push(list[j]);\n            j += 1;\n        }\n\
    \    }\n    list.remove(&mut i);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp45om5uy6.rs:8:28\n  |\n8 |\
    \     list.extend_from_slice(l2);\n  |                            ^^\n  |    \
    \                        |\n  |                            expected `&[isize]`,\
    \ found struct `Vec`\n  |                            help: consider borrowing\
    \ here: `&l2`\n  |\n  = note: expected reference `&[isize]`\n                found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45om5uy6.rs:22:17\n\
    \   |\n22 |     list.remove(&mut i);\n   |                 ^^^^^^ expected `usize`,\
    \ found `&mut usize`\n   |\nhelp: consider removing the borrow\n   |\n22 -   \
    \  list.remove(&mut i);\n22 +     list.remove(i);\n   | \n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    debug_assert!(l1.len() >= l2.len());\n    let mut set: HashSet<_>\
    \ = HashSet::new();\n    l1.iter().filter(|x| set.insert(x)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpvga_2_23.rs:8:18\n\
    \  |\n8 |     let mut set: HashSet<_> = HashSet::new();\n  |                 \
    \ ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpvga_2_23.rs:8:31\n  |\n8 |  \
    \   let mut set: HashSet<_> = HashSet::new();\n  |                           \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter();\n    let mut l2 = l2.iter();\n   \
    \ l1.sort();\n    l2.sort();\n    loop {\n        if l1.peek() == l2.peek() {\n\
    \            loop {\n                if l1.peek().is_none() {\n              \
    \      l1.next();\n                } else {\n                    l2.next();\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if l1.peek().is_none() {\n            l2.next();\n        } else if l2.peek().is_none()\
    \ {\n            l1.next();\n        } else {\n            break;\n        }\n\
    \    }\n    l1.collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmp7fxgm6s_.rs:9:8\n  |\n9 |     l1.sort();\n\
    \  |        ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]:\
    \ no method named `sort` found for struct `std::slice::Iter` in the current scope\n\
    \  --> /tmp/tmp7fxgm6s_.rs:10:8\n   |\n10 |     l2.sort();\n   |        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp7fxgm6s_.rs:12:15\n\
    \   |\n12 |         if l1.peek() == l2.peek() {\n   |               ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp7fxgm6s_.rs:12:28\n\
    \   |\n12 |         if l1.peek() == l2.peek() {\n   |                        \
    \    ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no\
    \ method named `peek` found for struct `std::slice::Iter` in the current scope\n\
    \  --> /tmp/tmp7fxgm6s_.rs:14:23\n   |\n14 |                 if l1.peek().is_none()\
    \ {\n   |                       ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp7fxgm6s_.rs:22:15\n   |\n22 |         if\
    \ l1.peek().is_none() {\n   |               ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp7fxgm6s_.rs:24:22\n   |\n24 |         }\
    \ else if l2.peek().is_none() {\n   |                      ^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp7fxgm6s_.rs:30:8\n\
    \     |\n30   |     l1.collect::<Vec<isize>>()\n     |        ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is no"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut mu = vec![0; l1.len()];\n    for &x in l1.iter() {\n\
    \        mu.push(x) as isize;\n    }\n    for &x in l2.iter() {\n        mu.push(x)\
    \ as isize;\n    }\n    mu.sort();\n    mu.dedup();\n    mu\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0605]: non-primitive cast: `()` as `isize`\n --> /tmp/tmpjtdcp5pf.rs:9:9\n\
    \  |\n9 |         mu.push(x) as isize;\n  |         ^^^^^^^^^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror[E0605]: non-primitive cast: `()` as `isize`\n\
    \  --> /tmp/tmpjtdcp5pf.rs:12:9\n   |\n12 |         mu.push(x) as isize;\n   |\
    \         ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0605`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common = vec![];\n    for x in l1 {\n        if l2.contains(&x)\
    \ {\n            common.append(x);\n        }\n    }\n    common\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplekb7xtp.rs:10:27\n   |\n\
    10 |             common.append(x);\n   |                           ^ expected\
    \ `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n    let mut j\
    \ = 0;\n    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n\
    \            let l1_element = l1_iter.next().unwrap();\n            if l2_iter.any()\
    \ && l2_iter.next().unwrap() == l1_element {\n                j = j + 1;\n   \
    \         }\n            j = j + 1;\n        }\n        if l2_iter.any() {\n \
    \           let l2_element = l2_iter.next().unwrap();\n            if l1_iter.any()\
    \ && l1_iter.next().unwrap() == l2_element {\n                j = j + 1;\n   \
    \         }\n            j = j + 1;\n        }\n    }\n    let mut i = 0;\n  \
    \  while i < result.len() {\n        if result.len() - i < j {\n            result.drain(i,\
    \ result.len() - i);\n        } else {\n            i += j;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp6owj3g0c.rs:11:19\n   |\n11 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp6owj3g0c.rs:11:36\n   |\n11 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp6owj3g0c.rs:12:20\n   |\n12 |         if\
    \ l1_iter.any() {\n   |                    ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp6owj3g0c.rs:13:38\n   |\n13 |             let l1_element\
    \ = l1_iter.next().unwrap();\n   |                                      ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp6owj3g0c.rs:14:24\n   |\n14\
    \ |             if l2_iter.any() && l2_iter.next().unwrap() == l1_element {\n\
    \   |                        ^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmp6owj3g0c.rs:14:41\n   |\n14 |             if l2_iter.any() && l2_iter.next().unwrap()\
    \ == l1_element {\n   |                                         ^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp6owj3g0c.rs:19:20\n   |\n19\
    \ |         if l2_iter.any() {\n   |                    ^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp6owj3g0c.rs:20:38\n   |\n20 |          \
    \   let l2_element = l2_iter.next().unwrap();\n   |                          \
    \            ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `any` found for "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut r = Vec::new();\n\n    for &x in l1 {\n        if\
    \ !l2.contains(&x) {\n            r.push(x);\n        }\n    }\n\n    r\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl8x5o3bg.rs:9:9\n  |\n9 |\
    \     for &x in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    l2.iter().for_each(|&i|\
    \ set.insert(i));\n    l1.iter().filter(|&i| set.contains(i)).collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpjqd93zdn.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]: a\
    \ value of type `Vec<isize>` cannot be built from an iterator over elements of\
    \ type `&isize`\n    --> /tmp/tmpjqd93zdn.rs:9:44\n     |\n9    |     l1.iter().filter(|&i|\
    \ set.contains(i)).collect()\n     |                                         \
    \   ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n    for\
    \ a in l2 {\n        if a == result.last_mut().unwrap() {\n            continue;\n\
    \        }\n        result.remove(a);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ep6x68g.rs:10:17\n   |\n\
    10 |         if a == result.last_mut().unwrap() {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n10 |         if a == *result.last_mut().unwrap() {\n   |     \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ep6x68g.rs:13:23\n\
    \   |\n13 |         result.remove(a);\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n13 |         result.remove(a.try_into().unwrap());\n\
    \   |                        ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = Vec::with_capacity(l1.len());\n    let mut intersect\
    \ = Vec::with_capacity(l1.len());\n    for &a in l1 {\n        for &b in l2 {\n\
    \            if a == b {\n                continue;\n            }\n         \
    \   if a < b {\n                s.push(a);\n            } else {\n           \
    \     s.push(b);\n            }\n        }\n        if s.len() > intersect.len()\
    \ {\n            intersect = s;\n        }\n        s.push(a);\n    }\n    if\
    \ s.len() != intersect.len() {\n        intersect = s;\n    }\n    intersect\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpus_xnvzn.rs:9:9\n  |\n9 |\
    \     for &a in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `a`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpus_xnvzn.rs:10:13\n   |\n10 |         for &b in l2 {\n   |    \
    \         ^^    -- this expression has type `Option<isize>`\n   |            \
    \ |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `b`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for x in l1.iter() {\n \
    \       for y in l2.iter() {\n            if *x == *y {\n                result.append(*x);\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8zvlkg5.rs:11:31\n   |\n\
    11 |                 result.append(*x);\n   |                               ^^\
    \ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c = HashSet::new();\n    c.insert(l1.clone());\n \
    \   c.insert(l2.clone());\n    c.clone().into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpovsra55s.rs:7:17\n  |\n7 |     let mut c = HashSet::new();\n  |    \
    \             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|&(&x, &y)| x == y).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmph1f92jaj.rs:7:57\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|&(&x, &y)| x == y).collect()\n\
    \     |                                                         ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    for e in l1 {\n       \
    \ if !set.contains(&e) {\n            set.insert(e);\n        }\n    }\n    for\
    \ e in l2 {\n        if !set.contains(&e) {\n            set.insert(e);\n    \
    \    }\n    }\n    set.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpni4wfs46.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).map(|(a,\
    \ b)| a).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpkwj80usp.rs:7:70\n     |\n7\
    \    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).map(|(a, b)| a).collect()\n\
    \     |                                                                      ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s1 = HashSet::new();\n    let mut s2 = HashSet::new();\n\
    \    let mut c1 = l1.len();\n    let mut c2 = l2.len();\n\n    while c1 > 0 ||\
    \ c2 > 0 {\n        if c1 > 0 && c2 > 0 {\n            if l1[c1 - 1] < l2[c2 -\
    \ 1] {\n                s2.insert(l1[c1 - 1]);\n                c1 -= 1;\n   \
    \         } else {\n                s1.insert(l2[c2 - 1]);\n                c2\
    \ -= 1;\n            }\n        } else if c1 > 0 {\n            s1.insert(l1[c1\
    \ - 1]);\n            c1 -= 1;\n        } else if c2 > 0 {\n            s2.insert(l2[c2\
    \ - 1]);\n            c2 -= 1;\n        }\n    }\n\n    s1.into_iter().collect::<Vec<_>>().union(&s2.into_iter()).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp9edfqv1n.rs:7:18\n  |\n7 |     let mut s1 = HashSet::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp9edfqv1n.rs:8:18\n\
    \  |\n8 |     let mut s2 = HashSet::new();\n  |                  ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \n    for i in 0..l1.len() {\n        if l1[i] == l2[i] {\n            result.push(l1[i]);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \ --> /tmp/tmp27hz51m9.rs:9:5\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n  |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n9 |     l1.sort_unstable();\n  |     ^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `l2` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp27hz51m9.rs:10:5\n   |\n6  | fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \ -- help: consider changing this to be mutable: `mut l2`\n...\n10 |     l2.sort_unstable();\n\
    \   |     ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut iset = HashSet::new();\n    for x in l1 {\n      \
    \  if !iset.insert(x).is_empty() {\n            return l1\n        }\n    }\n\
    \    for x in l2 {\n        if !iset.insert(x).is_empty() {\n            return\
    \ l2\n        }\n    }\n    return l1.iter().cloned().collect();\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmplp5_v40i.rs:7:20\n  |\n7 |     let mut iset = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n\n\
    \    while l1.len() >= l2.len() {\n        l1.pop();\n    }\n\n    while l2.len()\
    \ >= l1.len() {\n        l2.pop();\n    }\n\n    while l1.len() != l2.len() {\n\
    \        if l1.is_empty() {\n            l1.push(l2.pop());\n        } else if\
    \ l2.is_empty() {\n            l2.push(l1.pop());\n        } else {\n        \
    \    match &l1[0] as usize {\n                x if x == &l2[0] => l1.pop(),\n\
    \                _ => l2.pop(),\n            }\n        }\n    }\n\n    l1\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumazo2mh.rs:20:21\n   |\n\
    20 |             l1.push(l2.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpumazo2mh.rs:22:21\n   |\n22 |             l2.push(l1.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpumazo2mh.rs:25:27\n   |\n25 |  \
    \               x if x == &l2[0] => l1.pop(),\n   |                          \
    \ ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpumazo2mh.rs:24:13\n   |\n21 |            } else if l2.is_empty()\
    \ {\n   |   ________________-\n22 |  |             l2.push(l1.pop());\n23 |  |\
    \         } else {\n24 |  |             match &l1[0] as usize {\n   |  |_____________^\n\
    25 | ||                 x if x == &l2[0] => l1.pop(),\n26 | ||               \
    \  _ => l2.pop(),\n27 | ||             }\n   | ||_____________^ expected `()`,\
    \ found enum `Option`\n28 |  |         }\n   |  |_________- expected this to be\
    \ `()`\n   |\n   = note: expected unit type `()`\n                   found enum\
    \ `Option<isize>`\nhelp: consider using a semicolon here\n   |\n27 |         \
    \    };\n   |              +\nhelp: consider using a semicolon here\n   |\n28\
    \ |         };\n   |          +\n\nerror[E0606]: casting `&isize` as `usize` is\
    \ invalid\n  --> /tmp/tmpumazo2mh.rs:24:19\n   |\n24 |             match &l1[0]\
    \ as usize {\n   |                   ------^^^^^^^^^\n   |                   |\n\
    \   |                   cannot cast `&isize` as `usize`\n   |                \
    \   help: dereference the expression: `*&l1[0]`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = l1.clone();\n    let mut comp: usize\
    \ = 0;\n    let mut len: usize = l1.len();\n\n    while comp.cmp(l2.len()) < 0\
    \ {\n        if ret.is_empty() {\n            return ret;\n        }\n       \
    \ len -= 1;\n        for j in 0..(len as usize) {\n            if l1[comp] < l2[comp]\
    \ {\n                ret.insert(j, l1[comp]);\n                comp += 1;\n  \
    \              break;\n            } else if l1[comp] > l2[comp] {\n         \
    \       comp += 1;\n                break;\n            } else {\n           \
    \     break;\n            }\n        }\n    }\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0tbxz29.rs:11:20\n   |\n\
    11 |     while comp.cmp(l2.len()) < 0 {\n   |                    ^^^^^^^^\n  \
    \ |                    |\n   |                    expected `&usize`, found `usize`\n\
    \   |                    help: consider borrowing here: `&l2.len()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt0tbxz29.rs:11:32\n   |\n11 |     while comp.cmp(l2.len())\
    \ < 0 {\n   |                                ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1.clone();\n    l2.sort_unstable();\n  \
    \  for &x in l1 {\n        if result.iter().any(|&y| &x == &y) {\n           \
    \ result.erase(result.iter().find(|&y| &x == &y).unwrap());\n        }\n    }\n\
    \    for &x in l2 {\n        if result.iter().any(|&y| &x == &y) {\n         \
    \   result.insert(result.iter().find(|&y| &x == &y).unwrap(), x);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpigr7kjuf.rs:9:9\n  |\n9 |\
    \     for &x in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `x`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0599]: no method named\
    \ `erase` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpigr7kjuf.rs:11:20\n\
    \   |\n11 |             result.erase(result.iter().find(|&y| &x == &y).unwrap());\n\
    \   |                    ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpigr7kjuf.rs:14:9\n   |\n14 |     for &x in l2\
    \ {\n   |         ^^    -- this expression has type `Option<isize>`\n   |    \
    \     |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpigr7kjuf.rs:16:27\n   |\n16 |             result.insert(result.iter().find(|&y|\
    \ &x == &y).unwrap(), x);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0277]: can't compare `isize` with\
    \ `&isize`\n  --> /tmp/tmpigr7kjuf.rs:16:54\n   |\n16 |             result.insert(result.iter().find(|&y|\
    \ &x == &y).unwrap(), x);\n   |                                              \
    \        ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<&&isize>` for `&isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 || l1.len() != l2.len()\
    \ {\n        vec![]\n    }\n\n    let mut result = Vec::with_capacity(l1.len());\n\
    \    let mut l1 = l1.iter().cloned();\n    let mut l2 = l2.iter().cloned();\n\
    \    let mut i = 1;\n\n    while i <= l1.len() {\n        let mut j = i;\n\n \
    \       while j <= l2.len() {\n            if *l1 == *l2 {\n                result.append(*l1);\n\
    \                l1 = l1.clone();\n                l2 = l2.clone();\n        \
    \        i += 1;\n                j += 1;\n            } else {\n            \
    \    j += 1;\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4jkc3osz.rs:8:9\n  |\n7 |\
    \ /     if l1.len() == 0 || l2.len() == 0 || l1.len() != l2.len() {\n8 | |   \
    \      vec![]\n  | |         ^^^^^^ expected `()`, found struct `Vec`\n9 | | \
    \    }\n  | |_____- expected this to be `()`\n  |\n  = note: expected unit type\
    \ `()`\n                found struct `Vec<_>`\n  = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\nhelp: consider using a semicolon here\n  |\n9 |     };\n  |      +\n\n\
    error[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmp4jkc3osz.rs:20:16\n   |\n20 |             if *l1 == *l2 {\n   |\
    \                ^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>`\
    \ cannot be dereferenced\n  --> /tmp/tmp4jkc3osz.rs:20:23\n   |\n20 |        \
    \     if *l1 == *l2 {\n   |                       ^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmp4jkc3osz.rs:21:31\n   |\n21 |\
    \                 result.append(*l1);\n   |                               ^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"Cannot compare\
    \ unequal lists {} and {}\", l1.len(), l2.len());\n    }\n    let mut result =\
    \ vec![];\n    for i in 0..l1.len() {\n        let mut j = i;\n        while j\
    \ > 0 && l1.get(j) == l2.get(j - 1) {\n            j -= 1;\n        }\n      \
    \  result.push(l1.get(j));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9cixlloa.rs:18:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n18 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<&isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        panic!(\"len(l1) != len(l2)\"\
    );\n    }\n    let mut ret = Vec::new();\n    let mut l1 = l1.iter().cloned().collect();\n\
    \    let mut l2 = l2.iter().cloned().collect();\n    let mut common = vec![0;\
    \ l1.len()];\n    while l1.len() > 0 || l2.len() > 0 {\n        let mut left_idx\
    \ = 0;\n        let mut right_idx = 0;\n        while left_idx < l1.len() && right_idx\
    \ < l2.len() {\n            if l1[left_idx] < l2[right_idx] {\n              \
    \  common[left_idx] += 1;\n                left_idx += 1;\n            } else\
    \ {\n                common[right_idx] += 1;\n                right_idx += 1;\n\
    \            }\n        }\n        if left_idx > l1.len() {\n            l1.pop();\n\
    \            l1.extend(common);\n            common = vec![0; l1.len()];\n   \
    \     } else if right_idx > l2.len() {\n            l2.pop();\n            l2.extend(common);\n\
    \            common = vec![0; l2.len()];\n        }\n    }\n    while common.len()\
    \ > 0 {\n        ret.push(common[0]);\n        common.pop();\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpxogoidxm.rs:13:30\n\
    \   |\n11 |     let mut l1 = l1.iter().cloned().collect();\n   |         ------\
    \ consider giving `l1` a type\n12 |     let mut l2 = l2.iter().cloned().collect();\n\
    13 |     let mut common = vec![0; l1.len()];\n   |                           \
    \   ^^ cannot infer type\n   |\n   = note: type must be known at this point\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m = HashMap::new();\n    for &e in l1 { m.insert(e,\
    \ 0); }\n    for &e in l2 { m.insert(e, 1); }\n    let mut common: Vec<isize>\
    \ = vec![];\n    for e in m.iter() {\n        if *e > 1 {\n            common.push(*e);\n\
    \        }\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmppokceawj.rs:7:17\n  |\n7 |     let mut m = HashMap::new();\n  |    \
    \             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppokceawj.rs:8:9\n  |\n8 |     for &e in l1 { m.insert(e,\
    \ 0); }\n  |         ^^    -- this expression has type `Option<isize>`\n  |  \
    \       |\n  |         expected `isize`, found reference\n  |         help: you\
    \ can probably remove the explicit borrow: `e`\n  |\n  = note:   expected type\
    \ `isize`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmppokceawj.rs:9:9\n  |\n9 |     for &e in l2 { m.insert(e, 1); }\n\
    \  |         ^^    -- this expression has type `Option<isize>`\n  |         |\n\
    \  |         expected `isize`, found reference\n  |         help: you can probably\
    \ remove the explicit borrow: `e`\n  |\n  = note:   expected type `isize`\n  \
    \        found reference `&_`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut a = l1\n    let mut b = l2\n    if a.len() < b.len()\
    \ {\n        a.extend_from_slice(&b[..a.len()])\n    } else {\n        b.extend_from_slice(&a[..b.len()])\n\
    \    }\n    a.sort_unstable();\n    b.sort_unstable();\n    a.intersection(&b)\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmp24lmnaca.rs:7:19\n\
    \  |\n7 |     let mut a = l1\n  |                   ^ help: add `;` here\n8 |\
    \     let mut b = l2\n  |     --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `if`\n --> /tmp/tmp24lmnaca.rs:8:19\n  |\n8 |     let mut b = l2\n \
    \ |                   ^ help: add `;` here\n9 |     if a.len() < b.len() {\n \
    \ |     -- unexpected token\n\nerror[E0599]: no method named `intersection` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp24lmnaca.rs:16:7\n\
    \   |\n16 |     a.intersection(&b)\n   |       ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `insert`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    for i in l1.iter()\
    \ {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkiddjn27.rs:9:36\n  |\n9 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n9 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkiddjn27.rs:10:25\n\
    \   |\n10 |             result.push(i);\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    10 |             result.push(*i);\n   |                         +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut d = vec![];\n    for i in l1 {\n        match d.binary_search_by(|&x|\
    \ *x == i) {\n            Ok(i) => {}\n            Err(_) => {\n             \
    \   d.push(i);\n            }\n        }\n    }\n    for i in l2 {\n        match\
    \ d.binary_search_by(|&x| *x == i) {\n            Ok(i) => {}\n            Err(_)\
    \ => {\n                d.push(i);\n            }\n        }\n    }\n    d\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n --> /tmp/tmp8doefdg9.rs:9:35\n\
    \  |\n9 |         match d.binary_search_by(|&x| *x == i) {\n  |              \
    \                     ^^ consider giving this closure parameter the explicit type\
    \ `&T`, with the type parameters specified\n  |\n  = note: type must be known\
    \ at this point\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8doefdg9.rs:9:39\n\
    \  |\n9 |         match d.binary_search_by(|&x| *x == i) {\n  |              \
    \                         ^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l2.sort();\n    l1.sort();\n    let mut ans = Vec::new();\n    for i in 0..l1.len()\
    \ {\n        let mut j = 0;\n        while j < l2.len() && l2[j] == l1[i] {\n\
    \            j += 1\n        }\n        ans.push(l1[i]);\n        if j == l2.len()\
    \ {\n            ans.push(l2[i]);\n        }\n    }\n    ans\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpjtg6xk_5.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    use std::cmp::Ordering;\n    let mut c = 0;\n    let mut i\
    \ = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n\
    \            c += 1;\n        }\n        if l1[i] < l2[i] {\n            i +=\
    \ 1;\n        } else {\n            i += 1;\n        }\n    }\n    if l1.len()\
    \ == i {\n        l1.par_iter().cloned().collect::<Vec<_>>()\n    } else {\n \
    \       l2.par_iter().cloned().collect::<Vec<_>>()\n    }\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpcnjj2zrh.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method named\
    \ `par_iter` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcnjj2zrh.rs:21:12\n\
    \   |\n21 |         l1.par_iter().cloned().collect::<Vec<_>>()\n   |         \
    \   ^^^^^^^^ help: there is an associated function with a similar name: `iter`\n\
    \nerror[E0599]: no method named `par_iter` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpcnjj2zrh.rs:23:12\n   |\n23 |         l2.par_iter().cloned().collect::<Vec<_>>()\n\
    \   |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `iter`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1.len();\n    if l2 < l {\n        l = l2;\n\
    \    }\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    for i in\
    \ (0..l - 1).rev() {\n        for j in (0..l - 1).rev() {\n            match (i,\
    \ j) {\n                (0, _) => (),\n                (_, 0)  => (),\n      \
    \          _ => {\n                    if l1[i - 1] == l2[j - 1] {\n         \
    \               a.push(i);\n                        b.push(j);\n             \
    \       }\n                }\n            };\n        }\n    }\n    a.sort_unstable();\n\
    \    b.sort_unstable();\n    let mut c = Vec::new();\n    for i in 0..l {\n  \
    \      if i == 0 || (a[0] != b[0]) {\n            c.push(a[0]);\n        }\n \
    \       a.shift();\n        b.shift();\n    }\n    c\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2s38o7oi.rs:8:13\n  |\n8 |\
    \     if l2 < l {\n  |             ^ expected struct `Vec`, found `usize`\n  |\n\
    \  = note: expected struct `Vec<isize>`\n               found type `usize`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp2s38o7oi.rs:9:13\n  |\n7 |     let\
    \ mut l = l1.len();\n  |                 -------- expected due to this value\n\
    8 |     if l2 < l {\n9 |         l = l2;\n  |             ^^ expected `usize`,\
    \ found struct `Vec`\n  |\n  = note: expected type `usize`\n           found struct\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `shift` found for struct `Vec<usize>`\
    \ in the current scope\n  --> /tmp/tmp2s38o7oi.rs:34:11\n   |\n34 |         a.shift();\n\
    \   |           ^^^^^ method not found in `Vec<usize>`\n\nerror[E0599]: no method\
    \ named `shift` found for struct `Vec<usize>` in the current scope\n  --> /tmp/tmp2s38o7oi.rs:35:11\n\
    \   |\n35 |         b.shift();\n   |           ^^^^^ method not found in `Vec<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2s38o7oi.rs:37:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n37 |     c\n   |     ^ expected `isize`, found `usize`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|&(l, r)| l == r).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmp5h2hh7pb.rs:7:55\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|&(l, r)| l == r).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \n    for i in l1..=l2 {\n        if result.iter().any(|&x| x == i).is_false()\
    \ {\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Vec<isize>: Step` is not satisfied\n  -->\
    \ /tmp/tmpnlc8jmjb.rs:11:14\n   |\n11 |     for i in l1..=l2 {\n   |         \
    \     ^^^^^^^ the trait `Step` is not implemented for `Vec<isize>`\n   |\n   =\
    \ help: the following other types implement trait `Step`:\n             char\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n             u128\n           and 5 others\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `RangeInclusive<Vec<isize>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `RangeInclusive<Vec<isize>>`\n\nerror[E0599]:\
    \ no method named `is_false` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmpnlc8jmjb.rs:12:43\n   |\n12 |         if result.iter().any(|&x| x ==\
    \ i).is_false() {\n   |                                           ^^^^^^^^ method\
    \ not found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlc8jmjb.rs:16:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n16 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n        \
    \      found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    common_inner(result, l1,\
    \ l2, 1);\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `common_inner` in this scope\n --> /tmp/tmpwie4wa9z.rs:8:5\n\
    \  |\n8 |     common_inner(result, l1, l2, 1);\n  |     ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    for elt in l1.iter() {\n\
    \        if !set.insert(elt).is_empty() {\n            return l2;\n        }\n\
    \    }\n    return l2;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp_2klsttj.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = l1.iter();\n    let mut it_next = l2.iter();\n\
    \    let mut result = [it];\n    while let Some(next) = it_next.next() {\n   \
    \     if let Some(elem) = it.next() {\n            if elem == next {\n       \
    \         result.push(it);\n            }\n        }\n        it = it_next;\n\
    \        it_next = l2.iter();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for array `[std::slice::Iter<'_,\
    \ isize>; 1]` in the current scope\n  --> /tmp/tmpl7715vq4.rs:13:24\n   |\n13\
    \ |                 result.push(it);\n   |                        ^^^^ method\
    \ not found in `[std::slice::Iter<'_, isize>; 1]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl7715vq4.rs:19:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n19 |  \
    \   result\n   |     ^^^^^^ expected struct `Vec`, found array of 1 element\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found array `[std::slice::Iter<'_,\
    \ isize>; 1]`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut l1 = l1.iter().cloned().collect();\n\
    \    let mut l2 = l2.iter().cloned().collect();\n    let mut l1 = l1\n       \
    \ .iter()\n        .enumerate()\n        .filter(|(i, &elem)| {\n            l2.contains(&elem)\
    \ && l1.iter().any(|(_, j, _)| {\n                l2.contains(&elem)\n       \
    \             && l1.iter().any(|(_, j, _)| {\n                        l1.iter().any(|(_,\
    \ k, __)| {\n                            l2.contains(&elem) && l1.iter().any(|(_,\
    \ k, __)| {\n                                l1.iter().any(|(_, k, __)| {\n  \
    \                                  l2.contains(&elem)\n                      \
    \          })\n                            })\n                        })\n  \
    \                  })\n            })\n        })\n        .map(|(_, j)| j)\n\
    \        .collect();\n\n    while l1.len() != 0 && l2.len() != 0 {\n        result.push(*l1.first());\n\
    \        l1.pop();\n        l2.pop();\n    }\n\n    while l1.len() != 0 {\n  \
    \      result.push(*l1.first());\n        l1.pop();\n    }\n\n    while l2.len()\
    \ != 0 {\n        result.push(*l2.first());\n        l2.pop();\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmph9qjvr3b.rs:10:18\n\
    \   |\n8  |     let mut l1 = l1.iter().cloned().collect();\n   |         ------\
    \ consider giving `l1` a type\n9  |     let mut l2 = l2.iter().cloned().collect();\n\
    10 |     let mut l1 = l1\n   |                  ^^ cannot infer type\n   |\n \
    \  = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    sort_by_key(l1, l2);\n    intersect(l1, l2)\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_key` in this scope\n --> /tmp/tmperk5nnvl.rs:7:5\n\
    \  |\n7 |     sort_by_key(l1, l2);\n  |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `intersect` in this scope\n --> /tmp/tmperk5nnvl.rs:8:5\n\
    \  |\n8 |     intersect(l1, l2)\n  |     ^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(_, x)| x == Some(1)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&isize` with `Option<{integer}>`\n --> /tmp/tmpslebl1h7.rs:7:48\n\
    \  |\n7 |     l1.iter().zip(l2.iter()).filter(|(_, x)| x == Some(1)).collect()\n\
    \  |                                                ^^ no implementation for `&&isize\
    \ == Option<{integer}>`\n  |\n  = help: the trait `PartialEq<Option<{integer}>>`\
    \ is not implemented for `&&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `(&isize, &isize)`\n\
    \    --> /tmp/tmpslebl1h7.rs:7:60\n     |\n7    |     l1.iter().zip(l2.iter()).filter(|(_,\
    \ x)| x == Some(1)).collect()\n     |                                        \
    \                    ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n\n\
    \    let mut common: Vec<isize> = vec![0; l1.len()];\n\n    while l1.len() !=\
    \ 0 && l2.len() != 0 {\n        if l1[0] > l2[0] {\n            l2.remove(0);\n\
    \        } else {\n            l1.remove(0);\n        }\n    }\n\n    for e in\
    \ l1 {\n        if l2.iter().all(|x| x == e)) {\n            common.append(e);\n\
    \        }\n    }\n\n    return common;\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd0uzo7k7.rs:27:1\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - this opening brace...\n\
    ...\n24 |     }\n   |     - ...matches this closing brace\n...\n27 | }\n   | ^\
    \ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n \
    \ --> /tmp/tmpd0uzo7k7.rs:20:17\n   |\n20 |     for e in l1 {\n   |          \
    \       ^ unclosed delimiter\n21 |         if l2.iter().all(|x| x == e)) {\n \
    \  |                                     ^ mismatched closing delimiter\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    l1.iter().zip2(l2, |a, b|\
    \ if a == b { result.push(a) }).collect();\n    result.dedup();\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpoo0hsbtb.rs:8:15\n  |\n8 |     l1.iter().zip2(l2,\
    \ |a, b| if a == b { result.push(a) }).collect();\n  |               ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut seen: HashSet<isize> = HashSet::new();\n    seen.insert(l1.clone());\n\
    \    seen.insert(l2.clone());\n\n    let mut i = 1;\n    let mut j = 1;\n    let\
    \ mut common = l1;\n\n    while i < l1.len() && j < l2.len() {\n        let mut\
    \ smallest = i; //l1.len()\n        let mut largest = j; //l2.len()\n        loop\
    \ {\n            match seen.get(&l1[smallest]) {\n                None => break,\n\
    \                Some(&l2[largest]) => return common[smallest..largest],\n   \
    \         }\n\n            smallest = smallest + 1;\n            largest = largest\
    \ + 1;\n\n            if largest == l2.len() {\n                largest = l1.len();\n\
    \            }\n        }\n\n        common.push(l1[smallest]);\n        seen.remove(&l1[smallest]);\n\
    \n        if smallest < l1.len() {\n            smallest = smallest + 1;\n   \
    \     }\n\n        if smallest == l1.len() {\n            smallest = 1;\n    \
    \    }\n\n        j = j + 1;\n        if j == l2.len() {\n            j = 1;\n\
    \        }\n    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `[`\n  --> /tmp/tmpcfc7z5aq.rs:21:25\n\
    \   |\n21 |                 Some(&l2[largest]) => return common[smallest..largest],\n\
    \   |                         ^\n   |                         |\n   |        \
    \                 expected one of `)`, `,`, `@`, or `|`\n   |                \
    \         help: missing `,`\n\nerror[E0412]: cannot find type `HashSet` in this\
    \ scope\n --> /tmp/tmpcfc7z5aq.rs:7:19\n  |\n7 |     let mut seen: HashSet<isize>\
    \ = HashSet::new();\n  |                   ^^^^^^^ not found in this scope\n \
    \ |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpcfc7z5aq.rs:7:36\n  |\n7 |     let mut seen: HashSet<isize> = HashSet::new();\n\
    \  |                                    ^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0023]: this pattern has 2 fields, but the corresponding tuple variant\
    \ has 1 field\n   --> /tmp/tmpcfc7z5aq.rs:21:22\n    |\n21  |                \
    \ Some(&l2[largest]) => return common[smallest..largest],\n    |             \
    \         ^^^^^^^^^^^^ expected 1 field, found 2\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcfc7z5aq.rs:21:46\n   |\n21 |                 Some(&l2[largest])\
    \ => return common[smallest..largest],\n   |                                 \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                                              |\n   |     \
    \                                         expected struct `Vec`, found slice `[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nwarning: unreachable statement\n  --> /tmp/tmpcfc7z5aq.rs:24:13\n   |\n19 |\
    \ /             match seen.get(&l1[smallest]) {\n20 | |                 None =>\
    \ break,\n21 | |                 Some(&l2[largest]) => return common[smallest..largest],\n\
    22 | |             }\n   | |_____________- any code following this `match` expression\
    \ is unreachab"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    loop {\n        let mut it = l1.iter().cloned();\n       \
    \ it.next();\n        if it.next() == l2.front() {\n            let mut l3 = vec![];\n\
    \            l3.push(it.next_mut());\n            while l3.len() > 0 {\n     \
    \           if l3.last().unwrap() == l2.front() {\n                    break;\n\
    \                }\n                l3.pop();\n            }\n            if l3.len()\
    \ == 0 {\n                l3.push(l2.front());\n            }\n            return\
    \ l3;\n        }\n    }\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpxpa_qlas.rs:10:28\n   |\n10 |         if it.next()\
    \ == l2.front() {\n   |                            ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `next_mut` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpxpa_qlas.rs:12:24\n   |\n12 |             l3.push(it.next_mut());\n\
    \   |                        ^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpxpa_qlas.rs:14:45\n   |\n14 |          \
    \       if l3.last().unwrap() == l2.front() {\n   |                          \
    \                   ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no\
    \ method named `front` found for struct `Vec<isize>` in the current scope\n  -->\
    \ /tmp/tmpxpa_qlas.rs:20:28\n   |\n20 |                 l3.push(l2.front());\n\
    \   |                            ^^^^^ method not found in `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1.len();\n    l += l2.len();\n    let mut v =\
    \ Vec::new();\n    for i in 0..l {\n        let mut n1 = l1.len() - i;\n     \
    \   let mut n2 = l2.len() - i;\n        while n1 > 0 {\n            let n1 = n1\
    \ - 1;\n            let mut n2 = n2 - 1;\n            while n2 > 0 {\n       \
    \         let k = l[n2] as usize - l[n1] as usize;\n                if k == 0\
    \ || (n2 < n1 && v[k] >= v[k + 1]) {\n                    break;\n           \
    \     }\n                v[k + 1] = v[k];\n                n2 = n2 - 1;\n    \
    \        }\n            n1 = n1 - 1;\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpfkv55q77.rs:17:25\n\
    \   |\n17 |                 let k = l[n2] as usize - l[n1] as usize;\n   |   \
    \                      ^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `usize`\n  --> /tmp/tmpfkv55q77.rs:17:42\n   |\n17 |                 let k =\
    \ l[n2] as usize - l[n1] as usize;\n   |                                     \
    \     ^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    loop {\n        let len1 = l1.len();\n        let len2 = l2.len();\n\
    \n        if len1 < len2 {\n            break;\n        }\n        if len1 > len2\
    \ {\n            break;\n        }\n\n        let mut i1 = 0..len1;\n        let\
    \ mut i2 = 0..len2;\n\n        let mut shared = 0;\n        for &n in i1.iter().chain(i2.iter())\
    \ {\n            if &l1[n] == &l2[n] {\n                shared += 1;\n       \
    \     }\n        }\n\n        if shared == len1 {\n            return l1;\n  \
    \      }\n        if shared == len2 {\n            return l2;\n        }\n   \
    \ }\n    panic!()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpjn4wep12.rs:22:22\n   |\n22 |         for\
    \ &n in i1.iter().chain(i2.iter()) {\n   |                      ^^^^ method not\
    \ found in `std::ops::Range<usize>`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `std::ops::Range` in the current scope\n  --> /tmp/tmpjn4wep12.rs:22:38\n\
    \   |\n22 |         for &n in i1.iter().chain(i2.iter()) {\n   |             \
    \                         ^^^^ method not found in `std::ops::Range<usize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = Vec::new();\n    l1.sort_unstable();\n    l2.sort_unstable();\n\
    \    for &i in l1 & l2 {\n        s.push(i as isize);\n    }\n    s.sort_unstable();\n\
    \    s\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `Vec<isize> & Vec<isize>`\n  --> /tmp/tmpc08smwxw.rs:10:18\n\
    \   |\n10 |     for &i in l1 & l2 {\n   |               -- ^ -- Vec<isize>\n \
    \  |               |\n   |               Vec<isize>\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut u1: HashSet<isize> = HashSet::new();\n    let mut\
    \ u2: HashSet<isize> = HashSet::new();\n    l1.sort_unstable().dedup();\n    l2.sort_unstable().dedup();\n\
    \    for elt in l1 {\n        if !u2.contains(&elt) {\n            u2.insert(elt);\n\
    \        }\n    }\n    for elt in l2 {\n        if !u1.contains(&elt) {\n    \
    \        u1.insert(elt);\n        }\n    }\n    u2.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp0_whzn3w.rs:7:17\n\
    \  |\n7 |     let mut u1: HashSet<isize> = HashSet::new();\n  |              \
    \   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp0_whzn3w.rs:7:34\n  |\n7 |  \
    \   let mut u1: HashSet<isize> = HashSet::new();\n  |                        \
    \          ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp0_whzn3w.rs:8:17\n  |\n8 | \
    \    let mut u2: HashSet<isize> = HashSet::new();\n  |                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmp0_whzn3w.rs:8:34\n  |\n8 |     let\
    \ mut u2: HashSet<isize> = HashSet::new();\n  |                              \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0599]: no method named\
    \ `dedup` found for unit type `()` in the current scope\n --> /tmp/tmp0_whzn3w.rs:9:24\n\
    \  |\n9 |     l1.sort_unstable().dedup();\n  |                        ^^^^^ method\
    \ not found in `()`\n\nerror[E0599]: no method named `dedup` found for unit type\
    \ `()` in the current scope\n  --> /tmp/tmp0_whzn3w.rs:10:24\n   |\n10 |     l2.sort_unstable().dedup();\n\
    \   |                        ^^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0412, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    while l1.len() != 0 || l2.len()\
    \ != 0 {\n        if l1.len() == 0 {\n            result.push(*l2);\n        \
    \    l2.pop();\n        }\n        if l2.len() == 0 {\n            result.push(*l1);\n\
    \            l1.pop();\n        }\n        let mut i1 = l1.iter().enumerate().find(|(i,\
    \ e1)| *e1 == 1).unwrap();\n        let mut i2 = l2.iter().enumerate().find(|(i,\
    \ e2)| *e2 == 1).unwrap();\n        while i1 != i2 {\n            if *i1 < *i2\
    \ {\n                result.push(*i1);\n                i1.pop();\n          \
    \  } else {\n                result.push(*i2);\n                i2.pop();\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n   --> /tmp/tmpxidvbu8f.rs:10:25\n    |\n10  |           \
    \  result.push(*l2);\n    |                    ---- ^^^ doesn't have a size known\
    \ at compile-time\n    |                    |\n    |                    required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `[isize]`\nnote: required by a bound in `Vec::<T, A>::push`\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpxidvbu8f.rs:7:22\n    |\n7   |     let mut result = Vec::new();\n\
    \    |                      ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `[isize]`\nnote:\
    \ required by a bound in `Vec::<T>::new`\n\nerror[E0277]: the size for values\
    \ of type `[isize]` cannot be known at compilation time\n   --> /tmp/tmpxidvbu8f.rs:7:22\n\
    \    |\n7   |     let mut result = Vec::new();\n    |                      ^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[isize]`\nnote: required by a bound in `Vec`\n\nerror[E0599]:\
    \ the method `push` exists for struct `Vec<[isize]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpxidvbu8f.rs:14:20\n   |\n14 |             result.push(*l1);\n\
    \   |                    ^^^^ method cannot be called on `Vec<[isize]>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `[isize]: Sized`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpxidvbu8f.rs:17:63\n   |\n17 |         let mut\
    \ i1 = l1.iter().enumerate().find(|(i, e1)| *e1 == 1).unwrap();\n   |        \
    \                                                       ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n           "
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().cloned().zip(l2.iter().cloned()).filter(|(a, b)|\
    \ a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(isize, isize)`\n    --> /tmp/tmpwi3y6bgg.rs:7:72\n \
    \    |\n7    |     l1.iter().cloned().zip(l2.iter().cloned()).filter(|(a, b)|\
    \ a == b).collect()\n     |                                                  \
    \                      ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=(isize, isize)>`\n     |\n     = help: the trait `FromIterator<(isize,\
    \ isize)>` is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    Vec::new()\n        .iter()\n        .zip(l1.iter().zip(l2).map(|(a1,\
    \ a2)| a1.cmp(a2).unwrap()))\n        .filter(|&(a, b)| b)\n        .map(|&(a1,\
    \ a2)| a1)\n        .collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdkfg0b9b.rs:9:54\n  |\n9 |\
    \         .zip(l1.iter().zip(l2).map(|(a1, a2)| a1.cmp(a2).unwrap()))\n  |   \
    \                                                   ^^\n  |                  \
    \                                    |\n  |                                  \
    \                    expected `&isize`, found `isize`\n  |                   \
    \                                   help: consider borrowing here: `&a2`\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n --> /tmp/tmpdkfg0b9b.rs:9:58\n  |\n9 |         .zip(l1.iter().zip(l2).map(|(a1,\
    \ a2)| a1.cmp(a2).unwrap()))\n  |                                            \
    \              ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdkfg0b9b.rs:11:15\n   |\n11 |         .map(|&(a1,\
    \ a2)| a1)\n   |               ^^^^^^^^-\n   |               |       |\n   | \
    \              |       expected due to this\n   |               expected tuple,\
    \ found reference\n   |\n   = note:  expected tuple `(&_, bool)`\n           found\
    \ reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n    let mut result = vec![];\n\
    \    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n    let mut i1\
    \ = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n    \
    \    match l1[i1] < l2[i2] {\n            true => result.push(*l1[i1]),\n    \
    \        false => result.push(*l2[i2]),\n        }\n        i1 += 1;\n       \
    \ i2 += 1;\n    }\n    result.push(l1[i1], l2[i2])\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpkj48766k.rs:15:33\n\
    \   |\n15 |             true => result.push(*l1[i1]),\n   |                  \
    \               ^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpkj48766k.rs:16:34\n   |\n16 |             false => result.push(*l2[i2]),\n\
    \   |                                  ^^^^^^^\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpkj48766k.rs:21:12\n\
    \     |\n21   |     result.push(l1[i1], l2[i2])\n     |            ^^^^ ------\
    \  ------ supplied 2 arguments\n     |            |\n     |            expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkj48766k.rs:21:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n21 |  \
    \   result.push(l1[i1], l2[i2])\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut lv = l1;\n    lv.sort_unstable();\n    lv.sort_unstable();\n\
    \    lv.dedup();\n    lv.dedup();\n    vec![lv[0], lv[lv.len() - 1]]\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp0vran582.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result: Vec<isize> = l1.iter().cloned().collect();\n\
    \    l2.iter().cloned().for_each(|v| result.push(if v < result.len() {\n     \
    \   result[v]\n    } else {\n        result.push(*v)\n    }));\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5cjgsj2t.rs:8:56\n  |\n8 |\
    \     l2.iter().cloned().for_each(|v| result.push(if v < result.len() {\n  | \
    \                                                       ^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n8 |     l2.iter().cloned().for_each(|v|\
    \ result.push(if v < result.len().try_into().unwrap() {\n  |                 \
    \                                                   ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n --> /tmp/tmp5cjgsj2t.rs:9:9\n\
    \  |\n9 |         result[v]\n  |         ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n  = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  -->\
    \ /tmp/tmp5cjgsj2t.rs:11:21\n   |\n11 |         result.push(*v)\n   |        \
    \             ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5cjgsj2t.rs:11:9\n\
    \   |\n11 |         result.push(*v)\n   |         ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n    let mut ret = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            ret.append(l1[i]);\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ir5eyix.rs:12:24\n   |\n\
    12 |             ret.append(l1[i]);\n   |                        ^^^^^ expected\
    \ `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().union(l2.iter()).collect()\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `union` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmp1yj75fy7.rs:7:15\n  |\n7 |     l1.iter().union(l2.iter()).collect()\n\
    \  |               ^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    for element in l1.iter()\
    \ {\n        set.insert(element);\n    }\n    for element in l2.iter() {\n   \
    \     if set.contains(element) {\n            set.insert(element);\n        }\n\
    \    }\n    set.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpe16wkhpr.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result: Vec<_> = vec![l2[0]; l1.len()];\n    for i\
    \ in l1.iter().rev() {\n        match result.iter().find(|&x| x == &i) {\n   \
    \         Some(val) => result.push(val),\n            None => result.push(i),\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n --> /tmp/tmpedkbi8g5.rs:9:41\n\
    \  |\n9 |         match result.iter().find(|&x| x == &i) {\n  |              \
    \                           ^^ no implementation for `isize == &isize`\n  |\n\
    \  = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n  = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n            f32\n\
    \            f64\n            i128\n            i16\n            i32\n       \
    \     i64\n            i8\n            isize\n          and 6 others\n  = note:\
    \ required because of the requirements on the impl of `PartialEq<&&isize>` for\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpedkbi8g5.rs:10:38\n\
    \   |\n10 |             Some(val) => result.push(val),\n   |                 \
    \                     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n10 |             Some(val) => result.push(*val),\n\
    \   |                                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpedkbi8g5.rs:11:33\n   |\n11 |             None => result.push(i),\n\
    \   |                                 ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n11 |             None => result.push(*i),\n\
    \   |                                 +\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    debug_assert!(l1.len() == l2.len());\n    let mut res = vec![l2[0]];\n\
    \    let mut j = 0;\n    for i in l1.iter().enumerate() {\n        if l1[i] !=\
    \ l2[j] {\n            while j != res.len() - 1 {\n                j += 1;\n \
    \               res[j] += 1;\n            }\n            res.push(i);\n      \
    \      j += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `(usize, &isize)`\n\
    \  --> /tmp/tmpc7qdgusm.rs:11:12\n   |\n11 |         if l1[i] != l2[j] {\n   |\
    \            ^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `(usize,\
    \ &isize)`\n   = help: the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>,\
    \ Bound<usize>)`\n   = note: required because of the requirements on the impl\
    \ of `Index<(usize, &isize)>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc7qdgusm.rs:16:22\n   |\n16 |             res.push(i);\n   |  \
    \                    ^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `(usize, &isize)`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1.len() as usize;\n    if l != l2.len() {\n \
    \       l = l1.len() as usize + l2.len() as usize;\n    }\n    let mut ans = vec![l1[l\
    \ - 1] as isize];\n    for i in 1..l {\n        if l1[i - 1] != l2[i] {\n    \
    \        break;\n        }\n        ans.push(l1[i - 1]);\n    }\n    ans\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5]`,\n right: `[1, 5, 653]`', /tmp/tmphi0tv8oo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|x| l2.contains(&x)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpw94jeeyw.rs:7:43\n     |\n7\
    \    |     l1.iter().filter(|x| l2.contains(&x)).collect()\n     |           \
    \                                ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        std::vec::Vec::new(l1.len()).into_iter().collect()\n\
    \    } else {\n        l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).map(|(a,\
    \ b)| a).collect()\n    }\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp1zkxh0aq.rs:8:9\n    |\n8   |         std::vec::Vec::new(l1.len()).into_iter().collect()\n\
    \    |         ^^^^^^^^^^^^^^^^^^ -------- supplied 1 argument\n    |        \
    \ |\n    |         expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp1zkxh0aq.rs:10:74\n     |\n\
    10   |         l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).map(|(a, b)| a).collect()\n\
    \     |                                                                      \
    \    ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1_hashset = HashSet::new();\n    let mut l2_hashset\
    \ = HashSet::new();\n\n    l1.sort_unstable();\n    l2.sort_unstable();\n\n  \
    \  for i in l1.iter() {\n        if !l2_hashset.contains(&i) {\n            l1_hashset.insert(*i);\n\
    \        }\n    }\n\n    for i in l2.iter() {\n        if !l1_hashset.contains(&i)\
    \ {\n            l2_hashset.insert(*i);\n        }\n    }\n\n    l1_hashset\n\
    \        .iter()\n        .chain(l2_hashset.iter())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp8_3d_okp.rs:7:26\n  |\n7 |     let mut l1_hashset = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp8_3d_okp.rs:8:26\n\
    \  |\n8 |     let mut l2_hashset = HashSet::new();\n  |                      \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() > l2.len() {\n        common(l2, l1)\n    } else\
    \ {\n        common(l1, l2)\n    }\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = vec![];\n    for i in l1.iter().cloned().chain(l2.iter().cloned())\
    \ {\n        if let Some(j) = (s.iter().position(|x| *x == *i)).cloned() {\n \
    \           s.swap(j, j + 1);\n        }\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpt70xq7vq.rs:9:55\n\
    \  |\n9 |         if let Some(j) = (s.iter().position(|x| *x == *i)).cloned()\
    \ {\n  |                                                       ^^\n\nerror[E0599]:\
    \ `Option<usize>` is not an iterator\n   --> /tmp/tmpt70xq7vq.rs:9:60\n    |\n\
    9   |           if let Some(j) = (s.iter().position(|x| *x == *i)).cloned() {\n\
    \    |                                                              ^^^^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    let mut rest = l2;\n\n    while\
    \ result.len() > 0 && rest.len() > 0 {\n        if &result[0] < &rest[0] {\n \
    \           result.swap_remove(0);\n        } else {\n            rest.swap_remove(0);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653, 4, 3, 34]`,\n right: `[1, 5, 653]`', /tmp/tmpfkm44a7l.rs:23:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().cloned().chain(l2.iter().cloned()).filter(|&elem|\
    \ !l1.contains(&elem) && !l2.contains(&elem))\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmlyhgi0z.rs:7:5\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n7 |     l1.iter().cloned().chain(l2.iter().cloned()).filter(|&elem|\
    \ !l1.contains(&elem) && !l2.contains(&elem))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Filter`\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n             found struct `Filter<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ isize>>, Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpmlyhgi0z.rs:7:57:\
    \ 7:107]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect();\n    let mut l2\
    \ = l2.iter().cloned().collect();\n\n    let mut l3 = Vec::new();\n    while l1.len()\
    \ > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n            l3.push(l2.pop());\n\
    \            continue;\n        }\n\n        if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \            continue;\n        }\n\n        if l1[0] < l2[0] {\n            l3.push(l1.pop());\n\
    \        } else {\n            l3.push(l2.pop());\n        }\n    }\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp28yxef2y.rs:11:11\n\
    \   |\n7  |     let mut l1 = l1.iter().cloned().collect();\n   |         ------\
    \ consider giving `l1` a type\n...\n11 |     while l1.len() > 0 || l2.len() >\
    \ 0 {\n   |           ^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1.len();\n    let mut r = l2.len();\n    if l\
    \ < r {\n        let tmp = l;\n        l = r;\n        r = tmp;\n    }\n    while\
    \ l > 0 {\n        let mut i = l1.len();\n        let mut j = l2.len();\n    \
    \    if j > i {\n            j = i;\n            i = j;\n        }\n        while\
    \ i && j {\n            if l1[i] < l2[j] {\n                l1.pop();\n      \
    \      } else {\n                l2.pop();\n            }\n            i -= 1;\n\
    \            j -= 1;\n        }\n        l -= 1;\n    }\n    while r > 0 {\n \
    \       let mut i = l1.len();\n        let mut j = l2.len();\n        if j > i\
    \ {\n            j = i;\n            i = j;\n        }\n        while i && j {\n\
    \            if l1[i] > l2[j] {\n                l1.pop();\n            } else\
    \ {\n                l2.pop();\n            }\n            i -= 1;\n         \
    \   j -= 1;\n        }\n        r -= 1;\n    }\n    l1.reverse();\n    l2.reverse();\n\
    \    l1.clone() + l2\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_yt74vx1.rs:21:15\n   |\n\
    21 |         while i && j {\n   |               ^ expected `bool`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_yt74vx1.rs:21:20\n   |\n21 |\
    \         while i && j {\n   |                    ^ expected `bool`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_yt74vx1.rs:39:15\n   |\n39 |\
    \         while i && j {\n   |               ^ expected `bool`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_yt74vx1.rs:39:20\n   |\n39 |\
    \         while i && j {\n   |                    ^ expected `bool`, found `usize`\n\
    \nerror[E0369]: cannot add `Vec<isize>` to `Vec<isize>`\n  --> /tmp/tmp_yt74vx1.rs:52:16\n\
    \   |\n52 |     l1.clone() + l2\n   |     ---------- ^ -- Vec<isize>\n   |   \
    \  |\n   |     Vec<isize>\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n\
    \            result.push(l1[i]);\n            i += 1;\n        } else if l2[j]\
    \ < l1[i] {\n            result.push(l2[j]);\n            j += 1;\n        } else\
    \ {\n            i += 1;\n            j += 1;\n        }\n    }\n    while i <\
    \ l1.len() {\n        result.push(l1[i]);\n        i += 1;\n    }\n    while j\
    \ < l2.len() {\n        result.push(l2[j]);\n        j += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 2, 5, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpqsds9lin.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut iter = l1.iter().cloned();\n    iter.sort_unstable();\n\
    \    let mut iter = l2.iter().cloned();\n    iter.sort_unstable();\n    let mut\
    \ result = l1.iter().cloned();\n    for el in l1.iter() {\n        loop {\n  \
    \          if iter.next().unwrap() == el {\n                break;\n         \
    \   }\n            result.push(el);\n        }\n    }\n    for el in l2.iter()\
    \ {\n        loop {\n            if iter.next().unwrap() == el {\n           \
    \     break;\n            }\n            result.push(el);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_unstable` found for struct `Cloned`\
    \ in the current scope\n --> /tmp/tmpt6pctwgx.rs:8:10\n  |\n8 |     iter.sort_unstable();\n\
    \  |          ^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `sort_unstable` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpt6pctwgx.rs:10:10\n   |\n10 |     iter.sort_unstable();\n\
    \   |          ^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt6pctwgx.rs:14:40\n\
    \   |\n14 |             if iter.next().unwrap() == el {\n   |                \
    \                        ^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |             if iter.next().unwrap() ==\
    \ *el {\n   |                                        +\n\nerror[E0599]: no method\
    \ named `push` found for struct `Cloned` in the current scope\n  --> /tmp/tmpt6pctwgx.rs:17:20\n\
    \   |\n17 |             result.push(el);\n   |                    ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt6pctwgx.rs:22:40\n   |\n22 |             if iter.next().unwrap()\
    \ == el {\n   |                                        ^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \     if iter.next().unwrap() == *el {\n   |                                 \
    \       +\n\nerror[E0599]: no method named `push` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpt6pctwgx.rs:25:20\n   |\n25 |             result.push(el);\n\
    \   |                    ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt6pctwgx.rs:28:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n28 |     result\n   |     ^^^^^^ expected struct\
    \ `Vec`, found struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found s"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    while i < l1.len()\n        && j < l2.len()\n        && l1[i]\
    \ < l2[j]\n    {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n            i += 1;\n        }\n        if i >= l1.len() {\n           \
    \ break;\n        }\n        if j >= l2.len() {\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpfp2djgo_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    for x in l2 {\n        if result.contains(&x)\
    \ {\n            continue;\n        }\n        result.push(x);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmph8w752cs.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut u: Vec<_> = l1.iter().cloned().collect();\n    u.sort();\n\
    \    u.dedup();\n    let mut d: Vec<_> = l2.iter().cloned().collect();\n    d.sort();\n\
    \    d.dedup();\n    u.dedup();\n    if u.len() < d.len() {\n        d\n    }\
    \ else {\n        u\n    }\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpb5d7vl03.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 {\n        return l2;\n    }\n    if l2.len()\
    \ == 0 {\n        return l1;\n    }\n    let mut a = l1.iter();\n    let mut b\
    \ = l2.iter();\n    let mut c: Vec<isize> = vec![];\n    while a.next() && b.next()\
    \ {\n        if *a > *b {\n            c.push(*b);\n            b.next();\n  \
    \      }\n        else {\n            c.push(*a);\n            a.next();\n   \
    \     }\n    }\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpba4w987u.rs:16:11\n   |\n\
    16 |     while a.next() && b.next() {\n   |           ^^^^^^^^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpba4w987u.rs:16:23\n\
    \   |\n16 |     while a.next() && b.next() {\n   |                       ^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpba4w987u.rs:17:12\n   |\n17 |\
    \         if *a > *b {\n   |            ^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpba4w987u.rs:17:17\n   |\n17 |\
    \         if *a > *b {\n   |                 ^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpba4w987u.rs:18:20\n   |\n18 |\
    \             c.push(*b);\n   |                    ^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpba4w987u.rs:22:20\n   |\n22 |\
    \             c.push(*a);\n   |                    ^^\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() != l2.len() {\n        return vec![];\n    }\n\
    \n    let mut result = vec![];\n\n    for i in l1.iter() {\n        let mut j\
    \ = l2.iter().cloned().position(|&x| x == i).unwrap();\n        while j != result.len()\
    \ {\n            if l1[i] == l2[j] {\n                result[j] = i;\n       \
    \         break;\n            }\n            j += 1\n        };\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp7rkusn8.rs:14:50\n   |\n\
    14 |         let mut j = l2.iter().cloned().position(|&x| x == i).unwrap();\n\
    \   |                                                  ^--\n   |             \
    \                                     ||\n   |                               \
    \                   |expected due to this\n   |                              \
    \                    expected `isize`, found reference\n   |                 \
    \                                 help: did you mean `x`: `&isize`\n   |\n   =\
    \ note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpp7rkusn8.rs:16:16\n\
    \   |\n16 |             if l1[i] == l2[j] {\n   |                ^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp7rkusn8.rs:24:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n24 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common: Vec<isize> = Vec::new();\n\n    for i in l1.iter().cloned()\
    \ {\n        if l2.iter().any(|&i| i == i) {\n            common.push(i);\n  \
    \      }\n    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp689rqxxp.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c = 0;\n    for i in l1.iter().cloned() {\n      \
    \  c += l1.iter().filter(|&x| x == i).count();\n    }\n    for i in l2.iter().cloned()\
    \ {\n        c += l2.iter().filter(|&x| x == i).count();\n    }\n    (l1.iter().cloned()\
    \ + l2.iter().cloned()).into_iter().filter(|&x| x == c).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmphrcz27tx.rs:9:38\n\
    \  |\n9 |         c += l1.iter().filter(|&x| x == i).count();\n  |           \
    \                           ^^ no implementation for `&isize == isize`\n  |\n\
    \  = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n  = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n            f32\n\
    \            f64\n            i128\n            i16\n            i32\n       \
    \     i64\n            i8\n            isize\n          and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmphrcz27tx.rs:12:38\n   |\n\
    12 |         c += l2.iter().filter(|&x| x == i).count();\n   |               \
    \                       ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0369]: cannot add `Cloned<std::slice::Iter<'_, isize>>` to `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmphrcz27tx.rs:14:25\n   |\n14 |     (l1.iter().cloned()\
    \ + l2.iter().cloned()).into_iter().filter(|&x| x == c).cloned()\n   |      ------------------\
    \ ^ ------------------ Cloned<std::slice::Iter<'_, isize>>\n   |      |\n   |\
    \      Cloned<std::slice::Iter<'_, isize>>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = l1.len()\
    \ as isize;\n    let mut u = HashMap::<isize, usize>::new();\n    let mut v =\
    \ HashMap::<isize, usize>::new();\n    while i < l1.len() && j < l2.len() {\n\
    \        if l1.get(i) == l2.get(j) {\n            k.swap(i, j);\n            u.insert(l1.get(i),\
    \ i);\n            v.insert(l2.get(j), j);\n            i += 1;\n            j\
    \ += 1;\n        }\n        else {\n            i += 1;\n        }\n    }\n  \
    \  for _ in 0..k {\n        u.insert(l1.get(i), i);\n        i += 1;\n    }\n\
    \    for _ in 0..k {\n        v.insert(l2.get(j), j);\n        j += 1;\n    }\n\
    \    v.into_iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp_dy6a11d.rs:10:17\n   |\n10 |     let mut u = HashMap::<isize, usize>::new();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp_dy6a11d.rs:11:17\n\
    \   |\n11 |     let mut v = HashMap::<isize, usize>::new();\n   |            \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]: no method named\
    \ `swap` found for type `isize` in the current scope\n  --> /tmp/tmp_dy6a11d.rs:14:15\n\
    \   |\n14 |             k.swap(i, j);\n   |               ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| l2.iter().any(|&y| x == y)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n --> /tmp/tmpxg7z9jl7.rs:7:48\n\
    \  |\n7 |     l1.iter().filter(|&x| l2.iter().any(|&y| x == y)).cloned().collect()\n\
    \  |                                                ^^ no implementation for `&isize\
    \ == isize`\n  |\n  = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            f32\n            f64\n            i128\n            i16\n       \
    \     i32\n            i64\n            i8\n            isize\n          and 6\
    \ others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = vec![];\n    while l1.len() != 0\
    \ || l2.len() != 0 {\n        if l1.len() == 0 {\n            ret.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            ret.push(l1.pop());\n        }\
    \ else {\n            let mut i: isize = 0;\n            let mut j: isize = 0;\n\
    \            match l1[i] {\n                Some(a) => {\n                   \
    \ if j == 0 && a == l2[j] {\n                        i += 1;\n               \
    \     } else {\n                        j += 1;\n                    }\n     \
    \           }\n                None => {\n                    if j == l2.len()\
    \ - 1 {\n                        i += 1;\n                    } else {\n     \
    \                   j += 1;\n                    }\n                }\n      \
    \      }\n            ret.push(i + j);\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8z0_kxoc.rs:10:22\n   |\n\
    10 |             ret.push(l2.pop());\n   |                      ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8z0_kxoc.rs:12:22\n   |\n12 |             ret.push(l1.pop());\n   |\
    \                      ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8z0_kxoc.rs:16:19\n\
    \   |\n16 |             match l1[i] {\n   |                   ^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp8z0_kxoc.rs:18:39\n   |\n18 |            \
    \         if j == 0 && a == l2[j] {\n   |                                    \
    \   ^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8z0_kxoc.rs:25:29\n   |\n25 |              \
    \       if j == l2.len() - 1 {\n   |                             ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n25 |           \
    \          if j == (l2.len() - 1).try_into().unwrap() {\n   |                \
    \             +            +++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --ex"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut intersection = l1.clone();\n    for value in l2 {\n\
    \        if !intersection.contains(value) {\n            intersection.push(value);\n\
    \        }\n    }\n    intersection\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgqzhetnc.rs:9:35\n  |\n9 |\
    \         if !intersection.contains(value) {\n  |                            \
    \       ^^^^^\n  |                                   |\n  |                  \
    \                 expected `&isize`, found `isize`\n  |                      \
    \             help: consider borrowing here: `&value`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut intersection = vec![];\n    let mut i = 0;\n    while i <\
    \ l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            i += 1;\n\
    \        } else {\n            intersection.push(l1[i]);\n            i += 1;\n\
    \        }\n    }\n    intersection\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpagxy5ifx.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n\n    let mut seen = HashSet::new();\n\
    \    for e in l1 {\n        if !seen.insert(e) {\n            return l2;\n   \
    \     }\n    }\n    for e in l2 {\n        if !seen.insert(e) {\n            return\
    \ l1;\n        }\n    }\n    vec![l1.last().unwrap(), l2.last().unwrap()]\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp_66kcohj.rs:9:20\n  |\n9 |     let mut seen = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_66kcohj.rs:20:10\n   |\n20 |     vec![l1.last().unwrap(),\
    \ l2.last().unwrap()]\n   |          ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |     vec![*l1.last().unwrap(),\
    \ l2.last().unwrap()]\n   |          +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m = l1.len();\n    let mut n = l2.len();\n    let\
    \ mut result = vec![l1.len()];\n\n    while m > 0 && n > 0 {\n        if l1[m-1]\
    \ == l2[n-1] {\n            result[0] += 1;\n            if m > 1 {\n        \
    \        m -= 1;\n            } else {\n                n -= 1;\n            }\n\
    \        } else {\n            m -= 1;\n            n -= 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt5fq8ps9.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n    let mut res = Vec::new();\n\
    \    let mut itrs = vec![];\n    for (l, r) in l1.iter().zip(l2.iter()) {\n  \
    \      if l != r {\n            itrs.push(l);\n            itrs.push(r);\n   \
    \     }\n    }\n    for v in itrs.into_iter().rev() {\n        if !res.contains(&v)\
    \ {\n            res.push(v);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqry3d4f.rs:21:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n21 |     res\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    assert_eq!(l1.len(), l2.len());\n    let mut i: usize = 0;\n\
    \    let mut j: usize = 0;\n    let mut common: Vec<isize> = vec![];\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(*i\
    \ as isize);\n            i += 1;\n            j += 1;\n        } else if l1[i]\
    \ < l2[j] {\n            i += 1;\n        } else {\n            j += 1;\n    \
    \    }\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpav73hp_z.rs:13:25\n\
    \   |\n13 |             common.push(*i as isize);\n   |                      \
    \   ^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = Set::new();\n    for x in l1.iter() {\n    \
    \    if !set.insert(x).is_empty() {\n            continue;\n        }\n      \
    \  for x in l2.iter() {\n            if !set.insert(x).is_empty() {\n        \
    \        continue;\n            }\n            return Vec::new();\n        }\n\
    \    }\n    return set.iter().cloned().collect();\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/tmpag9kob3m.rs:7:19\n\
    \  |\n7 |     let mut set = Set::new();\n  |                   ^^^ use of undeclared\
    \ type `Set`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l = l1;\n    let mut c = l2;\n\n    l.sort();\n  \
    \  c.sort();\n\n    let mut i = 0;\n    let mut j = 0;\n\n    let mut common:\
    \ Vec<isize> = Vec::new();\n\n    while i < l.len() && j < c.len() {\n       \
    \ if l[i] < c[j] {\n            common.push(l[i++]);\n        } else {\n     \
    \       common.push(c[j++]);\n        }\n    }\n\n    while i < l.len() {\n  \
    \      common.push(l[i++]);\n    }\n\n    while j < c.len() {\n        common.push(c[j++]);\n\
    \    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpen1fea3n.rs:20:28\n\
    \   |\n20 |             common.push(l[i++]);\n   |                           \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |\
    \             common.push(l[{ let tmp = i; i += 1; tmp }]);\n   |            \
    \               +++++++++++  ~~~~~~~~~~~~~~~\n20 -             common.push(l[i++]);\n\
    20 +             common.push(l[i += 1]);\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpen1fea3n.rs:22:28\n   |\n22 |            \
    \ common.push(c[j++]);\n   |                            ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |             common.push(c[{\
    \ let tmp = j; j += 1; tmp }]);\n   |                           +++++++++++  ~~~~~~~~~~~~~~~\n\
    22 -             common.push(c[j++]);\n22 +             common.push(c[j += 1]);\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpen1fea3n.rs:27:24\n\
    \   |\n27 |         common.push(l[i++]);\n   |                        ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |         common.push(l[{\
    \ let tmp = i; i += 1; tmp }]);\n   |                       +++++++++++  ~~~~~~~~~~~~~~~\n\
    27 -         common.push(l[i++]);\n27 +         common.push(l[i += 1]);\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpen1fea3n.rs:31:24\n\
    \   |\n31 |         common.push(c[j++]);\n   |                        ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |         common.push(c[{\
    \ let tmp = j; j += 1; tmp }]);\n   |                       +++++++++++  ~~~~~~~~~~~~~~~\n\
    31 -         common.push(c[j++]);\n31 +         common.push(c[j += 1]);\n   |\
    \ \n\nerror: aborting due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1\n        .iter()\n        .cloned()\n    \
    \    .zip(l2.iter().cloned())\n        .collect::<Vec<_>>();\n    l1.sort();\n\
    \    l1.dedup();\n    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp29l0u8bp.rs:14:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 |     l1\n   |     ^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<(isize,\
    \ isize)>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n    let mut len1 =\
    \ l1.len();\n    let mut len2 = l2.len();\n    let mut i = 0;\n\n    while i <\
    \ len1 && i < len2 {\n        if l1.get(i) == l2.get(i) {\n            i += 1;\n\
    \        } else {\n            ret.push(l1.get(i));\n            i += 1;\n   \
    \     }\n    }\n\n    while i < len1 {\n        ret.push(l1.get(i));\n       \
    \ i += 1;\n    }\n\n    while i < len2 {\n        ret.push(l2.get(i));\n     \
    \   i += 1;\n    }\n\n    ret\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa79okkgz.rs:16:22\n   |\n\
    16 |             ret.push(l1.get(i));\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa79okkgz.rs:22:18\n   |\n22 |         ret.push(l1.get(i));\n   |   \
    \               ^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa79okkgz.rs:27:18\n   |\n27 |         ret.push(l2.get(i));\n\
    \   |                  ^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)| {\n        a == b\n\
    \    }).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpcau42jtb.rs:9:8\n     |\n9    | \
    \    }).cloned().collect()\n     |        ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_, isize>,\
    \ std::slice::Iter<'_, isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpcau42jtb.rs:9:17\n   |\n\
    9  |        }).cloned().collect()\n   |                    ^^^^^^^ method cannot\
    \ be called on `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]> as Iterator>::Item = &_`\n        \
    \   which is required by `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>>: Iterator`\n           `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpcau42jtb.rs:7:37: 9:6]>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n \
    \   let mut res = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if\
    \ l1.len() == 0 {\n            while l2.len() > 0 {\n                res.push(l2.remove(0));\n\
    \            }\n        } else if l2.len() == 0 {\n            while l1.len()\
    \ > 0 {\n                res.push(l1.remove(0));\n            }\n        } else\
    \ {\n            let l1_el = l1.remove(0)\n                .unwrap();\n      \
    \      let l2_el = l2.remove(0)\n                .unwrap();\n            if l1_el\
    \ == l2_el {\n                res.push(l1_el);\n            } else {\n       \
    \         res.push(l1_el);\n                res.push(l2_el);\n            }\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpnjfd9b2o.rs:21:18\n   |\n21 |                 .unwrap();\n\
    \   |                  ^^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpnjfd9b2o.rs:23:18\n\
    \   |\n23 |                 .unwrap();\n   |                  ^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = Set::new();\n    for elt in l1 {\n        set.insert(elt);\n\
    \    }\n    for elt in l2 {\n        if set.contains(&elt) {\n            set.remove(&elt);\n\
    \        }\n    }\n    set.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/tmpep1943k4.rs:7:19\n\
    \  |\n7 |     let mut set = Set::new();\n  |                   ^^^ use of undeclared\
    \ type `Set`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut c = l1.len();\n    let mut res = vec![];\n    while\
    \ c != 0 && l1[c - 1] != l2[c - 1] {\n        res.push(*l1[c - 1]);\n        c\
    \ -= 1;\n    }\n    while c != 0 {\n        res.push(*l1[c - 1]);\n        c -=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp6gmlmdus.rs:10:18\n\
    \   |\n10 |         res.push(*l1[c - 1]);\n   |                  ^^^^^^^^^^\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp6gmlmdus.rs:14:18\n\
    \   |\n14 |         res.push(*l1[c - 1]);\n   |                  ^^^^^^^^^^\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1;\n    let mut seen = HashSet::new();\n\
    \    for x in l1 {\n        if !seen.contains(x) {\n            seen.insert(x);\n\
    \            result.push(x);\n        }\n    }\n\n    for x in l2 {\n        if\
    \ !seen.contains(&x) {\n            seen.insert(&x);\n            result.push(x);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmparzbyak0.rs:8:20\n  |\n8 |     let mut seen = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    for x in l1 {\n       \
    \ if !set.insert(x).is_empty() {\n            set.insert(x);\n        }\n    }\n\
    \    for x in l2 {\n        if !set.insert(x).is_empty() {\n            set.insert(x);\n\
    \        }\n    }\n    set.into_iter().cloned().collect()\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpi9xv88dv.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m = std::collections::HashSet::new();\n    for i in\
    \ l1 { m.insert(i); }\n    for i in l2 { m.insert(i); }\n    for i in m.keys()\
    \ { m.remove(i); }\n    let mut s = Vec::new();\n    m.iter().filter(|x| s.contains(&x)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `keys` found for struct `HashSet` in the\
    \ current scope\n  --> /tmp/tmpz1uz807a.rs:10:16\n   |\n10 |     for i in m.keys()\
    \ { m.remove(i); }\n   |                ^^^^ method not found in `HashSet<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut l2 = l2.to_vec();\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut common = vec![];\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            common.push(l1[i]);\n            i += 1;\n         \
    \   i += 1;\n            i += 1;\n            i += 1;\n            i += 1;\n \
    \           j += 1;\n        }\n        else {\n            i += 1;\n        \
    \    j += 1;\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[1, 5, 653]`', /tmp/tmpl_kodw6d.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    itertools::unique(itertools::merge(&l1, &l2))\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `itertools`\n\
    \ --> /tmp/tmp6uurxxr0.rs:7:5\n  |\n7 |     itertools::unique(itertools::merge(&l1,\
    \ &l2))\n  |     ^^^^^^^^^ use of undeclared crate or module `itertools`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `itertools`\n --> /tmp/tmp6uurxxr0.rs:7:23\n\
    \  |\n7 |     itertools::unique(itertools::merge(&l1, &l2))\n  |             \
    \          ^^^^^^^^^ use of undeclared crate or module `itertools`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.is_empty() || l2.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut res = vec![l1.first() as usize];\n    for i in 0..l1.len()\
    \ {\n        let mut ls = l1.iter();\n        if l2.contains(&i) {\n         \
    \   ls = ls.skip(1);\n        }\n        for j in ls {\n            if *i == *j\
    \ {\n                continue;\n            }\n            *res.insert((*res).last()\
    \ + 1).unwrap() = *i;\n        }\n    }\n    res.sort_unstable();\n    res\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpijhs2f7h.rs:13:24\n   |\n\
    13 |         if l2.contains(&i) {\n   |                        ^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected reference `&isize`\n              found\
    \ reference `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpijhs2f7h.rs:14:18\n\
    \   |\n12 |         let mut ls = l1.iter();\n   |                      ---------\
    \ expected due to this value\n13 |         if l2.contains(&i) {\n14 |        \
    \     ls = ls.skip(1);\n   |                  ^^^^^^^^^^ expected struct `std::slice::Iter`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `std::slice::Iter<'_,\
    \ _>`\n              found struct `Skip<std::slice::Iter<'_, _>>`\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpijhs2f7h.rs:17:16\n   |\n\
    17 |             if *i == *j {\n   |                ^^\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<&usize>`\n  --> /tmp/tmpijhs2f7h.rs:20:39\n   |\n\
    20 |             *res.insert((*res).last() + 1).unwrap() = *i;\n   |         \
    \                ------------- ^ - {integer}\n   |                         |\n\
    \   |                         Option<&usize>\n\nerror[E0061]: this function takes\
    \ 2 arguments but 1 argument was supplied\n    --> /tmp/tmpijhs2f7h.rs:20:18\n\
    \     |\n20   |             *res.insert((*res).last() + 1).unwrap() = *i;\n  \
    \   |                  ^^^^^^ ----------------- supplied 1 argument\n     |  \
    \                |\n     |                  expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0599]: no method named `unwrap` found\
    \ for unit type `()` in the current scope\n  --> /tmp/tmpijhs2f7h.rs:20:44\n \
    \  |\n20 |             *res.insert((*res).last() + 1).unwrap() = *i;\n   |   \
    \                                         ^^^^^^ method not found in `()`\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpijhs2f7h.rs:20:55\n\
    \   |\n20 |             *res.insert((*res).last() + 1).unwrap() = *i;\n   |  \
    \                                                     ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpijhs2f7h.rs:24:5\n   |\n6  | fn com"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \ let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    loop {\n        if\
    \ l1.len() == l2.len() {\n            break;\n        }\n        let mut c = l1.len()\
    \ - l2.len();\n        for i in l2.len() {\n            if l1[i] < l2[i] {\n \
    \               l1.swap(i, c);\n                c -= 1;\n            }\n     \
    \   }\n    }\n    l1.sort();\n    l2.sort();\n    l1\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmpw71npcs3.rs:14:18\n\
    \   |\n14 |         for i in l2.len() {\n   |                  ^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = HashSet::new();\n    for x in l1 {\n        v1.insert(x);\n\
    \    }\n    let mut v2 = HashSet::new();\n    for x in l2 {\n        v2.insert(x);\n\
    \    }\n    v1.intersection(&v2).cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpg8h172ks.rs:7:18\n  |\n7 |     let mut v1 = HashSet::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpg8h172ks.rs:11:18\n\
    \   |\n11 |     let mut v2 = HashSet::new();\n   |                  ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    for i in l1.iter().cloned().skip(l2.iter().cloned().count())\
    \ {\n        res.push(i);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmplnmmqwjm.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    vec![(l1.iter().cloned().collect::<Vec<_>>().iter().max().unwrap()),\n\
    \        (l2.iter().cloned().collect::<Vec<_>>().iter().max().unwrap())]\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk51x97ky.rs:7:10\n  |\n7 |\
    \     vec![(l1.iter().cloned().collect::<Vec<_>>().iter().max().unwrap()),\n \
    \ |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n\
    7 |     vec![*(l1.iter().cloned().collect::<Vec<_>>().iter().max().unwrap()),\n\
    \  |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpulb098d6.rs:7:54\n\
    \     |\n7    |     l1.iter().zip(l2.iter()).filter(|(a, b)| a == b).collect()\n\
    \     |                                                      ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() > l2.len() {\n        let mut lt = l1;\n     \
    \   let mut lb = l2;\n        lt.sort();\n        lb.sort();\n        loop {\n\
    \            let mut ln = lt.len();\n            for _ in 0..ln {\n          \
    \      lt.remove(0);\n                if lt.len() == 0 {\n                   \
    \ break;\n                }\n            }\n            for _ in 0..lb.len() {\n\
    \                lt.remove(0);\n                if lb.len() == 0 {\n         \
    \           break;\n                }\n            }\n            if lt.len()\
    \ == 0 || lb.len() == 0 {\n                break;\n            }\n        }\n\
    \        lt.iter().cloned().collect()\n    } else {\n        let mut lt = l1;\n\
    \        let mut lb = l2;\n        lt.sort();\n        lb.sort();\n        loop\
    \ {\n            let mut ln = lt.len();\n            for _ in 0..ln {\n      \
    \          lt.remove(0);\n                if lt.len() == 0 {\n               \
    \     break;\n                }\n            }\n            for _ in 0..lb.len()\
    \ {\n                lt.remove(0);\n                if lb.len() == 0 {\n     \
    \               break;\n                }\n            }\n            if lt.len()\
    \ == 0 || lb.len() == 0 {\n                break;\n            }\n        }\n\
    \        lb.iter().cloned().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'removal index (is 0) should be < len (is 0)',\
    \ /tmp/tmp3w46oo4f.rs:45:20\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1.clone();\n\
    \    let mut l2 = l2.clone();\n    l1.sort();\n    l2.sort();\n\n    while !l1.is_empty()\
    \ && !l2.is_empty() {\n        if l1.front() == l2.front() {\n            result.push(l1.pop());\n\
    \            l1.pop();\n            l2.pop();\n        } else {\n            if\
    \ l1.front() > l2.front() {\n                result.push(l1.pop());\n        \
    \    } else {\n                result.push(l2.pop());\n            }\n       \
    \ }\n    }\n\n    while !l1.is_empty() {\n        result.push(l1.pop());\n   \
    \ }\n\n    while !l2.is_empty() {\n        result.push(l2.pop());\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpam549ot4.rs:14:15\n   |\n14 |         if l1.front()\
    \ == l2.front() {\n   |               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpam549ot4.rs:14:29\n   |\n14 |         if l1.front() ==\
    \ l2.front() {\n   |                             ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpam549ot4.rs:19:19\n   |\n19 |             if l1.front()\
    \ > l2.front() {\n   |                   ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpam549ot4.rs:19:32\n   |\n19 |             if l1.front()\
    \ > l2.front() {\n   |                                ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpam549ot4.rs:35:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n35 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    while l1.len() > 0 || l2.len()\
    \ > 0 {\n        if l1.len() == 0 {\n            res.push(*l2.pop());\n      \
    \  } else if l2.len() == 0 {\n            res.push(*l1.pop());\n        } else\
    \ {\n            if *l1.front() == *l2.front() {\n                l1.pop();\n\
    \                l2.pop();\n            } else if *l1.front() < *l2.front() {\n\
    \                res.push(*l1.front());\n                l1.pop();\n         \
    \   } else {\n                res.push(*l2.front());\n                l2.pop();\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2wyybgpp.rs:10:22\n\
    \   |\n10 |             res.push(*l2.pop());\n   |                      ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2wyybgpp.rs:12:22\n\
    \   |\n12 |             res.push(*l1.pop());\n   |                      ^^^^^^^^^\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp2wyybgpp.rs:14:20\n   |\n14 |             if *l1.front()\
    \ == *l2.front() {\n   |                    ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp2wyybgpp.rs:14:35\n   |\n14 |             if *l1.front()\
    \ == *l2.front() {\n   |                                   ^^^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp2wyybgpp.rs:17:27\n   |\n17 |          \
    \   } else if *l1.front() < *l2.front() {\n   |                           ^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2wyybgpp.rs:17:41\n\
    \   |\n17 |             } else if *l1.front() < *l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `front` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmp2wyybgpp.rs:18:30\n   |\n18 |                 res.push(*l1.front());\n\
    \   |                              ^^^^^ method not found in `Vec<isize>`\n\n\
    error[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp2wyybgpp.rs:21:30\n   |\n21 |                 res.push(*l2.front());\n\
    \   |                              ^^^^^ method not found in `Vec<isize>`\n\n\
    error: aborting due to 8 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut it = l1.iter().cloned().peekable();\n    let mut it2\
    \ = l2.iter().cloned().peekable();\n    let mut result = Vec::new();\n    while\
    \ it.peek().unwrap() != l1.last().unwrap() {\n        let mut it1r = it.peek().unwrap().rnext();\n\
    \        let mut it2r = it2.peek().unwrap().rnext();\n        while it1r != it2r\
    \ {\n            if *it1r == *it2r {\n                result.append(*it1r);\n\
    \                it1r = it1r.rnext();\n                it2r = it2r.rnext();\n\
    \            } else {\n                if *it1r < +*it2r {\n                 \
    \   result.push(*it1r);\n                    it1r = it1r.rnext();\n          \
    \      } else {\n                    result.push(*it2r);\n                   \
    \ it2r = it2r.rnext();\n                }\n            }\n        }\n        it.next();\n\
    \        it2.next();\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpgbt8vdfw.rs:19:28\n\
    \   |\n19 |                 if *it1r < +*it2r {\n   |                        \
    \    ^ expected expression\n\nerror[E0599]: no method named `rnext` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpgbt8vdfw.rs:11:43\n \
    \  |\n11 |         let mut it1r = it.peek().unwrap().rnext();\n   |          \
    \                                 ^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `rnext` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpgbt8vdfw.rs:12:44\n   |\n12 |         let mut it2r = it2.peek().unwrap().rnext();\n\
    \   |                                            ^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s = HashSet::new();\n    for &x in l1.iter() {\n \
    \       if !s.insert(x).is_empty() {\n            return l1;\n        }\n    }\n\
    \    for &x in l2.iter() {\n        if !s.insert(x).is_empty() {\n           \
    \ return l2;\n        }\n    }\n    l1\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpd1u8njui.rs:7:17\n  |\n7 |     let mut s = HashSet::new();\n  |    \
    \             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.extend_from_slice(&l2);\n\
    \    l3.sort_unstable();\n    l3.dedup();\n    l3.retain(|x| *l == *l);\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmp3_vfbxkv.rs:11:20\n\
    \   |\n11 |     l3.retain(|x| *l == *l);\n   |                    ^ help: a local\
    \ variable with a similar name exists: `l1`\n\nerror[E0425]: cannot find value\
    \ `l` in this scope\n  --> /tmp/tmp3_vfbxkv.rs:11:26\n   |\n11 |     l3.retain(|x|\
    \ *l == *l);\n   |                          ^ help: a local variable with a similar\
    \ name exists: `l1`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set = HashSet::new();\n    for x in l1.iter().cloned().zip(l2.iter().cloned())\
    \ {\n        set.insert(x.0);\n    }\n    set.iter().cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp66bgpd33.rs:7:19\n  |\n7 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\n\
    \    while l3.len() != l4.len() {\n        if l3.pop() != l4.pop() {\n       \
    \     break;\n        }\n    }\n\n    l4\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 7, 1, 5, 9, 653, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpx8b53s0p.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    let mut index = 0;\n    while\
    \ index < l1.len() && index < l2.len() {\n        if l1[index] == l2[index] {\n\
    \            result.push(l1[index]);\n            index += 1;\n        }\n   \
    \     index += 1\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp0e6z2cjo.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n\n    for i in l1.iter().cloned()\
    \ {\n        if !l2.contains(&i) {\n            result.push(i);\n        }\n \
    \   }\n\n    for i in l2.iter().cloned() {\n        if !l1.contains(&i) {\n  \
    \          result.push(i);\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpm44g_eav.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
