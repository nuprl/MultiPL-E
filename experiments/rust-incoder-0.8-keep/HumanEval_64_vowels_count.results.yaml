name: HumanEval_64_vowels_count
language: rust
results:
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        !c.is_lowercase()\n          \
    \  && c != 'a'\n            && c != 'e'\n            && c != 'i'\n           \
    \ && c != 'o'\n            && c != 'u'\n            && c != 'y'\n    ).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:13:18\n\
    \   |\n13 |             && c != 'a'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:14:18\n\
    \   |\n14 |             && c != 'e'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:15:18\n\
    \   |\n15 |             && c != 'i'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:16:18\n\
    \   |\n16 |             && c != 'o'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:17:18\n\
    \   |\n17 |             && c != 'u'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgt5rrp70.rs:18:18\n\
    \   |\n18 |             && c != 'y'\n   |                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgt5rrp70.rs:11:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` beca"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut vowels: Vec<String> = vec![\"\
    a\",\"e\",\"i\",\"o\",\"u\"];\n    let mut s_lower: String = s.to_lowercase();\n\
    \    while let Some(mut c) = s_lower.chars().nth(s_lower.len() - 1) {\n      \
    \  if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n           \
    \ count += 1;\n        }\n        s_lower = s_lower.chars().nth(s_lower.len()\
    \ - 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyc35dwwn.rs:12:40\n   |\n\
    12 |     let mut vowels: Vec<String> = vec![\"a\",\"e\",\"i\",\"o\",\"u\"];\n\
    \   |                                        ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \                                        expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyc35dwwn.rs:18:19\n   |\n13 |\
    \     let mut s_lower: String = s.to_lowercase();\n   |                      ------\
    \ expected due to this type\n...\n18 |         s_lower = s_lower.chars().nth(s_lower.len()\
    \ - 1);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<char>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_helper(s.chars()).count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmp3vr6lp88.rs:11:5\n   |\n11 |     vowels_count_helper(s.chars()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c == 'i' ||\
    \ *c == 'o' || *c == 'u')\n        .filter(|c| *c == 'A' || *c == 'E' || *c ==\
    \ 'I' || *c == 'O' || *c == 'U')\n        .count()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplf4votw1.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u')\n12 | |     \
    \    .filter(|c| *c == 'A' || *c == 'E' || *c == 'I' || *c == 'O' || *c == 'U')\n\
    13 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    use core::cmp::Ordering::{Equal, Greater};\n    s.chars().filter_map(|c|\
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' { Some(c) } else\
    \ { None }).count().cmp(&*s.chars().filter_map(|c| if c == 'y' { Some(c) } else\
    \ { None }).count())\n}\n\nfn main() {\n    let candidate = vowels_count;\n  \
    \  assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: maybe a missing crate `core`?\n  --> /tmp/tmpjs_7kgov.rs:11:9\n\
    \   |\n11 |     use core::cmp::Ordering::{Equal, Greater};\n   |         ^^^^\
    \ maybe a missing crate `core`?\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpjs_7kgov.rs:12:130\n   |\n12 | ... } else { None }).count().cmp(&*s.chars().filter_map(|c|\
    \ if c == 'y' { Some(c) } else { None }).count())\n   |                      \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjs_7kgov.rs:12:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n11 |     use core::cmp::Ordering::{Equal,\
    \ Greater};\n12 |     s.chars().filter_map(|c| if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' { Some(c) } else { None }).count().cmp(&*s.chars().filter_map(|c|\
    \ if c == 'y' { Some(c) } else { None }).count())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `std::cmp::Ordering`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpk8b46ieh.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpk8b46ieh.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpk8b46ieh.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpk8b46ieh.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpk8b46ieh.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_ascii_lowercase().is_ok()).filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count() + 1\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpir6z70d5.rs:11:49\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_ascii_lowercase().is_ok()).filter(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u').count(...\n   |                                 \
    \                ^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpir6z70d5.rs:11:74\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_ascii_lowercase().is_ok()).filter(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u').count(...\n   |                                 \
    \                                         ^^^^ expected `char`, found `u8`\n\n\
    error[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpir6z70d5.rs:11:71\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase().is_ok()).filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count(...\n \
    \  |                                                                       ^^\
    \ no implementation for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir6z70d5.rs:11:87\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase().is_ok()).filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count(...\n \
    \  |                                                                         \
    \              ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare\
    \ `&char` with `u8`\n  --> /tmp/tmpir6z70d5.rs:11:84\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_ascii_lowercase().is_ok()).filter(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u').count(...\n   |                                 \
    \                                                   ^^ no implementation for `&char\
    \ == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpir6z70d5.rs:11:100\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_impl(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmpkhas1yzf.rs:11:5\n   |\n11 |     vowels_count_impl(s, 0)\n   |\
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = &['a', 'e', 'i', 'o', 'u', 'y'];\n    let mut count\
    \ = 0;\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            count += 1;\n        }\n        if i == s.len() - 1 {\n     \
    \       if c == 'y' {\n                count += 1;\n            }\n        }\n\
    \    }\n    return count;\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpa5c961td.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0hmn4nb6.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0hmn4nb6.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0hmn4nb6.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0hmn4nb6.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp0hmn4nb6.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n       \
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowel_count\
    \ += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpvy9fok1g.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = vec!['a'; 'e'; 'i'; 'o'; 'u'];\n    let mut\
    \ index = 0;\n    let mut vowels_count = 0;\n    let mut cur_letter = s[0];\n\n\
    \    loop {\n        if cur_letter == 'y' {\n            vowels_count++;\n   \
    \         cur_letter = s[index+1];\n            index = 0;\n        } else {\n\
    \            if cur_letter in vowels {\n                vowels_count += 1;\n \
    \               cur_letter = s[index+1];\n                index = 0;\n       \
    \     } else {\n                index += 1;\n                cur_letter = s[index];\n\
    \            }\n        }\n        if cur_letter == 0 {\n            break;\n\
    \        }\n    }\n    vowels_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpv446u2hz.rs:18:25\n\
    \   |\n18 |             vowels_count++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |         \
    \    { let tmp = vowels_count; vowels_count += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n18 -             vowels_count++;\n18\
    \ +             vowels_count += 1;\n   | \n\nerror: expected `{`, found keyword\
    \ `in`\n  --> /tmp/tmpv446u2hz.rs:22:27\n   |\n22 |             if cur_letter\
    \ in vowels {\n   |             --            ^^ expected `{`\n   |          \
    \   |\n   |             this `if` expression has a condition, but no block\n\n\
    error: no rules expected the token `;`\n  --> /tmp/tmpv446u2hz.rs:11:35\n   |\n\
    11 |     let mut vowels = vec!['a'; 'e'; 'i'; 'o'; 'u'];\n   |               \
    \                    ^ no rules expected this token in macro call\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpv446u2hz.rs:14:26\n\
    \   |\n14 |     let mut cur_letter = s[0];\n   |                          ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s {\n        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o'\
    \ || ch == 'u' {\n            vowel_count += 1;\n            if ch == 'y' {\n\
    \                vowel_flag = true;\n            }\n        }\n    }\n    if vowel_flag\
    \ {\n        vowel_count += 1;\n    }\n    vowel_count\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp6y3hvtu4.rs:13:15\n\
    \   |\n13 |     for ch in s {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s.as_bytes())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvxx4hrn.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_bytes())\n   |                  ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizo690pe.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizo690pe.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizo690pe.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizo690pe.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpizo690pe.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        match c {\n            'a' =>\
    \ true,\n            'e' => true,\n            'i' => true,\n            'o' =>\
    \ true,\n            'u' => true,\n            _ => false,\n        }\n    ).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmb5txqsh.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\n\
    12 | |         match c {\n13 | |             'a' => true,\n14 | |            \
    \ 'e' => true,\n...  |\n19 | |         }\n20 | |     ).count()\n   | |_____________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     ).count().try_into().unwrap()\n\
    \   |              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c.is_vowel())\n        .count();\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp2lxbhw8i.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.is_vowel())\n   |                       ^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2lxbhw8i.rs:10:31\n   |\n10 |\
    \ fn vowels_count(s: String) -> isize {\n   |    ------------               ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_eklc0xo.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_eklc0xo.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_eklc0xo.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_eklc0xo.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp_eklc0xo.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut s = s;\n    let mut count = 0;\n    let mut last = s.len();\n\
    \    loop {\n        if s.chars().any(|c| *c != 'a' && *c != 'e' && *c != 'i'\
    \ && *c != 'o' && *c != 'u') {\n            break;\n        }\n        last =\
    \ last - 1;\n        count = count + 1;\n        s = &s[last..];\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp330q1lfj.rs:15:30\n\
    \   |\n15 |         if s.chars().any(|c| *c != 'a' && *c != 'e' && *c != 'i' &&\
    \ *c != 'o' && *c != 'u') {\n   |                              ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp330q1lfj.rs:15:43\n   |\n\
    15 |         if s.chars().any(|c| *c != 'a' && *c != 'e' && *c != 'i' && *c !=\
    \ 'o' && *c != 'u') {\n   |                                           ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp330q1lfj.rs:15:56\n   |\n\
    15 |         if s.chars().any(|c| *c != 'a' && *c != 'e' && *c != 'i' && *c !=\
    \ 'o' && *c != 'u') {\n   |                                                  \
    \      ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp330q1lfj.rs:15:69\n\
    \   |\n15 |         if s.chars().any(|c| *c != 'a' && *c != 'e' && *c != 'i' &&\
    \ *c != 'o' && *c != 'u') {\n   |                                            \
    \                         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp330q1lfj.rs:15:82\n   |\n15 |         if s.chars().any(|c| *c !=\
    \ 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n   |           \
    \                                                                       ^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp330q1lfj.rs:20:13\n   |\n11 |  \
    \   let mut s = s;\n   |                 - expected due to this value\n...\n20\
    \ |         s = &s[last..];\n   |             ^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n20 |        \
    \ s = (&s[last..]).to_string();\n   |             +          +++++++++++++\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels(&s).iter().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpjk2kz8fp.rs:11:5\n\
    \   |\n11 |     vowels(&s).iter().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    match (s) {\n        s @ \"\" => 0,\n        s @ _ | is_vowel(s.chars().next().unwrap())\
    \ => 1,\n        _ => 0,\n    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `.`\n  --> /tmp/tmpv6d2kttd.rs:13:27\n\
    \   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap()) => 1,\n   |  \
    \                         ^\n   |                           |\n   |          \
    \                 expected one of `)`, `,`, `@`, or `|`\n   |                \
    \           help: missing `,`\n\nerror: expected one of `)`, `,`, or `|`, found\
    \ `.`\n  --> /tmp/tmpv6d2kttd.rs:13:35\n   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap())\
    \ => 1,\n   |                                   ^\n   |                      \
    \             |\n   |                                   expected one of `)`, `,`,\
    \ or `|`\n   |                                   help: missing `,`\n\nerror: expected\
    \ one of `)`, `,`, or `|`, found `.`\n  --> /tmp/tmpv6d2kttd.rs:13:42\n   |\n\
    13 |         s @ _ | is_vowel(s.chars().next().unwrap()) => 1,\n   |         \
    \                                 ^\n   |                                    \
    \      |\n   |                                          expected one of `)`, `,`,\
    \ or `|`\n   |                                          help: missing `,`\n\n\
    error[E0531]: cannot find tuple struct or tuple variant `is_vowel` in this scope\n\
    \  --> /tmp/tmpv6d2kttd.rs:13:17\n   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap())\
    \ => 1,\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `chars` in this scope\n  --> /tmp/tmpv6d2kttd.rs:13:28\n\
    \   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap()) => 1,\n   |  \
    \                          ^^^^^ not found in this scope\n\nerror[E0531]: cannot\
    \ find tuple struct or tuple variant `next` in this scope\n  --> /tmp/tmpv6d2kttd.rs:13:36\n\
    \   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap()) => 1,\n   |  \
    \                                  ^^^^ not found in this scope\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `unwrap` in this scope\n  --> /tmp/tmpv6d2kttd.rs:13:43\n\
    \   |\n13 |         s @ _ | is_vowel(s.chars().next().unwrap()) => 1,\n   |  \
    \                                         ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21jevhl3.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21jevhl3.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21jevhl3.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21jevhl3.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp21jevhl3.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' ||\
    \ c == b'o' || c == b'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvmavrbk.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o'\
    \ || c == b'u').count()\n   |                               ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpqvmavrbk.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                            ^^ no implementation\
    \ for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqvmavrbk.rs:11:44\n   |\n11 |  \
    \   s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o' || c\
    \ == b'u').count()\n   |                                            ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpqvmavrbk.rs:11:41\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                                        \
    \ ^^ no implementation for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvmavrbk.rs:11:57\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                                        \
    \                 ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare\
    \ `&char` with `u8`\n  --> /tmp/tmpqvmavrbk.rs:11:54\n   |\n11 |     s.chars().filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count()\n   |\
    \                                                      ^^ no implementation for\
    \ `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqvmavrbk.rs:11:70\n   |\n11 |  \
    \   s.chars().filte"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = s.len();\n    for letter in s.chars()\
    \ {\n        match letter {\n            'a' | 'e' | 'i' | 'o' | 'u' => vowel_count\
    \ = vowel_count + 1,\n            _ => (),\n        }\n    }\n    vowel_count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_649_sb.rs:18:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n18 |     vowel_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    18 |     vowel_count.try_into().unwrap()\n   |                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpyflt4413.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyflt4413.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter_map(|c| match c {\n        'a' => true,\n \
    \       'e' => true,\n        'i' => true,\n        'o' => true,\n        'u'\
    \ => true,\n        _ => false,\n    }).count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7rvo_ivm.rs:12:16\n   |\n\
    12 |         'a' => true,\n   |                ^^^^ expected enum `Option`, found\
    \ `bool`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `bool`\nhelp: try wrapping the expression in `Some`\n   |\n12 |         'a'\
    \ => Some(true),\n   |                +++++    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7rvo_ivm.rs:11:5\n   |\n10 |   fn vowels_count(s: String) -> isize\
    \ {\n   |                                 ----- expected `isize` because of return\
    \ type\n11 | /     s.chars().filter_map(|c| match c {\n12 | |         'a' => true,\n\
    13 | |         'e' => true,\n14 | |         'i' => true,\n...  |\n17 | |     \
    \    _ => false,\n18 | |     }).count()\n   | |______________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpokyaecu2.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpokyaecu2.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpokyaecu2.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpokyaecu2.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpokyaecu2.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnsi5rvdx.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnsi5rvdx.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnsi5rvdx.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpnsi5rvdx.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnsi5rvdx.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: Vec<usize> = vec!['a'..'u'];\n\n    for &vowel\
    \ in vowels.iter() {\n        let index = s.char_indices().nth(0).unwrap();\n\
    \        if index == 0 || s[index - 1 - vowel].is_uppercase() {\n            continue;\n\
    \        }\n        return vowels.len();\n    }\n    s.chars().filter(|c| !c.is_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7fu5ix3d.rs:11:39\n   |\n\
    11 |     let mut vowels: Vec<usize> = vec!['a'..'u'];\n   |                  \
    \                     ^^^^^^^^ expected `usize`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `usize`\n            found struct `std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7fu5ix3d.rs:15:21\n   |\n15 |\
    \         if index == 0 || s[index - 1 - vowel].is_uppercase() {\n   |       \
    \              ^ expected tuple, found integer\n   |\n   = note: expected tuple\
    \ `(usize, char)`\n               found type `{integer}`\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `(usize, char)`\n  --> /tmp/tmp7fu5ix3d.rs:15:34\n\
    \   |\n15 |         if index == 0 || s[index - 1 - vowel].is_uppercase() {\n \
    \  |                            ----- ^ - {integer}\n   |                    \
    \        |\n   |                            (usize, char)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7fu5ix3d.rs:18:16\n   |\n18 |         return vowels.len();\n\
    \   |                ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         return vowels.len().try_into().unwrap();\n   |     \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7fu5ix3d.rs:20:5\n   |\n10 | fn vowels_count(s: String) -> isize\
    \ {\n   |                               ----- expected `isize` because of return\
    \ type\n...\n20 |     s.chars().filter(|c| !c.is_uppercase()).count()\n   |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     s.chars().filter(|c| !c.is_uppercase()).count().try_into().unwrap()\n\
    \   |                                                    ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s.chars().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = vec!['a'..'u', 'e'..'i', 'o'..'u', 'y'..'y'];\n\
    \    vowels.iter_mut().for_each(|vowel| s.chars().any(|c| vowel == c));\n    s.chars().filter(|c|\
    \ vowels[c]).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n  \
    \  assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&mut std::ops::Range<char>` with `char`\n\
    \  --> /tmp/tmp_3ox7r2w.rs:12:64\n   |\n12 |     vowels.iter_mut().for_each(|vowel|\
    \ s.chars().any(|c| vowel == c));\n   |                                      \
    \                          ^^ no implementation for `&mut std::ops::Range<char>\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&mut std::ops::Range<char>`\n   = help: the trait `PartialEq` is implemented\
    \ for `std::ops::Range<Idx>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3ox7r2w.rs:12:40\n\
    \   |\n12 |     vowels.iter_mut().for_each(|vowel| s.chars().any(|c| vowel ==\
    \ c));\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found `bool`\n\nerror[E0277]: the type `[std::ops::Range<char>]`\
    \ cannot be indexed by `&char`\n  --> /tmp/tmp_3ox7r2w.rs:13:26\n   |\n13 |  \
    \   s.chars().filter(|c| vowels[c]).count()\n   |                          ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[std::ops::Range<char>]>` is not implemented for `&char`\n\
    \   = note: required because of the requirements on the impl of `Index<&char>`\
    \ for `Vec<std::ops::Range<char>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3ox7r2w.rs:13:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n13 |     s.chars().filter(|c|\
    \ vowels[c]).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     s.chars().filter(|c|\
    \ vowels[c]).count().try_into().unwrap()\n   |                               \
    \             ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.to_ascii_lowercase() == c).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp60ciauxh.rs:11:52\n   |\n\
    11 |     s.chars().filter(|c| c.to_ascii_lowercase() == c).count()\n   |     \
    \                                               ^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n11 |     s.chars().filter(|c|\
    \ c.to_ascii_lowercase() == *c).count()\n   |                                \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp60ciauxh.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.to_ascii_lowercase() == c).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.to_ascii_lowercase() == c).count().try_into().unwrap()\n   |             \
    \                                                 ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: Vec<_> = vec!['a'; 'e'; 'i'; 'o'; 'u'];\n\n\
    \    vowels.iter().filter(|&c| c == s.chars().last().unwrap()).count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: no rules expected the token `;`\n  --> /tmp/tmp0ehi8g5m.rs:11:43\n\
    \   |\n11 |     let mut vowels: Vec<_> = vec!['a'; 'e'; 'i'; 'o'; 'u'];\n   |\
    \                                           ^ no rules expected this token in\
    \ macro call\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmp0ehi8g5m.rs:13:33\n\
    \   |\n13 |     vowels.iter().filter(|&c| c == s.chars().last().unwrap()).count()\n\
    \   |                                 ^^ no implementation for `&_ == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0ehi8g5m.rs:13:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n...\n13 |     vowels.iter().filter(|&c|\
    \ c == s.chars().last().unwrap()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |     vowels.iter().filter(|&c|\
    \ c == s.chars().last().unwrap()).count().try_into().unwrap()\n   |          \
    \                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: Vec<&'static str> = vec![\n        \"a\",\n    \
    \    \"e\",\n        \"i\",\n        \"o\",\n        \"u\",\n        \"y\",\n\
    \    ];\n\n    let mut vowel_count = 0;\n    let mut s = String::from(s);\n  \
    \  for (i, ch) in s.chars().enumerate() {\n        if let Some(ch) = vowels.iter().position(|&x|\
    \ x.to_string() + ch.to_string()) {\n            if ch == 0 {\n              \
    \  vowel_count += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n    }\n    return vowel_count;\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyu010qm_.rs:23:71\n   |\n\
    23 |         if let Some(ch) = vowels.iter().position(|&x| x.to_string() + ch.to_string())\
    \ {\n   |                                                                    \
    \   ^^^^^^^^^^^^^^\n   |                                                     \
    \                  |\n   |                                                   \
    \                    expected `&str`, found struct `String`\n   |            \
    \                                                           help: consider borrowing\
    \ here: `&ch.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyu010qm_.rs:23:55\n\
    \   |\n23 |         if let Some(ch) = vowels.iter().position(|&x| x.to_string()\
    \ + ch.to_string()) {\n   |                                                  \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c != 'a' && *c != 'e' && *c != 'i' &&\
    \ *c != 'o' && *c != 'u' && *c != 'y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplan9tflf.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u' && *c != 'y').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u' && *c != 'y').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt6wewwc4.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt6wewwc4.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt6wewwc4.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpt6wewwc4.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt6wewwc4.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowel_count(s, String::new())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpkr904h97.rs:11:5\n\
    \   |\n11 |     vowel_count(s, String::new())\n   |     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppmnl48pl.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppmnl48pl.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppmnl48pl.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmppmnl48pl.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmppmnl48pl.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = Vec::new();\n    for ch in s.chars() {\n  \
    \      match ch {\n            'a' | 'e' | 'i' | 'o' | 'u' => vowels.push(ch),\n\
    \            _ => (),\n        }\n    }\n    vowels.len()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ynkqptl.rs:18:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n18 |     vowels.len()\n\
    \   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    18 |     vowels.len().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = 0;\n    for ch in s.chars() {\n        match\
    \ ch {\n            'a' | 'e' | ...| 'u' | ... => {\n                vowels +=\
    \ 1;\n            }\n            _ => {}\n        }\n    }\n    vowels\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: unexpected `...`\n  --> /tmp/tmpprzzq8yk.rs:14:25\n   |\n14 |  \
    \           'a' | 'e' | ...| 'u' | ... => {\n   |                         ^^^\n\
    \   |                         |\n   |                         not a valid pattern\n\
    \   |                         help: for a rest pattern, use `..` instead of `...`\n\
    \nerror: unexpected `...`\n  --> /tmp/tmpprzzq8yk.rs:14:36\n   |\n14 |       \
    \      'a' | 'e' | ...| 'u' | ... => {\n   |                                 \
    \   ^^^\n   |                                    |\n   |                     \
    \               not a valid pattern\n   |                                    help:\
    \ for a rest pattern, use `..` instead of `...`\n\nerror: `..` patterns are not\
    \ allowed here\n  --> /tmp/tmpprzzq8yk.rs:14:25\n   |\n14 |             'a' |\
    \ 'e' | ...| 'u' | ... => {\n   |                         ^^^\n   |\n   = note:\
    \ only allowed in tuple, tuple struct, and slice patterns\n\nerror: `..` patterns\
    \ are not allowed here\n  --> /tmp/tmpprzzq8yk.rs:14:36\n   |\n14 |          \
    \   'a' | 'e' | ...| 'u' | ... => {\n   |                                    ^^^\n\
    \   |\n   = note: only allowed in tuple, tuple struct, and slice patterns\n\n\
    error: aborting due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxuphmv1n.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxuphmv1n.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxuphmv1n.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxuphmv1n.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpxuphmv1n.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizwjr30e.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizwjr30e.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizwjr30e.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpizwjr30e.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpizwjr30e.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        c.is_alphabetic() &&\n       \
    \ (c.is_upper() || c.is_lower() || c == 'i' || c == 'o' || c == 'u')\n    ).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp63jr7d0t.rs:13:12\n   |\n13 |         (c.is_upper()\
    \ || c.is_lower() || c == 'i' || c == 'o' || c == 'u')\n   |            ^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_uppercase`\n\n\
    error[E0599]: no method named `is_lower` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp63jr7d0t.rs:13:28\n   |\n13 |         (c.is_upper() ||\
    \ c.is_lower() || c == 'i' || c == 'o' || c == 'u')\n   |                    \
    \        ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp63jr7d0t.rs:13:44\n\
    \   |\n13 |         (c.is_upper() || c.is_lower() || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp63jr7d0t.rs:13:56\n\
    \   |\n13 |         (c.is_upper() || c.is_lower() || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp63jr7d0t.rs:13:68\n\
    \   |\n13 |         (c.is_upper() || c.is_lower() || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                                              \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp63jr7d0t.rs:11:5\n\
    \   |\n10 |   fn vowels_count(s: String) -> isize {\n   |                    \
    \             ----- expected `isize` because of return type\n11 | /     s.chars()"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_impl(s.as_str())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmpao6y5t8r.rs:11:5\n   |\n11 |     vowels_count_impl(s.as_str())\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c == 'i' ||\n\
    \                     *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdiu3wo8.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' ||\n12 | |                      *c == 'o'\
    \ || *c == 'u').count()\n   | |____________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |           \
    \           *c == 'o' || *c == 'u').count().try_into().unwrap()\n   |        \
    \                                             ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowel_count: isize = 0;\n    let mut word_vowel_count: isize\
    \ = 0;\n    for ch in s.chars() {\n        if vowels.iter().any(|w| w == ch ||\
    \ w.ends_with(ch))\n            || ch.ends_with('y')\n        {\n            vowel_count\
    \ += 1;\n        } else {\n            word_vowel_count += 1;\n        }\n   \
    \ }\n    word_vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp822v7ysx.rs:15:36\n\
    \   |\n15 |         if vowels.iter().any(|w| w == ch || w.ends_with(ch))\n   |\
    \                                    ^^ no implementation for `&&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `ends_with` found for type `char` in the current scope\n  --> /tmp/tmp822v7ysx.rs:16:19\n\
    \   |\n16 |             || ch.ends_with('y')\n   |                   ^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcmrlcktq.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpcmrlcktq.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpcmrlcktq.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpcmrlcktq.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcmrlcktq.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcmrlcktq.rs:11:5\n\
    \   |\n10 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // Write code here\n    let mut count = 1\n    for i in s.chars()\
    \ {\n        if i.is_vowel() {\n            count += 1;\n        }\n    }\n  \
    \  return count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcjdgva2m.rs:12:22\n\
    \   |\n12 |     let mut count = 1\n   |                      ^ help: add `;` here\n\
    13 |     for i in s.chars() {\n   |     --- unexpected token\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpcjdgva2m.rs:14:14\n   |\n14 |         if i.is_vowel() {\n   |      \
    \        ^^^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowel_count::<Char>().filter(s).len()\n}\n\nfn main() {\n  \
    \  let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpyrszp1xp.rs:11:5\n\
    \   |\n11 |     vowel_count::<Char>().filter(s).len()\n   |     ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0412]: cannot find type `Char` in this scope\n\
    \  --> /tmp/tmpyrszp1xp.rs:11:19\n   |\n11 |     vowel_count::<Char>().filter(s).len()\n\
    \   |                   ^^^^\n   |\nhelp: a builtin type with a similar name exists\n\
    \   |\n11 |     vowel_count::<char>().filter(s).len()\n   |                  \
    \ ~~~~\nhelp: you might be missing a type parameter\n   |\n10 | fn vowels_count<Char>(s:\
    \ String) -> isize {\n   |                ++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpicakdwf_.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpicakdwf_.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpicakdwf_.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpicakdwf_.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpicakdwf_.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = \"aeiou\".to_string();\n    let mut count = 0;\n\
    \    for ch in s.chars() {\n        match ch {\n            'a' | vowels[0..vowels.len()\
    \ - 1].to_string() => count += 1,\n            'e' | vowels[vowels.len() - 0..vowels.len()\
    \ - 1].to_string() => count += 1,\n            'i' | vowels[vowels.len() - 1..\
    \ vowels.len() - 2].to_string() => count += 1,\n            'o' | vowels[vowels.len()\
    \ - 2.. vowels.len() - 3].to_string() => count += 1,\n            'u' | vowels[vowels.len()\
    \ - 3..vowels.len() - 4].to_string() => count += 1,\n            _ => ()\n   \
    \     }\n    }\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `[`\n  --> /tmp/tmpfc16jng7.rs:15:25\n\
    \   |\n15 |             'a' | vowels[0..vowels.len() - 1].to_string() => count\
    \ += 1,\n   |                         ^ expected one of `=>`, `@`, `if`, or `|`\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqvgcsnrl.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqvgcsnrl.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqvgcsnrl.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqvgcsnrl.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpqvgcsnrl.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count: usize = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        match c {\n            'a' => vowel_count = vowel_count + 1,\n  \
    \          'e' => vowel_count = vowel_count + 1,\n            'i' => vowel_count\
    \ = vowel_count + 1,\n            'o' => vowel_count = vowel_count + 1,\n    \
    \        'u' => if i == s.len() - 1 { vowel_count += 1 } else { vowel_count +=\
    \ 0 },\n            _ => {}\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbx39l_bd.rs:22:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n22 |     vowel_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |     vowel_count.try_into().unwrap()\n   |                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_helper(s.as_bytes(), s.len())\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmp8zq5lrnf.rs:11:5\n   |\n11 |     vowels_count_helper(s.as_bytes(),\
    \ s.len())\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpg6ubdixw.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6ubdixw.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp__py4sx1.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp__py4sx1.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp__py4sx1.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp__py4sx1.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp__py4sx1.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfbj0pyww.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfbj0pyww.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfbj0pyww.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpfbj0pyww.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfbj0pyww.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        (c == 'a') || (c == 'e') || (c\
    \ == 'i') || (c == 'o') || (c == 'u')\n    ).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0xh_va8t.rs:12:12\n\
    \   |\n12 |         (c == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c\
    \ == 'u')\n   |            ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp0xh_va8t.rs:12:26\n   |\n12 |         (c\
    \ == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')\n   |      \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp0xh_va8t.rs:12:40\n   |\n12 |         (c == 'a')\
    \ || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')\n   |              \
    \                          ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp0xh_va8t.rs:12:54\n   |\n12 |         (c\
    \ == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')\n   |      \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp0xh_va8t.rs:12:68\n   |\n12\
    \ |         (c == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')\n\
    \   |                                                                    ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    match s.chars().count((char) => {\n        char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' ||\n            char ==\
    \ 'y' || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char == 'U'\n\
    \    })\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmph7zmyxsc.rs:11:34\n   |\n11 |     match s.chars().count((char)\
    \ => {\n   |                                  ^^ expected one of `)`, `,`, `.`,\
    \ `?`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9bwj06ht.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9bwj06ht.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9bwj06ht.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp9bwj06ht.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp9bwj06ht.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmppmkzpb0t.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppmkzpb0t.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr_8p6d3t.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr_8p6d3t.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr_8p6d3t.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr_8p6d3t.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpr_8p6d3t.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // TODO\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2vipb0oe.rs:10:31\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |    ------------             \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // count number of vowels in s\n    let mut count = 0;\n   \
    \ for c in s.chars() {\n        match c {\n            'a' | ('e' | 'i' | ('o'\
    \ | 'u') | 'y') => {\n                count += 1;\n            }\n           \
    \ _ => {\n                // do nothing\n            }\n        }\n    }\n   \
    \ return count;\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpwe_49sj5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels(s).iter().filter(|vowel| vowel != 'y').count() + 1\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpprzn3ikm.rs:11:5\n\
    \   |\n11 |     vowels(s).iter().filter(|vowel| vowel != 'y').count() + 1\n  \
    \ |     ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: Vec<&str> = vec![];\n    for char in s.chars()\
    \ {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' {\n            vowels.push(&char);\n        }\n    }\n    if let Some(vowel)\
    \ = vowels.iter().find(|&x| x == 'y') {\n        vowels.insert(vowels.iter().position(|&x|\
    \ x == 'y').unwrap_or(usize), &'y');\n    }\n    let vowels_count = vowels.iter().filter(|x|\
    \ x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u').count() + vowels.iter().filter(|x|\
    \ x == 'y').count();\n    vowels_count\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `usize`\n  --> /tmp/tmp1gl1rygl.rs:18:71\n\
    \   |\n18 |         vowels.insert(vowels.iter().position(|&x| x == 'y').unwrap_or(usize),\
    \ &'y');\n   |                                                               \
    \        ^^^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1gl1rygl.rs:14:25\n\
    \   |\n14 |             vowels.push(&char);\n   |                         ^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: can't compare `&&str` with\
    \ `char`\n  --> /tmp/tmp1gl1rygl.rs:17:52\n   |\n17 |     if let Some(vowel) =\
    \ vowels.iter().find(|&x| x == 'y') {\n   |                                  \
    \                  ^^ no implementation for `&&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  -->\
    \ /tmp/tmp1gl1rygl.rs:18:53\n   |\n18 |         vowels.insert(vowels.iter().position(|&x|\
    \ x == 'y').unwrap_or(usize), &'y');\n   |                                   \
    \                  ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as Pa"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpqikhqqb_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| {\n        if c != 'a' && c != 'e' && c\
    \ != 'i' && c != 'o' && c != 'u' {\n            return false;\n        }\n   \
    \     true\n    }).count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4qmszyy5.rs:12:14\n\
    \   |\n12 |         if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ {\n   |              ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4qmszyy5.rs:12:26\n   |\n12 |         if c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n   |                    \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4qmszyy5.rs:12:38\n\
    \   |\n12 |         if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ {\n   |                                      ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp4qmszyy5.rs:12:50\n   |\n12\
    \ |         if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n  \
    \ |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4qmszyy5.rs:12:62\n\
    \   |\n12 |         if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpsgwu2bri.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgwu2bri.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n        .count() + 1\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt7iw6_fd.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpt7iw6_fd.rs:11:40\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                        ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt7iw6_fd.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpt7iw6_fd.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpt7iw6_fd.rs:11:76\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatche"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c| *c >=\
    \ 'A' && *c <= 'Z').filter(|c| *c == 'y').count() + vowels_count(s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c ==\
    \ 'y').take(s.len()))\n}\n\nfn main() {\n    let candidate = vowels_count;\n \
    \   assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvix41k7u.rs:11:130\n   |\n\
    11 | ..._count(s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A'\
    \ && *c <= 'Z').filter(|c| *c == 'y').take(s.len()))\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `std::iter::Take`\n   |\n   = note: expected\
    \ struct `String`\n              found struct `std::iter::Take<Filter<Filter<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpvix41k7u.rs:11:147: 11:173]>, [closure@/tmp/tmpvix41k7u.rs:11:182:\
    \ 11:208]>, [closure@/tmp/tmpvix41k7u.rs:11:217: 11:230]>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvix41k7u.rs:11:117\n   |\n11 | ... + vowels_count(s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c ==\
    \ 'y').take(s.len()))\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvix41k7u.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c ==\
    \ 'y').count() + vowels_count(s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c == 'y').take(s.len()))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c ==\
    \ 'y').count() + vowels_count(s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuron5upc.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuron5upc.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuron5upc.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuron5upc.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpuron5upc.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpoxrls3j6.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpoxrls3j6.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpoxrls3j6.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpoxrls3j6.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpoxrls3j6.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut cnt = 0;\n    for &vowel in &s {\n        cnt += if\
    \ vowel == 'a' || vowel == 'e' || vowel == 'i' || vowel == 'o' || vowel == 'u'\
    \ {\n            1\n        } else {\n            0\n        };\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpr99xd0r0.rs:12:19\n\
    \   |\n12 |     for &vowel in &s {\n   |                   ^^ `&String` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21x6q5xl.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21x6q5xl.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21x6q5xl.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp21x6q5xl.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp21x6q5xl.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c == 0x61 || c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpya5lt6c8.rs:11:32\n   |\n\
    11 |     s.chars().filter(|c| *c == 0x61 || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u').count() + 1\n   |                                ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpya5lt6c8.rs:11:42\n   |\n11 |     s.chars().filter(|c| *c == 0x61\
    \ || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n \
    \  |                                          ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpya5lt6c8.rs:11:54\n   |\n11\
    \ |     s.chars().filter(|c| *c == 0x61 || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u').count() + 1\n   |                                    \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpya5lt6c8.rs:11:66\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 0x61 || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\
    \ + 1\n   |                                                                  ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpya5lt6c8.rs:11:78\n\
    \   |\n11 |     s.chars().filter(|c| *c == 0x61 || c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count() + 1\n   |                             \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzf_gvrcz.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzf_gvrcz.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzf_gvrcz.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpzf_gvrcz.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzf_gvrcz.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf_gvrcz.rs:11:5\n\
    \   |\n10 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = &\"aeiouy\";\n    let mut count: usize = 0;\n\n\
    \    let mut it = s.char_indices();\n    let mut end = it.end();\n    while let\
    \ Some(end) = (it.next(), end) {\n        match it.index() {\n            Some(index)\
    \ => if let Some(vowel) = vowels.as_bytes()[index] {\n                if vowel\
    \ == b'y' {\n                    count += 1;\n                }\n            }\n\
    \            _ => {\n                if let Some(vowel) = vowels.as_bytes()[it.index()\
    \ - 1] {\n                    if vowel == b'y' {\n                        count\
    \ += 1;\n                    }\n                }\n            }\n        }\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpyprrj9kh.rs:15:22\n   |\n15 |     let mut end =\
    \ it.end();\n   |                      ^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyprrj9kh.rs:16:15\n   |\n16 |\
    \     while let Some(end) = (it.next(), end) {\n   |               ^^^^^^^^^ \
    \  ---------------- this expression has type `(Option<(usize, char)>, _)`\n  \
    \ |               |\n   |               expected tuple, found enum `Option`\n\
    \   |\n   = note: expected tuple `(Option<(usize, char)>, _)`\n              \
    \ found enum `Option<_>`\n\nerror[E0599]: no method named `index` found for struct\
    \ `CharIndices` in the current scope\n  --> /tmp/tmpyprrj9kh.rs:17:18\n   |\n\
    17 |         match it.index() {\n   |                  ^^^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror[E0599]: no method named `index` found for struct\
    \ `CharIndices` in the current scope\n  --> /tmp/tmpyprrj9kh.rs:24:59\n   |\n\
    24 |                 if let Some(vowel) = vowels.as_bytes()[it.index() - 1] {\n\
    \   |                                                           ^^^^^ method not\
    \ found in `CharIndices<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyprrj9kh.rs:33:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n33 |     count\n\
    \   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n33\
    \ |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp552o1owx.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp552o1owx.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0d1s_rvf.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0d1s_rvf.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0d1s_rvf.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0d1s_rvf.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp0d1s_rvf.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    match (s.chars().filter(|c| c.is_uppercase()).count(), s.chars().filter(|c|\
    \ c.is_lowercase()).count()) {\n        (2, 0) => 0,\n        (2, 1) => 1,\n \
    \       _ => 2,\n    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpysg717wp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    count(s, &vowels)\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count` in this scope\n  --> /tmp/tmphqtvrut5.rs:11:5\n\
    \   |\n11 |     count(s, &vowels)\n   |     ^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmphqtvrut5.rs:11:15\n\
    \   |\n11 |     count(s, &vowels)\n   |               ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n    ).count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yj30gti.rs:12:12\n\
    \   |\n12 |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |            ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4yj30gti.rs:12:24\n   |\n12 |         (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yj30gti.rs:12:36\n\
    \   |\n12 |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4yj30gti.rs:12:48\n   |\n12 |   \
    \      (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |      \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4yj30gti.rs:12:60\n   |\n12 |   \
    \      (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |      \
    \                                                      ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4yj30gti.rs:11:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` because of "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut s = String::from(s);\n    s.chars().filter(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3og762oi.rs:12:28\n\
    \   |\n12 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3og762oi.rs:12:40\n\
    \   |\n12 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3og762oi.rs:12:52\n\
    \   |\n12 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3og762oi.rs:12:64\n\
    \   |\n12 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3og762oi.rs:12:76\n   |\n12 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // Return the number of vowels, as described above.\n    match\
    \ s.chars().any(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n        true => 1,\n        false => 0\n    }\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp7b1oybxf.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c.is_ascii_letter()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpim06yvo5.rs:11:29\n   |\n11 |     s.chars().filter(|&c|\
    \ c.is_ascii_letter()).filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                             ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpim06yvo5.rs:11:61\n   |\n11 |   \
    \  s.chars().filter(|&c| c.is_ascii_letter()).filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n   |                                 \
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpim06yvo5.rs:11:73\n   |\n11 |     s.chars().filter(|&c|\
    \ c.is_ascii_letter()).filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                         \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpim06yvo5.rs:11:85\n   |\n11 |     s.chars().filter(|&c|\
    \ c.is_ascii_letter()).filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                         \
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpim06yvo5.rs:11:97\n   |\n11 |     s.chars().filter(|&c|\
    \ c.is_ascii_letter()).filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                         \
    \                                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn7vfnsqj.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn7vfnsqj.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn7vfnsqj.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpn7vfnsqj.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn7vfnsqj.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: &[&'static str] = &[\n        \"a\",\n        \"\
    e\",\n        \"i\",\n        \"o\",\n        \"u\",\n    ];\n    s.chars().filter(|c|\
    \ vowels.iter().any(|v| v.contains(c)))\n        .count() + s.chars().filter(|c|\
    \ c == 'y' && s.chars().any(|v| v == 'y'))\n        .count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpqk9yby74.rs:18:59\n\
    \     |\n18   |     s.chars().filter(|c| vowels.iter().any(|v| v.contains(c)))\n\
    \     |                                                  -------- ^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n     |                                \
    \                  |\n     |                                                 \
    \ required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n18   |     s.chars().filter(|c| vowels.iter().any(|v|\
    \ v.contains(*c)))\n     |                                                   \
    \        +\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqk9yby74.rs:19:43\n\
    \   |\n19 |         .count() + s.chars().filter(|c| c == 'y' && s.chars().any(|v|\
    \ v == 'y'))\n   |                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqk9yby74.rs:18:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` because of return type\n...\n18 | /     s.chars().filter(|c|\
    \ vowels.iter().any(|v| v.contains(c)))\n19 | |         .count() + s.chars().filter(|c|\
    \ c == 'y' && s.chars().any(|v| v == 'y'))\n20 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 ~     (s.chars().filter(|c|\
    \ vowels.iter().any(|v| v.contains(c)))\n19 |         .count() + s.chars().filter(|c|\
    \ c == 'y' && s.chars().any(|v| v == 'y'))\n20 ~         "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels(s).count(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpgfe0douw.rs:11:5\n\
    \   |\n11 |     vowels(s).count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |     ^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s.chars().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        match c {\n            'a' =>\
    \ true,\n            'e' => true,\n            'i' => true,\n            'o' =>\
    \ true,\n            'u' => true,\n            _ => false,\n        })\n     \
    \   .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy5s0atnx.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\n\
    12 | |         match c {\n13 | |             'a' => true,\n14 | |            \
    \ 'e' => true,\n...  |\n19 | |         })\n20 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_impl(s.as_bytes())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmphgvfec29.rs:11:5\n   |\n11 |     vowels_count_impl(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // return 0 if the input string doesn't consist of a single\
    \ word.\n    if s.is_empty() { return 0; }\n\n    // initialize counter and set\
    \ to count each vowel found in input string.\n    let mut c: usize = 0;\n\n  \
    \  // process first character of string for vowels.\n    if s.chars().any(|c|\
    \ vowel(c)) {\n        c += 1;\n    }\n\n    // process remaining characters of\
    \ string for vowels.\n    for c in s.chars() {\n        // if the character is\
    \ a vowel, increment the counter and continue\n        if vowel(c) && !c.is_uppercase()\
    \ {\n            c += 1;\n            continue;\n        }\n        break;\n \
    \   }\n\n    // return counter\n    c\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowel` in this scope\n  --> /tmp/tmpc_tdktm8.rs:18:26\n\
    \   |\n18 |     if s.chars().any(|c| vowel(c)) {\n   |                       \
    \   ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `vowel`\
    \ in this scope\n  --> /tmp/tmpc_tdktm8.rs:25:12\n   |\n25 |         if vowel(c)\
    \ && !c.is_uppercase() {\n   |            ^^^^^ not found in this scope\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpc_tdktm8.rs:26:13\n\
    \   |\n26 |             c += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc_tdktm8.rs:33:5\n   |\n10 | fn vowels_count(s: String) -> isize\
    \ {\n   |                               ----- expected `isize` because of return\
    \ type\n...\n33 |     c\n   |     ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n33 |     c.try_into().unwrap()\n   |      ++++++++++++++++++++\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u')\n        .count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpl8sbl2zw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c|\n        c.is_ascii_ascii_case() &&\n \
    \       c >= 'a' && c <= 'z' &&\n        c != 'Y'\n    ).count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_ascii_case` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp6xmxova0.rs:12:11\n   |\n12 |  \
    \       c.is_ascii_ascii_case() &&\n   |           ^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_lowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6xmxova0.rs:13:14\n   |\n13 |         c >= 'a'\
    \ && c <= 'z' &&\n   |              ^^^\n   |              |\n   |           \
    \   expected `&char`, found `char`\n   |              help: consider borrowing\
    \ here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xmxova0.rs:13:26\n\
    \   |\n13 |         c >= 'a' && c <= 'z' &&\n   |                          ^^^\n\
    \   |                          |\n   |                          expected `&char`,\
    \ found `char`\n   |                          help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6xmxova0.rs:14:11\n\
    \   |\n14 |         c != 'Y'\n   |           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6xmxova0.rs:11:5\n   |\n10 |   fn vowels_count(s: String)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n11 | /     s.chars().filter(|c|\n12 | |         c.is_ascii_ascii_case()\
    \ &&\n13 | |         c >= 'a' && c <= 'z' &&\n14 | |         c != 'Y'\n15 | |\
    \     ).count()\n   | |_____________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n15 |     ).count().try_into().unwrap()\n   |            \
    \  ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowel_count(s.as_bytes()).0\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpbf08z_ua.rs:11:5\n\
    \   |\n11 |     vowel_count(s.as_bytes()).0\n   |     ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd1u70d_x.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd1u70d_x.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd1u70d_x.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd1u70d_x.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpd1u70d_x.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = \"aouie\";\n    let vowels_count = s.chars().filter(|c|\
    \ vowels.contains(c)).count();\n    let mut vowels_count_by_letter = HashMap::new();\n\
    \    for c in s {\n        vowels_count_by_letter.insert((c, 0), 0);\n    }\n\
    \    for i in 0..(vowels_count + 1) {\n        vowels_count_by_letter.get_mut(&i).unwrap()[1]\
    \ += 1;\n    }\n    vowels_count_by_letter.len()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkpudku8q.rs:13:38\n   |\n13 |     let mut vowels_count_by_letter = HashMap::new();\n\
    \   |                                      ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    -->\
    \ /tmp/tmpkpudku8q.rs:12:61\n     |\n12   |     let vowels_count = s.chars().filter(|c|\
    \ vowels.contains(c)).count();\n     |                                       \
    \             -------- ^ expected an `Fn<(char,)>` closure, found `char`\n   \
    \  |                                                    |\n     |            \
    \                                        required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n12   |     let vowels_count = s.chars().filter(|c|\
    \ vowels.contains(*c)).count();\n     |                                      \
    \                       +\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpkpudku8q.rs:14:14\n   |\n14 |     for c in s {\n   |              ^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s.chars())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3b_wlts6.rs:11:18\n   |\n\
    11 |     vowels_count(s.chars())\n   |                  ^^^^^^^^^ expected struct\
    \ `String`, found struct `Chars`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut count = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        // if c is 'a' OR c is 'e' OR c is 'i' OR c is 'o' OR c is 'u'\n\
    \        // we increment count\n        if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n            count += 1;\n        }\n        // if 'y'\
    \ is at the end of the string, then count it as well\n        if i == s.len()\
    \ - 1 && c == 'y' {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp9zzvfgo6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // Return early when s is empty.\n    if s.is_empty() {\n  \
    \      return 0;\n    }\n    // Create a regex pattern to match vowels in s.\n\
    \    let re = Regex::new(r\"[aeiouAEIOU]\").unwrap();\n    // Count vowels in\
    \ s and return result.\n    s.chars().filter(|c| re.is_match(c)).count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpk759nxgr.rs:16:14\n   |\n16 |     let re = Regex::new(r\"[aeiouAEIOU]\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk759nxgr.rs:18:5\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n...\n18 |     s.chars().filter(|c| re.is_match(c)).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     s.chars().filter(|c| re.is_match(c)).count().try_into().unwrap()\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_aux(s.chars(), s.len())\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_aux` in this scope\n \
    \ --> /tmp/tmpvs2illnl.rs:11:5\n   |\n11 |     vowels_count_aux(s.chars(), s.len())\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: &[isize] = &[\n        0,\n        1,\n        2,\n\
    \        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n    \
    \    9,\n        10,\n        11,\n        12,\n        13,\n        14,\n   \
    \     15,\n        16,\n        17,\n        18,\n        19,\n        20,\n \
    \       21,\n        22,\n        23,\n        24,\n        25,\n        26,\n\
    \        27,\n        28,\n        29,\n        30,\n        31,\n        32,\n\
    \        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n\
    \        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n\
    \        45,\n        46,\n        47,\n        48,\n        49,\n        50,\n\
    \        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n\
    \        57,\n        58,\n        59,\n        60,\n        61,\n        62,\n\
    \        63,\n        64,\n        65,\n        66,\n        67,\n        68,\n\
    \        69,\n        70,\n        71,\n        72,\n        73,\n        74,\n\
    \        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n\
    \        81,\n        82,\n        83,\n        84,\n        85,\n        86,\n\
    \        87,\n        88,\n        89,\n        90,\n        91,\n        92,\n\
    \        93,\n        94,\n        95,\n        96,\n        97,\n        98,\n\
    \        99,\n        100,\n        101,\n        102,\n        103,\n       \
    \ 104,\n        105,\n        106,\n        107,\n        108,\n        109,\n\
    \        110,\n        111,\n        112,\n        113,\n        114,\n      \
    \  115,\n        116,\n        117,\n        118,\n        119,\n        120,\n\
    \        121,\n        122,\n        123,\n        124,\n        125,\n      \
    \  126,\n        127,\n        128,\n        129,\n        130,\n        131,\n\
    \        132,\n        133,\n        134,\n        135,\n        136,\n      \
    \  137,\n        \n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmp6yemqsbc.rs:11:29\n\
    \    |\n10  | fn vowels_count(s: String) -> isize {\n    |                   \
    \                  - closing delimiter possibly meant for this\n11  |     let\
    \ vowels: &[isize] = &[\n    |                             ^ unclosed delimiter\n\
    ...\n151 | }\n    | ^ mismatched closing delimiter\n\nerror: expected one of `.`,\
    \ `;`, `?`, `else`, or an operator, found `}`\n   --> /tmp/tmp6yemqsbc.rs:151:1\n\
    \    |\n151 | }\n    | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0ij5p2iq.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp0ij5p2iq.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c == 'y').count()\n   |                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0ij5p2iq.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp0ij5p2iq.rs:11:64\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp0ij5p2iq.rs:11:76\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // Return zero if the string is empty\n    if s.is_empty() {\n\
    \        return 0\n    }\n    // Loop over each character in the string\n    for\
    \ c in s.chars() {\n        match c {\n            // If this character is a vowel,\
    \ then increment the count\n            c if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' => 1,\n            _ => 0,\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqajj062.rs:17:9\n   |\n\
    17 | /         match c {\n18 | |             // If this character is a vowel,\
    \ then increment the count\n19 | |             c if c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u' => 1,\n20 | |             _ => 0,\n21 | |   \
    \      }\n   | |_________^ expected `()`, found integer\n   |\nhelp: consider\
    \ using a semicolon here\n   |\n21 |         };\n   |          +\nhelp: you might\
    \ have meant to return this value\n   |\n17 ~         return match c {\n18 | \
    \            // If this character is a vowel, then increment the count\n19 | \
    \            c if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' =>\
    \ 1,\n20 |             _ => 0,\n21 ~         };\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkqajj062.rs:16:5\n   |\n10 |   fn vowels_count(s: String)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n...\n16 | /     for c in s.chars() {\n17 | |         match c\
    \ {\n18 | |             // If this character is a vowel, then increment the count\n\
    19 | |             c if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ => 1,\n20 | |             _ => 0,\n21 | |         }\n22 | |     }\n   | |_____^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprvf03qy_.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprvf03qy_.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprvf03qy_.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprvf03qy_.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmprvf03qy_.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_helper(s).0\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmpa64kbv1r.rs:11:5\n   |\n11 |     vowels_count_helper(s).0\n   |\
    \     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl5sn7msa.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl5sn7msa.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl5sn7msa.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpl5sn7msa.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl5sn7msa.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count1(s, 0).0\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count1` in this scope\n  -->\
    \ /tmp/tmpl7u30e7_.rs:11:5\n   |\n11 |     vowels_count1(s, 0).0\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdymcih69.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpdymcih69.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpdymcih69.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpdymcih69.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdymcih69.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdymcih69.rs:11:5\n\
    \   |\n10 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n        .count() +\n        s.chars()\n      \
    \      .filter(|c| c == 'y' && s.chars().any(|x| x == 'a' || x == 'e' || x ==\
    \ 'i' || x == 'o' || x == 'u'))\n            .count()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1dypvgp0.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp1dypvgp0.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp1dypvgp0.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp1dypvgp0.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1dypvgp0.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp1dypvgp0.rs"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter_map(|c| c != 'a').filter(|c| c != 'e').filter(|c|\
    \ c != 'i')\n        .filter(|c| c != 'o').filter(|c| c != 'u').count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpees1e6z0.rs:11:30\n   |\n\
    11 |     s.chars().filter_map(|c| c != 'a').filter(|c| c != 'e').filter(|c| c\
    \ != 'i')\n   |                              ^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n11 |     s.chars().filter_map(|c|\
    \ Some(c != 'a')).filter(|c| c != 'e').filter(|c| c != 'i')\n   |            \
    \                  +++++        +\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpees1e6z0.rs:11:53\n   |\n11 |     s.chars().filter_map(|c| c !=\
    \ 'a').filter(|c| c != 'e').filter(|c| c != 'i')\n   |                       \
    \                              ^^ no implementation for `&_ == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n  --> /tmp/tmpees1e6z0.rs:11:74\n   |\n11 |\
    \     s.chars().filter_map(|c| c != 'a').filter(|c| c != 'e').filter(|c| c !=\
    \ 'i')\n   |                                                                 \
    \         ^^ no implementation for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpees1e6z0.rs:12:23\n   |\n12 |         .filter(|c| c != 'o').filter(|c|\
    \ c != 'u').count()\n   |                       ^^ no implementation for `&_ ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\
    \nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpees1e6z0.rs:12:44\n\
    \   |\n12 |         .filter(|c| c != 'o').filter(|c| c != 'u').count()\n   | \
    \                                           ^^ no implementation for `&_ == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpees1e6z0.rs:11:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` because of return type\n11 | /     s.chars().filter_map(|c|\
    \ c != 'a').filter(|c| c != 'e').filte"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = \"aeiou\";\n    let count = s.chars().filter(|c|\
    \ vowels.contains(c)).count();\n    count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp5hulms2z.rs:12:54\n\
    \     |\n12   |     let count = s.chars().filter(|c| vowels.contains(c)).count();\n\
    \     |                                             -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                             |\n\
    \     |                                             required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n12   |     let count\
    \ = s.chars().filter(|c| vowels.contains(*c)).count();\n     |               \
    \                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5hulms2z.rs:13:5\n   |\n10 | fn vowels_count(s: String) -> isize\
    \ {\n   |                               ----- expected `isize` because of return\
    \ type\n...\n13 |     count\n   |     ^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c.is_ascii_uppercase()).filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5d_62o8.rs:11:63\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars()...\n  \
    \ |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5d_62o8.rs:11:75\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars()...\n  \
    \ |                                                                          \
    \ ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5d_62o8.rs:11:87\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars()...\n  \
    \ |                                                                          \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpw5d_62o8.rs:11:99\n   |\n11 | ...lter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c| c.is_ascii_uppercase()).filter(|c|\
    \ c...\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpw5d_62o8.rs:11:111\n\
    \   |\n11 | ...= 'a' || c == 'e' || c == 'i' || c"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut counter = 0;\n    for i in s.chars() {\n        let\
    \ c = i as char;\n        counter += if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' {\n            1\n        } else {\n            0\n     \
    \   };\n        if c == 'y' {\n            counter += 1;\n        }\n    }\n \
    \   counter as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n  \
    \  assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpca3y_28j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0b0xew_y.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0b0xew_y.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0b0xew_y.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0b0xew_y.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp0b0xew_y.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.to_ascii_uppercase() in \"AEIOUY\").count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword\
    \ `in`\n  --> /tmp/tmp_ur4569d.rs:11:49\n   |\n11 |     s.chars().filter(|c| c.to_ascii_uppercase()\
    \ in \"AEIOUY\").count()\n   |                                               \
    \  ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    for (i, &c) in s.chars().enumerate()\
    \ {\n        vowel_count += if c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' {\n            1\n        } else {\n            0\n        };\n   \
    \     if i == s.len() - 1 && (c == 'y' || c == 'Y') {\n            vowel_count\
    \ += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7qil4yox.rs:12:13\n   |\n\
    12 |     for (i, &c) in s.chars().enumerate() {\n   |             ^^     ---------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|&c| c.is_uppercase() || c.is_lowercase())\n\
    \        .filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3clk8v5x.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars()\n12\
    \ | |         .filter(|&c| c.is_uppercase() || c.is_lowercase())\n13 | |     \
    \    .filter(|&c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    14 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: Vec<&'static str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut count: usize = 0;\n    for letter in s.chars() {\n\
    \        if vowels.contains(letter) {\n            count += 1;\n        }\n  \
    \  }\n    return count;\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4zj8okd.rs:14:28\n   |\n\
    14 |         if vowels.contains(letter) {\n   |                            ^^^^^^\
    \ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe4zj8okd.rs:18:12\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n18 |     return\
    \ count;\n   |            ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     return count.try_into().unwrap();\n   |                \
    \ ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcw9udia2.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() as isize\n   |                        \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcw9udia2.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() as isize\n   |                        \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpcw9udia2.rs:11:52\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\
    \ as isize\n   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcw9udia2.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() as isize\n   |                        \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpcw9udia2.rs:11:76\n   |\n11 |   \
    \  s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y').count() as isize\n   |                                        \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = hel"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = vec!['A'..'Z', 'a'..'z'];\n    let mut vowel_count\
    \ = s.chars().filter(|c| vowels.contains(&c)).count();\n    if vowel_count >=\
    \ 2 {\n        vowel_count -= 1;\n    }\n    vowel_count\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaqr3j2ps.rs:12:64\n   |\n\
    12 |     let mut vowel_count = s.chars().filter(|c| vowels.contains(&c)).count();\n\
    \   |                                                                ^^ expected\
    \ struct `std::ops::Range`, found `&char`\n   |\n   = note: expected reference\
    \ `&std::ops::Range<char>`\n              found reference `&&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaqr3j2ps.rs:16:5\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n...\n16 |     vowel_count\n   |     ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |     vowel_count.try_into().unwrap()\n\
    \   |                ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels(&s).iter().cloned().count()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmplcdix1mj.rs:11:5\n\
    \   |\n11 |     vowels(&s).iter().cloned().count()\n   |     ^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yygt2c3.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yygt2c3.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yygt2c3.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4yygt2c3.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4yygt2c3.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c == 'i' ||\
    \ *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqlu9upn8.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    if s.is_empty() {\n        return 0;\n    }\n    let mut count:\
    \ usize = 0;\n    for ch in s.chars() {\n        if ch.is_vowel() {\n        \
    \    count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgkm2n81a.rs:16:15\n   |\n16 |         if ch.is_vowel()\
    \ {\n   |               ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgkm2n81a.rs:20:12\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n20 |     return count;\n   |            ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     return count.try_into().unwrap();\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c != 'a' && *c != 'e' && *c != 'i' &&\
    \ *c != 'o' && *c != 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9maor_r.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut cnt = 0;\n\n    for i in s.chars() {\n        if i.is_vowel()\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnv_rh2d0.rs:14:14\n   |\n14 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    let vowels: Vec<&'static str>\
    \ = vec![\n        \"a\", \"e\", \"i\", \"o\", \"u\",\n    ];\n    for c in s.chars()\
    \ {\n        vowel_count += vowels.iter().any(|vowel| vowel == &*c);\n    }\n\
    \    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpxal7euo_.rs:16:60\n\
    \   |\n16 |         vowel_count += vowels.iter().any(|vowel| vowel == &*c);\n\
    \   |                                                            ^^\n\nerror[E0277]:\
    \ cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmpxal7euo_.rs:16:21\n \
    \  |\n16 |         vowel_count += vowels.iter().any(|vowel| vowel == &*c);\n \
    \  |                     ^^ no implementation for `{integer} += bool`\n   |\n\
    \   = help: the trait `AddAssign<bool>` is not implemented for `{integer}`\n \
    \  = help: the following other types implement trait `AddAssign<Rhs>`:\n     \
    \        <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n         \
    \    <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut c = 0;\n    let mut n = s.len();\n    while n > 0 {\n\
    \        match s.chars().next() {\n            Some(c) if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' => c += 1,\n            Some(_) => continue,\n\
    \            None => break,\n        }\n        n -= 1;\n    }\n    c\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpngbtx0ue.rs:15:84\n   |\n15 |             Some(c) if c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' => c += 1,\n   |    \
    \                                                                            \
    \    -^^^^^\n   |                                                            \
    \                        |\n   |                                             \
    \                                       cannot use `+=` on type `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_helper(s.as_bytes()).0\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmpey6vf3t8.rs:11:5\n   |\n11 |     vowels_count_helper(s.as_bytes()).0\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.to_ascii_lowercase() == c).count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdm793ljq.rs:11:52\n   |\n\
    11 |     s.chars().filter(|c| c.to_ascii_lowercase() == c).count(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                               ^ expected `char`, found `&char`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n11 |     s.chars().filter(|c| c.to_ascii_lowercase()\
    \ == *c).count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                    +\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpdm793ljq.rs:11:55\n\
    \    |\n11  |     s.chars().filter(|c| c.to_ascii_lowercase() == c).count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    |           \
    \                                            ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                                                 \
    \      |\n    |                                                       expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdm793ljq.rs:11:5\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n11 |     s.chars().filter(|c| c.to_ascii_lowercase()\
    \ == c).count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.to_ascii_lowercase() == c).count(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').try_into().unwrap()\n   |                              \
    \                                                                            \
    \                ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanati"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: Vec<&'static str> = vec!['a', 'e', 'i', 'o', 'u',\
    \ 'y'];\n    for c in s.chars() {\n        if !vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            return 0;\n        }\n    }\n    1\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb00d6pmh.rs:11:42\n   |\n\
    11 |     let vowels: Vec<&'static str> = vec!['a', 'e', 'i', 'o', 'u', 'y'];\n\
    \   |                                          ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    11 |     let vowels: Vec<&'static str> = vec![\"a\", 'e', 'i', 'o', 'u', 'y'];\n\
    \   |                                          ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb00d6pmh.rs:13:29\n   |\n13 |         if !vowels.contains(&c.to_ascii_lowercase())\
    \ {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n   |\n   = note: expected reference `&&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9bi0x0k1.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                    ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc6813mru.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc6813mru.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc6813mru.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc6813mru.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpc6813mru.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowel_count::<[_]>(s)\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpxbrrihgp.rs:11:5\n\
    \   |\n11 |     vowel_count::<[_]>(s)\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let vowels_count = s.chars().filter(|&c| vowels.contains(c)).count()\
    \ + 1;\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4f7io4dr.rs:13:62\n   |\n\
    13 |     let vowels_count = s.chars().filter(|&c| vowels.contains(c)).count()\
    \ + 1;\n   |                                                              ^\n\
    \   |                                                              |\n   |   \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \     help: consider borrowing here: `&c`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph5eua19q.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph5eua19q.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph5eua19q.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph5eua19q.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmph5eua19q.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvo43qkei.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvo43qkei.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvo43qkei.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvo43qkei.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpvo43qkei.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowel_count::<'_a, A>(s)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0261]: use of undeclared lifetime name `'_a`\n  --> /tmp/tmp86ps02dw.rs:11:19\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                - help:\
    \ consider introducing lifetime `'_a` here: `<'_a>`\n11 |     vowel_count::<'_a,\
    \ A>(s)\n   |                   ^^^ undeclared lifetime\n\nerror[E0425]: cannot\
    \ find function `vowel_count` in this scope\n  --> /tmp/tmp86ps02dw.rs:11:5\n\
    \   |\n11 |     vowel_count::<'_a, A>(s)\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0412]: cannot find type `A` in this scope\n  --> /tmp/tmp86ps02dw.rs:11:24\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                - help:\
    \ you might be missing a type parameter: `<A>`\n11 |     vowel_count::<'_a, A>(s)\n\
    \   |                        ^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0261, E0412,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0261`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    use std::ascii::AsciiExt;\n    let mut vowels = Vec::with_capacity(s.len());\n\
    \    vowels.push('a');\n    vowels.push('e');\n    vowels.push('i');\n    vowels.push('o');\n\
    \    vowels.push('u');\n    let vowels_pos = s.find('y');\n    if vowels_pos !=\
    \ s.len() {\n        vowels.push(s.chars().skip(vowels_pos).next()?);\n    }\n\
    \    let mut result = vec![0; 26];\n    for (i, _) in vowels.iter().enumerate()\
    \ {\n        if let Some(idx) = (&s)[i as usize].find(&vowels[i]) {\n        \
    \    result[idx] = result[idx + 1] + 1;\n        }\n    }\n    0\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmp4k81m19m.rs:11:9\n\
    \   |\n11 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: use of deprecated\
    \ trait `std::ascii::AsciiExt`: use inherent methods instead\n  --> /tmp/tmp4k81m19m.rs:11:21\n\
    \   |\n11 |     use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4k81m19m.rs:19:22\n   |\n19 |     if vowels_pos != s.len()\
    \ {\n   |                      ^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |     if vowels_pos != Some(s.len())\
    \ {\n   |                      +++++       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4k81m19m.rs:20:36\n   |\n20 |         vowels.push(s.chars().skip(vowels_pos).next()?);\n\
    \   |                                    ^^^^^^^^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmp4k81m19m.rs:20:54\n\
    \   |\n10 | / fn vowels_count(s: String) -> isize {\n11 | |     use std::ascii::AsciiExt;\n\
    12 | |     let mut vowels = Vec::with_capacity(s.len());\n13 | |     vowels.push('a');\n\
    ...  |\n20 | |         vowels.push(s.chars().skip(vowels_pos).next()?);\n   |\
    \ |                                                      ^ cannot use the `?`\
    \ operator in a function that returns `isize`\n...  |\n28 | |     0\n29 | | }\n\
    \   | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<Option<Infallible>>` is not implemented for\
    \ `isize`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmp4k81m19m.rs:24:28\n   |\n24 |         if let Some(idx) = (&s)[i as usize].find(&vowels[i])\
    \ {\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = Vec::new();\n    vowels.push(String::from(\"\
    a\"));\n    vowels.push(String::from(\"e\"));\n    vowels.push(String::from(\"\
    i\"));\n    vowels.push(String::from(\"o\"));\n    vowels.push(String::from(\"\
    u\"));\n    vowels.push(String::from(\"y\"));\n\n    let mut count = 0;\n    for\
    \ &c in s.chars() {\n        for vowel in vowels {\n            if c == vowel\
    \ {\n                count += 1;\n                break;\n            }\n    \
    \    }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rl5tjs1.rs:20:9\n   |\n\
    20 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = s.chars().filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' ||\n        c == 'o' || c == 'u').filter(|c| c == s[s.len()\
    \ - 1]).count();\n    vowel_count += 1;\n    vowel_count\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprmin6937.rs:11:50\n\
    \   |\n11 |     let mut vowel_count = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' ||\n   |                                                  ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprmin6937.rs:11:62\n\
    \   |\n11 |     let mut vowel_count = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' ||\n   |                                                       \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprmin6937.rs:11:74\n\
    \   |\n11 |     let mut vowel_count = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' ||\n   |                                                       \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmprmin6937.rs:12:11\n   |\n12 |         c == 'o' ||\
    \ c == 'u').filter(|c| c == s[s.len() - 1]).count();\n   |           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprmin6937.rs:12:23\n\
    \   |\n12 |         c == 'o' || c == 'u').filter(|c| c == s[s.len() - 1]).count();\n\
    \   |                       ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmprmin6937.rs:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut num = 0;\n\n    s.chars().for_each(|c| match c {\n \
    \       'a' => num += 1,\n        'e' => num += 1,\n        'i' => num += 1,\n\
    \        'o' => num += 1,\n        'u' => num += 1,\n        _ => {},\n    });\n\
    \n    num\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpyv0_r6qq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = Vec::new();\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           vowels.push((i, c));\n        }\n    }\n    vowels.iter().filter(|&(_,\
    \ c)| c == 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3g_nrnfx.rs:17:38\n\
    \   |\n17 |     vowels.iter().filter(|&(_, c)| c == 'y').count()\n   |       \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3g_nrnfx.rs:17:5\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n17 |     vowels.iter().filter(|&(_, c)| c == 'y').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     vowels.iter().filter(|&(_, c)| c\
    \ == 'y').count().try_into().unwrap()\n   |                                  \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88t3c_ir.rs:11:63\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n   |    \
    \                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88t3c_ir.rs:11:75\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n   |    \
    \                                                                       ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88t3c_ir.rs:11:87\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n   |    \
    \                                                                            \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88t3c_ir.rs:11:99\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_lowercase()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n   |    \
    \                                                                            \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp88t3c_ir.rs:11:111\n   |\n11 |     s.chars()"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_aux(s.chars().filter(|c|\n        c.is_alphabetic()\
    \ && c != 'y' && c != 'Y' && c != 'y'\n    ).map(|c|\n        c.to_ascii_lowercase()\n\
    \    ).collect::<Vec<_>>())\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_aux` in this scope\n \
    \ --> /tmp/tmp1d1at1lm.rs:11:5\n   |\n11 |     vowels_count_aux(s.chars().filter(|c|\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp1d1at1lm.rs:12:32\n   |\n12 |         c.is_alphabetic()\
    \ && c != 'y' && c != 'Y' && c != 'y'\n   |                                ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1d1at1lm.rs:12:44\n\
    \   |\n12 |         c.is_alphabetic() && c != 'y' && c != 'Y' && c != 'y'\n  \
    \ |                                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp1d1at1lm.rs:12:56\n   |\n12\
    \ |         c.is_alphabetic() && c != 'y' && c != 'Y' && c != 'y'\n   |      \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpml9t5qsg.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpml9t5qsg.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfnpa8kj6.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfnpa8kj6.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfnpa8kj6.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpfnpa8kj6.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfnpa8kj6.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s.as_bytes())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7vftx5zb.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_bytes())\n   |                  ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_rec(s.as_bytes())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_rec` in this scope\n \
    \ --> /tmp/tmpgukxjemb.rs:11:5\n   |\n11 |     vowels_count_rec(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut n = 0;\n    for c in s.chars() {\n        match c {\n\
    \            'a' => n += 1,\n            'e' => n += 1,\n            'i' => n\
    \ += 1,\n            'o' => n += 1,\n            'u' => n += 1,\n            c\
    \ => return n,\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpf_d29swd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    if s.is_empty() {\n        0\n    }\n    else {\n        let\
    \ mut vowel_count = s.chars().filter(|c| {\n            c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u'\n        }).count();\n        if vowel_count\
    \ == 0 {\n            vowel_count = s.len() - 1;\n        }\n        vowel_count\n\
    \    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2dugw6qo.rs:16:15\n\
    \   |\n16 |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |               ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp2dugw6qo.rs:16:27\n   |\n16 |             c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |                      \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2dugw6qo.rs:16:39\n\
    \   |\n16 |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |                                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp2dugw6qo.rs:16:51\n   |\n16 |   \
    \          c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |    \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp2dugw6qo.rs:16:63\n   |\n16\
    \ |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |\
    \                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2dugw6qo.rs:21:9\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expecte"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| *c == 'a' || *c == 'e' || *c\
    \ == 'i' || *c == 'o' || *c == 'u')\n        .count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp3yynnb86.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(&s[..])\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxdfglnle.rs:11:18\n   |\n\
    11 |     vowels_count(&s[..])\n   |                  ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n11 |     vowels_count((&s[..]).to_string())\n\
    \   |                  +      +++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpowjmba6w.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpowjmba6w.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpowjmba6w.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpowjmba6w.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpowjmba6w.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count1(s)\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count1` in this scope\n  -->\
    \ /tmp/tmpoh057apy.rs:11:5\n   |\n11 |     vowels_count1(s)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ vowel_count = s.chars().filter(|c| vowels.contains(&c)).count();\n    vowel_count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoo99jw4j.rs:12:60\n   |\n\
    12 |     let vowel_count = s.chars().filter(|c| vowels.contains(&c)).count();\n\
    \   |                                                            ^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&&str`\n              found\
    \ reference `&&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoo99jw4j.rs:13:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n13 |     vowel_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |     vowel_count.try_into().unwrap()\n   |                ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut i = 0;\n    let mut j = s.len();\n    let mut count\
    \ = 0;\n    loop {\n        while i < j {\n            let c = s[i..j].chars().next();\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               i += 1;\n                j -= 1;\n                count += 1;\n\
    \                continue;\n            }\n            i += 1;\n            j\
    \ -= 1;\n        }\n        break;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpir6fwmvd.rs:17:21\n   |\n\
    17 |             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \   |                     ^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<char>`\n              found type `char`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n17 |             if c == Some('a')\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n   |                    \
    \ +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir6fwmvd.rs:17:33\n\
    \   |\n17 |             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' {\n   |                                 ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<char>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n17 |            \
    \ if c == 'a' || c == Some('e') || c == 'i' || c == 'o' || c == 'u' {\n   |  \
    \                               +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpir6fwmvd.rs:17:45\n   |\n17 |             if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n   |                                \
    \             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n17 |             if c == 'a' || c == 'e' || c ==\
    \ Some('i') || c == 'o' || c == 'u' {\n   |                                  \
    \           +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir6fwmvd.rs:17:57\n\
    \   |\n17 |             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' {\n   |                                                         ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |             if c == 'a' || c == 'e' || c == 'i' || c == Some('o')\
    \ || c == 'u' {\n   |                                                        \
    \ +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir6fwmvd.rs:17:69\n\
    \ "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = 0;\n    for i in s.chars() {\n        if i.is_vowel()\
    \ {\n            vowels += 1;\n        }\n    }\n    vowels\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpo0xc4_hy.rs:13:14\n   |\n13 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let vowels: &[isize] = &[\n        'a',\n        'e',\n    \
    \    'i',\n        'o',\n        'u',\n    ];\n    let mut count = s.len();\n\n\
    \    for vowel in vowels {\n        count += s.chars().filter(|c| *c == vowel).count();\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrq341mx.rs:12:9\n   |\n\
    12 |         'a',\n   |         ^^^ expected `isize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjrq341mx.rs:21:45\n   |\n21 |         count\
    \ += s.chars().filter(|c| *c == vowel).count();\n   |                        \
    \                     ^^^^^ expected `char`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjrq341mx.rs:24:5\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n24 |     count\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n24 |     count.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxn_adetm.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxn_adetm.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxn_adetm.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpxn_adetm.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxn_adetm.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c == 'i' ||\
    \ *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph8qvazpg.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c >= 'a' && c <= 'z' && !(c >= 'y' && c\
    \ <= 'z')).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpappgea4l.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c >= 'a' && c <= 'z' && !(c >= 'y' && c <= 'z')).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpappgea4l.rs:11:43\n   |\n11 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' && !(c >= 'y' && c <= 'z')).count()\n   |             \
    \                              ^^^\n   |                                     \
    \      |\n   |                                           expected `&char`, found\
    \ `char`\n   |                                           help: consider borrowing\
    \ here: `&'z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpappgea4l.rs:11:57\n\
    \   |\n11 |     s.chars().filter(|c| c >= 'a' && c <= 'z' && !(c >= 'y' && c <=\
    \ 'z')).count()\n   |                                                        \
    \ ^^^\n   |                                                         |\n   |  \
    \                                                       expected `&char`, found\
    \ `char`\n   |                                                         help: consider\
    \ borrowing here: `&'y'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpappgea4l.rs:11:69\n\
    \   |\n11 |     s.chars().filter(|c| c >= 'a' && c <= 'z' && !(c >= 'y' && c <=\
    \ 'z')).count()\n   |                                                        \
    \             ^^^\n   |                                                      \
    \               |\n   |                                                      \
    \               expected `&char`, found `char`\n   |                         \
    \                                            help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpappgea4l.rs:11:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n11 |     s.chars().filter(|c| c >=\
    \ 'a' && c <= 'z' && !(c >= 'y' && c"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| !c.is_whitespace() && c.is_lowercase()\
    \ && c != 'y')\n        .filter(|c| c.is_uppercase() && c != 'U')\n        .filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n        .count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzp50gn9m.rs:12:65\n\
    \   |\n12 |         .filter(|c| !c.is_whitespace() && c.is_lowercase() && c !=\
    \ 'y')\n   |                                                                 ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzp50gn9m.rs:13:43\n\
    \   |\n13 |         .filter(|c| c.is_uppercase() && c != 'U')\n   |          \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzp50gn9m.rs:14:23\n   |\n14 |   \
    \      .filter(|c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n\
    \   |                       ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpzp50gn9m.rs:14:35\n   |\n14 |         .filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n   |            \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpzp50gn9m.rs:14:47\n   |\n14 |         .filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n   |            \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzp50gn9m.rs:14:59\n   |\n14 |   \
    \      .filter(|c| c == 'A' || c == 'E"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    for i in s.chars() {\n       \
    \ if let 'a' as char = (*i).into() {\n            vowel_count += 1;\n        }\
    \ else if let 'e' as char = (*i).into() {\n            vowel_count += 1;\n   \
    \     } else if let 'i' as char = (*i).into() {\n            vowel_count += 1;\n\
    \        } else if let 'o' as char = (*i).into() {\n            vowel_count +=\
    \ 1;\n        } else if let 'u' as char = (*i).into() {\n            vowel_count\
    \ += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=`, or `|`, found keyword `as`\n\
    \  --> /tmp/tmpv9ffwfnf.rs:13:20\n   |\n13 |         if let 'a' as char = (*i).into()\
    \ {\n   |                    ^^ expected one of `...`, `..=`, `..`, `=`, or `|`\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: isize = 0;\n    let mut last_letter: char;\n\
    \    for i in s.chars() {\n        last_letter = i.to_ascii_lowercase().last().unwrap();\n\
    \        if last_letter == 'a' || last_letter == 'e' || last_letter == 'i' ||\
    \ last_letter == 'o' || last_letter == 'u' {\n            vowels += 1;\n     \
    \   }\n    }\n    vowels\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmplmt4pb00.rs:14:46\n\
    \   |\n14 |         last_letter = i.to_ascii_lowercase().last().unwrap();\n  \
    \ |                                              ^^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' ||\
    \ c == b'o' || c == b'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_45e7fd.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o'\
    \ || c == b'u').count()\n   |                               ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpy_45e7fd.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                            ^^ no implementation\
    \ for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy_45e7fd.rs:11:44\n   |\n11 |  \
    \   s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o' || c\
    \ == b'u').count()\n   |                                            ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n  --> /tmp/tmpy_45e7fd.rs:11:41\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                                        \
    \ ^^ no implementation for `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_45e7fd.rs:11:57\n\
    \   |\n11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c\
    \ == b'o' || c == b'u').count()\n   |                                        \
    \                 ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare\
    \ `&char` with `u8`\n  --> /tmp/tmpy_45e7fd.rs:11:54\n   |\n11 |     s.chars().filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count()\n   |\
    \                                                      ^^ no implementation for\
    \ `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy_45e7fd.rs:11:70\n   |\n11 |  \
    \   s.chars().filte"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter_map(|c| c.is_vowel()).count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp7g9xuc5r.rs:11:32\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count()\n   |                                ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7g9xuc5r.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <=\
    \ 'Z').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuekt3rml.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                               ^^^\n   |                     \
    \          |\n   |                               expected `&char`, found `char`\n\
    \   |                               help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuekt3rml.rs:11:43\n   |\n11 |  \
    \   s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                                           ^^^\n   |         \
    \                                  |\n   |                                   \
    \        expected `&char`, found `char`\n   |                                \
    \           help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuekt3rml.rs:11:55\n   |\n11 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count() as isize\n   |       \
    \                                                ^^^\n   |                   \
    \                                    |\n   |                                 \
    \                      expected `&char`, found `char`\n   |                  \
    \                                     help: consider borrowing here: `&'A'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuekt3rml.rs:11:67\n   |\n11 |  \
    \   s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                                                             \
    \      ^^^\n   |                                                             \
    \      |\n   |                                                               \
    \    expected `&char`, found `char`\n   |                                    \
    \                               help: consider borrowing here: `&'Z'`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    for i in s.chars().filter(|c| vowels.contains(c)) {\n        vowels.push(i);\n\
    \    }\n    vowels.len()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xsnbggr.rs:12:51\n   |\n\
    12 |     for i in s.chars().filter(|c| vowels.contains(c)) {\n   |           \
    \                                        ^ expected `&str`, found `char`\n   |\n\
    \   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3xsnbggr.rs:13:21\n   |\n13 |\
    \         vowels.push(i);\n   |                     ^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3xsnbggr.rs:15:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n...\n15 |     vowels.len()\n   |  \
    \   ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |     vowels.len().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels(s).fold(0, |acc, c| acc + c.len_utf8())\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp7fd3gvlj.rs:11:5\n\
    \   |\n11 |     vowels(s).fold(0, |acc, c| acc + c.len_utf8())\n   |     ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbm7gk0e.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbm7gk0e.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbm7gk0e.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbm7gk0e.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpjbm7gk0e.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u')\n        .count() + s.chars().filter(|&c| c == 'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzlmbjvp.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n12 | |         .count()\
    \ + s.chars().filter(|&c| c == 'y').count()\n   | |__________________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 ~     (s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n12 ~         .count()\
    \ + s.chars().filter(|&c| c == 'y').count()).try_into().unwrap()\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_impl(s, s.chars().count(), &[\n        'a', 'e',\
    \ 'i', 'o', 'u',\n    ])\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmp1m5kby8h.rs:11:5\n   |\n11 |     vowels_count_impl(s, s.chars().count(),\
    \ &[\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4annrpk_.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4annrpk_.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4annrpk_.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4annrpk_.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4annrpk_.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbb023euq.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbb023euq.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbb023euq.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbb023euq.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpbb023euq.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    let mut last = None;\n    for\
    \ c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' {\n            vowel_count += 1;\n        }\n        last = c == 'y';\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0j3uqn4e.rs:17:16\n   |\n\
    12 |     let mut last = None;\n   |                    ---- expected due to this\
    \ value\n...\n17 |         last = c == 'y';\n   |                ^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         last = Some(c == 'y');\n   |                +++++        +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| match c {\n        'a' | 'e' | 'i' | 'o'\
    \ | 'u' => true,\n        _ => false,\n    })\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpepzf710y.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ match c {\n12 | |         'a' | 'e' | 'i' | 'o' | 'u' => true,\n13 | |     \
    \    _ => false,\n14 | |     })\n15 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u')\n        .count() + s.chars()\n            .filter(|c|\
    \ c == 'y')\n            .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88oe5m6q.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp88oe5m6q.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp88oe5m6q.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp88oe5m6q.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp88oe5m6q.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp88oe5m6q.rs"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut res = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        let ch = s[i..].chars().filter(|c|\n            !c.is_ascii_letter()\
    \ ||\n            c == 'A' || c == 'a' ||\n            c == 'E' || c == 'e' ||\n\
    \            c == 'I' || c == 'i' ||\n            c == 'O' || c == 'o' ||\n  \
    \          c == 'U' || c == 'u'\n        ).count();\n        if ch == 0 {\n  \
    \          i += 1;\n        } else {\n            res += ch;\n            i +=\
    \ 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpu170jkta.rs:15:16\n   |\n15 |          \
    \   !c.is_ascii_letter() ||\n   |                ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:16:15\n   |\n16 |   \
    \          c == 'A' || c == 'a' ||\n   |               ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:16:27\n\
    \   |\n16 |             c == 'A' || c == 'a' ||\n   |                        \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:17:15\n\
    \   |\n17 |             c == 'E' || c == 'e' ||\n   |               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:17:27\n\
    \   |\n17 |             c == 'E' || c == 'e' ||\n   |                        \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:18:15\n\
    \   |\n18 |             c == 'I' || c == 'i' ||\n   |               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpu170jkta.rs:18:27\n\
    \   |\n18 |             c == 'I' || c == 'i' ||\n   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count(s, s.length())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpk1gno9kq.rs:11:23\n   |\n11 |     vowels_count(s,\
    \ s.length())\n   |                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmpk1gno9kq.rs:11:5\n   |\n11 |  \
    \   vowels_count(s, s.length())\n   |     ^^^^^^^^^^^^ -  ---------- supplied\
    \ 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmpk1gno9kq.rs:10:4\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut counter = 0;\n    let len = s.len();\n    for i in 0..len\
    \ {\n        let c = s[i];\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            counter += 1;\n        }\n        if c == 'y'\
    \ && i != len - 1 {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxch09478.rs:14:17\n\
    \   |\n14 |         let c = s[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: isize = 0;\n\n    for ch in s.chars() {\n  \
    \      if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n  \
    \          vowels += 1;\n        }\n    }\n\n    vowels\n}\n\nfn main() {\n  \
    \  let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpp3sqqc7f.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n       \
    \ let v = c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n        if\
    \ v {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmplumvjahy.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u')\n        .count();\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiuk9b8vz.rs:10:31\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |    ------------             \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_impl(s, \"\", &mut 0)\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmpdg7kre1f.rs:11:5\n   |\n11 |     vowels_count_impl(s, \"\", &mut\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi65yjlex.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi65yjlex.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi65yjlex.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi65yjlex.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpi65yjlex.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    vowels_count_vec(s.chars().cloned().collect::<Vec<char>>()).0\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `vowels_count_vec` in this scope\n \
    \ --> /tmp/tmpn0w75l1g.rs:11:5\n   |\n11 |     vowels_count_vec(s.chars().cloned().collect::<Vec<char>>()).0\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpn0w75l1g.rs:11:32\n\
    \     |\n11   |     vowels_count_vec(s.chars().cloned().collect::<Vec<char>>()).0\n\
    \     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpn0w75l1g.rs:11:41\n   |\n11 |       vowels_count_vec(s.chars().cloned().collect::<Vec<char>>()).0\n\
    \   |                                           ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut count = 1;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        match c {\n            'a' => if i == s.len() - 1 || s[i+1] != 'u'\
    \ { count += 1 },\n            'e' => if i == s.len() - 1 || s[i+1] != 'i' { count\
    \ += 1 },\n            'i' => if i == s.len() - 1 || s[i+1] != 'o' { count +=\
    \ 1 },\n            'o' => if i == s.len() - 1 || s[i+1] != 'u' { count += 1 },\n\
    \            'u' => if i == s.len() - 1 || s[i+1] != 'y' { count += 1 },\n   \
    \         _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpslegxakh.rs:14:43\n\
    \   |\n14 |             'a' => if i == s.len() - 1 || s[i+1] != 'u' { count +=\
    \ 1 },\n   |                                           ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpslegxakh.rs:15:43\n   |\n15 |             'e' => if i == s.len()\
    \ - 1 || s[i+1] != 'i' { count += 1 },\n   |                                 \
    \          ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpslegxakh.rs:16:43\n   |\n16 |             'i' => if i == s.len()\
    \ - 1 || s[i+1] != 'o' { count += 1 },\n   |                                 \
    \          ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \            "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // return if s is empty\n    if s.is_empty() {\n        return\
    \ 0;\n    }\n\n    // iterate over all chars in s\n    for i in 0..s.len() {\n\
    \        // if current char is a vowel\n        if vowels.contains(&s[i]) {\n\
    \            // increment count by 1\n            count += 1;\n        }\n   \
    \ }\n\n    // return count\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpjdqnnze1.rs:19:12\n\
    \   |\n19 |         if vowels.contains(&s[i]) {\n   |            ^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `count` in this scope\n  -->\
    \ /tmp/tmpjdqnnze1.rs:21:13\n   |\n21 |             count += 1;\n   |        \
    \     ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `count`\
    \ in this scope\n  --> /tmp/tmpjdqnnze1.rs:26:5\n   |\n26 |     count\n   |  \
    \   ^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpjdqnnze1.rs:19:29\n   |\n19 |         if vowels.contains(&s[i])\
    \ {\n   |                             ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n        .count() + s.chars().filter(|c| c == 'y' && s.chars().last().unwrap()\
    \ == 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi4af2xeo.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpi4af2xeo.rs:11:40\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                        ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi4af2xeo.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpi4af2xeo.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpi4af2xeo.rs:11:76\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't com"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp080y7xtf.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp080y7xtf.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp080y7xtf.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp080y7xtf.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp080y7xtf.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // TODO\n    if s.is_empty() {\n        0\n    } else {\n  \
    \      s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count()\n    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpapzzbl5t.rs:15:32\n\
    \   |\n15 |         s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count()\n   |                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpapzzbl5t.rs:15:44\n\
    \   |\n15 |         s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count()\n   |                                          \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpapzzbl5t.rs:15:56\n\
    \   |\n15 |         s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count()\n   |                                          \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpapzzbl5t.rs:15:68\n   |\n15 |         s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpapzzbl5t.rs:15:80\n\
    \   |\n15 |         s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u').count()\n   |                                          \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    // vowels count\n    s.chars().filter(|c| c.is_vowel()).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpsoghce5f.rs:12:28\n   |\n12 |     s.chars().filter(|c|\
    \ c.is_vowel()).count() as isize\n   |                            ^^^^^^^^ method\
    \ not found in `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c.is_ascii_letter()).filter(|c| c.is_ascii_upper()).filter(|c|\
    \ c.is_ascii_lowercase())\n        .filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp8jie3tt8.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_ascii_upper()).filter(|c| c.is_ascii_lowercase())\n\
    \   |                            ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_upper`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp8jie3tt8.rs:11:60\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii_letter()).filter(|c| c.is_ascii_upper()).filter(|c|\
    \ c.is_ascii_lowercase())\n   |                                              \
    \              ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8jie3tt8.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8jie3tt8.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8jie3tt8.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp8jie3tt8.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplimcx5w4.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplimcx5w4.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplimcx5w4.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplimcx5w4.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmplimcx5w4.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzixo70ly.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzixo70ly.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzixo70ly.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzixo70ly.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpzixo70ly.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    let mut vowels: Vec<_> = vec!['A', 'E', 'I', 'O', 'U'];\n\n\
    \    for c in s.chars() {\n        if vowels.iter().any(|vowel| vowel == *c) {\n\
    \            vowels.push(*c);\n        }\n    }\n    vowels.len()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpzxwirv4g.rs:14:47\n\
    \   |\n14 |         if vowels.iter().any(|vowel| vowel == *c) {\n   |        \
    \                                       ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpzxwirv4g.rs:15:25\n   |\n15 |             vowels.push(*c);\n\
    \   |                         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzxwirv4g.rs:18:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n18 |     vowels.len()\n\
    \   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    18 |     vowels.len().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(\"\
    abcde\")\n/// 2\n/// >>> vowels_count(\"ACEDY\")\n/// 3\nfn vowels_count(s: String)\
    \ -> isize {\n    s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <=\
    \ 'Z').count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyny6h24_.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                               ^^^\n   |                     \
    \          |\n   |                               expected `&char`, found `char`\n\
    \   |                               help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyny6h24_.rs:11:43\n   |\n11 |  \
    \   s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                                           ^^^\n   |         \
    \                                  |\n   |                                   \
    \        expected `&char`, found `char`\n   |                                \
    \           help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyny6h24_.rs:11:55\n   |\n11 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count() as isize\n   |       \
    \                                                ^^^\n   |                   \
    \                                    |\n   |                                 \
    \                      expected `&char`, found `char`\n   |                  \
    \                                     help: consider borrowing here: `&'A'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyny6h24_.rs:11:67\n   |\n11 |  \
    \   s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count()\
    \ as isize\n   |                                                             \
    \      ^^^\n   |                                                             \
    \      |\n   |                                                               \
    \    expected `&char`, found `char`\n   |                                    \
    \                               help: consider borrowing here: `&'Z'`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
