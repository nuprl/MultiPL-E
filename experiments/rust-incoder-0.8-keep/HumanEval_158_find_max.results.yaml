name: HumanEval_158_find_max
language: rust
results:
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words_with_numbers =\
    \ words.iter().cloned().map(|w| {\n        let mut count_map = HashMap::new();\n\
    \        w.chars().filter(|c| !c.is_whitespace()).for_each(|c| {\n           \
    \ count_map.entry(c).or_insert(0usize);\n        });\n        w.chars().filter(|c|\
    \ !c.is_whitespace() && count_map.contains_key(&c)).count()\n    });\n\n    //\
    \ We need to sort the words by descending number of unique characters\n    words_with_numbers.sort_by_key(|w|\
    \ w.cmp(&w).reverse());\n\n    // Return the one with minimum number of unique\
    \ characters\n    words_with_numbers.next()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4hhh5_14.rs:10:29\n   |\n10 |         let mut count_map = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `sort_by_key` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmp4hhh5_14.rs:18:24\n   |\n18 |     words_with_numbers.sort_by_key(|w|\
    \ w.cmp(&w).reverse());\n   |                        ^^^^^^^^^^^ method not found\
    \ in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmp4hhh5_14.rs:9:60:\
    \ 15:6]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4hhh5_14.rs:21:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n21\
    \ |     words_with_numbers.next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_count = 0;\n    let\
    \ mut best_word = String::new();\n    for word in words {\n        let count =\
    \ word.chars().map(|c| c.chars().count()).collect::<Vec<_>>();\n        if count.iter().max().is_some()\
    \ {\n            if max_count < count.iter().max().unwrap() {\n              \
    \  max_count = count.iter().max().unwrap();\n                best_word = word;\n\
    \            }\n        }\n    }\n    match best_word.chars().map(|c| c.chars().count()).collect::<Vec<_>>()\
    \ {\n        x if x.iter().max().is_some() => best_word.to_owned(),\n        _\
    \ => \"\",\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpoirh14m_.rs:12:44\n   |\n12 |         let count = word.chars().map(|c|\
    \ c.chars().count()).collect::<Vec<_>>();\n   |                              \
    \              ^^^^^ method not found in `char`\n\nerror[E0277]: can't compare\
    \ `{integer}` with `&_`\n  --> /tmp/tmpoirh14m_.rs:14:26\n   |\n14 |         \
    \    if max_count < count.iter().max().unwrap() {\n   |                      \
    \    ^ no implementation for `{integer} < &_` and `{integer} > &_`\n   |\n   =\
    \ help: the trait `PartialOrd<&_>` is not implemented for `{integer}`\n   = help:\
    \ the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoirh14m_.rs:15:29\n   |\n9  |\
    \     let mut max_count = 0;\n   |                         - expected due to this\
    \ value\n...\n15 |                 max_count = count.iter().max().unwrap();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found reference\n   |\n   = note:   expected type `{integer}`\n           found\
    \ reference `&_`\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \         max_count = *count.iter().max().unwrap();\n   |                    \
    \         +\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpoirh14m_.rs:20:39\n   |\n20 |     match best_word.chars().map(|c|\
    \ c.chars().count()).collect::<Vec<_>>() {\n   |                             \
    \          ^^^^^ method not found in `char`\n\nerror[E0308]: `match` arms have\
    \ incompatible types\n  --> /tmp/tmpoirh14m_.rs:22:14\n   |\n20 | /     match\
    \ best_word.chars().map(|c| c.chars().count()).collect::<Vec<_>>() {\n21 | | \
    \        x if x.iter().max().is_some() => best_word.to_owned(),\n   | |      \
    \                                    -------------------- this is found to be\
    \ of type `String`\n22 | |         _ => \"\",\n   | |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Step 1: Count the number of\
    \ characters in each word\n    let mut char_counter = words.iter().map(|s| s.chars().count()).collect::<Vec<usize>>();\n\
    \    // Step 2: Sort characters by their frequency\n    char_counter.sort_unstable();\n\
    \    // Step 3: Find maximum frequency\n    char_counter.iter().max_by_key(|&x|\
    \ x).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktzxwpfp.rs:14:5\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n14 |     char_counter.iter().max_by_key(|&x|\
    \ x).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&usize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // sort words by length in descending\
    \ order\n    let mut len = words.len();\n    let mut max_len = words[0].len();\n\
    \    let mut first_word = words[0];\n    let mut first_len = words[0].len();\n\
    \n    for &s in &words {\n        if s.len() > max_len {\n            max_len\
    \ = s.len();\n        }\n    }\n\n    for i in len - 1 {\n        if words[i +\
    \ 1].len() > max_len {\n            max_len = words[i + 1].len();\n        }\n\
    \    }\n\n    for i in 0..words[0].len() {\n        for j in 0..len - 1 {\n  \
    \          if words[j][i] == words[i][j] {\n                first_len = 0;\n \
    \               first_word = words[j];\n            }\n        }\n    }\n\n  \
    \  if first_len > max_len {\n        return first_word;\n    }\n\n    \"\"\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmpm8uslo1q.rs:21:14\n\
    \   |\n21 |     for i in len - 1 {\n   |              ^^^^^^^ `usize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `usize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm8uslo1q.rs:29:16\n   |\n29 |             if words[j][i] == words[i][j]\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm8uslo1q.rs:29:31\n   |\n29 |             if words[j][i] == words[i][j]\
    \ {\n   |                               ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm8uslo1q.rs:40:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_count = 0;\n    for (word) in words {\n        let mut count\
    \ = 1;\n        for ch in word.chars() {\n            if *ch != *&mut count {\n\
    \                break;\n            }\n            count += 1;\n        }\n \
    \       if count == word.len() {\n            // no need to reset to zero\n  \
    \          break;\n        }\n        if count > max_count {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmp_dtcjic7.rs:11:9\n\
    \   |\n11 |     for (word) in words {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n11 -     for (word) in\
    \ words {\n11 +     for word in words {\n   | \n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp_dtcjic7.rs:14:16\n   |\n14 |             if\
    \ *ch != *&mut count {\n   |                ^^^\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut num_unique = 0;\n\n    for &s in words {\n        if &s.chars().filter(|c|\
    \ !c.is_ascii_letter()).count() > num_unique {\n            word = s;\n      \
    \      num_unique = &s.chars().filter(|c| !c.is_ascii_letter()).count();\n   \
    \     }\n    }\n\n    word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoh2j5rpn.rs:12:9\n   |\n\
    12 |     for &s in words {\n   |         ^^    ----- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return String::new();\n    }\n\n    let mut max_count = String::new();\n \
    \   let mut max_word = String::new();\n\n    for word in words {\n        let\
    \ mut count: usize = 0;\n        for ch in word.chars().cloned() {\n         \
    \   count += 1;\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    return max_word;\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpr1xq6bpp.rs:18:32\n     |\n18   |         for ch in word.chars().cloned()\
    \ {\n     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpr1xq6bpp.rs:18:19\n\
    \   |\n18 |         for ch in word.chars().cloned() {\n   |                  \
    \ ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpr1xq6bpp.rs:18:19\n   |\n18 |         for ch in word.chars().cloned()\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr1xq6bpp.rs:21:20\n   |\n21 |\
    \         if count > max_count {\n   |                    ^^^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr1xq6bpp.rs:22:25\n\
    \   |\n13 |     let mut max_count = String::new();\n   |                     \
    \    ------------- expected due to this value\n...\n22 |             max_count\
    \ = count;\n   |                         ^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `usize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .map(|word| word.chars().count_uniq())\n        .max()\n        .unwrap_or_else(||\
    \ \"\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_uniq` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpezr_ztkm.rs:11:34\n   |\n11 |         .map(|word|\
    \ word.chars().count_uniq())\n   |                                  ^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpezr_ztkm.rs:9:5\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n9  |\
    \ /     words\n10 | |         .into_iter()\n11 | |         .map(|word| word.chars().count_uniq())\n\
    12 | |         .max()\n13 | |         .unwrap_or_else(|| \"\")\n   | |       \
    \                       ^- help: try using a conversion method: `.to_string()`\n\
    \   | |______________________________|\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = vec![String::new();\
    \ words.len()];\n    for &s in words {\n        counters[s.chars().count() - 1]\
    \ += s;\n    }\n    if counters.iter().max().unwrap() >= words[0].chars().count()\
    \ {\n        counters.iter().max().unwrap()\n    } else {\n        counters.iter().next().unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qtttdhg.rs:10:9\n   |\n\
    10 |     for &s in words {\n   |         ^^    ----- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9qtttdhg.rs:13:42\n   |\n13 |  \
    \   if counters.iter().max().unwrap() >= words[0].chars().count() {\n   |    \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&String`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9qtttdhg.rs:14:9\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n14\
    \ |         counters.iter().max().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9qtttdhg.rs:16:9\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n16 |         counters.iter().next().unwrap()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |         |\n   |         expected struct `String`, found\
    \ `&String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    for word in words {\n        if word.chars().distinct().count() == word.chars().count()\
    \ {\n            if !max.is_empty() {\n                if max.len() < word.len()\
    \ {\n                    max = word;\n                }\n            } else {\n\
    \                max = word;\n            }\n        }\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `distinct` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp2ueqs2jf.rs:11:25\n   |\n11 |         if word.chars().distinct().count()\
    \ == word.chars().count() {\n   |                         ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .map(|w| w.chars().unique_count().unwrap())\n        .max()\n       \
    \ .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique_count` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp3wiov6nn.rs:11:28\n   |\n11 |         .map(|w|\
    \ w.chars().unique_count().unwrap())\n   |                            ^^^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // sort words by length and then\
    \ lexicographical order\n    let mut words = words.into_iter().sort_by_key(|s|\
    \ s.len()).collect::<Vec<_>>();\n    words.next().unwrap().to_ascii_lowercase().collect()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp7r43g_zy.rs:10:39\n   |\n10 |     let mut\
    \ words = words.into_iter().sort_by_key(|s| s.len()).collect::<Vec<_>>();\n  \
    \ |                                       ^^^^^^^^^^^ method not found in `std::vec::IntoIter<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|word| word.chars())\n        .flatten()\n        .filter(|c| c.len()\
    \ == c.chars().count())\n        .count()\n        .max()\n        .unwrap_or_else(||\
    \ \"\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpbycesss7.rs:13:23\n   |\n13 |         .filter(|c|\
    \ c.len() == c.chars().count())\n   |                       ^^^ method not found\
    \ in `&char`\n\nerror[E0599]: no method named `chars` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbycesss7.rs:13:34\n   |\n13 |         .filter(|c|\
    \ c.len() == c.chars().count())\n   |                                  ^^^^^ method\
    \ not found in `&char`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmpbycesss7.rs:15:10\n    |\n15  |         .max()\n\
    \    |          ^^^- supplied 0 arguments\n    |          |\n    |          expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `unwrap_or_else` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpbycesss7.rs:16:10\n   |\n16 |         .unwrap_or_else(|| \"\")\n\
    \   |          ^^^^^^^^^^^^^^ method not found in `usize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for (index, word) in words.iter().enumerate() {\n        let count = counts.entry(word).or_insert(0);\n\
    \        *count = *count + 1;\n    }\n    let mut max_key = String::new();\n \
    \   let mut max_counts = counts.iter().cloned().max_by_key(|&(_, &count)| count);\n\
    \    if let Some(count) = max_counts {\n        for (key, _) in counts {\n   \
    \         if *count > *max_counts {\n                max_counts = max_counts.clone();\n\
    \                max_key = key.clone();\n            }\n        }\n    }\n   \
    \ max_key\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpdzjltn9b.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \    for word in words {\n        let mut n = map.entry(word.clone()).or_insert(0);\n\
    \        *n += 1;\n    }\n    let mut max: String = String::new();\n    match\
    \ map.iter().max_by(|(_, count)| count as u32) {\n        Some((count, key)) =>\
    \ {\n            max = key;\n        }\n        None => {\n            for (key,\
    \ count) in map.iter() {\n                if *count > map.len() {\n          \
    \          max = key;\n                }\n            }\n        }\n    };\n \
    \   max.clone()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpnsu2w9fc.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   \"\".to_string()\n    } else {\n        let mut count = HashMap::new();\n\
    \        let mut max = 0;\n        for word in words {\n            if let Some(count)\
    \ = count.entry(word.to_string()).or_insert(0) {\n                count = *count\
    \ + 1;\n                if count > max {\n                    max = count;\n \
    \               }\n            } else {\n                count = *count + 1;\n\
    \            }\n        }\n        max > 0 ? words[0] : \"\".to_string()\n   \
    \ }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `words`\n\
    \  --> /tmp/tmpxs5vp1_i.rs:24:19\n   |\n24 |         max > 0 ? words[0] : \"\"\
    .to_string()\n   |                   ^^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmpxs5vp1_i.rs:12:25\n   |\n12 |         let mut count = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max: Vec<String> = Vec::new();\n\
    \    for (i, word) in words.iter().enumerate() {\n        let mut count: usize\
    \ = 0;\n        for j in 0..word.len() {\n            count += word.chars().filter(|c|\
    \ c != word[j]).count();\n        }\n        if count.is_max(&mut max) {\n   \
    \         max = Vec::from_iter(word.iter().cloned());\n        }\n    }\n    max.iter().cloned().next()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjbfwo615.rs:13:51\n\
    \   |\n13 |             count += word.chars().filter(|c| c != word[j]).count();\n\
    \   |                                                   ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `is_max` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpjbfwo615.rs:15:18\n   |\n15 |         if count.is_max(&mut\
    \ max) {\n   |                  ^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no function or associated item named `from_iter` found for struct `Vec<_, _>`\
    \ in the current scope\n  --> /tmp/tmpjbfwo615.rs:16:24\n   |\n16 |          \
    \   max = Vec::from_iter(word.iter().cloned());\n   |                        ^^^^^^^^^\
    \ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items\
    \ from traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `iter` found\
    \ for reference `&String` in the current scope\n  --> /tmp/tmpjbfwo615.rs:16:39\n\
    \   |\n16 |             max = Vec::from_iter(word.iter().cloned());\n   |    \
    \                                   ^^^^ method not found in `&String`\n   |\n\
    help: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n16 |             max =\
    \ Vec::from_iter(word.chars().cloned());\n   |                               \
    \        ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjbfwo615.rs:19"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for w in words.iter() {\n        for c in w {\n            counts.entry(c).or_insert(0)\n\
    \                .cloned()\n                .clone_from_slice(w.to_owned());\n\
    \        }\n    }\n    counts.iter().max_by_key(|&(_, count)| count).expect(\"\
    max not found\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpqpwtmb0e.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0277]: `&String`\
    \ is not an iterator\n  --> /tmp/tmpqpwtmb0e.rs:11:18\n   |\n11 |         for\
    \ c in w {\n   |                  ^ `&String` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `&String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut seen: Vec<String> = Vec::new();\n\
    \    let mut max = 0;\n\n    for word in words {\n        let mut len: usize =\
    \ 0;\n        for ch in word {\n            len = ch.chars().count();\n      \
    \      if !seen.contains(&ch.to_string()) {\n                seen.push(ch.to_string());\n\
    \                if len > max {\n                    max = len;\n            \
    \    }\n            }\n        }\n    }\n\n    if max > 0 {\n        for w in\
    \ seen {\n            if w < words.iter().take(1).next().unwrap() {\n        \
    \        return w;\n            }\n        }\n        return \"\";\n    }\n  \
    \  return \"\".to_string();\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpzr3og_5x.rs:14:19\n\
    \   |\n14 |         for ch in word {\n   |                   ^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzr3og_5x.rs:27:20\n   |\n27 |             if\
    \ w < words.iter().take(1).next().unwrap() {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzr3og_5x.rs:31:16\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n31 |         return \"\";\n   |      \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \           |\n   |                expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars: Vec<_> = words.iter().map(|word|\
    \ word.chars().collect()).collect();\n    let mut count = chars.iter().filter(|x|\
    \ x.is_unique()).count();\n    if count == chars.len() {\n        return \"\"\
    .to_string();\n    }\n    if chars.len() > count.max() {\n        return \"\"\
    .to_string();\n    }\n    let mut max_char = chars[0];\n    for i in 1..chars.len()\
    \ {\n        if chars[i-1] > chars[i] {\n            max_char = chars[i];\n  \
    \      }\n    }\n    max_char\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&&T`\n  --> /tmp/tmp2ilo6c94.rs:10:42\n\
    \   |\n10 |     let mut count = chars.iter().filter(|x| x.is_unique()).count();\n\
    \   |                                          ^ consider giving this closure\
    \ parameter the explicit type `&&T`, where the type parameter `T` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max: Option<String> =\
    \ None;\n    let mut result = String::new();\n    for w in words {\n        let\
    \ mut count = 0;\n        for c in w {\n            if let Some(count) = char_count[c]\
    \ {\n                count += 1;\n            } else {\n                char_count[c]\
    \ = Some(1);\n            }\n        }\n        let mut best = *count as u8;\n\
    \        if !max.is_none() && max < best {\n            max = Some(w);\n     \
    \       result = *count as String;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `char_count` in this scope\n  --> /tmp/tmpn05ddbmy.rs:14:34\n\
    \   |\n14 |             if let Some(count) = char_count[c] {\n   |           \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `char_count` in this scope\n  --> /tmp/tmpn05ddbmy.rs:17:17\n   |\n\
    17 |                 char_count[c] = Some(1);\n   |                 ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpn05ddbmy.rs:13:18\n   |\n13 |         for c in w {\n   |           \
    \       ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpn05ddbmy.rs:20:24\n\
    \   |\n20 |         let mut best = *count as u8;\n   |                       \
    \ ^^^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpn05ddbmy.rs:23:22\n\
    \   |\n23 |             result = *count as String;\n   |                     \
    \ ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn05ddbmy.rs:26:5\n \
    \  |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                 \
    \                   ------ expected `String` because of return type\n...\n26 |\
    \     max\n   |     ^^^ expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Sort the list by length descending,\
    \ then lexicographical order\n    let mut sorted_list = words\n        .iter()\n\
    \        .cloned()\n        .map(|s| s.to_owned())\n        .sort_by(|a, b| a.len()\
    \ < b.len());\n\n    sorted_list.sort();\n\n    // The largest element comes first\
    \ in the list\n    sorted_list.reverse();\n\n    let mut max_count = std::cmp::min(*sorted_list.last().unwrap().len(),\
    \ 10);\n    let mut max_string = sorted_list.last().unwrap();\n\n    // Iterate\
    \ over list and check each word against maximum number of unique\n    // characters\
    \ and if count is greater then update the largest count and the\n    // largest\
    \ string\n    for i in sorted_list.iter().rev() {\n        let mut count = std::cmp::min(*i.unwrap().len(),\
    \ 10);\n        let mut string = i.unwrap();\n\n        // Increase count if unique\
    \ characters count is greater than count\n        if string.chars().filter(|c|\
    \ !c.is_alphanumeric()).count() > count {\n            count = string.chars().filter(|c|\
    \ !c.is_alphanumeric()).count();\n        }\n\n        // If count is greater\
    \ than the maximum then update the largest count and the\n        // largest string\n\
    \        if count > max_count {\n            max_count = count;\n            max_string\
    \ = string;\n        }\n    }\n\n    // Return largest string which has maximum\
    \ number of unique characters\n    max_string\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpnjndaya8.rs:14:10\n   |\n14 |         .sort_by(|a, b| a.len()\
    \ < b.len());\n   |          ^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmpnjndaya8.rs:13:14: 13:30]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = words.len();\n\
    \    let mut max: Option<String> = Some(\"\");\n\n    for w in words {\n     \
    \   if count > 0 {\n            max = if let Some(max) = max {\n             \
    \   if max < w {\n                    Some(w)\n                } else {\n    \
    \                Some(max)\n                }\n            } else {\n        \
    \        Some(w)\n            }\n        } else {\n            max = Some(w)\n\
    \        }\n        count -= 1;\n    }\n\n    max.unwrap()\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfiun8yfe.rs:10:40\n   |\n\
    10 |     let mut max: Option<String> = Some(\"\");\n   |                     \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for w in words {\n        if let Some(n) = counts.iter().position(|&(_, c)|\
    \ c > n) {\n            counts.insert(w.to_lowercase(), 0);\n        } else {\n\
    \            counts.insert((w, 0), 1);\n        }\n    }\n\n    counts.keys()\n\
    \        .iter()\n        .fold(\"\".to_string(), |mut acc, &w| {\n          \
    \  let mut max_count = 0;\n            let (mut word, count) = w.split_whitespace().iter_mut().enumerate().find(|&(_,\
    \ c)| {\n                c > max_count\n            });\n            count = match\
    \ count {\n                Some(c) => c,\n                None => 0,\n       \
    \     };\n            max_count = count;\n            acc += word + &*word[count];\n\
    \            acc\n        });\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpi9wukdbn.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]: cannot\
    \ find value `n` in this scope\n  --> /tmp/tmpi9wukdbn.rs:11:63\n   |\n11 |  \
    \       if let Some(n) = counts.iter().position(|&(_, c)| c > n) {\n   |     \
    \                                                          ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi9wukdbn.rs:26:28\n\
    \   |\n26 |                 Some(c) => c,\n   |                            ^ cyclic\
    \ type of infinite size\n   |\nhelp: try wrapping the expression in `Some`\n \
    \  |\n26 |                 Some(c) => Some(c),\n   |                         \
    \   +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi9wukdbn.rs:29:25\n\
    \   |\n21 |             let mut max_count = 0;\n   |                         \
    \        - expected due to this value\n...\n29 |             max_count = count;\n\
    \   |                         ^^^^^ expected integer, found enum `Option`\n  \
    \ |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpi9wukdbn.rs:8:36\n  |\n8 | fn find_max(words:\
    \ Vec<String>) -> String {\n  |    --------                        ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .cloned()\n        .map(|s| s.chars().filter(|c| c.is_ascii_letter()).count())\n\
    \        .max_by_key(|i| i)\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp_530r96y.rs:12:41\n   |\n12 |         .map(|s|\
    \ s.chars().filter(|c| c.is_ascii_letter()).count())\n   |                   \
    \                      ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_530r96y.rs:9:5\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n9  |\
    \ /     words\n10 | |         .iter()\n11 | |         .cloned()\n12 | |      \
    \   .map(|s| s.chars().filter(|c| c.is_ascii_letter()).count())\n13 | |      \
    \   .max_by_key(|i| i)\n14 | |         .unwrap()\n   | |                 ^- help:\
    \ try using a conversion method: `.to_string()`\n   | |_________________|\n  \
    \ |                   expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_counter = Vec::<String>::new();\n\
    \n    for (i, word) in words.iter().enumerate() {\n        for c in word.chars()\
    \ {\n            if let Some(count) = chars_counter.get_mut(&c).or_insert(0) {\n\
    \                *count += 1;\n            }\n        }\n    }\n    chars_counter.sort();\n\
    \    let mut unique_count = chars_counter.iter().filter(|&x| x.iter().count()\
    \ == 1).count();\n    let mut max_count = chars_counter.iter().filter(|&x| x.iter().count()\
    \ == 1).count();\n    let mut max_word = String::new();\n\n    while unique_count\
    \ > max_count {\n        let mut max_index = chars_counter.iter().filter(|&x|\
    \ x.iter().count() == 1).max_by_key(|&x| x.iter().count());\n        max_word\
    \ = words[max_index];\n        chars_counter.remove(&chars_counter[max_index]);\n\
    \        unique_count -= 1;\n        max_count -= 1;\n    }\n\n    String::from(max_word)\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `&char`\n   -->\
    \ /tmp/tmpftxzp0lb.rs:13:56\n    |\n13  |             if let Some(count) = chars_counter.get_mut(&c).or_insert(0)\
    \ {\n    |                                                ------- ^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n    |                            \
    \                    |\n    |                                                required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&char`\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::get_mut`\n\nerror[E0599]: no method named `or_insert` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpftxzp0lb.rs:13:60\n   |\n13 |          \
    \   if let Some(count) = chars_counter.get_mut(&c).or_insert(0) {\n   |      \
    \                                                      ^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `get_or_insert`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpftxzp0lb.rs:19:63\n   |\n19 |     let mut unique_count = chars_counter.iter().filter(|&x|\
    \ x.iter().count() == 1).count();\n   |                                      \
    \                         ^^^^ method not found in `&String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n19 |     let mut unique_count = chars_counter.iter().filter(|&x|\
    \ x.chars().count() == 1).count();\n   |                                     \
    \                          ~~~~~\n\nerror[E0599]: no method named `iter` found\
    \ for reference `&String` in the current scope\n  --> /tmp/tmpftxzp0lb.rs:20:60\n\
    \   |\n20 |     let mut max_count = chars_counter.iter().filter(|&x| x.iter().count()\
    \ == 1).count();\n   |                                                       \
    \     ^^^^ method not found in `&String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n20 |   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut freqs = HashMap::<String,\
    \ usize>::new();\n    for word in words {\n        freqs.entry(word).or_insert(0)\
    \ as usize += 1;\n    }\n    freqs.iter().max_by_key(|(_, count)| count).map(|(_,\
    \ count)| count).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp3zr0ngka.rs:9:21\n  |\n9 |     let mut freqs = HashMap::<String, usize>::new();\n\
    \  |                     ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp3zr0ngka.rs:11:49\n   |\n\
    11 |         freqs.entry(word).or_insert(0) as usize += 1;\n   |         ---------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = words[0].to_owned().chars().count();\n\
    \    let mut max_unique = 0;\n    let mut max_unique_count = 0;\n\n    for word\
    \ in words {\n        let mut current_counter = counters.clone();\n\n        for\
    \ c in word.to_owned().chars() {\n            current_counter -= 1;\n        \
    \    if current_counter == 0 {\n                counters = max_unique_count;\n\
    \                break;\n            } else {\n                counters = c;\n\
    \                max_unique_count = current_counter;\n            }\n        }\n\
    \n        if max_unique_count == max_unique {\n            max_unique = max_unique_count;\n\
    \        }\n    }\n\n    max_unique.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpstcjau_a.rs:22:28\n   |\n\
    9  |     let mut counters = words[0].to_owned().chars().count();\n   |       \
    \                 ----------------------------------- expected due to this value\n\
    ...\n22 |                 counters = c;\n   |                            ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    use std::collections::HashMap;\n\
    \    use std::collections::HashSet;\n\n    let mut char_count = HashMap::new();\n\
    \    let mut total_count = HashMap::new();\n    for word in words {\n        for\
    \ c in word.chars() {\n            char_count.entry(c).or_insert(0) += 1;\n  \
    \          total_count.entry(c).or_insert(0) += 1;\n        }\n    }\n    \n \
    \   if char_count.len() == total_count.len() {\n        char_count\n         \
    \   .iter()\n            .filter_map(|&(_, count)| count > total_count.get(&_).unwrap())\n\
    \            .max()\n            .unwrap()\n    } else {\n        \"\"\n    }\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::collections::HashSet`\n  --> /tmp/tmp9d05u1ue.rs:10:9\n\
    \   |\n10 |     use std::collections::HashSet;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror: in expressions,\
    \ `_` can only be used on the left-hand side of an assignment\n  --> /tmp/tmp9d05u1ue.rs:24:64\n\
    \   |\n24 |             .filter_map(|&(_, count)| count > total_count.get(&_).unwrap())\n\
    \   |                                                                ^ `_` not\
    \ allowed here\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmp9d05u1ue.rs:16:13\n   |\n16 |      \
    \       char_count.entry(c).or_insert(0) += 1;\n   |             --------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `char_count.entry(c).or_insert(0)`\n\
    \   |\n16 |             *char_count.entry(c).or_insert(0) += 1;\n   |        \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9d05u1ue.rs:16:46\n\
    \   |\n16 |             char_count.entry(c).or_insert(0) += 1;\n   |         \
    \    -------------------------------- ^^\n   |             |\n   |           \
    \  cannot assign to this expression\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp9d05u1ue.rs:17:13\n\
    \   |\n17 |             total_count.entry(c).or_insert(0) += 1;\n   |        \
    \     ---------------------------------^^^^^\n   |             |\n   |       \
    \      cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `total_count.entry(c).or_insert(0)`\n  \
    \ |\n17 |             *total_count.entry(c).or_insert(0) += 1;\n   |         \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9d05u1ue.rs:17:47\n\
    \   |\n17 |             total_count.entry(c).or_insert(0) += 1;\n   |        \
    \     --------------------------------- ^^\n   |             |\n   |         \
    \    cannot assign to this expression\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            if counts.contains_key(&c)\
    \ {\n                counts.insert(c, counts.get(&c) + 1);\n            } else\
    \ {\n                counts.insert(c, 1);\n            }\n        }\n    }\n \
    \   if counts.values().iter().count() == 0 {\n        return String::new();\n\
    \    }\n    let mut max_value = counts.iter().max().unwrap();\n    for count in\
    \ counts.iter() {\n        if *count > max_value {\n            max_value = *count;\n\
    \        }\n    }\n    for word in words {\n        if word.chars().find(|c| counts.get(&c)\
    \ == max_value).is_some() {\n            return word;\n        }\n    }\n    \"\
    \"\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpieo1s72z.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpieo1s72z.rs:33:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n33 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = HashMap::new();\n\
    \    for w in words {\n        counter.insert(w.chars().count(), w);\n    }\n\
    \    let mut best_word = counter.keys().unwrap().to_string();\n    let mut best_count\
    \ = 1;\n    for w in counter.iter() {\n        let mut count = w.1;\n        if\
    \ count > best_count {\n            best_word = w.0;\n            best_count =\
    \ count;\n        }\n    }\n    best_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp667yi9lv.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut set = HashSet::new();\n\
    \    let mut max = 0;\n    let mut result = String::with_capacity(words.len());\n\
    \    for w in words {\n        let mut len = w.chars().filter(|c| c.is_alphanumeric()).count();\n\
    \        if len > max {\n            max = len;\n            result = w.to_string();\n\
    \        }\n        set.insert(w.to_owned());\n    }\n    if set.len() > max {\n\
    \        \"\".to_string()\n    } else {\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmprf59adaa.rs:9:19\n  |\n9 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut result = words.iter().cloned().collect::<Vec<String>>().clone();\n\
    \    let mut counts: Vec<usize> = result.iter().cloned().map(|x| x.chars().count()).collect();\n\
    \    counts.sort_unstable_by_key(|&x| *x).take(1).next().unwrap();\n    let mut\
    \ max: usize = 0;\n    for i in counts.iter().filter(|&x| *x >= max).rev() {\n\
    \        max = *i;\n        result = &result.remove(i);\n    }\n    result.iter().cloned().filter(|x|\
    \ *x == max).next().unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpzbelodf7.rs:11:38\n\
    \   |\n11 |     counts.sort_unstable_by_key(|&x| *x).take(1).next().unwrap();\n\
    \   |                                      ^^\n\nerror[E0599]: `()` is not an\
    \ iterator\n  --> /tmp/tmpzbelodf7.rs:11:42\n   |\n11 |     counts.sort_unstable_by_key(|&x|\
    \ *x).take(1).next().unwrap();\n   |                                         \
    \ ^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `(): Iterator`\n           which is required by `&mut\
    \ (): Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbelodf7.rs:15:33\n\
    \   |\n15 |         result = &result.remove(i);\n   |                        \
    \         ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |         result = &result.remove(*i);\n   |          \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbelodf7.rs:15:18\n\
    \   |\n9  |     let mut result = words.iter().cloned().collect::<Vec<String>>().clone();\n\
    \   |                      ------------------------------------------------------\
    \ expected due to this value\n...\n15 |         result = &result.remove(i);\n\
    \   |                  ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found reference `&String`\n\
    \nerror[E0277]: can't compare `String` with `usize`\n  --> /tmp/tmpzbelodf7.rs:17:42\n\
    \   |\n17 |     result.iter().cloned().filter(|x| *x == max).next().unwrap()\n\
    \   |                                          ^^ no implementation for `String\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .cloned()\n        .map(|word| word.chars().count())\n        .max()\n  \
    \      .unwrap_or(0)\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3k697vx.rs:9:5\n   |\n8\
    \  |   fn find_max(words: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n9  | /    \
    \ words\n10 | |         .iter()\n11 | |         .cloned()\n12 | |         .map(|word|\
    \ word.chars().count())\n13 | |         .max()\n14 | |         .unwrap_or(0)\n\
    \   | |                     ^- help: try using a conversion method: `.to_string()`\n\
    \   | |_____________________|\n   |                       expected struct `String`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // sort the words alphabetically\n\
    \    words.sort_by(|a, b| a.cmp(b));\n\n    // sort each word alphabetically\n\
    \    for word in words {\n        word.sort_by(|a, b| a.cmp(b));\n    }\n\n  \
    \  // now that we have the words in the order we want, find the maximum\n    //\
    \ character count and return the word with the maximum count\n    let max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for i in\
    \ 1..words.len() {\n        if max_count < words[i].chars().count() {\n      \
    \      max_count = words[i].chars().count();\n            max_word = words[i];\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp66_tfsl6.rs:14:14\n   |\n14 |         word.sort_by(|a,\
    \ b| a.cmp(b));\n   |              ^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return \"\";\n    }\n\n    let mut set = String::new();\n    let mut counter\
    \ = String::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            if !c.is_alphanumeric() {\n                continue;\n          \
    \  }\n            if set.contains(&c) {\n                counter.push(c);\n  \
    \          }\n            set.push(c);\n        }\n    }\n    if counter.len()\
    \ > set.len() {\n        counter.clone()\n    } else {\n        set.clone()\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_t_kg3s.rs:10:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     if words.is_empty()\
    \ {\n10 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmp8_t_kg3s.rs:20:29\n     |\n20   |            \
    \ if set.contains(&c) {\n     |                    -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                    |\n     |                 \
    \   required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n20   |             if set.contains(*&c) {\n    \
    \ |                             +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_len = 0;\n    let\
    \ mut max_len_name = String::new();\n    let mut max_len_name_len = String::new();\n\
    \    for word in words {\n        let mut max_unique_char = String::new();\n \
    \       let mut max_unique_name = String::new();\n        for c in word.chars().cloned().collect::<Vec<char>>()\
    \ {\n            if c.is_ascii_alphanumeric() {\n                if c.len() >\
    \ max_unique_char.len() {\n                    max_unique_char.clear();\n    \
    \            }\n                if c.len() > max_len.len() {\n               \
    \     max_len = c.len();\n                }\n                max_unique_char.push_str(&c.to_string());\n\
    \            } else {\n                if c.len() > max_len_name.len() {\n   \
    \                 max_len_name.clear();\n                }\n                if\
    \ c.len() > max_len_name_len.len() {\n                    max_len_name_len = c.len();\n\
    \                }\n                max_len_name.push_str(&c.to_string());\n \
    \           }\n        }\n        if max_unique_char.len() > max_len.len() {\n\
    \            max_len = max_unique_char.len();\n        }\n        if max_len_name.len()\
    \ > max_len_name_len.len() {\n            max_len_name = max_len_name_len;\n \
    \       }\n    }\n    if max_len.len() < max_len_name.len() {\n        return\
    \ max_len_name.to_string();\n    }\n    return max_unique_char.to_string();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_unique_char` in this scope\n  -->\
    \ /tmp/tmpk_f7xjpg.rs:44:12\n   |\n44 |     return max_unique_char.to_string();\n\
    \   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type\
    \ mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpk_f7xjpg.rs:15:31\n\
    \     |\n15   |         for c in word.chars().cloned().collect::<Vec<char>>()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpk_f7xjpg.rs:15:40\n   |\n15 |           for c in word.chars().cloned().collect::<Vec<char>>()\
    \ {\n   |                                          ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0689]: can't call method `len` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmpk_f7xjpg.rs:20:38\n   |\n20 |                 if\
    \ c.len() > max_len.len() {\n   |                                      ^^^\n \
    \  |\nhelp: you must specify a type for this binding, like `i32`\n   |\n9  | \
    \    let mut max_len: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpk_f7xjpg.rs:34:44\n\
    \   |\n34 |         if max_unique_char.len() > max_len.len() {\n   |         \
    \                                   ^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n9  |     let mut max_len: i32 = 0;\n   |   \
    \      ~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `len` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmpk_f7xjpg.rs:41:16\n   |\n41 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Sort first by length to avoid\
    \ sorting strings of same length in\n    // lexicographical order.\n    words.sort_by(|w1,\
    \ w2| w1.len().cmp(w2.len()));\n\n    // Initialize an array to store the count\
    \ of each unique character\n    // of every word found.\n    let mut word_counts\
    \ = Vec::with_capacity(words.len());\n\n    // For each word in the words vector.\n\
    \    for w in words {\n        // Split the word into characters, count their\
    \ number of unique\n        // characters and store the count of each unique character\
    \ into the\n        // word_counts vector.\n        let char_counts = w.chars().map(|c|\
    \ c.chars().count());\n        word_counts.extend_from_slice(char_counts);\n \
    \   }\n\n    // Find the maximum count of each unique character and return the\
    \ one\n    // that comes first in the lexicographical order.\n    let max_count\
    \ =\n        word_counts.iter().max().cloned().expect(\"Words with maximum count\
    \ are empty\");\n    let mut max_char: Char;\n    for i in 0..word_counts.len()\
    \ {\n        if word_counts[i].0 == max_count {\n            max_char = i;\n \
    \       }\n    }\n\n    // Return the string with the maximum number of unique\
    \ characters\n    // or the empty string if all words have same number of unique\
    \ characters.\n    return words[max_char].to_string();\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpwn_l1wu7.rs:30:23\n\
    \   |\n30 |     let mut max_char: Char;\n   |                       ^^^^ help:\
    \ a builtin type with a similar name exists (notice the capitalization): `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwn_l1wu7.rs:11:41\n   |\n11 |\
    \     words.sort_by(|w1, w2| w1.len().cmp(w2.len()));\n   |                  \
    \                       ^^^^^^^^\n   |                                       \
    \  |\n   |                                         expected `&usize`, found `usize`\n\
    \   |                                         help: consider borrowing here: `&w2.len()`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpwn_l1wu7.rs:22:47\n   |\n22 |         let char_counts = w.chars().map(|c|\
    \ c.chars().count());\n   |                                               ^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwn_l1wu7.rs:23:39\n\
    \   |\n23 |         word_counts.extend_from_slice(char_counts);\n   |        \
    \                               ^^^^^^^^^^^ expected `&[_]`, found struct `Map`\n\
    \   |\n   = note: expected reference `&[_]`\n                 found struct `Map<Chars<'_>,\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0412, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Sort the words in lexicographical\
    \ order and count the unique characters\n    words\n        .iter()\n        .cloned()\n\
    \        .sort();\n    let mut counts = HashMap::new();\n    counts.insert(String::new(),\
    \ 0);\n\n    for word in words {\n        if let Some(count) = counts.get(&word)\
    \ {\n            counts.insert(word, count + 1);\n        } else {\n         \
    \   counts.insert(word, 1);\n        }\n    }\n\n    // Find the word with max\
    \ number of unique characters\n    let mut word = String::new();\n    if let Some(count)\
    \ = counts.get(&\"\") {\n        word = &words[counts.iter().max_by_key(|&(_,\
    \ count)| *count).unwrap()];\n    }\n    word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7c12jv7e.rs:14:22\n   |\n14 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `sort` found for struct `Cloned` in the current scope\n  -->\
    \ /tmp/tmp7c12jv7e.rs:13:10\n   |\n13 |         .sort();\n   |          ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = \"\";\n    let\
    \ mut max_len = words.iter().map(|s| s.chars().count()).max().unwrap();\n    for\
    \ (i, word) in words.iter().enumerate() {\n        if max_len == word.length()\
    \ && max_len > (i + 1).unwrap() {\n            res = word;\n            max_len\
    \ = word.length();\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp6fdc0fel.rs:12:28\n   |\n12 |         if max_len\
    \ == word.length() && max_len > (i + 1).unwrap() {\n   |                     \
    \       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp6fdc0fel.rs:12:58\n   |\n12 |         if max_len == word.length()\
    \ && max_len > (i + 1).unwrap() {\n   |                                      \
    \                    ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `length` found for reference `&String` in the current scope\n  --> /tmp/tmp6fdc0fel.rs:14:28\n\
    \   |\n14 |             max_len = word.length();\n   |                       \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6fdc0fel.rs:17:5\n   |\n8  | fn\
    \ find_max(words: Vec<String>) -> String {\n   |                             \
    \       ------ expected `String` because of return type\n...\n17 |     res\n \
    \  |     ^^^- help: try using a conversion method: `.to_string()`\n   |     |\n\
    \   |     expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().cloned().max_by(|a,\
    \ b| a.chars().count() as u32 - b.chars().count() as u32)\n        .unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2spahh8c.rs:9:41\n  |\n9 |\
    \     words.iter().cloned().max_by(|a, b| a.chars().count() as u32 - b.chars().count()\
    \ as u32)\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `u32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2spahh8c.rs:10:20\n   |\n10 |         .unwrap_or(\"\")\n\
    \   |                    ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|x| x.chars().count()).max()\n\
    \        .unwrap_or(0)\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmpipph11q3.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_index = words.iter().enumerate().max_by_key(|(_,\
    \ elem)| *elem);\n    if let Some((i, ele)) = max_index {\n        if !words[i].is_empty()\
    \ {\n            return words[i];\n        }\n        max_index = i;\n    }\n\
    \    \"\"\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpelkhk2hf.rs:14:21\n   |\n\
    9  |     let mut max_index = words.iter().enumerate().max_by_key(|(_, elem)| *elem);\n\
    \   |                         ------------------------------------------------------\
    \ expected due to this value\n...\n14 |         max_index = i;\n   |         \
    \            ^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<(usize, &String)>`\n              found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpelkhk2hf.rs:16:5\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n16 |     \"\"\n   |     ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |     |\n   |     expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_map: HashMap<String,\
    \ usize> = HashMap::new();\n    for w in words {\n        let mut chars_count\
    \ = chars_map.entry(w.clone()).or_default();\n        chars_count.value += 1;\n\
    \        if chars_count.value > chars_count.key {\n            chars_map.replace(w.clone(),\
    \ 1);\n        }\n    }\n    chars_map.iter().max_by_key(|&(k, _)| k).unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmp3irlf4yr.rs:9:24\n\
    \  |\n9 |     let mut chars_map: HashMap<String, usize> = HashMap::new();\n  |\
    \                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n --> /tmp/tmp3irlf4yr.rs:9:49\n\
    \  |\n9 |     let mut chars_map: HashMap<String, usize> = HashMap::new();\n  |\
    \                                                 ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut count = 1;\n    for w in words {\n        if w.chars().filter(|&x|\
    \ x != ' ').count() > word.chars().filter(|&x| x != ' ').count() {\n         \
    \   word = w;\n            count = w.chars().filter(|&x| x != ' ').count();\n\
    \        }\n    }\n    return word;\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: variable `count` is assigned to, but never used\n  --> /tmp/tmpuy6zgdpq.rs:10:13\n\
    \   |\n10 |     let mut count = 1;\n   |             ^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_count` instead\n\nwarning: value\
    \ assigned to `count` is never read\n  --> /tmp/tmpuy6zgdpq.rs:14:13\n   |\n14\
    \ |             count = w.chars().filter(|&x| x != ' ').count();\n   |       \
    \      ^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n \
    \  = help: maybe it is overwritten before being read?\n\nerror[E0382]: borrow\
    \ of moved value: `w`\n  --> /tmp/tmpuy6zgdpq.rs:14:21\n   |\n11 |     for w in\
    \ words {\n   |         - move occurs because `w` has type `String`, which does\
    \ not implement the `Copy` trait\n12 |         if w.chars().filter(|&x| x != '\
    \ ').count() > word.chars().filter(|&x| x != ' ').count() {\n13 |            \
    \ word = w;\n   |                    - value moved here\n14 |             count\
    \ = w.chars().filter(|&x| x != ' ').count();\n   |                     ^^^^^^^^^\
    \ value borrowed here after move\n   |\n   = note: borrow occurs due to deref\
    \ coercion to `str`\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut n = String::new();\n\
    \    let mut count: u32 = 0;\n    for w in words {\n        for c in w {\n   \
    \         if !n.contains(&c) {\n                n += c;\n                count\
    \ += 1;\n            }\n        }\n    }\n    let mut w: String = n.to_string();\n\
    \    if count > w.len() {\n        w = n.to_string();\n    }\n    w\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp11czplsq.rs:12:18\n\
    \   |\n12 |         for c in w {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp11czplsq.rs:20:16\n   |\n20 |     if count > w.len() {\n   |  \
    \              ^^^^^^^ expected `u32`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to a `u32` and panic if the converted value doesn't fit\n   |\n20\
    \ |     if count > w.len().try_into().unwrap() {\n   |                       ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .cloned()\n        .fold(\"\".to_string(), |mut acc, word| {\n          \
    \  let mut unique_chars = acc.chars().cloned().collect::<Vec<_>>();\n        \
    \    let mut has_seen = false;\n\n            word.chars().for_each(|c| {\n  \
    \              if !has_seen {\n                    unique_chars.insert(c);\n \
    \                   has_seen = true;\n                } else {\n             \
    \       unique_chars.remove(c); // Remove already seen character\n           \
    \     }\n            });\n\n            acc.push_str(&word[..unique_chars.len()])\n\
    \        })\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp889aqf23.rs:13:48\n     |\n13   |             let mut unique_chars\
    \ = acc.chars().cloned().collect::<Vec<_>>();\n     |                        \
    \                        ^^^^^^ expected reference, found `char`\n     |\n   \
    \  = note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmp889aqf23.rs:13:57\n   |\n13 |               let mut unique_chars = acc.chars().cloned().collect::<Vec<_>>();\n\
    \   |                                                           ^^^^^^^ method\
    \ cannot be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp889aqf23.rs:25:13\n   |\n25 |             acc.push_str(&word[..unique_chars.len()])\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmp889aqf23.rs:25:17\n   |\n25 |             acc.push_str(&word[..unique_chars.len()])\n\
    \   |             --- ^^^^^^^^ this call modifies `acc` in-place\n   |       \
    \      |\n   |             you probably want to use this value after calling the\
    \ method...\n   = note: ...instead of the `()` output of method `push_str`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut num_unique = 0;\n   \
    \ let mut max_unique = 0;\n    for word in words {\n        if word.chars().filter(|c|\
    \ c.is_ascii()).count() > num_unique {\n            num_unique = word.chars().filter(|c|\
    \ c.is_ascii()).count();\n            max_unique = word;\n        }\n    }\n \
    \   if num_unique == 0 {\n        return String::from(\"\");\n    }\n    max_unique\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps72kzqsd.rs:14:26\n   |\n\
    10 |     let mut max_unique = 0;\n   |                          - expected due\
    \ to this value\n...\n14 |             max_unique = word;\n   |              \
    \            ^^^^ expected integer, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps72kzqsd.rs:20:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n20 |     max_unique\n   |     ^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = Vec::new();\n\
    \    let mut words = Vec::new();\n    for word in words {\n        if let Ok(count)\
    \ = word.chars().filter(|&c| !c.is_whitespace()).count();\n            count >\
    \ counts.len() {\n            counts.push(count);\n            words.push(word);\n\
    \        }\n    }\n    match counts.iter().max().unwrap() {\n        Some(count)\
    \ => {\n            for word in words {\n                if word.chars().filter(|&c|\
    \ !c.is_whitespace()).count() == count {\n                    return word;\n \
    \               }\n            }\n        }\n        _ => \"\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmpdxbw0js3.rs:12:80\n   |\n\
    12 |         if let Ok(count) = word.chars().filter(|&c| !c.is_whitespace()).count();\n\
    \   |         -- this `if` expression has a condition, but no block          \
    \        ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdxbw0js3.rs:20:13\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n...\n\
    20 | /             for word in words {\n21 | |                 if word.chars().filter(|&c|\
    \ !c.is_whitespace()).count() == count {\n22 | |                     return word;\n\
    23 | |                 }\n24 | |             }\n   | |_____________^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = String::new();\n\
    \    let mut max_counter = String::new();\n    let mut first_word = String::new();\n\
    \    for word in words {\n        counter += word.chars().filter(|c| c.is_ascii()).count()\
    \ + 1;\n        if counter.len() > max_counter.len() {\n            max_counter\
    \ = counter;\n            first_word = word;\n        }\n    }\n    return first_word;\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxiqso05y.rs:13:20\n   |\n\
    13 |         counter += word.chars().filter(|c| c.is_ascii()).count() + 1;\n \
    \  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = HashMap::new();\n\
    \    let mut word = String::new();\n\n    for word in words {\n        for c in\
    \ word.chars() {\n            let count = count.entry(c).or_insert(0);\n     \
    \       *count = *count + 1;\n        }\n    }\n\n    for entry in count.iter()\
    \ {\n        if *entry.value > 1 {\n            return entry.key;\n        }\n\
    \    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpb5vbb5r8.rs:9:21\n  |\n9 |     let mut count = HashMap::new();\n  |\
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = Vec::<i64>::with_capacity(words.len());\n\
    \    for word in words {\n        let len = word.chars().count();\n        counters.push(len);\n\
    \    }\n    let mut max_counter = counters.iter().max();\n    for word in words\
    \ {\n        let len = word.chars().count();\n        if len == max_counter {\n\
    \            return word;\n        }\n        max_counter = len;\n    }\n    return\
    \ \"\";\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzr_xz67x.rs:12:23\n   |\n\
    12 |         counters.push(len);\n   |                       ^^^ expected `i64`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `i64` and panic if\
    \ the converted value doesn't fit\n   |\n12 |         counters.push(len.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzr_xz67x.rs:17:19\n   |\n17 |         if len == max_counter\
    \ {\n   |                   ^^^^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&i64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzr_xz67x.rs:20:23\n   |\n14 |\
    \     let mut max_counter = counters.iter().max();\n   |                     \
    \      --------------------- expected due to this value\n...\n20 |         max_counter\
    \ = len;\n   |                       ^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<&i64>`\n              found type `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzr_xz67x.rs:22:12\n   |\n8  |\
    \ fn find_max(words: Vec<String>) -> String {\n   |                          \
    \          ------ expected `String` because of return type\n...\n22 |     return\
    \ \"\";\n   |            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_chars = Vec::new();\n\
    \    let mut highest_count = words[0].len();\n    let mut best_word = words[0][..];\n\
    \    for w in words {\n        let mut chars = w.chars().cloned();\n        for\
    \ c in chars {\n            unique_chars.push(c); unique_chars.sort();\n     \
    \   }\n        if unique_chars.len() > highest_count {\n            highest_count\
    \ = unique_chars.len();\n            best_word = w;\n        }\n    }\n    best_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpak37tk50.rs:11:9\n   |\n11 |     let mut best_word = words[0][..];\n\
    \   |         ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n11 |     let mut\
    \ best_word = &words[0][..];\n   |                         +\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpak37tk50.rs:13:35\n\
    \     |\n13   |         let mut chars = w.chars().cloned();\n     |          \
    \                         ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpak37tk50.rs:14:18\n   |\n\
    14 |         for c in chars {\n   |                  ^^^^^ expected `char`, found\
    \ reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpak37tk50.rs:14:18\n\
    \   |\n14 |         for c in chars {\n   |                  ^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpak37tk50.rs:19:25\n\
    \   |\n11 |     let mut best_word = words[0][..];\n   |                      \
    \   ------------ expected due to this value\n...\n19 |             best_word =\
    \ w;\n   |                         ^ expected `str`, found struct `String`\n\n\
    error[E0277"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_string: String =\
    \ words[0].clone();\n    let mut counter = 0;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        if word.len() < max_string.len() {\n            max_string = word.clone();\n\
    \            counter = 1;\n        }\n        if word.len() > max_string.len()\
    \ {\n            max_string = word.clone();\n        }\n        if i == words.len()\
    \ - 1 {\n            break;\n        }\n    }\n\n    if counter == 1 {\n     \
    \   return max_string;\n    }\n\n    let mut max_string_iter = max_string.chars().filter(|x|\
    \ x != 0);\n    if max_string.len() > max_string_iter.len() {\n        max_string_iter\
    \ = max_string_iter.take(max_string.len() - 1);\n    }\n\n    let mut iter = max_string_iter.filter(|&x|\
    \ !words.contains(&x));\n    if iter.len() > 0 {\n        iter = iter.take(1);\n\
    \    }\n    iter.fold(\"\", |mut acc, &mut x| {\n        if acc.chars().count(x)\
    \ > acc.chars().count(&x) {\n            acc = x;\n        }\n        acc\n  \
    \  });\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `{integer}`\n  --> /tmp/tmpzfnqkgr7.rs:28:63\n\
    \   |\n28 |     let mut max_string_iter = max_string.chars().filter(|x| x != 0);\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzfnqkgr7.rs:28:66\n\
    \   |\n28 |     let mut max_string_iter = max_string.chars().filter(|x| x != 0);\n\
    \   |                                                                  ^ expected\
    \ `char`, found integer\n\nerror[E0599]: no method named `len` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmpzfnqkgr7.rs:29:43\n   |\n29 | \
    \    if max_string.len() > max_string_iter.len() {\n   |                     \
    \                      ^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmpzfnqkgr7.rs:28:57:\
    \ 28:67]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzfnqkgr7.rs:30:27\n\
    \   |\n28 |     let mut max_string_iter = max_string.chars().filter(|x| x != 0);\n\
    \   |                               -------------------------------------\n  \
    \ |                               |                         |\n   |          \
    \                     |                         the expected closure\n   |   \
    \                            |                         the found closure\n   |\
    \                               expected due to this value\n29 |     if max_string.len()\
    \ > max_string_iter.len() {\n30 |         max_string_iter = max_string_iter.take(max_string.len()\
    \ - 1);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Filter`, found struct `std::iter::Take`\n   |\n   = note: expected\
    \ struct `Filter<Chars<'_>, _>`\n              found struct `std::iter::Take<Filter<Chars<'_>,\
    \ _>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzfnqkgr7.rs:33:64\n  \
    \ |\n33 |     let mut iter = max_string_iter.filter(|&x| !words.contains(&x));\n\
    \   |                                           "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Convert the list of strings\
    \ to a map of unique characters and a count\n    let chars_counts = words.iter().map(|word|\
    \ word.chars().count()).collect();\n    let chars_counts = HashMap::from_iter(chars_counts.iter().cloned());\n\
    \n    // Find the maximum count of unique characters\n    let mut max_chars =\
    \ chars_counts.iter().max().unwrap();\n    let mut index = chars_counts.iter().find(|&(_,\
    \ count)| count == max_chars).unwrap();\n\n    // Iterate through the list of\
    \ words and find the one with the maximum number of unique characters\n    for\
    \ word in words {\n        match index {\n            Some(index) => {\n     \
    \           if chars_counts[index] == chars_counts[word] {\n                 \
    \   max_chars = chars_counts[index];\n                    index = chars_counts.iter().find(|&(_,\
    \ count)| count == max_chars).unwrap();\n                }\n            }\n  \
    \          None => index = chars_counts.iter().find(|&(_, count)| count == max_chars).unwrap(),\n\
    \        }\n    }\n\n    match index {\n        Some(index) => words[index],\n\
    \        None => \"\",\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprf3njvj4.rs:11:24\n   |\n11 |     let chars_counts = HashMap::from_iter(chars_counts.iter().cloned());\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmprf3njvj4.rs:32:17\n   |\n\
    30 | /     match index {\n31 | |         Some(index) => words[index],\n   | |\
    \                        ------------ this is found to be of type `String`\n32\
    \ | |         None => \"\",\n   | |                 ^^- help: try using a conversion\
    \ method: `.to_string()`\n   | |                 |\n   | |                 expected\
    \ struct `String`, found `&str`\n33 | |     }\n   | |_____- `match` arms have\
    \ incompatible types\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut num_unique = usize::MAX;\n    let mut max_unique = 0;\n\n    for\
    \ w in words {\n        if w.chars().filter(|c| !c.is_ascii()).count() > num_unique\
    \ {\n            word = w;\n            num_unique = w.chars().filter(|c| !c.is_ascii()).count();\n\
    \            max_unique = num_unique;\n        }\n    }\n\n    if num_unique ==\
    \ 0 {\n        return \"\";\n    }\n\n    if num_unique == max_unique {\n    \
    \    return word;\n    }\n\n    let mut max_idx = 0;\n    let mut max_cnt = 0;\n\
    \    let mut max_word = String::new();\n\n    for idx in 0..num_unique {\n   \
    \     if words[max_idx] != word {\n            break;\n        }\n\n        if\
    \ words[idx].chars().filter(|c| !c.is_ascii()).count() > max_cnt {\n         \
    \   max_word = word;\n            max_idx = idx;\n            max_cnt = words[idx].chars().filter(|c|\
    \ !c.is_ascii()).count();\n        }\n    }\n\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpky5gif9b.rs:22:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n22 |     \
    \    return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words: Vec<String> =\
    \ words.to_owned();\n    let mut unique_count: usize = 0;\n    let mut max_unique_count\
    \ = std::u32::MAX;\n\n    loop {\n        let mut unique_chars = vec![0; words.len()];\n\
    \        let mut chars = vec![\"\"; words.len()];\n\n        for word in &words\
    \ {\n            for character in word.chars() {\n                if let Some(&count)\
    \ = unique_chars.iter_mut().find(|&v| v == character) {\n                    *count\
    \ += 1;\n                } else {\n                    unique_chars[unique_chars.len()]\
    \ = character;\n                }\n            }\n        }\n        for (i, v)\
    \ in unique_chars.iter().enumerate() {\n            if v > max_unique_count {\n\
    \                max_unique_count = v;\n                chars[i] = words[i];\n\
    \            }\n        }\n        if chars.len() == unique_chars.len() {\n  \
    \          break;\n        }\n        words.push(chars.to_owned());\n        unique_count\
    \ += unique_chars.len();\n    }\n    chars.to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `chars` in this scope\n  --> /tmp/tmpz7y4lso5.rs:38:5\n\
    \   |\n38 |     chars.to_owned()\n   |     ^^^^^ not found in this scope\n\nerror[E0277]:\
    \ can't compare `&mut {integer}` with `char`\n  --> /tmp/tmpz7y4lso5.rs:19:75\n\
    \   |\n19 |                 if let Some(&count) = unique_chars.iter_mut().find(|&v|\
    \ v == character) {\n   |                                                    \
    \                       ^^ no implementation for `&mut {integer} == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&mut {integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz7y4lso5.rs:19:29\n\
    \   |\n19 |                 if let Some(&count) = unique_chars.iter_mut().find(|&v|\
    \ v == character) {\n   |                             ^^^^^^    -------------------------------------------------\
    \ this expression has type `Option<&mut {integer}>`\n   |                    \
    \         |\n   |                             types differ in mutability\n   |\
    \                             help: you can probably remove the explicit borrow:\
    \ `count`\n   |\n   = note: expected mutable reference `&mut {integer}`\n    \
    \                  found reference `&_`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpz7y4lso5.rs:22:56\n   |\n22 |                     unique_chars[unique_chars.len()]\
    \ = character;\n   |                     --------------------------------   ^^^^^^^^^\
    \ expected integer, found `char`\n   |                     |\n   |           \
    \          expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz7y4lso5.rs:27:20\n   |\n27 |             if v > max_unique_count\
    \ {\n   |                    ^^^^^^^^^^^^^^^^\n   |                    |\n   |\
    \                    expected reference, found `u32`\n   |                   \
    \ help: consider borrowing here: `&max_unique_count`\n   |\n   = note: "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut sorted_keys = Vec::new();\n\
    \    for word in words {\n        sorted_keys.push(word.chars().count());\n  \
    \  }\n    let mut max_keys = sorted_keys[sorted_keys.len() - 1];\n    let mut\
    \ max_word = String::new();\n    for &k in sorted_keys {\n        if k >= max_keys\
    \ {\n            break;\n        }\n        max_keys = k;\n        max_word =\
    \ words[sorted_keys.len() - 1 - k];\n    }\n    max_word\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp589qjbyz.rs:15:9\n   |\n\
    15 |     for &k in sorted_keys {\n   |         ^^    ----------- this expression\
    \ has type `Option<usize>`\n   |         |\n   |         expected `usize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `k`\n\
    \   |\n   = note:   expected type `usize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_counts = vec![String::new();\
    \ words[0].len()];\n    for word in &words {\n        for char in word.chars()\
    \ {\n            chars_counts[char.len()].push(char);\n        }\n    }\n    let\
    \ chars_count = chars_counts.iter().filter(|i| i.len() > 1).count();\n    if chars_count\
    \ > words[0].len() {\n        // Found a word with maximum number of unique characters.\n\
    \        words[0]\n    } else if chars_count == words[0].len() {\n        // Found\
    \ a word with maximum number of unique characters.\n        String::from(\"\"\
    )\n    } else {\n        // Did not find any word with maximum number of unique\
    \ characters.\n        let mut chars_counts = vec![String::new(); words[0].len()];\n\
    \        let mut words = words.iter().cloned().collect::<Vec<_>>();\n        words[0]\
    \ = words[0].to_owned();\n        for word in words {\n            for char in\
    \ word.chars() {\n                chars_counts[char.len()].push(char);\n     \
    \       }\n        }\n        let chars_count = chars_counts.iter().filter(|i|\
    \ i.len() > 1).count();\n        if chars_count > words[0].len() {\n         \
    \   words[0]\n        } else if chars_count == words[0].len() {\n            String::from(\"\
    \")\n        } else {\n            let mut chars_counts = vec![String::new();\
    \ words[0].len()];\n            let mut words = words.iter().cloned().collect::<Vec<_>>();\n\
    \            words[0] = words[0].to_owned();\n            for word in words {\n\
    \                for char in word.chars() {\n                    chars_counts[char.len()].push(char);\n\
    \                }\n            }\n            let chars_count = chars_counts.iter().filter(|i|\
    \ i.len() > 1).count();\n            if chars_count > words[0].len() {\n     \
    \           String::from(\"\")\n            } else if chars_count == words[0].len()\
    \ {\n                words[0]\n            } else {\n                let mut chars_counts\
    \ = vec![String::new(); words[0].len()];\n                let mut words = words.iter().cloned().collect::<Vec<_>>();\n\
    \                words[0] = words[0].to_owned();\n                for word in\
    \ words {\n                    for char in word.chars() {\n                  \
    \      chars_counts[char.len()].push(char);\n                    }\n         \
    \       }\n                let chars_count = chars_counts.iter().filter(|i| i.len()\
    \ > 1).count();\n                if chars_count > words[0].len() {\n         \
    \           String::from(\"\")\n                } else if chars_count == words[0].len()\
    \ {\n                    words[0]\n                } else {\n                \
    \    let mut chars_counts = vec![String::new(); words[0].len\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1tq8nn8m.rs:81:3\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                           - unclosed delimiter\n...\n22 |     } else {\n   |\
    \            - unclosed delimiter\n...\n37 |         } else {\n   |          \
    \      - unclosed delimiter\n...\n51 |             } else {\n   |            \
    \        - unclosed delimiter\n...\n65 |                 } else {\n   |      \
    \                  - this delimiter might not be properly closed...\n66 |    \
    \                 let mut chars_counts = vec![String::new(); words[0].len\n67\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n81\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1tq8nn8m.rs:66:48\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                           - closing delimiter possibly meant for this\n...\n\
    66 |                     let mut chars_counts = vec![String::new(); words[0].len\n\
    \   |                                                ^ unclosed delimiter\n67\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `.`, `;`,\
    \ `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp1tq8nn8m.rs:67:1\n   |\n\
    67 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp1tq8nn8m.rs:12:31\n\
    \   |\n12 |             chars_counts[char.len()].push(char);\n   |           \
    \                    ^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `len` found for type `char` in the current scope\n  --> /tmp/tmp1tq8nn8m.rs:29:35\n\
    \   |\n29 |                 chars_counts[char.len()].push(char);\n   |       \
    \                            ^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `len` found for type `char` in the current scope\n  --> /tmp/tmp1tq8nn8m.rs:43:39\n\
    \   |\n43 |                     chars_counts[char.len()].push(char);\n   |   \
    \                                    ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `l"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars: Vec<String> =\
    \ Vec::new();\n    let mut char_counts = Vec::new();\n    for word in words {\n\
    \        let mut unique_chars: Vec<char> = Vec::new();\n        for c in word.chars().collect::<Vec<char>>()\
    \ {\n            if !chars.contains(&c) {\n                unique_chars.push(c);\n\
    \            }\n        }\n        chars.extend(unique_chars);\n        char_counts.extend(unique_chars.iter().cloned().map(|c|\
    \ c.count()).collect());\n    }\n    char_counts.sort_unstable_by_key(|&(a, b)|\
    \ {\n        b.cmp(a)\n    });\n    if char_counts.len() == 0 {\n        return\
    \ \"\";\n    }\n    chars.sort_unstable_by_key(|&(a, b)| {\n        b.cmp(a)\n\
    \    });\n    chars[0]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6cg2o9dx.rs:14:32\n   |\n\
    14 |             if !chars.contains(&c) {\n   |                              \
    \  ^^ expected struct `String`, found `char`\n   |\n   = note: expected reference\
    \ `&String`\n              found reference `&char`\n\nerror[E0271]: type mismatch\
    \ resolving `<Vec<char> as IntoIterator>::Item == String`\n   --> /tmp/tmp6cg2o9dx.rs:18:15\n\
    \    |\n18  |         chars.extend(unique_chars);\n    |               ^^^^^^\
    \ expected struct `String`, found `char`\n    |\nnote: required by a bound in\
    \ `extend`\n\nerror[E0599]: `char` is not an iterator\n  --> /tmp/tmp6cg2o9dx.rs:19:67\n\
    \   |\n19 |         char_counts.extend(unique_chars.iter().cloned().map(|c| c.count()).collect());\n\
    \   |                                                                   ^^^^^\
    \ `char` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `char: Iterator`\n           which is required by\
    \ `&mut char: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6cg2o9dx.rs:25:16\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n25\
    \ |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6cg2o9dx.rs:27:34\n\
    \   |\n27 |     chars.sort_unstable_by_key(|&(a, b)| {\n   |                 \
    \                 ^^^^^-\n   |                                  |    |\n   | \
    \                                 |    expected due to this\n   |            \
    \                      expected struct `String`, found tuple\n   |\n   = note:\
    \ expected struct `String`\n               found tuple `(_, _)`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    let mut num_unique = usize::MAX;\n    let mut max_word_len = usize::MAX;\n\
    \    let mut i = 0;\n    while i < words.size() {\n        if words[i].chars().filter(|c|\
    \ !c.is_alphanumeric()).count() > num_unique {\n            i += 1;\n        }\
    \ else {\n            num_unique = words[i].chars().filter(|c| c.is_alphanumeric()).count();\n\
    \            max_word_len = words[i].len();\n        }\n    }\n    if num_unique\
    \ == usize::MAX {\n        return String::from(\"0\".to_string() + \"0\".to_string());\n\
    \    }\n    return words[i % words.len()].to_string();\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp_3xfzot6.rs:13:21\n   |\n13 |     while i <\
    \ words.size() {\n   |                     ^^^^ help: there is an associated function\
    \ with a similar name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3xfzot6.rs:22:47\n\
    \   |\n22 |         return String::from(\"0\".to_string() + \"0\".to_string());\n\
    \   |                                               ^^^^^^^^^^^^^^^\n   |    \
    \                                           |\n   |                          \
    \                     expected `&str`, found struct `String`\n   |           \
    \                                    help: consider borrowing here: `&\"0\".to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut freqs = words[0]\n  \
    \  .chars()\n    .filter(|c| !c.is_ascii_alphanumeric())\n    .fold(HashSet::new(),\
    \ |mut set, c| {\n        set.insert(c);\n        set\n    });\n\n    let mut\
    \ max = 0;\n    let mut max_word = words.first().unwrap();\n    for w in words.iter().skip(1)\
    \ {\n        let mut freqs2 = w.chars()\n        .filter(|c| !c.is_ascii_alphanumeric())\n\
    \        .fold(HashSet::new(), |mut set2, c| {\n            set2.insert(c);\n\
    \            set2\n        });\n\n        if freqs.keys().union(&freqs2).len()\
    \ > max {\n            max = freqs.keys().union(&freqs2).len();\n            max_word\
    \ = w;\n        }\n        freqs = freqs2;\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvhlbyj5v.rs:12:11\n   |\n12 |     .fold(HashSet::new(), |mut set, c|\
    \ {\n   |           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpvhlbyj5v.rs:22:15\n\
    \   |\n22 |         .fold(HashSet::new(), |mut set2, c| {\n   |              \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvhlbyj5v.rs:33:5\n   |\n8  | fn find_max(words: Vec<String>) ->\
    \ String {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n33 |     max_word\n   |     ^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut seen: HashSet<String>\
    \ = HashSet::new();\n    let mut max_unique = 0;\n    for word in words.iter()\
    \ {\n        let word_count = word.chars().filter(|c| !seen.contains(&c)).count();\n\
    \        if word_count > max_unique {\n            max_unique = word_count;\n\
    \        }\n        seen.insert(word);\n    }\n    if max_unique > 0 {\n     \
    \   max_unique\n    } else {\n        let mut max_index = -1;\n        for index\
    \ in 0..words[0].len() {\n            if seen.contains(&words[0][index]) {\n \
    \               max_index = index;\n            }\n        }\n        words[0][max_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpge3eeap3.rs:9:19\n\
    \  |\n9 |     let mut seen: HashSet<String> = HashSet::new();\n  |           \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpge3eeap3.rs:9:37\n  |\n9 |  \
    \   let mut seen: HashSet<String> = HashSet::new();\n  |                     \
    \                ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpge3eeap3.rs:19:9\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n19 |         max_unique\n   |         ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `usize`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpge3eeap3.rs:23:31\n   |\n23 |  \
    \           if seen.contains(&words[0][index]) {\n   |                       \
    \        ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmpge3eeap3.rs:21:29\n   |\n21 |         let mut max_index = -1;\n\
    \   |                             ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_counter: Vec<usize>\
    \ = vec![0; words.len()];\n    for w in words {\n        for c in w.chars().count()\
    \ {\n            chars_counter[c] += 1;\n        }\n    }\n    chars_counter.sort();\n\
    \    chars_counter.iter().cloned().last().unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmpmkddjg6p.rs:11:18\n\
    \   |\n11 |         for c in w.chars().count() {\n   |                  ^^^^^^^^^^^^^^^^^\
    \ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkddjg6p.rs:16:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n16\
    \ |     chars_counter.iter().cloned().last().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut min_idx = words.iter().min_by(|a,\
    \ b| a.len() as usize - b.len() as usize);\n\n    if min_idx.is_none() {\n   \
    \     return String::from(\"\");\n    }\n\n    let word = words.iter().nth(min_idx.unwrap());\n\
    \n    if word.len() < min_idx.unwrap().len() {\n        min_idx = words.iter().max_by(|a,\
    \ b| a.len() as usize - b.len() as usize);\n    }\n\n    if min_idx.unwrap().len()\
    \ == 0 {\n        return String::from(\"\");\n    }\n\n    word.to_owned()\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdvtzvcu5.rs:9:50\n  |\n9 |\
    \     let mut min_idx = words.iter().min_by(|a, b| a.len() as usize - b.len()\
    \ as usize);\n  |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdvtzvcu5.rs:15:33\n   |\n15 |     let word = words.iter().nth(min_idx.unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&String`\n\nerror[E0599]: no method named `len` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpdvtzvcu5.rs:17:13\n   |\n17 |     if word.len()\
    \ < min_idx.unwrap().len() {\n   |             ^^^ method not found in `Option<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdvtzvcu5.rs:18:46\n   |\n18 |\
    \         min_idx = words.iter().max_by(|a, b| a.len() as usize - b.len() as usize);\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdvtzvcu5.rs:25:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n25 |     word.to_owned()\n   |     ^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_chars = HashMap::new();\n\
    \    for word in words.iter() {\n        let mut chars = chars_in_string(&word);\n\
    \        unique_chars.insert(chars, 1);\n    }\n\n    unique_chars.iter().max_by_key(|_,\
    \ count| count).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp4g261lho.rs:9:28\n  |\n9 |     let mut unique_chars = HashMap::new();\n\
    \  |                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]:\
    \ cannot find function `chars_in_string` in this scope\n  --> /tmp/tmp4g261lho.rs:11:25\n\
    \   |\n11 |         let mut chars = chars_in_string(&word);\n   |            \
    \             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Create a hashmap to count\
    \ the unique character\n    // for each word in the list.\n    let mut char_counts\
    \ = HashMap::new();\n    for word in words.iter() {\n        for char in word.chars()\
    \ {\n            char_counts.entry(char).or_insert(0) += 1;\n        }\n    }\n\
    \n    // Scan the hashmap to find the word with maximum number of\n    // unique\
    \ characters.\n    let max_count = char_counts.iter().max().unwrap();\n    let\
    \ max_key = char_counts.iter().filter(|(_, count)| count == max_count).keys().next();\n\
    \    // The value is the key with max number of unique characters\n    // or the\
    \ empty string if the number of unique characters are same.\n    char_counts.get_mut(max_key).unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpd4b937hb.rs:11:27\n   |\n11 |     let mut char_counts = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpd4b937hb.rs:14:50\n   |\n\
    14 |             char_counts.entry(char).or_insert(0) += 1;\n   |            \
    \ ------------------------------------ ^^\n   |             |\n   |          \
    \   cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_max = String::new();\n\
    \    let mut chars_count = usize::MAX;\n    let mut word: String = String::new();\n\
    \n    for i in words.iter() {\n        chars_count = chars_count.checked_add(i.chars().count()).unwrap();\n\
    \        if chars_count > chars_max {\n            word = i;\n            chars_max\
    \ = chars_count.clone(); // TODO: avoid clone (https://doc.rust-lang.org/std/primitive.u32.html#method.clone)\n\
    \        }\n    }\n\n    if chars_max > chars_count {\n        word.clone()\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprd_l6bpa.rs:15:26\n   |\n\
    15 |         if chars_count > chars_max {\n   |                          ^^^^^^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprd_l6bpa.rs:16:20\n   |\n11 |     let mut word: String = String::new();\n\
    \   |                   ------ expected due to this type\n...\n16 |          \
    \   word = i;\n   |                    ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprd_l6bpa.rs:17:25\n\
    \   |\n9  |     let mut chars_max = String::new();\n   |                     \
    \    ------------- expected due to this value\n...\n17 |             chars_max\
    \ = chars_count.clone(); // TODO: avoid clone (https://doc.rust-lang.org/std/primitive.u32.html#method.clone)\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^\n   |                      \
    \   |\n   |                         expected struct `String`, found `usize`\n\
    \   |                         help: try using a conversion method: `chars_count.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprd_l6bpa.rs:21:20\n   |\n21 |\
    \     if chars_max > chars_count {\n   |                    ^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                    |\n \
    \  |                    expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut max_count = 1;\n    for w in words.iter() {\n        word = w.to_ascii_lowercase().chars().count()\
    \ as u32;\n        if word > max_count {\n            max_count = word;\n    \
    \    }\n    }\n    if max_count == 1 { // no unique chars\n        String::from(\"\
    \".to_ascii_lowercase())\n    } else {\n        let mut first_index = words.iter().find(|&s|\
    \ s == String::from(word.to_ascii_lowercase()));\n        let mut res = String::new();\n\
    \        for w in words.iter() {\n            if w == String::from(word.to_ascii_lowercase())\
    \ {\n                first_index = words.iter().find(|&s| s == String::from(word.to_ascii_lowercase()));\n\
    \            }\n            if w < String::from(word.to_ascii_lowercase()) {\n\
    \                res = w;\n            }\n        }\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg1lpith4.rs:12:16\n   |\n\
    9  |     let mut word = String::new();\n   |                    -------------\
    \ expected due to this value\n...\n12 |         word = w.to_ascii_lowercase().chars().count()\
    \ as u32;\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `u32`\n   |\nhelp: try using a conversion method\n  \
    \ |\n12 |         word = (w.to_ascii_lowercase().chars().count() as u32).to_string();\n\
    \   |                +                                             +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg1lpith4.rs:13:19\n   |\n13 |\
    \         if word > max_count {\n   |                   ^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                   |\n   |        \
    \           expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg1lpith4.rs:14:25\n   |\n10 |     let mut max_count = 1;\n\
    \   |                         - expected due to this value\n...\n14 |        \
    \     max_count = word;\n   |                         ^^^^ expected integer, found\
    \ struct `String`\n\nerror[E0277]: can't compare `&String` with `String`\n  -->\
    \ /tmp/tmpg1lpith4.rs:20:56\n   |\n20 |         let mut first_index = words.iter().find(|&s|\
    \ s == String::from(word.to_ascii_lowercase()));\n   |                       \
    \                                 ^^ no implementation for `&String == String`\n\
    \   |\n   = help: the trait `PartialEq<String>` is not implemented for `&String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmpg1lpith4.rs:23:18\n   |\n23 |       \
    \      if w == S"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|word| word.chars().count())\n        .max()\n        .unwrap_or(0)\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmp_knam7vs.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    use std::collections::hash_map::Entry;\n\
    \    let mut result = String::new();\n    let mut counts = hash_map::HashMap::new();\n\
    \    for word in words {\n        counts.entry(word.chars().unique().count()).or_insert(0u8);\n\
    \    }\n    counts.entry(counts.iter().min().unwrap()).or_insert(0u8);\n    for\
    \ i in counts.iter() {\n        if counts.entry(i).or_insert(0u8) > *i {\n   \
    \         result = words[counts.iter().min().unwrap()];\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmp9i6zhhei.rs:11:32\n   |\n11 |     let mut counts = hash_map::HashMap::new();\n\
    \   |                                ^^^^^^^ not found in `hash_map`\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\nhelp: if you import `HashMap`, refer to it directly\n   |\n11 -     let\
    \ mut counts = hash_map::HashMap::new();\n11 +     let mut counts = HashMap::new();\n\
    \   | \n\nwarning: unused import: `std::collections::hash_map::Entry`\n --> /tmp/tmp9i6zhhei.rs:9:9\n\
    \  |\n9 |     use std::collections::hash_map::Entry;\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `unique` found for struct `Chars` in the current scope\n  --> /tmp/tmp9i6zhhei.rs:13:35\n\
    \   |\n13 |         counts.entry(word.chars().unique().count()).or_insert(0u8);\n\
    \   |                                   ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts: HashMap<char,\
    \ usize> = HashMap::new();\n    for word in words {\n        for c in word.chars()\
    \ {\n            counts.entry(c).or_insert(0) += 1;\n        }\n    }\n    let\
    \ mut max_count = counts.iter().max().unwrap().1.clone();\n    let mut max_string\
    \ = String::with_capacity(words[0].len());\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let count = counts[word[0]];\n        if count > max_count {\n  \
    \          max_count = count;\n            max_string = word.to_owned();\n   \
    \     }\n    }\n    return max_string;\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpsog7xe18.rs:9:21\n\
    \  |\n9 |     let mut counts: HashMap<char, usize> = HashMap::new();\n  |    \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpsog7xe18.rs:9:44\n\
    \  |\n9 |     let mut counts: HashMap<char, usize> = HashMap::new();\n  |    \
    \                                        ^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpsog7xe18.rs:12:42\n\
    \   |\n12 |             counts.entry(c).or_insert(0) += 1;\n   |             ----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpsog7xe18.rs:18:28\n\
    \   |\n18 |         let count = counts[word[0]];\n   |                       \
    \     ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0277, E0412, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // TODO: implement this\n   \
    \ \"\"\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsj1t5nq3.rs:10:5\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     // TODO:\
    \ implement this\n10 |     \"\"\n   |     ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = words[0];\n   \
    \ for i in 1..words.len() {\n        let mut j = 0;\n        for c in self.chars(&mut\
    \ i).cloned() {\n            if !res.contains(&c) {\n                j = i;\n\
    \                res = res.chars().collect::<String>().as_str() + c;\n       \
    \         break;\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0424]: expected value, found module `self`\n  --> /tmp/tmpov1vv249.rs:12:18\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |    -------- this\
    \ function can't have a `self` parameter\n...\n12 |         for c in self.chars(&mut\
    \ i).cloned() {\n   |                  ^^^^ `self` value is a keyword only available\
    \ in methods with a `self` parameter\n\nerror[E0369]: cannot add `_` to `&str`\n\
    \  --> /tmp/tmpov1vv249.rs:15:64\n   |\n15 |                 res = res.chars().collect::<String>().as_str()\
    \ + c;\n   |                       ---------------------------------------- ^\
    \ - _\n   |                       |\n   |                       &str\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0424.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut num_unique_chars = Vec::with_capacity(words.len());\n\
    \    let mut max_word = String::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let char_count = word.chars().filter(|c| !c.is_ascii()).count();\n\
    \        num_unique_chars.push((i, char_count));\n        if char_count == num_unique_chars.iter().max().unwrap().1\
    \ {\n            max_word = word;\n        }\n    }\n    if num_unique_chars.iter().last().unwrap().1\
    \ == 0 {\n        return String::new();\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe5ovogdi.rs:15:24\n   |\n\
    10 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n15 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = vec![String::new();\
    \ words.len()];\n    for word in words {\n        let mut counter = 0;\n     \
    \   for c in word.chars() {\n            if let Some(ref mut v) = &mut count[c.0]\
    \ {\n                v.1 += 1;\n                if v.1 > v.0 {\n             \
    \       v = Some(c.0);\n                }\n            } else {\n            \
    \    v = Some(c);\n            }\n        }\n        if let Some(key) = counter\
    \ {\n            count[key] = *counter;\n        } else {\n            return\
    \ word;\n        }\n    }\n    let mut max_word = words[0];\n    for (ref key)\
    \ in count.iter() {\n        if count[key].1 > max_word[0].len() {\n         \
    \   max_word = vec![words[0]];\n        }\n    }\n    max_word[0]\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmpqwq95jq5.rs:19:17\n\
    \   |\n19 |                 v = Some(c);\n   |                 ^ help: a local\
    \ variable with a similar name exists: `c`\n\nwarning: unnecessary parentheses\
    \ around pattern\n  --> /tmp/tmpqwq95jq5.rs:29:9\n   |\n29 |     for (ref key)\
    \ in count.iter() {\n   |         ^       ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n29 -     for (ref key)\
    \ in count.iter() {\n29 +     for ref key in count.iter() {\n   | \n\nerror[E0610]:\
    \ `char` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpqwq95jq5.rs:13:51\n\
    \   |\n13 |             if let Some(ref mut v) = &mut count[c.0] {\n   |     \
    \                                              ^\n\nerror[E0609]: no field `1`\
    \ on type `&mut _`\n  --> /tmp/tmpqwq95jq5.rs:14:19\n   |\n14 |              \
    \   v.1 += 1;\n   |                   ^\n\nerror[E0610]: `char` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpqwq95jq5.rs:16:32\n  \
    \ |\n16 |                     v = Some(c.0);\n   |                           \
    \     ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqwq95jq5.rs:22:16\n \
    \  |\n22 |         if let Some(key) = counter {\n   |                ^^^^^^^^^\
    \   ------- this expression has type `{integer}`\n   |                |\n   |\
    \                expected integer, found enum `Option`\n   |\n   = note: expected\
    \ type `{integer}`\n              found enum `Option<_>`\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmpqwq95jq5.rs:23:26\n   |\n\
    23 |             count[key] = *counter;\n   |                          ^^^^^^^^\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `&&String`\n  --> /tmp/tmpqwq95jq5.rs:30:12\n\
    \   |\n30 |         if count[key].1 > max_word[0].len() {\n   |            ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&&String`\n   = note: required\
    \ because of the requirements on the impl of `Index<&&String>` for `Vec<String>`\n\
    \nerror[E0277]: the type `St"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars: Vec<String> =\
    \ words.into_iter().map(|word| {\n        word\n            .chars()\n       \
    \     .filter_map(|c| c.to_string())\n            .collect()\n    }).collect();\n\
    \    let mut count = Vec::<i32>::with_capacity(chars.len());\n    for ch in chars.into_iter()\
    \ {\n        if let Some(count) = count.iter_mut().position(|&x| x == ch) {\n\
    \            *count = *count + 1;\n        } else {\n            count.push(1);\n\
    \        }\n    }\n    let mut max_count = count.iter().max();\n    let mut max_char\
    \ = None;\n    for (_, count) in count {\n        if *count >= max_count {\n \
    \           max_count = count;\n            max_char = Some(max_count);\n    \
    \    }\n    }\n    max_char.unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplayi2r9h.rs:12:29\n   |\n\
    12 |             .filter_map(|c| c.to_string())\n   |                        \
    \     ^^^^^^^^^^^^^ expected enum `Option`, found struct `String`\n   |\n   =\
    \ note: expected enum `Option<_>`\n            found struct `String`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n12 |             .filter_map(|c| Some(c.to_string()))\n\
    \   |                             +++++             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplayi2r9h.rs:17:57\n   |\n17 |         if let Some(count)\
    \ = count.iter_mut().position(|&x| x == ch) {\n   |                          \
    \                               ^--\n   |                                    \
    \                     ||\n   |                                               \
    \          |expected due to this\n   |                                       \
    \                  types differ in mutability\n   |                          \
    \                               help: did you mean `x`: `&&mut i32`\n   |\n  \
    \ = note: expected mutable reference `&mut i32`\n                      found reference\
    \ `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmplayi2r9h.rs:18:13\n\
    \   |\n18 |             *count = *count + 1;\n   |             ^^^^^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmplayi2r9h.rs:18:22\n   |\n\
    18 |             *count = *count + 1;\n   |                      ^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplayi2r9h.rs:25:9\n   |\n25 |     for (_, count)\
    \ in count {\n   |         ^^^^^^^^^^    ----- this expression has type `Option<i32>`\n\
    \   |         |\n   |         expected `i32`, found tuple\n   |\n   = note: expected\
    \ type `i32`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplayi2r9h.rs:31:24\n   |\n31 |     max_char.unwrap_or(\"\")\n  \
    \ |                        ^^ expected enum `Option`, found `&str`\n   |\n   =\
    \ note:   expected enum `Option<&i32>`\n           found reference `&'static str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplayi2r9h.rs:31:5\n   |\n8  | fn\
    \ find_max(words: Vec<Stri"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = vec![String::new();\
    \ words.len()];\n    for (idx, word) in words.into_iter().enumerate() {\n    \
    \    for c in word.chars() {\n            if let Some(found) = counter.iter_mut().find(|&c|\
    \ c == c) {\n                *found += 1;\n            } else {\n            \
    \    counter[idx] = String::new();\n                *counter[idx] += c;\n    \
    \        }\n        }\n    }\n    if counter.iter().any(|&x| x.len() > words[words.index(&x).unwrap()].len())\
    \ {\n        words[words.index(&0).unwrap()]\n    } else {\n        \"\"\n   \
    \ }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4miuuwl.rs:13:27\n   |\n\
    13 |                 *found += 1;\n   |                           ^ expected `&str`,\
    \ found integer\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `str`\n  --> /tmp/tmpe4miuuwl.rs:16:17\n   |\n16 |                 *counter[idx]\
    \ += c;\n   |                 -------------^^^^^\n   |                 |\n   |\
    \                 cannot use `+=` on type `str`\n\nerror[E0599]: no method named\
    \ `index` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpe4miuuwl.rs:20:54\n\
    \   |\n20 |     if counter.iter().any(|&x| x.len() > words[words.index(&x).unwrap()].len())\
    \ {\n   |                                                      ^^^^^ method not\
    \ found in `Vec<String>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error[E0599]: no method named `index` found for struct `Vec<String>` in the current\
    \ scope\n  --> /tmp/tmpe4miuuwl.rs:21:21\n   |\n21 |         words[words.index(&0).unwrap()]\n\
    \   |                     ^^^^^ method not found in `Vec<String>`\n   |\n   =\
    \ help: items from traits can only be used if the trait is in scope\nhelp: the\
    \ following trait is implemented but not in scope; perhaps add a `use` for it:\n\
    \   |\n1  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe4miuuwl.rs:23:9\n   |\n8  | fn find_max(words: Vec<String>) -> String\
    \ {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n23 |         \"\"\n   |         ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |         |\n   |         expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_count = 0u32;\n \
    \   let mut max_val = String::new();\n    for word in words {\n        let val\
    \ = word.chars().unique().count();\n        if val > max_count {\n           \
    \ max_count = val;\n            max_val = word;\n        }\n    }\n    return\
    \ max_val;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpyc_apbnl.rs:12:32\n   |\n12 |         let val =\
    \ word.chars().unique().count();\n   |                                ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().copied().dedup().max()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: Copy` is not satisfied\n    -->\
    \ /tmp/tmp5vqre3rg.rs:9:18\n     |\n9    |     words.iter().copied().dedup().max()\n\
    \     |                  ^^^^^^ the trait `Copy` is not implemented for `String`\n\
    \     |\nnote: required by a bound in `copied`\n\nerror[E0599]: no method named\
    \ `dedup` found for struct `Copied` in the current scope\n --> /tmp/tmp5vqre3rg.rs:9:27\n\
    \  |\n9 |     words.iter().copied().dedup().max()\n  |                       \
    \    ^^^^^ method not found in `Copied<std::slice::Iter<'_, String>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    for word in words {\n        res.push_str(word.chars().filter(|&c| *c !=\
    \ ' ').count());\n    }\n    let res = res.chars().filter(|&c| *c != ' ').max();\n\
    \    if res != \"\" {\n        res\n    } else {\n        find_max_non_empty(words)\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_max_non_empty` in this scope\n\
    \  --> /tmp/tmpdvxtxi5j.rs:17:9\n   |\n17 |         find_max_non_empty(words)\n\
    \   |         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpdvxtxi5j.rs:11:47\n   |\n11 | \
    \        res.push_str(word.chars().filter(|&c| *c != ' ').count());\n   |    \
    \                                           ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdvxtxi5j.rs:11:22\n   |\n11 |         res.push_str(word.chars().filter(|&c|\
    \ *c != ' ').count());\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpdvxtxi5j.rs:13:39\n   |\n13 |     let res = res.chars().filter(|&c|\
    \ *c != ' ').max();\n   |                                       ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdvxtxi5j.rs:14:15\n   |\n14 |     if res !=\
    \ \"\" {\n   |               ^^ expected enum `Option`, found `&str`\n   |\n \
    \  = note:   expected enum `Option<char>`\n           found reference `&'static\
    \ str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdvxtxi5j.rs:15:9\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n15 |     \
    \    res\n   |         ^^^ expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<char>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Create a hash of counts of\
    \ characters in each word.\n    let mut counts = HashMap::new();\n    for word\
    \ in words {\n        for c in word.chars() {\n            counts.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n\n    // Sort the words by counts of characters.\n\
    \    let mut sorted = words.iter().cloned().collect::<Vec<_>>();\n    sorted.sort_by_key(|x|\
    \ counts.get(x).unwrap());\n\n    // Iterate through sorted words and find max\
    \ word which has the most\n    // unique characters. Return empty string if the\
    \ sorted list is empty.\n    let mut max_char = counts.keys().next().unwrap();\n\
    \    let mut max_word = sorted.iter().take(1).next().unwrap();\n    for i in 0..=sorted.len()\
    \ {\n        if counts.get(&sorted[i]).unwrap() == max_char {\n            max_char\
    \ = counts.keys().next().unwrap();\n            max_word = sorted[i];\n      \
    \  }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpauvzjnez.rs:10:22\n   |\n10 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpauvzjnez.rs:13:42\n   |\n\
    13 |             counts.entry(c).or_insert(0) += 1;\n   |             ----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpauvzjnez.rs:28:24\n   |\n24 |  \
    \   let mut max_word = sorted.iter().take(1).next().unwrap();\n   |          \
    \              ------------------------------------- expected due to this value\n\
    ...\n28 |             max_word = sorted[i];\n   |                        ^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&String`,\
    \ found struct `String`\n   |                        help: consider borrowing\
    \ here: `&sorted[i]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauvzjnez.rs:31:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n31\
    \ |     max_word\n   |     ^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .cloned()\n        .max_by_key(|s| s.chars().filter(|c| !c.is_whitespace()).count())\n\
    \        .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmpfkli8pkv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return \"\";\n    }\n    let mut char = String::new();\n    let mut max_count\
    \ = 0;\n    let mut max_word = String::new();\n    let mut index = words[0].to_owned();\n\
    \n    for &s in words {\n        for &c in s.chars() {\n            if char.contains(&c)\
    \ {\n                max_count = 1;\n            }\n            if max_count <\
    \ 1 {\n                max_count = 1;\n                max_word = s;\n       \
    \     } else {\n                max_count += 1;\n            }\n            char\
    \ += c;\n        }\n    }\n\n    if max_count == words[0].len() {\n        return\
    \ words[0];\n    }\n\n    if max_count > words[0].len() {\n        max_word =\
    \ words[0];\n    }\n\n    if max_word == \"\" {\n        return \"\";\n    }\n\
    \n    if char.len() < max_word {\n        return \"\";\n    }\n\n    if char.len()\
    \ > max_word {\n        return \"\";\n    }\n\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq_rwrwpf.rs:10:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     if words.is_empty()\
    \ {\n10 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq_rwrwpf.rs:17:9\n\
    \   |\n17 |     for &s in words {\n   |         ^^    ----- this expression has\
    \ type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `s`\n   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq_rwrwpf.rs:44:21\n   |\n44 |\
    \     if char.len() < max_word {\n   |                     ^^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq_rwrwpf.rs:48:21\n\
    \   |\n48 |     if char.len() > max_word {\n   |                     ^^^^^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut char_counter = HashMap::new();\n\
    \    let mut word = String::new();\n    for word in words.iter() {\n        char_counter.into_entry(word).or_insert(0);\n\
    \    }\n\n    let mut max_val = -1;\n    let mut max_key_val = -1;\n    for entry\
    \ in char_counter.iter() {\n        let val = entry.get_mut(&word).unwrap();\n\
    \        *val += 1;\n        if *val > max_val {\n            max_val = *val;\n\
    \            max_key_val = entry.key();\n        }\n    }\n    if max_val > 0\
    \ {\n        max_key_val\n    } else {\n        \"\".to_string()\n    }\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmptm29ep00.rs:9:28\n  |\n9 |     let mut char_counter = HashMap::new();\n\
    \  |                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptm29ep00.rs:26:9\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n26 |         max_key_val\n   |       \
    \  ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |    \
    \     |\n   |         expected struct `String`, found integer\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return String::new();\n    }\n    let mut word = words[0][..];\n    let mut\
    \ max_len = word.chars().count();\n    for w in words {\n        let w_c = w.chars().count();\n\
    \        if w_c > max_len {\n            max_len = w_c;\n            word = w;\n\
    \        }\n    }\n    return word;\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmphtfb33iw.rs:12:9\n   |\n12 |     let mut word = words[0][..];\n\
    \   |         ^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n   |\n12 |     let mut word\
    \ = &words[0][..];\n   |                    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphtfb33iw.rs:18:20\n   |\n12 |     let mut word = words[0][..];\n\
    \   |                    ------------ expected due to this value\n...\n18 |  \
    \           word = w;\n   |                    ^ expected `str`, found struct\
    \ `String`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmphtfb33iw.rs:18:13\n   |\n18 |           \
    \  word = w;\n   |             ^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphtfb33iw.rs:21:12\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n21 |     return word;\n   |          \
    \  ^^^^- help: try using a conversion method: `.to_string()`\n   |           \
    \ |\n   |            expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for w in words {\n        let s = w.to_string();\n        if counts.contains_key(&s)\
    \ {\n            counts.insert(s, counts.get(&s) + 1) as usize;\n        } else\
    \ {\n            counts.insert(s, 1);\n        }\n    }\n\n    let mut res = String::new();\n\
    \    let mut i = 1;\n    for (s, c) in counts.iter().max_by_key(|(_, count)| {\n\
    \        if i > c {\n            i = 1;\n        } else {\n            i += 1;\n\
    \        }\n        c\n    }) {\n        res.push_str(&s);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpsyiuiv4z.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpsyiuiv4z.rs:22:16\n   |\n22 |  \
    \       if i > c {\n   |                ^ help: a local variable with a similar\
    \ name exists: `i`\n\nerror[E0425]: cannot find value `c` in this scope\n  -->\
    \ /tmp/tmpsyiuiv4z.rs:27:9\n   |\n27 |         c\n   |         ^ help: a local\
    \ variable with a similar name exists: `i`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpsyiuiv4z.rs:21:10\n\
    \   |\n21 |     for (s, c) in counts.iter().max_by_key(|(_, count)| {\n   |  \
    \        ^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpsyiuiv4z.rs:21:19\n   |\n21 |       for (s,\
    \ c) in counts.iter().max_by_key(|(_, count)| {\n   |  ___________________^\n\
    22 | |         if i > c {\n23 | |             i = 1;\n24 | |         } else {\n\
    ...  |\n27 | |         c\n28 | |     }) {\n   | |______^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: only the last element of a tuple may have a dynamically sized type\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|word| word.chars().count())\n        .max()\n        .unwrap()\n  \
    \      .name()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `name` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp5rhevy_c.rs:14:10\n   |\n14 |         .name()\n   |   \
    \       ^^^^ method not found in `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Sort alphabetically and count\
    \ the unique characters one by one.\n    let mut characters: HashMap<String, usize>\
    \ = HashMap::new();\n    for word in words {\n        for character in word.chars()\
    \ {\n            characters.entry(character).or_insert(0) += 1;\n        }\n \
    \   }\n\n    let mut max_char: String = String::new();\n    let mut max_count:\
    \ usize = 0;\n    for (char, count) in characters.iter() {\n        if count >\
    \ max_count {\n            max_count = count;\n            max_char = char;\n\
    \        }\n    }\n    max_char\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp97i1d9jc.rs:10:25\n\
    \   |\n10 |     let mut characters: HashMap<String, usize> = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp97i1d9jc.rs:10:50\n\
    \   |\n10 |     let mut characters: HashMap<String, usize> = HashMap::new();\n\
    \   |                                                  ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp97i1d9jc.rs:13:54\n\
    \   |\n13 |             characters.entry(character).or_insert(0) += 1;\n   | \
    \            ---------------------------------------- ^^\n   |             |\n\
    \   |             cannot assign to this expression\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut characters = Vec::new();\n\
    \    for word in words {\n        characters.extend(word.chars().collect());\n\
    \    }\n    characters = characters.dedup();\n    if characters.len() > 1 {\n\
    \        let mut index = 0;\n        let mut max_index = -1;\n        for (i,\
    \ c) in characters.iter().enumerate() {\n            if index == 0 {\n       \
    \         index = i;\n                max_index = i;\n            }\n        \
    \    if max_index == i {\n                max_index = i;\n            } else {\n\
    \                break;\n            }\n        }\n        if max_index != -1\
    \ {\n            return &words[max_index];\n        }\n    }\n    return &words[0];\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbflryhha.rs:13:18\n   |\n\
    9  |     let mut characters = Vec::new();\n   |                          ----------\
    \ expected due to this value\n...\n13 |     characters = characters.dedup();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\n\
    note: method `dedup` modifies its receiver in-place\n  --> /tmp/tmpbflryhha.rs:13:29\n\
    \   |\n13 |     characters = characters.dedup();\n   |                  ----------\
    \ ^^^^^ this call modifies `characters` in-place\n   |                  |\n  \
    \ |                  you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `dedup`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpbflryhha.rs:16:29\n\
    \   |\n16 |         let mut max_index = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpbflryhha.rs:28:25\n\
    \   |\n28 |         if max_index != -1 {\n   |                         ^^\n  \
    \ |                         |\n   |                         cannot apply unary\
    \ operator `-`\n   |                         help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbflryhha.rs:29:20\n   |\n8  |\
    \ fn find_max(words: Vec<String>) -> String {\n   |                          \
    \          ------ expected `String` because of return type\n...\n29 |        \
    \     return &words[max_index];\n   |                    ^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n29 -             return &words[max_index];\n29 +         "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut char_counter = vec![];\n\
    \n    for word in words {\n        char_counter.extend(word.chars().map(|c| c.to_ascii_lowercase()));\n\
    \    }\n\n    let max = char_counter.iter().max_by_key(|c| c.len()).expect(\"\
    No word with maximum number of unique chars\");\n    let index = words.iter().position(|w|\
    \ w.to_ascii_lowercase().contains(max));\n\n    if index != words.len() - 1 {\n\
    \        let mut current_word = String::new();\n        let mut next_word = String::new();\n\
    \n        for word in words.iter_mut() {\n            if index == 0 {\n      \
    \          word.push(max);\n            }\n            word.push(current_word);\n\
    \            current_word.clear();\n        }\n        \n        if index == words.len()\
    \ - 1 {\n            word.push(max);\n        }\n\n        return next_word;\n\
    \    } else {\n        return max;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmp1idf3a1h.rs:31:13\n\
    \   |\n31 |             word.push(max);\n   |             ^^^^ help: a local variable\
    \ with a similar name exists: `words`\n\nerror[E0599]: no method named `len` found\
    \ for reference `&&char` in the current scope\n  --> /tmp/tmp1idf3a1h.rs:15:52\n\
    \   |\n15 |     let max = char_counter.iter().max_by_key(|c| c.len()).expect(\"\
    No word with maximum number of unique chars\");\n   |                        \
    \                            ^^^ method not found in `&&char`\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp1idf3a1h.rs:16:75\n\
    \     |\n16   |     let index = words.iter().position(|w| w.to_ascii_lowercase().contains(max));\n\
    \     |                                                                  --------\
    \ ^^^ expected an `Fn<(char,)>` closure, found `char`\n     |                \
    \                                                  |\n     |                 \
    \                                                 required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n16   |     let index\
    \ = words.iter().position(|w| w.to_ascii_lowercase().contains(*max));\n     |\
    \                                                                           +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1idf3a1h.rs:18:17\n   |\n18 |\
    \     if index != words.len() - 1 {\n   |                 ^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |     if index != Some(words.len() - 1) {\n   |                 +++++\
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1idf3a1h.rs:23:25\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max: usize = 0;\n   \
    \ let mut index = 0;\n    while index < words.len() {\n        let mut unique\
    \ = 0;\n        for w in words {\n            let wl = w.chars().filter(|c| c\
    \ != '\\0').count();\n            if wl == 1 {\n                unique += 1;\n\
    \                if unique > max {\n                    max = unique;\n      \
    \              index = wl as i32;\n                }\n            }\n        }\n\
    \        index += 1;\n    }\n    return words[(index as usize) as usize].to_owned();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfk5l0sx1.rs:14:45\n\
    \   |\n14 |             let wl = w.chars().filter(|c| c != '\\0').count();\n \
    \  |                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfk5l0sx1.rs:19:29\n   |\n10 |     let mut index\
    \ = 0;\n   |                     - expected due to this value\n...\n19 |     \
    \                index = wl as i32;\n   |                             ^^^^^^^^^\
    \ expected `usize`, found `i32`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = HashMap::new();\n\
    \    let mut max_key = String::new();\n    for word in words.iter() {\n      \
    \  count += word.chars().filter(|c| *c != 'a' && *c != 'A').count();\n       \
    \ if count.len() > count.get(&max_key) {\n            max_key = word.clone();\n\
    \        }\n    }\n    if count.len() > count.get(&max_key) {\n        max_key\n\
    \    } else {\n        \"\"\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpx6_i9413.rs:9:21\n  |\n9 |     let mut count = HashMap::new();\n  |\
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx6_i9413.rs:20:9\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n20 |         \"\"\n   |         ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |         |\n   |         expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .fold((\"\".to_owned(), 0), |mut acc, word| {\n            if acc ==\
    \ 0 || (acc == 1 && word[0] < acc[0]) {\n                (word, acc)\n       \
    \     } else {\n                (acc[0], acc[1].cmp(&word[0]) < 0 ? acc[0] : word)\n\
    \            }\n        })\n        .1\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `acc`\n\
    \  --> /tmp/tmple25t502.rs:15:53\n   |\n15 |                 (acc[0], acc[1].cmp(&word[0])\
    \ < 0 ? acc[0] : word)\n   |                                                 \
    \   -^^^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |            \
    \                                        |\n   |                             \
    \                       help: missing `,`\n\nerror[E0573]: expected type, found\
    \ local variable `word`\n  --> /tmp/tmple25t502.rs:15:62\n   |\n15 |         \
    \        (acc[0], acc[1].cmp(&word[0]) < 0 ? acc[0] : word)\n   |            \
    \                                                  ^^^^ expecting a type here\
    \ because of type ascription\n\nerror[E0308]: mismatched types\n  --> /tmp/tmple25t502.rs:12:23\n\
    \   |\n12 |             if acc == 0 || (acc == 1 && word[0] < acc[0]) {\n   |\
    \                       ^ expected tuple, found integer\n   |\n   = note: expected\
    \ tuple `(String, {integer})`\n               found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmple25t502.rs:12:36\n   |\n12 |             if\
    \ acc == 0 || (acc == 1 && word[0] < acc[0]) {\n   |                         \
    \           ^ expected tuple, found integer\n   |\n   = note: expected tuple `(String,\
    \ {integer})`\n               found type `{integer}`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmple25t502.rs:12:41\n\
    \   |\n12 |             if acc == 0 || (acc == 1 && word[0] < acc[0]) {\n   |\
    \                                         ^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_chars = Vec::new();\n\
    \    for word in words {\n        for char in word.chars() {\n            if !unique_chars.contains(&char)\
    \ {\n                unique_chars.push(char);\n            }\n        }\n    }\n\
    \    if unique_chars.len() == words.len() {\n        return String::from(\"\"\
    );\n    }\n    let mut char = unique_chars[0];\n    for unique_char in unique_chars\
    \ {\n        if unique_chars.iter().all(|c| c != unique_char) {\n            char\
    \ = unique_char;\n            break;\n        }\n    }\n    char\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprvqrer5j.rs:22:42\n\
    \   |\n22 |         if unique_chars.iter().all(|c| c != unique_char) {\n   | \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprvqrer5j.rs:27:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n27 |     char\n   |     ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = std::collections::HashMap::new();\n\
    \    for word in words {\n        counter.insert(word.chars().count(), 1);\n \
    \   }\n\n    let max = counter.iter().max_by_key(|(_, count)| count).unwrap();\n\
    \    if max.0 > 0 {\n        return *max.0.to_string();\n    }\n    return \"\"\
    ;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xmvpn4c.rs:15:16\n   |\n\
    15 |     if max.0 > 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&usize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xmvpn4c.rs:16:16\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n16\
    \ |         return *max.0.to_string();\n   |                ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `str`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    use std::collections::HashSet;\n\
    \n    let mut result = String::new();\n\n    for word in words {\n        let\
    \ mut char_count: HashSet<String> = HashSet::new();\n\n        for char in word\
    \ {\n            char_count.insert(char.clone());\n        }\n\n        let count\
    \ = char_count.iter().filter(|c| !c.is_digit()).count();\n        match count\
    \ {\n            1 => result.push_str(&char),\n            n => continue,\n  \
    \      };\n    }\n\n    if result.len() < words.len() {\n        find_max(words[words.len()\
    \ - 1])\n    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmpmsvdwj76.rs:22:35\n\
    \   |\n22 |             1 => result.push_str(&char),\n   |                   \
    \                ^^^^ not a value\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpmsvdwj76.rs:16:21\n   |\n16 |         for char in word {\n   |\
    \                     ^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0599]: no method named `is_digit` found for reference\
    \ `&&String` in the current scope\n  --> /tmp/tmpmsvdwj76.rs:20:53\n   |\n20 |\
    \         let count = char_count.iter().filter(|c| !c.is_digit()).count();\n \
    \  |                                                     ^^^^^^^^ method not found\
    \ in `&&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmsvdwj76.rs:28:18\n\
    \   |\n28 |         find_max(words[words.len() - 1])\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `String`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0423,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.sort_by_key(|x| x.chars().count()).unwrap().next()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n --> /tmp/tmpuzzk5xc_.rs:9:46\n  |\n9 |     words.sort_by_key(|x|\
    \ x.chars().count()).unwrap().next()\n  |                                    \
    \          ^^^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|word| word.chars().count()).max().unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmpwn__8cau.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Get the number of unique characters\
    \ for each word.\n    let counts = words.iter().map(|s| s.chars().count()).collect();\n\
    \n    // Find the word with the maximum number of unique characters.\n    let\
    \ i = counts\n        .iter()\n        .enumerate()\n        .max_by_key(|(_,\
    \ count)| count)\n        .0;\n\n    // Return the word with the maximum unique\
    \ characters.\n    let word = words[i].clone();\n    word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp6r8v5n10.rs:13:13\n\
    \   |\n10 |     let counts = words.iter().map(|s| s.chars().count()).collect();\n\
    \   |         ------ consider giving `counts` a type\n...\n13 |     let i = counts\n\
    \   |             ^^^^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for w in words {\n        for c in w.chars() {\n            if counts.contains_key(&c).is_some()\
    \ {\n                counts.insert(c, counts.get(&c).unwrap() + 1);\n        \
    \    }\n            else {\n                counts.insert(c, 1);\n           \
    \ }\n        }\n    }\n    counts.iter().max_by_key(|&(_, cs)| cs.len()).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp7laz26mo.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_len = std::collections::HashSet::new();\n\
    \    let mut max_idx = 0;\n    for i in 0..words.len() {\n        let mut count\
    \ = 1;\n        for (j, word) in words.into_iter().enumerate() {\n           \
    \ if j > i {\n                if count == max_idx\n                    || (count.is_some()\
    \ && count < max_len.unwrap())\n                {\n                    max_idx\
    \ = i;\n                    max_len = count;\n                }\n            }\n\
    \            count = 1;\n        }\n    }\n    if max_len.len() == words.len()\
    \ {\n        let mut i = 0;\n        let mut idx = 0;\n        let mut cur_len\
    \ = words.len();\n        while i < cur_len {\n            if max_len.is_some()\
    \ {\n                max_len = max_len.unwrap();\n                max_idx = idx;\n\
    \            }\n            if words[i] == \"\" {\n                i += 1;\n \
    \           } else {\n                max_len.insert(words[i]);\n            \
    \    idx += 1;\n                i += 1;\n            }\n        }\n    }\n   \
    \ if max_len.is_some() {\n        words[max_idx].to_string()\n    } else {\n \
    \       \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_some` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmp3xvjsqa7.rs:16:31\n   |\n16 |                 \
    \    || (count.is_some() && count < max_len.unwrap())\n   |                  \
    \             ^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `HashSet` in the current scope\n  --> /tmp/tmp3xvjsqa7.rs:16:60\n\
    \   |\n16 |                     || (count.is_some() && count < max_len.unwrap())\n\
    \   |                                                            ^^^^^^ method\
    \ not found in `HashSet<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3xvjsqa7.rs:19:31\n\
    \   |\n9  |     let mut max_len = std::collections::HashSet::new();\n   |    \
    \                   -------------------------------- expected due to this value\n\
    ...\n19 |                     max_len = count;\n   |                         \
    \      ^^^^^ expected struct `HashSet`, found `usize`\n   |\n   = note: expected\
    \ struct `HashSet<_>`\n                found type `usize`\n\nerror[E0599]: no\
    \ method named `is_some` found for struct `HashSet` in the current scope\n  -->\
    \ /tmp/tmp3xvjsqa7.rs:30:24\n   |\n30 |             if max_len.is_some() {\n \
    \  |                        ^^^^^^^ method not found in `HashSet<_>`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `HashSet` in the current scope\n \
    \ --> /tmp/tmp3xvjsqa7.rs:31:35\n   |\n31 |                 max_len = max_len.unwrap();\n\
    \   |                                   ^^^^^^ method not found in `HashSet<_>`\n\
    \nerror[E0599]: no method named `is_some` found for struct `HashSet` in the current\
    \ scope\n  --> /tmp/tmp3xvjsqa7.rs:43:16\n   |\n43 |     if max_len.is_some()\
    \ {\n   |                ^^^^^^^ method not found in `HashSet<String>`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().fold(\"\".to_string(),\
    \ |mut acc, word| {\n        let mut num_unique_cnt = 0;\n        let mut max_unique_cnt\
    \ = 0;\n        let mut max_unique_word = String::new();\n\n        for c in word.chars()\
    \ {\n            if !acc.contains(&c) {\n                acc.push_str(&c.to_string());\n\
    \                num_unique_cnt++;\n            }\n            if num_unique_cnt\
    \ > max_unique_cnt {\n                max_unique_cnt = num_unique_cnt;\n     \
    \           max_unique_word = &c;\n            }\n        }\n        acc\n   \
    \ });\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmppfdc_hdq.rs:17:31\n\
    \   |\n17 |                 num_unique_cnt++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    17 |                 { let tmp = num_unique_cnt; num_unique_cnt += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    17 -                 num_unique_cnt++;\n17 +                 num_unique_cnt +=\
    \ 1;\n   | \n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \    --> /tmp/tmppfdc_hdq.rs:15:30\n     |\n15   |             if !acc.contains(&c)\
    \ {\n     |                     -------- ^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                     |\n     |                     required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n15   |             if !acc.contains(*&c) {\n     |           \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfdc_hdq.rs:21:35\n\
    \   |\n12 |         let mut max_unique_word = String::new();\n   |           \
    \                        ------------- expected due to this value\n...\n21 | \
    \                max_unique_word = &c;\n   |                                 \
    \  ^^ expected struct `String`, found `&char`\n   |\nhelp: try using a conversion\
    \ method\n   |\n21 |                 max_unique_word = (&c).to_string();\n   |\
    \                                   +  +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppfdc_hdq.rs:8:36\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |    --------                        ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n...\n25 |     });\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_chars = std::collections::HashSet::new();\n\
    \    for word in words {\n        for char in word.chars() {\n            if !max_chars.insert(char).is_inserted()\
    \ {\n                *max_chars.iter().max_by_key(|&(_, count)| count).unwrap()\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    if let Some(count) = max_chars.iter().map(|x| x.1).count() {\n        let\
    \ mut most_popular = count.to_string();\n        for word in words {\n       \
    \     for c in word.chars() {\n                if let Some(count) = max_chars.iter().filter(|(_,\
    \ count)| c == c).min(|(_, count)| count).unwrap_or(0) {\n                   \
    \ if count > most_popular.len() {\n                        most_popular = c.to_string();\n\
    \                    }\n                }\n            }\n        }\n        most_popular\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_inserted` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmp0bsqi0rn.rs:12:40\n   |\n12 |             if !max_chars.insert(char).is_inserted()\
    \ {\n   |                                        ^^^^^^^^^^^ method not found\
    \ in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0bsqi0rn.rs:13:48\n\
    \   |\n13 |                 *max_chars.iter().max_by_key(|&(_, count)| count).unwrap()\n\
    \   |                                                ^^^^^^^^^-\n   |        \
    \                                        |        |\n   |                    \
    \                            |        expected due to this\n   |             \
    \                                   expected `char`, found tuple\n   |\n   = note:\
    \ expected type `char`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0bsqi0rn.rs:13:17\n   |\n12 | /             if !max_chars.insert(char).is_inserted()\
    \ {\n13 | |                 *max_chars.iter().max_by_key(|&(_, count)| count).unwrap()\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found `char`\n14 | |             } else {\n15 | |           \
    \      break;\n16 | |             }\n   | |             -- help: consider using\
    \ a semicolon here\n   | |_____________|\n   |               expected this to\
    \ be `()`\n\nerror[E0609]: no field `1` on type `&char`\n  --> /tmp/tmp0bsqi0rn.rs:19:53\n\
    \   |\n19 |     if let Some(count) = max_chars.iter().map(|x| x.1).count() {\n\
    \   |                                                     ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0bsqi0rn.rs:19:12\n   |\n19 |     if let Some(count) =\
    \ max_chars.iter().map(|x| x.1).count() {\n   |            ^^^^^^^^^^^   -------------------------------------\
    \ this expression has type `usize`\n   |            |\n   |            expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0bsqi0rn.rs:23:63\n\
    \   |\n23 |                 if let Some(count) = max_chars.iter().filter(|(_,\
    \ count)| "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // return empty string if words\
    \ is empty\n    if words.is_empty() {\n        return \"\".to_string();\n    }\n\
    \    \n    let mut unique_count = HashMap::new();\n    let mut max_count = words[0].to_string().len();\n\
    \    \n    for word in words {\n        let word_string = word.to_string();\n\
    \        // if word is empty string, exit loop\n        if word_string.len() ==\
    \ 0 {\n            continue;\n        }\n        \n        let len = word_string.len();\n\
    \        // iterate through each character in word\n        for _ in 0..len {\n\
    \            // get current character in word\n            let current_char =\
    \ word_string[len-1];\n            \n            // check if current character\
    \ in HashMap\n            if let Some(current) = unique_count[current_char] {\n\
    \                // if current character in HashMap is less than the one in word\n\
    \                if current < max_count {\n                    // set current\
    \ character in HashMap to current in word\n                    unique_count[current_char]\
    \ = current;\n                    // set current character in word to 0\n    \
    \                unique_count[current_char] = 0;\n                }\n        \
    \        // if current character in HashMap is greater than current in word\n\
    \                else if current > max_count {\n                    // set current\
    \ character in HashMap to current in word\n                    unique_count[current_char]\
    \ = current;\n                }\n                // if current character in HashMap\
    \ is equal to current in word\n                // and current character in word\
    \ is 0, keep current character in HashMap\n                // and increment max_count\n\
    \                else if current == 0 {\n                    unique_count[current_char]\
    \ += 1;\n                    max_count += 1;\n                }\n            }\n\
    \            // if current character in word is not in HashMap\n            else\
    \ {\n                // add current character to HashMap\n                unique_count.insert(current_char,\
    \ 0);\n                max_count += 1;\n            }\n        }\n    }\n    \n\
    \    let mut max_key = String::new();\n    // iterate through unique_count and\
    \ find key with max value\n    // return key with max value in lexicographical\
    \ order\n    for (_, count) in unique_count.iter().cloned() {\n        if count\
    \ > max_count {\n            max_key = String::from(char::from_u32(count as u32).unwrap());\n\
    \        }\n    }\n    \n    // return the key with max value\n    max_key.to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpisfp4t23.rs:14:28\n   |\n14 |     let mut unique_count = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpisfp4t23.rs:28:32\n\
    \   |\n28 |             let current_char = word_string[len-1];\n   |         \
    \                       ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut max_unique = 0;\n    loop {\n        word.clear();\n        for word\
    \ in words {\n            for ch in word.chars() {\n                if *ch > max_unique\
    \ {\n                    max_unique = *ch;\n                }\n            }\n\
    \        }\n        if !word.is_empty() {\n            return word;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpct2pdoji.rs:15:20\n\
    \   |\n15 |                 if *ch > max_unique {\n   |                    ^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpct2pdoji.rs:16:34\n\
    \   |\n16 |                     max_unique = *ch;\n   |                      \
    \            ^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = String::new();\n\
    \    let mut word = String::new();\n\n    for word in words {\n        if let\
    \ Some(count) = word\n            .chars()\n            .filter(|c| !c.is_whitespace())\n\
    \            .count() {\n                count = count.to_string();\n        \
    \        if count.len() > word.len() {\n                    word = word;\n   \
    \             }\n            }\n        }\n\n    word\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8fkv0301.rs:13:16\n   |\n\
    13 |           if let Some(count) = word\n   |  ________________^^^^^^^^^^^___-\n\
    \   | |                |\n   | |                expected `usize`, found enum `Option`\n\
    14 | |             .chars()\n15 | |             .filter(|c| !c.is_whitespace())\n\
    16 | |             .count() {\n   | |____________________- this expression has\
    \ type `usize`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_chars = String::new();\n\
    \    let mut words = words.clone();\n    loop {\n        let mut i = 0;\n    \
    \    let mut j = i + 1;\n        let mut max_idx = i;\n        while j < words.len()\
    \ {\n            let mut chars = 0;\n            for ch in words[i..j] {\n   \
    \             chars += ch.chars().count(|c| c.is_ascii_letter());\n          \
    \  }\n            if chars > max_chars.chars().count(|c| c.is_ascii_letter())\
    \ {\n                max_chars = chars;\n                max_idx = i;\n      \
    \      }\n            i += 1;\n            j += 1\n        }\n        if max_chars.chars().count(|c|\
    \ c.is_ascii_letter()) == 0 {\n            break;\n        }\n        words =\
    \ words.clone();\n        words[max_idx] = words[max_idx].to_ascii_lowercase();\n\
    \    }\n    words.join(\"\").to_ascii_lowercase()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[String]` cannot be known at\
    \ compilation time\n  --> /tmp/tmp2z5qpr_w.rs:17:23\n   |\n17 |             for\
    \ ch in words[i..j] {\n   |                       ^^^^^^^^^^^ expected an implementor\
    \ of trait `IntoIterator`\n   |\n   = note: the trait bound `[String]: IntoIterator`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[String]`\nhelp: consider borrowing here\n   |\n17 |\
    \             for ch in &words[i..j] {\n   |                       +\n17 |   \
    \          for ch in &mut words[i..j] {\n   |                       ++++\n\nerror[E0277]:\
    \ `[String]` is not an iterator\n  --> /tmp/tmp2z5qpr_w.rs:17:23\n   |\n17 | \
    \            for ch in words[i..j] {\n   |                       ^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[String]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[String]`\nhelp: consider borrowing here\n\
    \   |\n17 |             for ch in &words[i..j] {\n   |                       +\n\
    17 |             for ch in &mut words[i..j] {\n   |                       ++++\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp2z5qpr_w.rs:20:42\n    |\n20  |             if chars > max_chars.chars().count(|c|\
    \ c.is_ascii_letter()) {\n    |                                          ^^^^^\
    \ ----------------------- supplied 1 argument\n    |                         \
    \                 |\n    |                                          expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2z5qpr_w.rs:21:29\n   |\n9  |     let mut max_chars = String::new();\n\
    \   |                         ------------- expected due to this value\n...\n\
    21 |                 max_chars = chars;\n   |                             ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \           |\n   |                             expected struct `String`, found\
    \ `usize`\n\ne"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut best = words[0];\n  \
    \  let mut current_unique_count = 1;\n    for &w in words {\n        if w.chars().count()\
    \ > current_unique_count {\n            current_unique_count = w.chars().count();\n\
    \            best = w;\n        }\n    }\n    best\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hp6d9uy.rs:11:9\n   |\n\
    11 |     for &w in words {\n   |         ^^    ----- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `w`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut lens: HashMap<usize,\
    \ String> = HashMap::new();\n    for (i, word) in words.iter().enumerate() {\n\
    \        lens.entry(word.len()).or_insert(word.clone());\n    }\n    let len =\
    \ lens.iter().max().unwrap().len();\n    let mut res = Vec::new();\n    for (i,\
    \ word) in words.iter().enumerate() {\n        if word.len() == len {\n      \
    \      res.push(i);\n        }\n    }\n    res.sort_unstable_by_key(|x| lens[x]).unwrap().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpm0eihq5m.rs:9:19\n\
    \  |\n9 |     let mut lens: HashMap<usize, String> = HashMap::new();\n  |    \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpm0eihq5m.rs:9:44\n\
    \  |\n9 |     let mut lens: HashMap<usize, String> = HashMap::new();\n  |    \
    \                                        ^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpm0eihq5m.rs:20:43\n   |\n20 |     res.sort_unstable_by_key(|x|\
    \ lens[x]).unwrap().unwrap()\n   |                                           ^^^^^^\
    \ method not found in `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0412, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    use std::cmp::Ordering;\n   \
    \ words.sort_by(|a, b| b.chars().count().cmp(&a.chars().count()).reverse())\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpxc7qarnp.rs:9:9\n\
    \  |\n9 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxc7qarnp.rs:10:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n9  |     use std::cmp::Ordering;\n10 |     words.sort_by(|a,\
    \ b| b.chars().count().cmp(&a.chars().count()).reverse())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return \"\";\n    }\n    let mut counts = words[0].chars().filter(|c| !c.is_whitespace()).counts();\n\
    \    let mut max = 0;\n    let mut index = 0;\n    for &c in words {\n       \
    \ let c = c.chars().filter(|c| !c.is_whitespace()).counts();\n        if c > count\
    \ {\n            max = count;\n            index = i;\n        }\n        if max\
    \ < c.len() {\n            max = c.len();\n            index = i;\n        }\n\
    \    }\n    return words[index];\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `count` in this scope\n  --> /tmp/tmp6gxdxjps.rs:17:16\n\
    \   |\n17 |         if c > count {\n   |                ^^^^^ help: a local variable\
    \ with a similar name exists: `counts`\n\nerror[E0425]: cannot find value `count`\
    \ in this scope\n  --> /tmp/tmp6gxdxjps.rs:18:19\n   |\n18 |             max =\
    \ count;\n   |                   ^^^^^ help: a local variable with a similar name\
    \ exists: `counts`\n\nerror[E0425]: cannot find value `i` in this scope\n  -->\
    \ /tmp/tmp6gxdxjps.rs:19:21\n   |\n19 |             index = i;\n   |         \
    \            ^ help: a local variable with a similar name exists: `c`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmp6gxdxjps.rs:23:21\n   |\n\
    23 |             index = i;\n   |                     ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6gxdxjps.rs:10:16\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n9  |   \
    \  if words.is_empty() {\n10 |         return \"\";\n   |                ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0599]: no method\
    \ named `counts` found for struct `Filter` in the current scope\n  --> /tmp/tmp6gxdxjps.rs:12:70\n\
    \   |\n12 |     let mut counts = words[0].chars().filter(|c| !c.is_whitespace()).counts();\n\
    \   |                                                                      ^^^^^^\
    \ method not found in `Filter<Chars<'_>, [closure@/tmp/tmp6gxdxjps.rs:12:46: 12:68]>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6gxdxjps.rs:15:9\n   |\n15 | \
    \    for &c in words {\n   |         ^^    ----- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `c`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .filter_map(|x| x.chars().unique().count())\n        .max()\n        .unwrap_or_else(||\
    \ \"\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpp6ujn2o1.rs:11:35\n   |\n11 |         .filter_map(|x|\
    \ x.chars().unique().count())\n   |                                   ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6ujn2o1.rs:9:5\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n9  |\
    \ /     words\n10 | |         .iter()\n11 | |         .filter_map(|x| x.chars().unique().count())\n\
    12 | |         .max()\n13 | |         .unwrap_or_else(|| \"\")\n   | |       \
    \                       ^- help: try using a conversion method: `.to_string()`\n\
    \   | |______________________________|\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    words.sort_by(|a, b| b.len() - a.len());\n    words.dedup();\n    words[1..].max()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplu88ue97.rs:10:26\n   |\n\
    10 |     words.sort_by(|a, b| b.len() - a.len());\n   |                      \
    \    ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0277]:\
    \ the size for values of type `[String]` cannot be known at compilation time\n\
    \   --> /tmp/tmplu88ue97.rs:12:16\n    |\n12  |     words[1..].max()\n    |  \
    \              ^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `[String]`\nnote: required by a bound\
    \ in `std::cmp::Ord::max`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmplu88ue97.rs:12:16\n    |\n12  |  \
    \   words[1..].max()\n    |                ^^^- supplied 0 arguments\n    |  \
    \              |\n    |                expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplu88ue97.rs:12:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n12\
    \ |     words[1..].max()\n   |     ^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found slice\n   |\n   = note: expected struct `String`\n               found\
    \ slice `[String]`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = HashMap::new();\n\
    \n    for word in words {\n        if let Some(count) = counter.entry(word.chars().count()).or_insert(0)\
    \ {\n            if count < word.chars().count() {\n                counter.entry(count).and_modify(|x|\
    \ x + 1);\n            }\n        } else {\n            counter.insert(word.chars().count(),\
    \ 1);\n        }\n    }\n\n    let max = counter.iter().max_by_key(|&(_, count)|\
    \ count);\n    max.0.to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpvhecikr2.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Sort lexicographically for\
    \ max number of characters\n    words.sort_by_key(|word| word.len());\n\n    //\
    \ Check if there are more than one words with max number of unique characters\n\
    \    if words.len() > 1 {\n        // Find the string with max number of unique\
    \ characters\n        let mut max_chars = words[0].len();\n        let mut i =\
    \ 0;\n        for word in words.iter().skip(1) {\n            if word.len() >\
    \ max_chars {\n                max_chars = word.len();\n                i = i;\n\
    \            }\n        }\n        return if i == words.len() - 1 {\n        \
    \    // There is only one word with max number of unique characters\n        \
    \    words[0]\n        } else {\n            // There are two or more words with\
    \ max number of unique characters\n            words[words.len() - i]\n      \
    \  };\n    } else {\n        // There is only one word with max number of unique\
    \ characters\n        return words[0];\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `words` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp0zr85gjq.rs:10:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |             ----- help: consider changing this to be mutable:\
    \ `mut words`\n9  |     // Sort lexicographically for max number of characters\n\
    10 |     words.sort_by_key(|word| word.len());\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmp0zr85gjq.rs:25:13\n   |\n25 |             words[0]\n   |      \
    \       ^^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmp0zr85gjq.rs:28:13\n   |\n28 |             words[words.len() - i]\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmp0zr85gjq.rs:32:16\n   |\n32 |        \
    \ return words[0];\n   |                ^^^^^^^^ move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0507, E0596.\n\
    For more information about an error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = Vec::new();\n\
    \    for w in words {\n        let mut count = counters.len();\n        for c\
    \ in w.chars() {\n            count += 1;\n        }\n        counters.push(count);\n\
    \    }\n    \n    let mut max: usize = 0;\n    let mut max_index = counters.len();\n\
    \    for (i, count) in counters.iter().enumerate() {\n        if count > max {\n\
    \            max = count;\n            max_index = i;\n        }\n    }\n    \n\
    \    words[max_index]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7gks_7a.rs:21:20\n   |\n\
    21 |         if count > max {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected `&usize`, found `usize`\n   |    \
    \                help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph7gks_7a.rs:22:19\n   |\n18 |     let mut max: usize =\
    \ 0;\n   |                  ----- expected due to this type\n...\n22 |       \
    \      max = count;\n   |                   ^^^^^ expected `usize`, found `&usize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |             max = *count;\n\
    \   |                   +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().cloned().filter(|word|\
    \ word.chars().unique().count() <= 1).max().unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmp7a5msjk6.rs:9:54\n  |\n9 |     words.iter().cloned().filter(|word|\
    \ word.chars().unique().count() <= 1).max().unwrap()\n  |                    \
    \                                  ^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.len() == 0 {\n     \
    \   return \"\";\n    }\n    let mut unique_characters = Vec::new();\n    let\
    \ mut max_unique = 0;\n    for w in words {\n        unique_characters.clear();\n\
    \        for c in w {\n            if !unique_characters.contains(&c) {\n    \
    \            unique_characters.push(&c);\n                if unique_characters.len()\
    \ > max_unique {\n                    max_unique = unique_characters.len();\n\
    \                }\n            }\n        }\n    }\n    if unique_characters.len()\
    \ > max_unique {\n        unique_characters.remove(max_unique);\n    }\n    unique_characters.sort();\n\
    \    unique_characters.reverse();\n    unique_characters.remove(0).unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6l430upj.rs:10:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     if words.len()\
    \ == 0 {\n10 |         return \"\";\n   |                ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmp6l430upj.rs:16:18\n   |\n16 |         for c in w {\n\
    \   |                  ^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6l430upj.rs:18:40\n\
    \   |\n18 |                 unique_characters.push(&c);\n   |                \
    \                        ^^ cyclic type of infinite size\n   |\nhelp: consider\
    \ removing the borrow\n   |\n18 -                 unique_characters.push(&c);\n\
    18 +                 unique_characters.push(c);\n   | \n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = \"\".to_string();\n\
    \    let mut max_len = usize::MAX;\n    for w in words {\n        let mut counter\
    \ = 0;\n        for c in w.chars() {\n            if !res.contains(&c.to_string())\
    \ {\n                counter += 1;\n            }\n        }\n        if counter\
    \ > max_len {\n            max_len = counter;\n            res = w.to_string();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmph1z75eku.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().cloned().map(|word|\
    \ {\n        let mut num_unique: usize = 0;\n        let mut word_string = word.to_string();\n\
    \        word_string.split(' ').iter().for_each(|&c|{\n            if c.is_ascii_lowercase()\n\
    \            {\n                num_unique += 1;\n            }\n        })\n\
    \        num_unique\n    }).max_by(|a, b| a.cmp(b))\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `num_unique`\n  --> /tmp/tmpxykm36av.rs:17:11\n\
    \   |\n17 |         })\n   |           ^ help: add `;` here\n18 |         num_unique\n\
    \   |         ---------- unexpected token\n\nerror[E0599]: no method named `iter`\
    \ found for struct `std::str::Split` in the current scope\n  --> /tmp/tmpxykm36av.rs:12:32\n\
    \   |\n12 |         word_string.split(' ').iter().for_each(|&c|{\n   |       \
    \                         ^^^^ method not found in `std::str::Split<'_, char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxykm36av.rs:9:5\n   |\n8  |  \
    \ fn find_max(words: Vec<String>) -> String {\n   |                          \
    \            ------ expected `String` because of return type\n9  | /     words.iter().cloned().map(|word|\
    \ {\n10 | |         let mut num_unique: usize = 0;\n11 | |         let mut word_string\
    \ = word.to_string();\n12 | |         word_string.split(' ').iter().for_each(|&c|{\n\
    ...  |\n18 | |         num_unique\n19 | |     }).max_by(|a, b| a.cmp(b))\n   |\
    \ |______________________________^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut wordmap = HashMap::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            if let\
    \ Some(&count) = get_count(c, &mut wordmap) {\n                if count > wordmap.entry(c).or_insert(0u).1\
    \ {\n                    wordmap.insert(c, count);\n                }\n      \
    \      }\n        }\n    }\n\n    let mut chars = String::new();\n    for (key,\
    \ value) in wordmap.iter() {\n        if value == wordmap.len() {\n          \
    \  chars.push_str(&key);\n        } else {\n            chars.push_str(&key);\n\
    \            chars.push_str(&value.to_string());\n        }\n    }\n    chars.to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmp72_yxnmc.rs:13:55\n\
    \   |\n13 |                 if count > wordmap.entry(c).or_insert(0u).1 {\n  \
    \ |                                                       ^^ invalid suffix `u`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \ --> /tmp/tmp72_yxnmc.rs:9:23\n  |\n9 |     let mut wordmap = HashMap::new();\n\
    \  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]:\
    \ cannot find function `get_count` in this scope\n  --> /tmp/tmp72_yxnmc.rs:12:35\n\
    \   |\n12 |             if let Some(&count) = get_count(c, &mut wordmap) {\n \
    \  |                                   ^^^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::rt::panic_count::get_count;\n\
    \   |\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp72_yxnmc.rs:21:10\n   |\n21 |     for (key, value) in wordmap.iter()\
    \ {\n   |          ^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n  --> /tmp/tmp72_yxnmc.rs:21:25\n   |\n21 |     for\
    \ (key, value) in wordmap.iter() {\n   |                         ^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: only the last element of a tuple may\
    \ have a dynamically sized type\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = words.iter().cloned().count();\n\
    \    let mut max = words.iter().cloned().count();\n    let mut result = words.iter().cloned();\n\
    \n    loop {\n        let next_max = result.next().cloned();\n        if count.cmp(&max)\
    \ == cmp::Ordering::Less {\n            return next_max.unwrap().clone();\n  \
    \      }\n        count = next_max.unwrap().count();\n        max = next_max.unwrap().count();\n\
    \        result = next_max.unwrap().iter().cloned();\n    }\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp8ydzps6r.rs:15:31\n   |\n15 |         if count.cmp(&max) == cmp::Ordering::Less\
    \ {\n   |                               ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp8ydzps6r.rs:14:38\n\
    \    |\n14  |           let next_max = result.next().cloned();\n    |        \
    \                                ^^^^^^ `Option<String>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<String>: Iterator`\n            which is required by `&mut Option<String>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::<String,\
    \ usize>::new();\n\n    for (i, word) in words.iter().enumerate() {\n        if\
    \ let Some(count) = counts.entry(word).or_insert(0) {\n            *count += 1;\n\
    \        }\n    }\n\n    let mut max_counts = counts.iter().max_by_key(|(_, count)|\
    \ *count).unwrap();\n\n    for (word, count) in max_counts {\n        if count\
    \ > 1 {\n            return word;\n        }\n    }\n\n    \"\"\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmplgyy7rta.rs:9:22\n  |\n9 |     let mut counts = HashMap::<String, usize>::new();\n\
    \  |                      ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplgyy7rta.rs:25:5\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n25 |     \"\"\n   |     ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |     |\n   |     expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_char = words[0][0].as_bytes().count();\n\
    \    let mut max_word = words[0].0[..];\n    for word in words.iter() {\n    \
    \    let c = word[0].as_bytes().count();\n        if c > max_char {\n        \
    \    max_char = c\n        }\n        if c >= max_char {\n            max_word\
    \ = word.0[..];\n        }\n    }\n    return max_word;\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpnubbszz3.rs:9:24\n  |\n9 |     let mut max_char = words[0][0].as_bytes().count();\n\
    \  |                        ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0609]: no field `0` on type `String`\n  --> /tmp/tmpnubbszz3.rs:10:33\n\
    \   |\n10 |     let mut max_word = words[0].0[..];\n   |                     \
    \            ^ unknown field\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpnubbszz3.rs:12:17\n   |\n12 |         let c =\
    \ word[0].as_bytes().count();\n   |                 ^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0609]: no field `0` on type `&String`\n  --> /tmp/tmpnubbszz3.rs:17:29\n\
    \   |\n17 |             max_word = word.0[..];\n   |                         \
    \    ^ unknown field\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   String::new()\n    } else {\n        let mut counts = HashMap::new();\n  \
    \      for word in words {\n            for ch in word.chars() {\n           \
    \     counts\n                    .entry(ch)\n                    .or_insert(0)\n\
    \                    .cloned()\n                    .compare_to(&*counts.get(&ch.to_string())).unwrap();\n\
    \            }\n        }\n        let mut max_key = String::new();\n        let\
    \ mut max_val = String::new();\n        max_key = words[0].to_string();\n    \
    \    max_val = words[0].to_string();\n        for i in 1..words.len() {\n    \
    \        if counts.get(&words[i].to_string()) > counts.get(&max_key) {\n     \
    \           max_key = words[i].to_string();\n                max_val = max_key;\n\
    \            }\n        }\n        max_val\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1pdj2gcj.rs:12:26\n   |\n12 |         let mut counts = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut seen = HashMap::new();\n\
    \    for word in words {\n        let mut count = seen.entry(word[0]).or_insert(0);\n\
    \        *count += 1;\n        seen.entry(word[0]).or_insert(count);\n    }\n\
    \    let mut max_length = 0;\n    let mut max_key = \"\";\n    for (key, val)\
    \ in seen.iter() {\n        if val > max_length {\n            max_length = val;\n\
    \            max_key = key;\n        }\n    }\n    max_key\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp_toh_uc0.rs:9:20\n  |\n9 |     let mut seen = HashMap::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_toh_uc0.rs:11:36\n\
    \   |\n11 |         let mut count = seen.entry(word[0]).or_insert(0);\n   |  \
    \                                  ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp_toh_uc0.rs:13:20\n   |\n13 |         seen.entry(word[0]).or_insert(count);\n\
    \   |                    ^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_toh_uc0.rs:23:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n23\
    \ |     max_key\n   |     ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struc"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = HashMap::new();\n\
    \    for w in words {\n        count.entry(w.to_lowercase()).or_insert(0);\n \
    \       count = count.entry(w.to_lowercase()).or_insert(0);\n    }\n\n    for\
    \ &(_, v) in count.iter() {\n        if *v > words[0][0].len() {\n           \
    \ return *v;\n        }\n    }\n\n    \"\"\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpyg173kpr.rs:9:21\n  |\n9 |     let mut count = HashMap::new();\n  |\
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyg173kpr.rs:16:17\n\
    \   |\n16 |         if *v > words[0][0].len() {\n   |                 ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyg173kpr.rs:21:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n21\
    \ |     \"\"\n   |     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words_to_chars(words).map(|words|\
    \ {\n        let mut max = String::new();\n        let mut current_max = String::new();\n\
    \        for word in words {\n            match word.chars().filter(|&c| c.is_ascii()).count(),\
    \ word.chars().filter(|&c| !c.is_ascii()).count() {\n                // if words\
    \ with same number of unique characters exist, take the first one alphabetically\n\
    \                // if words with same number of unique characters don't exist,\
    \ take the first alphabetically\n                (Some(n), Some(0)) => current_max\
    \ = Some(word),\n                (Some(n), None) => current_max = Some(word.chars().filter(|&c|\
    \ c.is_ascii()).collect()),\n                (None, Some(0)) => current_max =\
    \ Some(word.chars().filter(|&c| !c.is_ascii()).collect()),\n                (None,\
    \ None) => current_max = Some(word.chars().filter(|&c| !c.is_ascii()).collect()),\n\
    \                (_, _) => current_max = Some(word.chars().filter(|&c| !c.is_ascii()).collect()),\n\
    \            }\n            if n == 0 {\n                continue;\n         \
    \   }\n            if word.chars().filter(|&c| c.is_ascii()).count() > max {\n\
    \                max = word.chars().filter(|&c| c.is_ascii()).count();\n     \
    \       }\n        }\n        if max != \"\" {\n            Some(current_max)\n\
    \        } else {\n            None\n        }\n    }).unwrap_or(\"\")\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `,`\n  -->\
    \ /tmp/tmpvyzhzjkn.rs:13:65\n   |\n13 |             match word.chars().filter(|&c|\
    \ c.is_ascii()).count(), word.chars().filter(|&c| !c.is_ascii()).count() {\n \
    \  |             ----- while parsing this `match` expression         ^ expected\
    \ one of `.`, `?`, `{`, or an operator\n\nerror[E0425]: cannot find function `words_to_chars`\
    \ in this scope\n --> /tmp/tmpvyzhzjkn.rs:9:5\n  |\n9 |     words_to_chars(words).map(|words|\
    \ {\n  |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .map(|word| {\n            let mut char_counter = HashMap::new();\n \
    \           for c in word.chars() {\n                char_counter.insert(c, char_counter.get(&c).unwrap_or(0)\
    \ + 1);\n            }\n            (char_counter.iter()\n                 .max()\n\
    \                 .unwrap_or(0), word)\n        })\n        .filter(|(_, word)|\
    \ word != \"\")\n        .next()\n        .unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6octc37j.rs:12:36\n   |\n12 |             let mut char_counter = HashMap::new();\n\
    \   |                                    ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6octc37j.rs:9:5\n   |\n\
    8  |   fn find_max(words: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n9  | /    \
    \ words\n10 | |         .into_iter()\n11 | |         .map(|word| {\n12 | |   \
    \          let mut char_counter = HashMap::new();\n...  |\n21 | |         .next()\n\
    22 | |         .unwrap()\n   | |_________________^ expected struct `String`, found\
    \ tuple\n   |\n   = note: expected struct `String`\n               found tuple\
    \ `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = vec![0; words.len()];\n\
    \    for (word, idx) in words.iter().zip(counts.iter_mut()) {\n        *idx =\
    \ 1;\n        for c in word.chars() {\n            if *idx + 1 < counts[*idx]\
    \ {\n                *idx = *idx + 1;\n            }\n        }\n    }\n    let\
    \ mut max = String::new();\n    for i in counts[counts.len() - 1].iter() {\n \
    \       if i != 0 {\n            if counts[counts.len() - 1] < i {\n         \
    \       max = words[counts.len() - 1];\n                break;\n            }\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpclg6vk_g.rs:19:39\n   |\n19 |     for i in counts[counts.len()\
    \ - 1].iter() {\n   |                                       ^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_chars = String::new();\n\
    \    words.iter().fold(String::new(), |mut acc, str| {\n        for c in str {\n\
    \            if !unique_chars.is_empty() {\n                if acc.chars().count()\
    \ == unique_chars.chars().count() {\n                    return acc;\n       \
    \         }\n            }\n            unique_chars.push_str(c);\n        }\n\
    \        acc.push_str(str);\n        acc\n    });\n    if words.len() < unique_chars.len()\
    \ {\n        \"\".to_string()\n    } else {\n        unique_chars\n    }\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpga6v6148.rs:11:18\n\
    \   |\n11 |         for c in str {\n   |                  ^^^ `&String` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_char = char::MAX;\n\
    \    let mut max_word = String::new();\n\n    for word in words {\n        let\
    \ mut unique_char = 0;\n        for c in word.chars() {\n            if *c !=\
    \ max_char {\n                unique_char += 1;\n            }\n        }\n  \
    \      if unique_char > max_char {\n            max_char = unique_char;\n    \
    \        max_word = word;\n        }\n    }\n\n    if max_char == char::MAX &&\
    \ max_word.is_empty() {\n        return \"\".to_string();\n    }\n\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp393yqk99.rs:15:16\n\
    \   |\n15 |             if *c != max_char {\n   |                ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp393yqk99.rs:19:26\n   |\n19 |         if unique_char\
    \ > max_char {\n   |                          ^^^^^^^^ expected integer, found\
    \ `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmp393yqk99.rs:19:24\n\
    \   |\n19 |         if unique_char > max_char {\n   |                        ^\
    \ no implementation for `{integer} < char` and `{integer} > char`\n   |\n   =\
    \ help: the trait `PartialOrd<char>` is not implemented for `{integer}`\n   =\
    \ help: the following other types implement trait `PartialOrd<Rhs>`:\n       \
    \      f32\n             f64\n             i128\n             i16\n          \
    \   i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp393yqk99.rs:20:24\n\
    \   |\n9  |     let mut max_char = char::MAX;\n   |                        ---------\
    \ expected due to this value\n...\n20 |             max_char = unique_char;\n\
    \   |                        ^^^^^^^^^^^ expected `char`, found integer\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter()\n        .map(|x|\
    \ x.chars().unique().count())\n        .max()\n        .unwrap()\n        .to_ascii_lowercase()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl7jc_0ph.rs:10:28\n   |\n10 |         .map(|x|\
    \ x.chars().unique().count())\n   |                            ^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max: usize = 0;\n   \
    \ let mut word: String = String::new();\n    for word in words {\n        match\
    \ word.chars().filter(|c| c.is_ascii_lowercase().is_ok()).count() {\n        \
    \    1 => {\n                max = word.len() - 1;\n                word.clear();\n\
    \            }\n            _ => {\n                max = word.chars().filter(|c|\
    \ c.is_ascii_lowercase().is_ok()).count() as usize - 1;\n                word.clear();\n\
    \            }\n        }\n        if max > word.length() {\n            word\
    \ = word;\n        }\n    }\n    if max < word.length() {\n        word\n    }\
    \ else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ok` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp22opqs4n.rs:12:62\n   |\n12 |         match word.chars().filter(|c|\
    \ c.is_ascii_lowercase().is_ok()).count() {\n   |                            \
    \                                  ^^^^^ method not found in `bool`\n\nerror[E0599]:\
    \ no method named `is_ok` found for type `bool` in the current scope\n  --> /tmp/tmp22opqs4n.rs:18:70\n\
    \   |\n18 |                 max = word.chars().filter(|c| c.is_ascii_lowercase().is_ok()).count()\
    \ as usize - 1;\n   |                                                        \
    \              ^^^^^ method not found in `bool`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmp22opqs4n.rs:22:23\n\
    \   |\n22 |         if max > word.length() {\n   |                       ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp22opqs4n.rs:26:19\n   |\n26 |     if max < word.length() {\n   |   \
    \                ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return String::new();\n    }\n\n    let mut char_count = vec![String::new();\
    \ words.len()];\n    let mut unique_chars = vec![String::new(); words.len()];\n\
    \n    let mut max_count = 0;\n\n    for (i, word) in words.iter().enumerate()\
    \ {\n        for c in word.chars() {\n            char_count[i].push(c); // count\
    \ each unique letter\n            unique_chars[i].push(c); // store each unique\
    \ letter\n\n            if unique_chars[i].len() > max_count {\n             \
    \   max_count = unique_chars[i].len();\n            }\n        }\n    }\n\n  \
    \  unique_chars\n        .iter()\n        .take_while(|&x| x.len() == max_count)\
    \ // remove excess unique characters\n        .next()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi5mgg3z.rs:29:5\n   |\n\
    8  |   fn find_max(words: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n...\n29 | /\
    \     unique_chars\n30 | |         .iter()\n31 | |         .take_while(|&x| x.len()\
    \ == max_count) // remove excess unique characters\n32 | |         .next()\n \
    \  | |_______________^ expected struct `String`, found enum `Option`\n   |\n \
    \  = note: expected struct `String`\n                found enum `Option<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_count = words.iter().cloned().count();\n\
    \    let mut max_word = String::new();\n    for word in words {\n        if max_count\
    \ > words.iter().cloned().count() {\n            break;\n        }\n        let\
    \ count = word.chars().cloned().count();\n        if count > max_count {\n   \
    \         max_count = count;\n            max_word = word.to_owned();\n      \
    \  }\n    }\n    return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpp16k3as0.rs:15:34\n     |\n15   |         let count = word.chars().cloned().count();\n\
    \     |                                  ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `count`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpp16k3as0.rs:15:43\n   |\n15 |           let count = word.chars().cloned().count();\n\
    \   |                                             ^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|word| {\n \
    \       word.chars().filter(|c| c.is_unique()).count()\n    }).max_by_key(|x|\
    \ x).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_unique` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpvmbs81m8.rs:10:35\n   |\n10 |         word.chars().filter(|c|\
    \ c.is_unique()).count()\n   |                                   ^^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmbs81m8.rs:9:5\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n9  |\
    \ /     words.iter().map(|word| {\n10 | |         word.chars().filter(|c| c.is_unique()).count()\n\
    11 | |     }).max_by_key(|x| x).unwrap()\n   | |                             \
    \    ^- help: try using a conversion method: `.to_string()`\n   | |_________________________________|\n\
    \   |                                   expected struct `String`, found `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|word| word.chars().count()).max()\n\
    \        .unwrap()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmpqohj8tz_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut set = HashSet::new();\n\
    \    for word in words {\n        set.insert(word.chars().count());\n    }\n \
    \   set.iter().max_by_key(|&i| i).unwrap().to_string()\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp7hqyy1u2.rs:9:19\n  |\n9 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().fold(\"\", |mut\
    \ a, word| {\n        if a.chars().count() < word.chars().count() {\n        \
    \    a\n        } else {\n            word\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp24vx5do1.rs:9:23\n  |\n9 |\
    \     words.iter().fold(\"\", |mut a, word| {\n  |                       ^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                       |\n\
    \  |                       expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp24vx5do1.rs:13:13\n   |\n13 |             word\n\
    \   |             ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |             |\n   |             expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .fold(\"\".to_string(), |mut max, word| {\n            let mut count: usize\
    \ = 0;\n            for c in word.chars() {\n                if *c != *max {\n\
    \                    count += 1;\n                }\n            }\n         \
    \   max = if count > 0 { word } else { \"\".to_string() };\n            max\n\
    \        })\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpja0n1p2h.rs:14:20\n\
    \   |\n14 |                 if *c != *max {\n   |                    ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpja0n1p2h.rs:18:34\n   |\n18 |             max\
    \ = if count > 0 { word } else { \"\".to_string() };\n   |                   \
    \               ^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                                  |\n   |                                 \
    \ expected struct `String`, found `&String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|word| word.chars().count())\n        .max()\n        .unwrap()\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfy8adjew.rs:9:5\n   |\n8\
    \  |   fn find_max(words: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n9  | /    \
    \ words\n10 | |         .iter()\n11 | |         .map(|word| word.chars().count())\n\
    12 | |         .max()\n13 | |         .unwrap()\n   | |                 ^- help:\
    \ try using a conversion method: `.to_string()`\n   | |_________________|\n  \
    \ |                   expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter: HashMap<String,\
    \ usize> = HashMap::new();\n\n    for word in words {\n        for c in word.chars()\
    \ {\n            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n\n   \
    \ match counter.iter().max_by(|a, b| a.1.cmp(&b.1)) {\n        Some(&(word, _))\
    \ -> word,\n        None => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `if`, or `|`, found `->`\n  --> /tmp/tmpkl8w8qn1.rs:18:26\n\
    \   |\n18 |         Some(&(word, _)) -> word,\n   |                          ^^\n\
    \   |                          |\n   |                          expected one of\
    \ `=>`, `if`, or `|`\n   |                          help: try using a fat arrow\
    \ here: `=>`\n\nerror[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpkl8w8qn1.rs:9:22\n\
    \  |\n9 |     let mut counter: HashMap<String, usize> = HashMap::new();\n  | \
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpkl8w8qn1.rs:9:47\n\
    \  |\n9 |     let mut counter: HashMap<String, usize> = HashMap::new();\n  | \
    \                                              ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpkl8w8qn1.rs:13:43\n\
    \   |\n13 |             counter.entry(c).or_insert(0) += 1;\n   |            \
    \ ----------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .filter_map(|word| word.chars().distinct().count())\n        .max()\n   \
    \     .unwrap_or(0)\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `distinct` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp412y52xv.rs:11:41\n   |\n11 |         .filter_map(|word|\
    \ word.chars().distinct().count())\n   |                                     \
    \    ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp412y52xv.rs:13:20\n   |\n13 |         .unwrap_or(0)\n   |     \
    \               ^- help: try using a conversion method: `.to_string()`\n   | \
    \                   |\n   |                    expected struct `String`, found\
    \ integer\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    let mut unique_set = HashSet::new();\n    for w in words {\n        unique_set.insert(w.chars().map(|c|\
    \ c.to_string()).collect::<String>());\n    }\n    for w in words {\n        if\
    \ unique_set.iter().filter(|c| c == w.chars().map(|c| c.to_string()).collect::<String>()).count()\
    \ > 1 {\n            break;\n        }\n        res.push_str(w.to_string());\n\
    \    }\n    if unique_set.len() > 1 {\n        find_max(words[0..words.len()])\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmps9_b94z2.rs:10:26\n   |\n10 |     let mut unique_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps9_b94z2.rs:18:22\n   |\n18 |         res.push_str(w.to_string());\n\
    \   |                      ^^^^^^^^^^^^^\n   |                      |\n   |  \
    \                    expected `&str`, found struct `String`\n   |            \
    \          help: consider borrowing here: `&w.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps9_b94z2.rs:21:18\n   |\n21 |         find_max(words[0..words.len()])\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                  |\n   |                  expected struct\
    \ `Vec`, found slice\n   |\n   = note: expected struct `Vec<String>`\n       \
    \        found slice `[String]`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut result = String::new();\n\
    \    let mut unique_chars = 0;\n    for word in words {\n        for c in word.chars()\
    \ {\n            if !result.contains(&c) {\n                result.push_str(&c);\n\
    \                unique_chars += 1;\n            }\n        }\n    }\n    if unique_chars\
    \ > result.len() {\n        \"\"\n    } else {\n        result\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp1botw17k.rs:13:33\n\
    \     |\n13   |             if !result.contains(&c) {\n     |                \
    \        -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     | \
    \                       |\n     |                        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n13   |         \
    \    if !result.contains(*&c) {\n     |                                 +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1botw17k.rs:14:33\n   |\n14 |  \
    \               result.push_str(&c);\n   |                                 ^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1botw17k.rs:20:9\n   |\n8  | fn find_max(words: Vec<String>) -> String\
    \ {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n20 |         \"\"\n   |         ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |         |\n   |         expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut set = HashSet::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            if let\
    \ Some(_) = set.insert(c) {\n                return word.clone(); // Found a repeated\
    \ char.\n            }\n        }\n    }\n    \"\"\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp452un7ne.rs:9:19\n  |\n9 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp452un7ne.rs:17:5\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n17 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_count = HashMap::new();\n\
    \    let mut max_count = 0;\n    let mut max_word = String::new();\n    for word\
    \ in words {\n        let mut unique_count = HashMap::new();\n        for char\
    \ in word.chars() {\n            if unique_count.contains_key(&char) {\n     \
    \           unique_count.insert(char, 0);\n            } else {\n            \
    \    unique_count.insert(char, 1);\n            }\n        }\n        if unique_count.len()\
    \ > max_count {\n            max_count = unique_count.len();\n            max_word\
    \ = word.clone();\n        }\n    }\n    if max_count == 0 {\n        return \"\
    \";\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpxz664iqx.rs:9:28\n  |\n9 |     let mut unique_count = HashMap::new();\n\
    \  |                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxz664iqx.rs:13:32\n\
    \   |\n13 |         let mut unique_count = HashMap::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxz664iqx.rs:27:16\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n27 |         return \"\";\n   |      \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \           |\n   |                expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = vec![0; words.len()];\n\
    \    for word in words {\n        for c in word.chars() {\n            counters[c]\
    \ += 1;\n        }\n    }\n\n    words[counters.iter().max_by_key(|&c| c).unwrap()]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `char`\n  -->\
    \ /tmp/tmpe19n7ugq.rs:12:13\n   |\n12 |             counters[c] += 1;\n   |  \
    \           ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[String]` cannot be indexed\
    \ by `&{integer}`\n  --> /tmp/tmpe19n7ugq.rs:16:5\n   |\n16 |     words[counters.iter().max_by_key(|&c|\
    \ c).unwrap()]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `&{integer}`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&{integer}>` for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    use std::collections::HashMap;\n\
    \    let mut result = String::new();\n    result.clear();\n    words.sort_by_key(|w|\
    \ w.chars().count());\n    for word in words {\n        let count = word.chars().count();\n\
    \        if result.len() < count {\n            result = word;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::collections::HashMap`\n --> /tmp/tmparvk_4js.rs:9:9\n\
    \  |\n9 |     use std::collections::HashMap;\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0596]: cannot\
    \ borrow `words` as mutable, as it is not declared as mutable\n  --> /tmp/tmparvk_4js.rs:12:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |             -----\
    \ help: consider changing this to be mutable: `mut words`\n...\n12 |     words.sort_by_key(|w|\
    \ w.chars().count());\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .fold(String::new(), |mut acc, w| {\n            acc.into_iter().map(|c|\
    \ if acc.contains(&c) { c } else { c }).collect::<Vec<String>>()\n           \
    \     .iter()\n                .cloned()\n                .map(|c| {\n       \
    \             c.chars().unique().filter(|c| *c == 0).count() as u32\n        \
    \        })\n                .max().to_string()\n        })\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp6oubsh_l.rs:12:17\n    |\n12\
    \  |               acc.into_iter().map(|c| if acc.contains(&c) { c } else { c\
    \ }).collect::<Vec<String>>()\n    |                   ^^^^^^^^^\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count = String::new();\n\
    \    for word in words.iter() {\n        if count.len() < word.len() {\n     \
    \       count = word.clone();\n        }\n    }\n    if count.len() == 0 {\n \
    \       return \"\";\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0m6l7x6q.rs:16:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n16 |     \
    \    return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   \"\".to_string()\n    }\n\n    let mut unique_characters = String::new();\n\
    \n    for word in words {\n        for character in word.chars() {\n         \
    \   if !unique_characters.contains(&character) {\n                unique_characters.push_str(&character);\n\
    \            }\n        }\n    }\n\n    if unique_characters.len() > words.len()\
    \ {\n        \"\".to_string()\n    } else {\n        words.iter()\n          \
    \  .zip(unique_characters.iter())\n            .max_by(|(word, character)| word.chars().count(char::from_u32(character.code())))\n\
    \            .unwrap()\n            .to_string()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_ezvtnx.rs:10:9\n   |\n\
    9  | /     if words.is_empty() {\n10 | |         \"\".to_string()\n   | |    \
    \     ^^^^^^^^^^^^^^ expected `()`, found struct `String`\n11 | |     }\n   |\
    \ |_____- expected this to be `()`\n   |\nhelp: consider using a semicolon here\n\
    \   |\n10 |         \"\".to_string();\n   |                       +\nhelp: consider\
    \ using a semicolon here\n   |\n11 |     };\n   |      +\nhelp: you might have\
    \ meant to return this value\n   |\n10 |         return \"\".to_string();\n  \
    \ |         ++++++               +\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmpm_ezvtnx.rs:17:44\n     |\n17   |            \
    \ if !unique_characters.contains(&character) {\n     |                       \
    \            -------- ^^^^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                                   |\n     |                          \
    \         required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n     = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n17   |             if !unique_characters.contains(*&character)\
    \ {\n     |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm_ezvtnx.rs:18:44\n   |\n18 |                 unique_characters.push_str(&character);\n\
    \   |                                            ^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0599]: no method named `iter` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpm_ezvtnx.rs:27:36\n   |\n27 |             .zip(unique_characters.iter())\n\
    \   |                                    ^^^^ method not found in `String`\n \
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    match words {\n        vec![word]=>\
    \ {\n            let mut char_set = HashMap::new();\n            for w in word.to_string().chars().collect::<Vec<_>>()\
    \ {\n                char_set.set(w, char_set.get(w).unwrap_or_else(|| 1));\n\
    \            }\n            char_set\n                .iter()\n              \
    \  .max_by_key(|(_, v)| v)\n                .expect(\"No string contains any characters\
    \ that appear more than once\");\n        }\n        vec![] => String::new(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmpxwd_ay6g.rs:10:14\n\
    \   |\n10 |         vec![word]=> {\n   |              ^^^^ help: a local variable\
    \ with a similar name exists: `words`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmpxwd_ay6g.rs:11:32\n   |\n11 |  \
    \           let mut char_set = HashMap::new();\n   |                         \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot find\
    \ value `word` in this scope\n  --> /tmp/tmpxwd_ay6g.rs:12:22\n   |\n12 |    \
    \         for w in word.to_string().chars().collect::<Vec<_>>() {\n   |      \
    \                ^^^^ help: a local variable with a similar name exists: `words`\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpxwd_ay6g.rs:10:9\n\
    \   |\n10 |         vec![word]=> {\n   |         ^^^^^^^^^^\n   |\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmpxwd_ay6g.rs:20:9\n   |\n20 |         vec![] => String::new(),\n\
    \   |         ^^^^^^\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxwd_ay6g.rs:10:22\n   |\n10 |           vec![word]=>\
    \ {\n   |  ______________________^\n11 | |             let mut char_set = HashMap::new();\n\
    12 | |             for w in word.to_string().chars().collect::<Vec<_>>() {\n13\
    \ | |                 char_set.set(w, char_set.get(w).unwrap_or_else(|| 1));\n\
    ...  |\n18 | |                 .expect(\"No string contains any characters that\
    \ appear more than once\");\n19 | |         }\n   | |_________^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    let mut chars_seen: HashSet<String> = HashSet::new();\n    for word in words.iter()\
    \ {\n        chars_seen.insert(word);\n    }\n\n    while !chars_seen.is_empty()\
    \ {\n        let mut max: Option<String> = if chars_seen.len() > 1 {\n       \
    \     Some(\n                chars_seen\n                    .iter()\n       \
    \             .filter(|c| !chars_seen.insert(c).is_ok())\n                   \
    \ .max_by(|a, b| a.len() < b.len())\n                    .unwrap_or_else(|| \"\
    \"),\n            )\n        } else {\n            None\n        };\n        let\
    \ mut curr_max: Option<String> = max.map(|w| w.to_owned());\n        let mut curr_word:\
    \ Option<String> = words.iter().find(|w| w.to_owned() == curr_max.unwrap());\n\
    \        while curr_word {\n            if curr_word.as_ref().len() < curr_max.unwrap().len()\
    \ {\n                chars_seen.remove(curr_word.as_ref());\n                max\
    \ = Some(curr_word.as_ref());\n                curr_max = Some(curr_max.unwrap());\n\
    \            }\n            curr_word = words.iter().find(|w| w.to_owned() ==\
    \ curr_max.unwrap());\n        }\n        if let Some(mut curr_max) = (max) {\n\
    \            res = curr_max.unwrap() + &mut res;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpc72mnvyc.rs:10:25\n\
    \   |\n10 |     let mut chars_seen: HashSet<String> = HashSet::new();\n   |  \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpc72mnvyc.rs:10:43\n\
    \   |\n10 |     let mut chars_seen: HashSet<String> = HashSet::new();\n   |  \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nwarning: unnecessary parentheses around `let` scrutinee expression\n\
    \  --> /tmp/tmpc72mnvyc.rs:37:37\n   |\n37 |         if let Some(mut curr_max)\
    \ = (max) {\n   |                                     ^   ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    37 -         if let Some(mut curr_max) = (max) {\n37 +         if let Some(mut\
    \ curr_max) = max {\n   | \n\nerror[E0277]: can't compare `&String` with `String`\n\
    \  --> /tmp/tmpc72mnvyc.rs:28:80\n   |\n28 |         let mut curr_word: Option<String>\
    \ = words.iter().find(|w| w.to_owned() == curr_max.unwrap());\n   |          \
    \                                                                      ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc72mnvyc.rs:28:45\n\
    \   |\n28 |         let mut curr_word: Option<String> = words.iter().find(|w|\
    \ w.to_owned() == curr_m"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = vec![String::new();\
    \ words.len()];\n    for w in words {\n        counts[w.chars().filter(|c| *c).count().min(2)]\
    \ += w.to_owned();\n    }\n    let mut max_length = 0;\n    let mut max_length_word:\
    \ Option<String> = None;\n    for c in counts.iter() {\n        if *c > max_length\
    \ {\n            max_length = *c;\n            max_length_word = Some(\n     \
    \           words.iter().find(|w| w.chars().filter(|c| *c == c).count() == *c).unwrap()\n\
    \            );\n        }\n    }\n    max_length_word.unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpva5t5xcr.rs:11:37\n   |\n\
    11 |         counts[w.chars().filter(|c| *c).count().min(2)] += w.to_owned();\n\
    \   |                                     ^^ expected `bool`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpva5t5xcr.rs:11:60\n   |\n11 |  \
    \       counts[w.chars().filter(|c| *c).count().min(2)] += w.to_owned();\n   |\
    \                                                            ^^^^^^^^^^^^\n  \
    \ |                                                            |\n   |       \
    \                                                     expected `&str`, found struct\
    \ `String`\n   |                                                            help:\
    \ consider borrowing here: `&w.to_owned()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpva5t5xcr.rs:16:17\n   |\n16 |         if *c > max_length {\n  \
    \ |                 ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                 |\n   |                 expected struct `String`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpva5t5xcr.rs:17:26\n\
    \   |\n13 |     let mut max_length = 0;\n   |                          - expected\
    \ due to this value\n...\n17 |             max_length = *c;\n   |            \
    \              ^^ expected integer, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpva5t5xcr.rs:19:66\n   |\n19 |                 words.iter().find(|w|\
    \ w.chars().filter(|c| *c == c).count() == *c).unwrap()\n   |                \
    \                                                  ^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |                 words.iter().find(|w|\
    \ w.chars().filter(|c| *c == *c).count() == *c).unwrap()\n   |               \
    \                                                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpva5t5xcr.rs:19:80\n   |\n19 |                 words.iter().find(|w|\
    \ w.chars().filter(|c| *c == c).count() == *c).unwrap()\n   |                \
    \                                                                ^^ expected `usize`,\
    \ found struct `String"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|s| s.chars().count_unique()).max()\n\
    \        .unwrap_or_else(|| \"\")\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_unique` found for struct `Chars` in\
    \ the current scope\n --> /tmp/tmp47v3qwme.rs:9:36\n  |\n9 |     words.iter().map(|s|\
    \ s.chars().count_unique()).max()\n  |                                    ^^^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp47v3qwme.rs:9:5\n\
    \   |\n8  |   fn find_max(words: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n9  |\
    \ /     words.iter().map(|s| s.chars().count_unique()).max()\n10 | |         .unwrap_or_else(||\
    \ \"\")\n   | |                              ^- help: try using a conversion method:\
    \ `.to_string()`\n   | |______________________________|\n   |                \
    \                expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        if max < words.len() {\n      \
    \      // Found a word with a unique character in lexicographical order.\n   \
    \         // Update max with the current word length.\n            max = i;\n\
    \        }\n        // Increment index by one\n        i += 1;\n    }\n    //\
    \ If max is greater than or equal to number of words,\n    // then there are no\
    \ words with the maximum number of unique characters.\n    // Return the empty\
    \ string.\n    if max >= words.len() {\n        return String::new();\n    }\n\
    \    // Return the word with maximum number of unique characters.\n    words[max]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpsjf8e6nz.rs:27:5\n\
    \   |\n27 |     words[max]\n   |     ^^^^^^^^^^ move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|x| x.chars().count())\n        .max()\n        .cloned()\n        .ok_or(format!(\"\
    No word with max number of unique characters: {:?}\", words))\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpumoncgk2.rs:13:10\n\
    \    |\n13  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    words.sort();\n    let mut max_cnt = 0;\n    let mut max_word = String::new();\n\
    \n    for i in 0..words.len() {\n        if words[i].chars().count() > max_cnt\
    \ {\n            max_cnt = words[i].chars().count();\n            max_word = words[i];\n\
    \        }\n    }\n    if max_cnt == 0 {\n        String::new()\n    } else {\n\
    \        max_word\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpyxs9jf7u.rs:17:24\n\
    \   |\n17 |             max_word = words[i];\n   |                        ^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut s = String::new();\n\
    \    for &word in words {\n        let mut n = word.chars().filter(|&c| c.is_ascii_lowercase()).count();\n\
    \        if n > s.len() {\n            s = word;\n        }\n    }\n    s.to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7hcbqm0.rs:10:9\n   |\n\
    10 |     for &word in words {\n   |         ^^^^^    ----- this expression has\
    \ type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `word`\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .map(|w| w.chars().distinct().count())\n        .max_by(|a, b| a.cmp(b))\n\
    \        .unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `distinct` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpo9kgj23h.rs:11:28\n   |\n11 |         .map(|w|\
    \ w.chars().distinct().count())\n   |                            ^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .group_by(|&word| word.chars().count())\n        .max_by(|&(count, words)|\
    \ count)\n        .unwrap_or_else(|| \"\".to_string())\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp7d758dym.rs:11:10\n   |\n11 |         .group_by(|&word|\
    \ word.chars().count())\n   |          ^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ String>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut char_counts = vec![0;\
    \ words.len()];\n    for (i, word) in words.iter().enumerate() {\n        for\
    \ c in word.chars() {\n            char_counts[i] += 1;\n            if char_counts[i]\
    \ > char_counts.last().unwrap() {\n                char_counts[i] = 0;\n     \
    \       }\n        }\n    }\n\n    let mut max_idx = 0;\n    let mut max_val =\
    \ char_counts[max_idx];\n    for (i, count) in char_counts.iter().enumerate()\
    \ {\n        if count > max_val {\n            max_val = count;\n            max_idx\
    \ = i;\n        }\n    }\n\n    words[max_idx]\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `{integer}` with `&{integer}`\n  --> /tmp/tmprpj3v1lz.rs:13:31\n\
    \   |\n13 |             if char_counts[i] > char_counts.last().unwrap() {\n  \
    \ |                               ^ no implementation for `{integer} < &{integer}`\
    \ and `{integer} > &{integer}`\n   |\n   = help: the trait `PartialOrd<&{integer}>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprpj3v1lz.rs:22:20\n   |\n22 |         if count > max_val {\n   |   \
    \                 ^^^^^^^\n   |                    |\n   |                   \
    \ expected reference, found integer\n   |                    help: consider borrowing\
    \ here: `&max_val`\n   |\n   = note: expected reference `&_`\n               \
    \    found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpj3v1lz.rs:23:23\n\
    \   |\n20 |     let mut max_val = char_counts[max_idx];\n   |                \
    \       -------------------- expected due to this value\n...\n23 |           \
    \  max_val = count;\n   |                       ^^^^^ expected integer, found\
    \ `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |    \
    \         max_val = *count;\n   |                       +\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \    for word in words.iter() {\n        let mut counter = 0;\n        for c in\
    \ word.chars() {\n            if !map.contains_key(&c) {\n                map.insert(c,\
    \ 0);\n            }\n            map.entry(c).or_default() += 1;\n          \
    \  counter += 1;\n        }\n        if counter > map.len() {\n            continue;\n\
    \        }\n        let mut max_key = word;\n        let mut max_val = 0;\n  \
    \      for (c, v) in map.iter().by_ref().take(counter) {\n            if v > max_val\
    \ {\n                max_val = v;\n                max_key = &c;\n           \
    \ }\n        }\n        return max_key;\n    }\n    \"\"\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp2cpaluwd.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp2cpaluwd.rs:16:39\n   |\n16 |  \
    \           map.entry(c).or_default() += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2cpaluwd.rs:30:16\n   |\n30 |  \
    \       return max_key;\n   |                ^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cpaluwd.rs:32:5\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n32\
    \ |     \"\"\n   |     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut hash: HashSet<usize>\
    \ = HashSet::new();\n    for w in words {\n        hash.add(w.chars().filter(|c|\
    \ *c != ' ').count());\n    }\n    let mut max_key: usize = 0;\n    let mut max_value:\
    \ usize = 0;\n    for k in hash {\n        if k > max_value {\n            max_value\
    \ = k;\n            max_key = k;\n        }\n    }\n    if max_key == max_value\
    \ {\n        \"\".to_string()\n    } else {\n        words[max_key]\n    }\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp0_dt2mmp.rs:9:19\n\
    \  |\n9 |     let mut hash: HashSet<usize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp0_dt2mmp.rs:9:36\n  |\n9 |  \
    \   let mut hash: HashSet<usize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // TODO: Write a function that\
    \ accepts a list of strings, and returns the\n    // word with maximum number\
    \ of unique characters.\n    if words.is_empty() {\n        return \"\";\n   \
    \ }\n    let mut max_unique = 0;\n    let mut max_unique_word = String::new();\n\
    \    for word in words {\n        let mut temp_unique = word.chars().filter(|&c|\
    \ c != ' ').count();\n        if temp_unique > max_unique {\n            max_unique\
    \ = temp_unique;\n            max_unique_word = word;\n        }\n    }\n    return\
    \ max_unique_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7reh79mf.rs:12:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n12 |     \
    \    return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count: usize = 0;\n \
    \   let mut max_chars = 1;\n    for (i, word) in words.iter().enumerate() {\n\
    \        count = word.chars().filter(|c| c != ' ').count();\n        if count\
    \ > max_chars {\n            max_chars = count;\n        }\n    }\n    if max_chars\
    \ > 1 {\n        let mut max: String;\n        if words.len() > 2 {\n        \
    \    for (i, word) in words.iter().enumerate() {\n                if i > 0 &&\
    \ word.chars().filter(|c| c != ' ').count() == words.last().chars().filter(|c|\
    \ c != ' ').count() {\n                    break;\n                }\n       \
    \     }\n        }\n        max = words.first();\n        for word in words {\n\
    \            if word.chars().filter(|c| c != ' ').count() > max.chars().filter(|c|\
    \ c != ' ').count() {\n                max = word;\n            }\n        }\n\
    \        max\n    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzll7ulqa.rs:12:43\n\
    \   |\n12 |         count = word.chars().filter(|c| c != ' ').count();\n   | \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzll7ulqa.rs:21:55\n   |\n21 |   \
    \              if i > 0 && word.chars().filter(|c| c != ' ').count() == words.last().chars().filter(|c|\
    \ c != ' ').count() {\n   |                                                  \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `chars` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpzll7ulqa.rs:21:87\n   |\n21 |          \
    \       if i > 0 && word.chars().filter(|c| c != ' ').count() == words.last().chars().filter(|c|\
    \ c != ' ').count() {\n   |                                                  \
    \                                     ^^^^^ method not found in `Option<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzll7ulqa.rs:26:15\n   |\n18 |\
    \         let mut max: String;\n   |                      ------ expected due\
    \ to this type\n...\n26 |         max = words.first();\n   |               ^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpzll7ulqa.rs:28:42\n   |\n28 |   \
    \          if word.chars().filter(|c| c != ' ').count() > max.chars().filter(|c|\
    \ c != ' ').count() {\n   |                                          ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut set = HashSet::new();\n\
    \    for w in words.into_iter() {\n        if set.insert(w.chars()).is_err() {\n\
    \            return String::new();\n        }\n    }\n    set.iter().next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpdqe_b527.rs:9:19\n  |\n9 |     let mut set = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter()\n        .map(|word|\
    \ word.chars().count())\n        .max()\n        .unwrap()\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0p0yn7yu.rs:9:5\n   |\n8\
    \  |   fn find_max(words: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n9  | /    \
    \ words.iter()\n10 | |         .map(|word| word.chars().count())\n11 | |     \
    \    .max()\n12 | |         .unwrap()\n   | |                 ^- help: try using\
    \ a conversion method: `.to_string()`\n   | |_________________|\n   |        \
    \           expected struct `String`, found `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // TODO: Write the code here\n\
    \    let mut count_map: HashMap<String, usize> = HashMap::new();\n    words.into_iter().for_each(|word|\
    \ {\n        let count = count_map.entry(word).or_insert(0);\n        *count +=\
    \ 1;\n    });\n\n    let max_element = count_map.iter().max_by_key(|&(word, count)|\
    \ {\n        count.cmp(&1).reverse()\n    });\n    match max_element.key {\n \
    \       Some(word) => word,\n        None => \"\".to_string(),\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp0poublx5.rs:10:24\n\
    \   |\n10 |     let mut count_map: HashMap<String, usize> = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0poublx5.rs:10:49\n\
    \   |\n10 |     let mut count_map: HashMap<String, usize> = HashMap::new();\n\
    \   |                                                 ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \    let mut counter = 0;\n    for w in words {\n        map.insert(w.chars().count(),\
    \ w);\n        counter += w.chars().count();\n    }\n    let mut max_key = map.keys().max().unwrap();\n\
    \    let mut max_value = map.get(&max_key).unwrap().to_string();\n    let mut\
    \ min_key = map.keys().min().unwrap();\n    let mut min_value = map.get(&min_key).unwrap().to_string();\n\
    \n    if min_value == max_value {\n        let mut first_key = map.keys().nth(0).unwrap();\n\
    \        let mut first_value = map.get(&first_key).unwrap().to_string();\n   \
    \     if min_key < first_key {\n            max_value = min_value;\n         \
    \   max_key = min_key;\n        } else {\n            max_value = first_value;\n\
    \            max_key = first_key;\n        }\n    }\n    return map.get(&max_key).unwrap().to_string();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpj_kfk2ct.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.len() == 0 {\n     \
    \   return \"\";\n    }\n\n    let mut res = words[0].clone();\n    for (i, word)\
    \ in words.iter_mut().enumerate() {\n        word.chars().unique().sort_unstable().for_each(|char|\
    \ {\n            res.insert1(char);\n        });\n        if i == 0 {\n      \
    \      continue;\n        }\n\n        if res.chars().unique().len() > res.chars().count()\
    \ {\n            res = word;\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgn56obah.rs:10:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     if words.len()\
    \ == 0 {\n10 |         return \"\";\n   |                ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                |\n   |             \
    \   expected struct `String`, found `&str`\n\nerror[E0599]: no method named `unique`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpgn56obah.rs:15:22\n\
    \   |\n15 |         word.chars().unique().sort_unstable().for_each(|char| {\n\
    \   |                      ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `insert1` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpgn56obah.rs:16:17\n   |\n16 |             res.insert1(char);\n \
    \  |                 ^^^^^^^ help: there is an associated function with a similar\
    \ name: `insert`\n\nerror[E0599]: no method named `unique` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpgn56obah.rs:22:24\n   |\n22 |         if\
    \ res.chars().unique().len() > res.chars().count() {\n   |                   \
    \     ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgn56obah.rs:23:19\n   |\n13 |     let mut res = words[0].clone();\n\
    \   |                   ---------------- expected due to this value\n...\n23 |\
    \             res = word;\n   |                   ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found `&mut String`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n    \
    \    .cloned()\n        .flat_map(|word| word.chars())\n        .map(|c| c.chars().unique_count())\n\
    \        .max_by(|a, b| a.cmp(&b))\n        .unwrap_or(\"\")\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxq5nf6im.rs:13:20\n   |\n13 |         .map(|c| c.chars().unique_count())\n\
    \   |                    ^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|word| word).filter_map(|word|\
    \ {\n        word.chars().group_by(|&c| c).max(|&(_, count)| count)\n    }).unwrap_or_else(||\
    \ \"\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp8c_2_3ks.rs:10:22\n   |\n10 |         word.chars().group_by(|&c|\
    \ c).max(|&(_, count)| count)\n   |                      ^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `unwrap_or_else` found for struct\
    \ `FilterMap` in the current scope\n  --> /tmp/tmp8c_2_3ks.rs:11:8\n   |\n11 |\
    \     }).unwrap_or_else(|| \"\")\n   |        ^^^^^^^^^^^^^^ method not found\
    \ in `FilterMap<Map<std::slice::Iter<'_, String>, [closure@/tmp/tmp8c_2_3ks.rs:9:22:\
    \ 9:33]>, [closure@/tmp/tmp8c_2_3ks.rs:9:46: 11:6]>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut chars_counters = HashMap::new();\n\
    \n    for word in words {\n        for char in word.chars() {\n            chars_counters.entry(char).or_insert(0)\
    \ += 1;\n        }\n    }\n\n    if chars_counters.is_empty() {\n        return\
    \ \"\";\n    }\n\n    let max_value = 0;\n\n    for (char, count) in chars_counters.iter()\
    \ {\n        max_value = if count > max_value {\n            count\n        }\
    \ else {\n            max_value\n        };\n    }\n\n    let mut found = false;\n\
    \    for (char, count) in chars_counters.iter() {\n        if count > max_value\
    \ {\n            found = true;\n            break;\n        }\n    }\n\n    found\
    \ && words[0]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpr5ipc3m1.rs:9:30\n  |\n9 |     let mut chars_counters = HashMap::new();\n\
    \  |                              ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpr5ipc3m1.rs:13:53\n\
    \   |\n13 |             chars_counters.entry(char).or_insert(0) += 1;\n   |  \
    \           --------------------------------------- ^^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr5ipc3m1.rs:18:16\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n18 |         return \"\";\n   |               \
    \ ^^- help: try using a conversion method: `.to_string()`\n   |              \
    \  |\n   |                expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr5ipc3m1.rs:39:14\n   |\n39 |     found && words[0]\n\
    \   |              ^^^^^^^^ expected `bool`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr5ipc3m1.rs:39:5\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n39 |     found && words[0]\n   |     ^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `bool`\n   |\nhelp: try using a conversion method\n\
    \   |\n39 |     (found && words[0]).to_string()\n   |     +                 +++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_char = words[0].chars().count();\n\
    \    let mut max_len = words[0].len();\n    for i in 1..words.len() {\n      \
    \  let c = words[i].chars().count();\n        if c > max_char {\n            max_char\
    \ = c\n        }\n        if c > max_len {\n            max_len = c\n        }\n\
    \    }\n    for i in 0..words.len() {\n        let c = words[i].chars().count();\n\
    \        if c == max_len && i != words.len() - 1 {\n            return words[i];\n\
    \        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps2nrposz.rs:26:12\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n26 |     return\
    \ \"\";\n   |            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut characters = Vec::new();\n\
    \n    for word in words {\n        for character in word.chars() {\n         \
    \   if characters.contains(&character) {\n                characters.remove(&character);\n\
    \            } else {\n                characters.push(character);\n         \
    \   }\n        }\n    }\n\n    characters.sort_unstable_by((|a, b| a.cmp(b)).unwrap());\n\
    \n    if characters.len() > 0 {\n        return characters[0]\n    }\n    return\
    \ \"\".to_string();\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo9heect.rs:14:35\n   |\n\
    14 |                 characters.remove(&character);\n   |                    \
    \               ^^^^^^^^^^ expected `usize`, found `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqo9heect.rs:24:16\n   |\n8  | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n24 |         return characters[0]\n   |       \
    \         ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut m = vec![0; words.len()];\n\
    \    for (i, w) in words.iter().enumerate() {\n        for c in w {\n        \
    \    m[i] = m[i] + 1 if  c > m[i] else  c;\n        }\n    }\n\n    if m.len()\
    \ == words.len() {\n        \"\"\n    } else {\n        if m.len() > words.index(&m.max())\
    \ {\n            \"\"\n        } else {\n            words.iter().find(|&w| w\
    \ == words.index(m.iter().max()))\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpp3bd5jd7.rs:12:29\n   |\n12 |             m[i] = m[i] +\
    \ 1 if  c > m[i] else  c;\n   |                             ^^ expected one of\
    \ `.`, `;`, `?`, `}`, or an operator\n\nerror[E0277]: `&String` is not an iterator\n\
    \  --> /tmp/tmpp3bd5jd7.rs:11:18\n   |\n11 |         for c in w {\n   |      \
    \            ^ `&String` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp3bd5jd7.rs:17:9\n   |\n8  | fn find_max(words: Vec<String>) ->\
    \ String {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n17 |         \"\"\n   |         ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |         |\n   |         expected struct `String`,\
    \ found `&str`\n\nerror[E0599]: no method named `index` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpp3bd5jd7.rs:19:28\n   |\n19 |         if\
    \ m.len() > words.index(&m.max()) {\n   |                            ^^^^^ method\
    \ not found in `Vec<String>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \  --> /tmp/tmpp3bd5jd7.rs:19:37\n    |\n19  |         if m.len() > words.index(&m.max())\
    \ {\n    |                                     ^^^- supplied 0 arguments\n   \
    \ |                                     |\n    |                             \
    \        expected 1 argument\n    |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpp3bd5jd7.rs:20:13\n   |\n8  | fn\
    \ find_max(words: Vec<String>) -> String {\n   |                             \
    \       ------ expected `String` because of return type\n...\n20 |           \
    \  \"\"\n   |             ^^- help: try using a conve"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut char = words.iter().map(|word|\
    \ word.chars()).sum::<u64>();\n    let mut max_word = String::new();\n    let\
    \ mut word_count = 0;\n\n    for (i, word) in words.iter().enumerate() {\n   \
    \     if word_count > char {\n            max_word = word;\n            word_count\
    \ = i;\n        }\n        char &= word.chars().sum::<u64>();\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `u64: Sum<Chars<'_>>` is not satisfied\n\
    \    --> /tmp/tmpiu3nov70.rs:9:58\n     |\n9    |     let mut char = words.iter().map(|word|\
    \ word.chars()).sum::<u64>();\n     |                                        \
    \                  ^^^ the trait `Sum<Chars<'_>>` is not implemented for `u64`\n\
    \     |\n     = help: the following other types implement trait `Sum<A>`:\n  \
    \             <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n           \
    \    <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128\
    \ as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iterator::sum`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiu3nov70.rs:15:24\n   |\n10 |     let mut max_word = String::new();\n\
    \   |                        ------------- expected due to this value\n...\n15\
    \ |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiu3nov70.rs:16:26\n   |\n11 |     let mut word_count\
    \ = 0;\n   |                          - expected due to this value\n...\n16 |\
    \             word_count = i;\n   |                          ^ expected `u64`,\
    \ found `usize`\n\nerror[E0277]: the trait bound `u64: Sum<char>` is not satisfied\n\
    \    --> /tmp/tmpiu3nov70.rs:18:30\n     |\n18   |         char &= word.chars().sum::<u64>();\n\
    \     |                              ^^^ the trait `Sum<char>` is not implemented\
    \ for `u64`\n     |\n     = help: the following other types implement trait `Sum<A>`:\n\
    \               <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n         \
    \      <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128\
    \ as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iter"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    let mut res = String::new();\n    for word in words {\n        for c in word.chars()\
    \ {\n            counts.entry(c).or_insert(0) += 1;\n        }\n    }\n    for\
    \ e in counts.iter() {\n        if e.value >= 2 {\n            e.key.sort().rev().unwrap();\n\
    \            if res.len() != 0 && res.chars().count(e.key[0]) == 0 {\n       \
    \         return res;\n            }\n            res = e.key;\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpjeijzm7s.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpjeijzm7s.rs:13:42\n   |\n13 |  \
    \           counts.entry(c).or_insert(0) += 1;\n   |             ----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \ --> /tmp/tmpjeijzm7s.rs:19:46\n    |\n19  |             if res.len() != 0 &&\
    \ res.chars().count(e.key[0]) == 0 {\n    |                                  \
    \            ^^^^^ -------- supplied 1 argument\n    |                       \
    \                       |\n    |                                             \
    \ expected 0 arguments\n    |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0067, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // Write your code here.\n  \
    \  let mut unique_chars = HashSet::new();\n    let mut chars = words.iter().map(|word|\
    \ word.chars().count()).max();\n    while chars > unique_chars.len() {\n     \
    \   unique_chars.insert(chars);\n        chars = words.iter().map(|word| word.chars().count()).max();\n\
    \    }\n    for word in words {\n        if unique_chars.iter().any(|x| *x ==\
    \ word.chars().count()) {\n            return word;\n        }\n    }\n    return\
    \ \"\";\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpqh9zjygu.rs:10:28\n   |\n10 |     let mut unique_chars = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqh9zjygu.rs:21:12\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n21 |     return\
    \ \"\";\n   |            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut count_map = HashMap::new();\n\
    \    let mut max_length = 0;\n    for (i, word) in words.iter().enumerate() {\n\
    \        count_map.insert(word.to_string(), i + 1);\n        if count_map[word]\
    \ > max_length {\n            max_length = count_map[word];\n        }\n    }\n\
    \    let mut word_with_max_length = String::new();\n    for (_, word) in count_map.iter()\
    \ {\n        if word == max_length {\n            word_with_max_length = word;\n\
    \        }\n    }\n    word_with_max_length\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmptj1pxtb2.rs:9:25\n  |\n9 |     let mut count_map = HashMap::new();\n\
    \  |                         ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmptj1pxtb2.rs:19:17\n \
    \  |\n19 |         if word == max_length {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().map(|s| s.chars().count()\
    \ as u64).max().unwrap()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmpc5q8lptg.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counter = HashMap::new();\n\
    \    for w in words {\n        counter.insert(w.chars().distinct().count(), w);\n\
    \    }\n    counter.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpqlrg862e.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0599]:\
    \ no method named `distinct` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmpqlrg862e.rs:11:34\n   |\n11 |         counter.insert(w.chars().distinct().count(),\
    \ w);\n   |                                  ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut num_unique = words[0].chars().unique().count();\n\
    \    for word in words {\n        if word.chars().unique().count() > num_unique\
    \ {\n            num_unique = word.chars().unique().count();\n        }\n    }\n\
    \    for word in words {\n        if word.chars().unique().count() == num_unique\
    \ {\n            return word;\n        }\n    }\n    return \"\";\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpf_krijco.rs:9:43\n  |\n9 |     let mut num_unique\
    \ = words[0].chars().unique().count();\n  |                                  \
    \         ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `unique` found for struct `Chars` in the current scope\n  --> /tmp/tmpf_krijco.rs:11:25\n\
    \   |\n11 |         if word.chars().unique().count() > num_unique {\n   |    \
    \                     ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `unique` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpf_krijco.rs:12:39\n   |\n12 |             num_unique = word.chars().unique().count();\n\
    \   |                                       ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `unique` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpf_krijco.rs:16:25\n   |\n16 |         if word.chars().unique().count()\
    \ == num_unique {\n   |                         ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf_krijco.rs:20:12\n   |\n8  |\
    \ fn find_max(words: Vec<String>) -> String {\n   |                          \
    \          ------ expected `String` because of return type\n...\n20 |     return\
    \ \"\";\n   |            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            expected struct `String`, found `&str`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \n    // Get the word with maximum number of unique characters.\n    for word\
    \ in words {\n        let mut len = 0;\n        let mut c = 0;\n        for c\
    \ in word.chars().filter(|&c| c.is_ascii_lowercase()) {\n            len += 1;\n\
    \        }\n        if len > max.len() {\n            max = word;\n        }\n\
    \    }\n\n    // Return an empty string if there are more than one words.\n  \
    \  if !words.is_empty() || max.is_empty() {\n        \"\"\n    } else {\n    \
    \    match words.index(max.cmp(&max[..])..) {\n            None => \"\",\n   \
    \         Some(index) => words[index],\n        }\n    }\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9un46tl.rs:25:9\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n25 |     \
    \    \"\"\n   |         ^^- help: try using a conversion method: `.to_string()`\n\
    \   |         |\n   |         expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `index` found for struct `Vec<String>` in the current scope\n\
    \  --> /tmp/tmpf9un46tl.rs:27:21\n   |\n27 |         match words.index(max.cmp(&max[..])..)\
    \ {\n   |                     ^^^^^ method not found in `Vec<String>`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf9un46tl.rs:27:35\n   |\n27 |         match words.index(max.cmp(&max[..])..)\
    \ {\n   |                                   ^^^^^^^^ expected struct `String`,\
    \ found `str`\n   |\n   = note: expected reference `&String`\n              found\
    \ reference `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf9un46tl.rs:28:21\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n28\
    \ |             None => \"\",\n   |                     ^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                     |\n   |        \
    \             expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut char_map = HashMap::new();\n\
    \    let mut max_key = String::new();\n    for word in words {\n        let mut\
    \ char_count = char_map.entry(word).or_insert(0);\n        *char_count += 1;\n\
    \        if *char_count > char_map.len() {\n            max_key = word;\n    \
    \    }\n    }\n    if char_map.len() > char_map.len() {\n        max_key\n   \
    \ } else {\n        \"\"\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpx9eysdcy.rs:9:24\n  |\n9 |     let mut char_map = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx9eysdcy.rs:21:9\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n21 |         \"\"\n   |         ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |         |\n   |        \
    \ expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n    let mut\
    \ chars = String::new();\n    for word in words {\n        if chars.len() > max\
    \ {\n            max = chars.len();\n        }\n        for ch in word.chars()\
    \ {\n            if chars.contains(&ch) {\n                chars.insert(ch);\n\
    \            }\n        }\n    }\n    if chars.len() > max {\n        return chars.to_string();\n\
    \    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpq7t1ez4w.rs:16:31\n\
    \     |\n16   |             if chars.contains(&ch) {\n     |                 \
    \     -------- ^^^ expected an `Fn<(char,)>` closure, found `char`\n     |   \
    \                   |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n16   |         \
    \    if chars.contains(*&ch) {\n     |                               +\n\nerror[E0061]:\
    \ this function takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmpq7t1ez4w.rs:17:23\n\
    \     |\n17   |                 chars.insert(ch);\n     |                    \
    \   ^^^^^^ -- supplied 1 argument\n     |                       |\n     |    \
    \                   expected 2 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    if words.is_empty() {\n     \
    \   return \"\";\n    }\n    match words.iter().max_by_key(|w| w.chars().count(|c|\
    \ !c.is_ascii())) {\n        Some(w) => w,\n        None => find_max(words.iter().filter(|w|\
    \ w.chars().count(|c| !c.is_ascii())).collect()),\n    }\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwo797am.rs:10:16\n   |\n\
    8  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n9  |     if words.is_empty()\
    \ {\n10 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpwwo797am.rs:12:49\n    |\n12  |\
    \     match words.iter().max_by_key(|w| w.chars().count(|c| !c.is_ascii())) {\n\
    \    |                                                 ^^^^^ -----------------\
    \ supplied 1 argument\n    |                                                 |\n\
    \    |                                                 expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwwo797am.rs:13:20\n   |\n8  | fn find_max(words: Vec<String>) ->\
    \ String {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n13 |         Some(w) => w,\n   |                    ^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `&String`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwwo797am.rs:14:60\n\
    \    |\n14  |         None => find_max(words.iter().filter(|w| w.chars().count(|c|\
    \ !c.is_ascii())).collect()),\n    |                                         \
    \                   ^^^^^ ----------------- supplied 1 argument\n    |       \
    \                                                     |\n    |               \
    \                                             expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwwo797am.rs:14:50\n\
    \   |\n14 |         None => find_max(words.iter().filter(|w| w.chars().count(|c|\
    \ !c.is_ascii())).collect()),\n   |                                          \
    \        ^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts: Vec<usize> =\
    \ words.iter().map(|word| word.chars().count()).collect();\n    counts.sort();\n\
    \    let maxword = words[counts.iter().max().unwrap()];\n    return maxword;\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `&usize`\n  -->\
    \ /tmp/tmptayxm3hd.rs:11:19\n   |\n11 |     let maxword = words[counts.iter().max().unwrap()];\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&usize>` for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    // TODO: Your code here\n   \
    \ \"\".to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp7e2kfev6.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    words.sort_by(|x, y| x.chars().count().cmp(&y.chars().count()));\n    if\
    \ words.iter().any(|w| w.chars().count().eq_u64(1)).is_false() {\n        return\
    \ words.first().unwrap();\n    }\n    return \"\";\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `eq_u64` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpmytpetns.rs:11:47\n   |\n11 |     if words.iter().any(|w|\
    \ w.chars().count().eq_u64(1)).is_false() {\n   |                            \
    \                   ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `is_false` found for type `bool` in the current scope\n  --> /tmp/tmpmytpetns.rs:11:58\n\
    \   |\n11 |     if words.iter().any(|w| w.chars().count().eq_u64(1)).is_false()\
    \ {\n   |                                                          ^^^^^^^^ method\
    \ not found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmytpetns.rs:12:16\n\
    \   |\n8  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n12\
    \ |         return words.first().unwrap();\n   |                ^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counters = HashMap::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            counters.insert(c,\
    \ counters.get(c).clone() + 1);\n        }\n    }\n\n    let mut max_length: Option<usize>\
    \ = None;\n    let mut best_word_len = 0;\n    for c in counters.keys() {\n  \
    \      let mut len: Option<usize> = None;\n        if counters.get(c) >= best_word_len\
    \ {\n            len = Some(counters.get(c));\n        } else {\n            len\
    \ = Some(best_word_len);\n        }\n\n        if let Some(mut len) = len {\n\
    \            if max_length.is_some() {\n                len = max_length.take().unwrap_or(0)\
    \ + 1;\n            } else {\n                len = max_length.unwrap_or(0) +\
    \ 1;\n            }\n            if len > best_word_len {\n                best_word_len\
    \ = len;\n            }\n            max_length = Some(len);\n        }\n    }\n\
    \    if max_length.is_some() {\n        best_word_len\n    } else {\n        \"\
    \".to_string()\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp7oa_fuqo.rs:9:24\n  |\n9 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7oa_fuqo.rs:39:9\n   |\n8  | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n39 |         best_word_len\n   |     \
    \    ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \         |\n   |         expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_chars = String::new();\n\
    \    let mut index = 0;\n\n    for word in words {\n        if let Some(mut count)\
    \ = word.chars().count() {\n            if count > max_chars.len() {\n       \
    \         max_chars = word;\n                index = word\n                  \
    \  .chars()\n                    .iter()\n                    .chain(word.chars().skip(1))\n\
    \                    .count();\n            }\n        }\n    }\n\n    words[index]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpna6_3t8n.rs:13:16\n   |\n\
    13 |         if let Some(mut count) = word.chars().count() {\n   |           \
    \     ^^^^^^^^^^^^^^^   -------------------- this expression has type `usize`\n\
    \   |                |\n   |                expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpna6_3t8n.rs:18:22\n   |\n18 |                     .iter()\n\
    \   |                      ^^^^ private field, not a method\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \    for w in words {\n        for c in w.chars() {\n            *map.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let max = *map.iter().max_by_key(|(_, count)| count).key;\n\
    \    match max {\n        Some(max) => max,\n        None => \"\",\n    }\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpvrurydkh.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpvrurydkh.rs:18:17\n   |\n16 | /\
    \     match max {\n17 | |         Some(max) => max,\n   | |                  \
    \    --- this is found to be of type `String`\n18 | |         None => \"\",\n\
    \   | |                 ^^- help: try using a conversion method: `.to_string()`\n\
    \   | |                 |\n   | |                 expected struct `String`, found\
    \ `&str`\n19 | |     }\n   | |_____- `match` arms have incompatible types\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut m = String::new();\n\
    \    let mut max_index = -1;\n    for i in 0..words.len() {\n        m.clear();\n\
    \        for (j, s) in words.iter().enumerate().skip(1) {\n            let len\
    \ = s.chars().filter(|c| c != ' ').count();\n            if m.len() < len {\n\
    \                m = s;\n                max_index = j;\n            }\n     \
    \   }\n    }\n    if max_index == words.len() {\n        return \"\".to_string();\n\
    \    }\n    return words.iter().nth(max_index).unwrap();\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7ca11npq.rs:14:46\n\
    \   |\n14 |             let len = s.chars().filter(|c| c != ' ').count();\n  \
    \ |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7ca11npq.rs:16:21\n   |\n9  |     let mut m\
    \ = String::new();\n   |                 ------------- expected due to this value\n\
    ...\n16 |                 m = s;\n   |                     ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                     |\n   |      \
    \               expected struct `String`, found `&String`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp7ca11npq.rs:10:25\n\
    \   |\n10 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7ca11npq.rs:24:12\n   |\n8  | fn find_max(words: Vec<String>) ->\
    \ String {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n24 |     return words.iter().nth(max_index).unwrap();\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |            |\n   |            expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    words.sort_by(|a, b| a.chars().flat_map(|c| c.chars()).count());\n    let\
    \ mut res = String::new();\n    let mut max_char = String::new();\n    let mut\
    \ max_pos = 0;\n    words.into_iter().for_each(|word|{\n        let mut max_count\
    \ = word\n            .chars()\n            .flat_map(|c| c.chars())\n       \
    \     .count();\n        if max_count > max_char.len() {\n            max_char\
    \ = word.chars().flat_map(|c| c.chars()).to_string();\n            max_pos = 0;\n\
    \        }\n        if max_count == max_char.len() {\n            res.push_str(&word[max_pos..]);\n\
    \            max_pos+=1;\n        }\n    });\n    if max_pos != words.len() {\n\
    \        res.push_str(&words[max_pos]);\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpimq8y2he.rs:10:51\n   |\n10 |     words.sort_by(|a, b|\
    \ a.chars().flat_map(|c| c.chars()).count());\n   |                          \
    \                         ^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpimq8y2he.rs:17:29\n\
    \   |\n17 |             .flat_map(|c| c.chars())\n   |                       \
    \      ^^^^^ method not found in `char`\n\nerror[E0599]: no method named `chars`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpimq8y2he.rs:20:52\n\
    \   |\n20 |             max_char = word.chars().flat_map(|c| c.chars()).to_string();\n\
    \   |                                                    ^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut counts = HashMap::new();\n\
    \    for word in words {\n        if let Some(count) = counts.get(&word) {\n \
    \           counts.entry(count.clone()).or_insert(0) + 1;\n        } else {\n\
    \            counts.insert(word.clone(), 1);\n        }\n    }\n    let max_count\
    \ = counts.iter().max().unwrap();\n    if max_count == 1 {\n        // No words\
    \ have more than one unique character.\n        return \"\".to_string();\n   \
    \ }\n    for word in words {\n        let count = counts.get(&word).unwrap();\n\
    \        if count == max_count {\n            return word;\n        }\n    }\n\
    \    \"\".to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp8prd6pu0.rs:9:22\n  |\n9 |     let mut counts = HashMap::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
