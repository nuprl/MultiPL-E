name: HumanEval_161_solve
language: rust
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n/// solve(\"\
  ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ["    let mut s = String::from(s);\n    s.chars().for_each(|c| {\n  \
    \      if c.is_ascii_lowercase() || c.is_ascii_uppercase() {\n            s.insert_len(1,\
    \ c.to_ascii_lowercase());\n        } else {\n            s.insert_len(1, c.to_ascii_uppercase());\n\
    \        }\n    });\n    match s.chars().count() {\n        0 => s,\n        _\
    \ => s.chars().cloned().reverse().collect::<String>().into(),\n    }", "    if\
    \ s.chars().count() > 0 {\n        if s.chars().any(|c| match c {\n          \
    \  'a' => String::from(\"A\"),\n            'b' => String::from(\"B\"),\n    \
    \        'c' => String::from(\"C\"),\n            'd' => String::from(\"D\"),\n\
    \            'e' => String::from(\"E\"),\n            'f' => String::from(\"F\"\
    ),\n            'g' => String::from(\"G\"),\n            'h' => String::from(\"\
    H\"),\n            'i' => String::from(\"I\"),\n            'j' => String::from(\"\
    J\"),\n            'k' => String::from(\"K\"),\n            'l' => String::from(\"\
    L\"),\n            'm' => String::from(\"M\"),\n            'n' => String::from(\"\
    N\"),\n            'o' => String::from(\"O\"),\n            'p' => String::from(\"\
    P\"),\n            'q' => String::from(\"Q\"),\n            'r' => String::from(\"\
    R\"),\n            's' => String::from(\"S\"),\n            't' => String::from(\"\
    T\"),\n            'u' => String::from(\"U\"),\n            'v' => String::from(\"\
    V\"),\n            'w' => String::from(\"W\"),\n            'x' => String::from(\"\
    X\"),\n            'y' => String::from(\"Y\"),\n            'z' => String::from(\"\
    Z\"),\n            _ => String::from(\"_\"),\n        }) {\n            reverse(s.chars().collect::<String>())\n\
    \        } else {\n            reverse(s.chars().collect::<String>())\n      \
    \  }\n    } else {\n        reverse(s)\n    }", "    s.chars().map(|c| match c\
    \ {\n        'a' => c.to_ascii_lowercase().rev(),\n        'A' => c.to_ascii_uppercase().rev(),\n\
    \        _ => c,\n    }).collect::<String>()", "    s.chars().enumerate().filter\
    \ (|(i,c)| {\n        c == 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c'\
    \ || c == 'C'\n    }).map (|(i,c)| {\n        if c == 'a' || c == 'A' {\n    \
    \        return c + c.to_uppercase().to_string();\n        }\n        if c ==\
    \ 'b' || c == 'B' {\n            return c + c.to_lowercase().to_string();\n  \
    \      }\n        if c == 'c' || c == 'C' {\n            return c.to_string();\n\
    \        }\n    }).fold(\"\".to_string(), |s, c| s + &c)", "    let mut s = s.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        match s[i] {\n         \
    \   c @ _ => s[i] = c.to_ascii_uppercase(),\n            _ => s[i] = c.to_ascii_lowercase(),\n\
    \        }\n        i += 1;\n    }\n    String::from(s)", "    let mut chars =\
    \ s.chars().collect::<Vec<_>>();\n    let mut i = 0;\n    while i < chars.len()\
    \ {\n        match chars[i] {\n            'a' as char => {\n                if\
    \ chars.len() > i + 1 {\n                    if chars[i + 1] == 'z' {\n      \
    \                  chars[i] = 'a';\n                        chars[i + 1] = 'A';\n\
    \                    } else if chars[i + 1] == 'Z' {\n                       \
    \ chars[i] = 'A';\n                        chars[i + 1] = 'a';\n             \
    \       }\n                }\n                i += 1;\n            },\n      \
    \      'A' as char => {\n                if chars.len() > i + 1 {\n          \
    \          if chars[i + 1] == 'z' {\n                        chars[i] = 'A';\n\
    \                        chars[i + 1] = 'a';\n                    } else if chars[i\
    \ + 1] == 'Z' {\n                        chars[i] = 'a';\n                   \
    \     chars[i + 1] = 'A';\n                    }\n                }\n        \
    \        i += 1;\n            },\n            _ => {\n                i += 1;\n\
    \            }\n        }\n    }\n    chars.iter().map(|c| c.to_string()).collect::<String>()",
  "    let mut s = s.chars();\n    \n    while let Some(item) = s.next() {\n     \
    \   if item.is_uppercase() {\n            s = s.map(|c| *c ^ (c as u32).to_string()).collect();\n\
    \        } else if item.is_lowercase() {\n            s = s.map(|c| *c ^ (c as\
    \ u32).to_string()).collect();\n        }\n    }\n    s.collect::<String>()",
  "    let mut s = s;\n    let mut new_s = s;\n    while !new_s.is_empty() {\n   \
    \     let mut i = new_s.len() - 1;\n        let mut j = new_s.len() - 1;\n   \
    \     while i >= 0 && j >= 0 {\n            if new_s[i] == new_s[j] {\n      \
    \          new_s[i..] = new_s[i..].reverse();\n                i -= 1;\n     \
    \           j -= 1;\n            } else {\n                i -= 1;\n         \
    \   }\n        }\n    }\n    new_s", "    let mut s = s.chars();\n    s.reverse();\n\
    \    let mut res = s.collect::<String>();\n    if s.is_empty() {\n        res.reverse();\n\
    \    }\n    res.chars().collect();", "    let mut res = String::new();\n    for\
    \ c in s.chars() {\n        if let Some(c_upper) = (c.to_ascii_uppercase()).chars()\
    \ {\n            if c_upper.len() > 0 {\n                res += c_upper.last().to_string();\n\
    \            }\n        }\n        else {\n            res += c.to_string();\n\
    \        }\n    }\n    if res.is_empty() {\n        res = \"#\".to_string();\n\
    \    }\n    res.to_string()", "    if s.is_empty() {\n        return \"\".to_string();\n\
    \    }\n\n    let mut res = String::new();\n\n    for c in s.chars() {\n     \
    \   match c.to_ascii_lowercase() {\n            None => continue,\n          \
    \  Some(c) => {\n                if c.is_uppercase() {\n                    res.push((*c).to_ascii_uppercase());\n\
    \                } else {\n                    res.push((*c).to_ascii_lowercase());\n\
    \                }\n            }\n        }\n    }\n\n    res.reverse();\n\n\
    \    return res;", "    // your code goes here\n    let mut reversed_s = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    \n    loop {\n       \
    \ if s.len() == 0 {\n            break;\n        }\n        if s.last().unwrap().is_lowercase()\
    \ {\n            s.last_mut().unwrap().to_uppercase();\n        } else {\n   \
    \         s.last_mut().unwrap().to_lowercase();\n        }\n        reversed_s.extend(s.clone());\n\
    \    }\n    reversed_s", "    let mut s = s;\n    s.chars().for_each(|c| {\n \
    \       if c.is_uppercase() {\n            s = s.to_lowercase().to_uppercase().to_string();\n\
    \        } else {\n            s = s.to_lowercase().to_string();\n        }\n\
    \    });\n    s", "    s.chars().map(|c| if c.is_alphabetic() || c == '#' {\n\
    \        c ^ c.to_ascii_lowercase()\n    } else {\n        c ^ c.to_ascii_uppercase()\n\
    \    }).collect::<String>().to_owned()", "    if s.is_empty() {\n        s\n \
    \   } else {\n        match s.chars() {\n            [] => s,\n            c =>\
    \ {\n                let i = s.find(|c| c.is_letter());\n                if i\
    \ > 0 {\n                    if i >= s.len() - 1 {\n                        s\n\
    \                    } else {\n                        let mut s = \"\";\n   \
    \                     for i in 0..i + 1 {\n                            if i !=\
    \ i {\n                                s = s.to_string().swapcase() + s.to_string().swapcase();\n\
    \                            }\n                        }\n                  \
    \      s\n                    }\n                } else {\n                  \
    \  s\n                }\n            }\n        }\n    }", "    let mut s = s;\n\
    \    let len = s.len();\n    for i in 0..len {\n        if s[i] > 'z' {\n    \
    \        s = s.chars().map(|c| c as u8 ).collect::<Vec<u8>>().to_string();\n \
    \       }\n    }\n    s", "    \n    let mut new_s: String = s.to_owned();\n \
    \   for i in s.chars() {\n        let new_i = i as char;\n        if new_i !=\
    \ new_s.chars().next().unwrap() {\n            new_s.insert(new_i, new_s.chars().next().unwrap());\n\
    \        }\n    }\n    new_s", "    s.chars().map(|x| if x.is_alphabetic() ||\
    \ x.is_numeric() {\n        let y = x.to_lowercase();\n        x.to_lowercase()\n\
    \    } else if x.is_alphanumeric() {\n        let y = x.to_uppercase();\n    \
    \    x.to_uppercase()\n    } else if x.is_punctuation() {\n        let y = x.to_lowercase();\n\
    \        x.to_uppercase()\n    }\n    else if x.is_empty() {\n        let y =\
    \ x.to_lowercase();\n        x.to_uppercase()\n    }\n    else { x }).collect::<String>().to_string()",
  "    s.chars().collect()\n        .filter_map(|c| {\n            if !c.is_alpha()\
    \ {\n                Some(c.to_ascii_lowercase())\n            } else {\n    \
    \            Some(c.to_ascii_uppercase())\n            }\n        })\n       \
    \ .map(|x| x.join())\n        .collect::<Vec<_>>()\n        .join();", "    let\
    \ mut new_string = s.clone();\n    let mut flag = true;\n\n    for c in s.chars()\
    \ {\n        if !flag {\n            new_string = new_string.replace_range(c.start(),\
    \ c.end(), c.to_uppercase());\n            flag = true;\n        } else {\n  \
    \          new_string = new_string.replace_range(c.start(), c.end(), c.to_lowercase());\n\
    \            flag = false;\n        }\n    }\n    new_string", "    let mut s\
    \ = s.to_lowercase();\n    s.chars().for_each(|c| {\n        if let Some(mut c)\
    \ = c {\n            let mut lower = false;\n            if c.is_lowercase() {\n\
    \                lower = true;\n                c = c.to_uppercase();\n      \
    \      } else {\n                c = c.to_lowercase();\n            }\n      \
    \      if !s.contains(&c) {\n                s = s.replace(&c, &c).to_string();\n\
    \                lower = !lower;\n            }\n            c = Some(c);\n  \
    \          c.unwrap().set_not(lower);\n        }\n    });\n    s.to_string()",
  "    // write your code here\n    let mut s = s.replace(\" \",\"\").to_lowercase();\n\
    \    let mut result = s.clone();\n    if s.len() > 0 {\n        if s.chars().any(|c|\
    \ c.is_ascii_lowercase()) {\n            let mut char = s.chars().filter(|c| c.is_ascii_lowercase()).next();\n\
    \            let mut i = 1;\n            while i < s.len() {\n               \
    \ if char == None {\n                    s = s.replace(&s[i], &s[i]);\n      \
    \          } else {\n                    let mut j = i;\n                    while\
    \ j > 0 && j > 0 {\n                        s = s.remove(&s[j-1],&s[i]);\n   \
    \                     j--;\n                    }\n                    s = s.remove(&i,&s[i]);\n\
    \                    s = s.remove(&char.unwrap(),&s[i]);\n                }\n\
    \                i = i + 1;\n                char = s.chars().filter(|c| c.is_ascii_lowercase()).next();\n\
    \            }\n        } else {\n            let mut char = s.chars().filter(|c|\
    \ !c.is_ascii_lowercase()).next();\n            let mut i = 1;\n            while\
    \ i < s.len() {\n                if char == None {\n                    s = s.replace(&s[i],\
    \ &s[i]);\n                } else {\n                    let mut j = i;\n    \
    \                while j > 0 && j > 0 {\n                        s = s.remove(&s[j-1],&s[i]);\n\
    \                        j--;\n                    }\n                    s =\
    \ s.remove(&i,&s[i]);\n                    s = s.remove(&char.unwrap(),&s[i]);\n\
    \                }\n                i = i + 1;\n                char = s.chars().filter(|c|\
    \ !c.is_ascii_lowercase()).next();\n            }\n        }\n    }\n    s", " \
    \   if s.is_empty() { return \"\"; }\n    let mut chars = s.chars().collect::<Vec<_>>();\n\
    \    chars.sort();\n    chars.reverse();\n    chars.dedup();\n    chars.iter().map(|&x|\
    \ x.to_ascii_lowercase()).collect::<String>()", "    let mut res = String::new();\n\
    \    let mut s = s.chars();\n    while let Some(first) = s.next() {\n        match\
    \ first {\n            c if c.is_alpha() => res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n\
    \            _ => res.push(c),\n        }\n    }\n    res", "    let mut s = s;\n\
    \    for i in s.chars().filter(|x| x.is_letter()) {\n        if i.is_uppercase()\
    \ {\n            s = s.to_uppercase() + &s[i..].to_string();\n        } else {\n\
    \            s = s.to_lowercase() + &s[i..].to_string();\n        }\n    }\n \
    \   s", "    s.chars().map(|x| if is_letter(x.to_lowercase()) \n\t\t    then x.to_uppercase()\n\
    \t\t    else x.to_lowercase()).collect()", "    if s.is_empty() {\n        return\
    \ s.clone();\n    }\n    if let Some(first) = s.chars().next()? {\n        let\
    \ mut c = first;\n        for c in s.chars().skip_while(|c| !c.is_ascii() || c.is_ascii_letter())\
    \ {\n            let mut v = c.to_ascii_lowercase();\n            if let Some(first)\
    \ = c.to_ascii_uppercase().clone() {\n                v = v.to_ascii_uppercase();\n\
    \            }\n            c.write_to(&mut v)?;\n        }\n    }\n    s", " \
    \   s.chars()\n        .filter(|c| c.is_alphanumeric() || c.is_ascii_letter())\n\
    \        .map(|c| if c.is_ascii_letter() || c.is_ascii_uppercase() {\n       \
    \     c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        })\n        .collect()\n        .join(\"\")", "    if s.len() == 0 {\n\
    \        return s\n    }\n    let mut reversed: String = \"\".to_string();\n \
    \   let mut has_letter = false;\n    for ch in s.chars() {\n        if let Some(_)\
    \ = ch.to_ascii_lowercase() {\n            has_letter = true;\n            reversed.push_str(ch.to_ascii_uppercase());\n\
    \        }\n        else {\n            reversed.push_str(ch.to_string());\n \
    \       }\n    }\n    if !has_letter {\n        reversed.reverse();\n    }\n \
    \   reversed", "    s.chars()\n        .map(|c| match c {\n            'a' =>\
    \ c,\n            'b' => c,\n            'c' => c,\n            'd' => c,\n  \
    \          'e' => c,\n            'f' => c,\n            'g' => c,\n         \
    \   'h' => c,\n            'i' => c,\n            'j' => c,\n            'k' =>\
    \ c,\n            'l' => c,\n            'm' => c,\n            'n' => c,\n  \
    \          'o' => c,\n            'p' => c,\n            'q' => c,\n         \
    \   'r' => c,\n            's' => c,\n            't' => c,\n            'u' =>\
    \ c,\n            'v' => c,\n            'w' => c,\n            'x' => c,\n  \
    \          'y' => c,\n            'z' => c,\n            _ => c,\n        })\n\
    \        .collect()", "    let mut res = String::with_capacity(s.size());\n  \
    \  for ch in s.chars() {\n        if let Some(ascii_ch) = char::to_ascii_lowercase(ch)\
    \ {\n            res.push_str(&ascii_ch);\n        } else {\n            res.push_str(&ch);\n\
    \        }\n    }\n    solve(&res)", "    let mut rev = s.chars().fold(String::new(),\
    \ |mut acc, c| {\n        if c.is_lowercase() {\n            acc.push((*c).to_uppercase());\n\
    \            acc.push((*c).to_lowercase());\n        } else {\n            acc.push(c);\n\
    \        }\n        acc\n    });\n    rev.push(b'\\0');\n    rev", "    let mut\
    \ str = s.to_string();\n    let mut result = s.clone();\n\n    for i in 0..str.len()\
    \ {\n        if str.chars().any(|c| c.is_alpha()) {\n            if let Some(mut\
    \ i) = str.chars().find(|c| c.is_alpha()) {\n                if str[i] = 'A' {\n\
    \                    str[i] = 'a';\n                } else if str[i] = 'a' {\n\
    \                    str[i] = 'A';\n                }\n            }\n       \
    \ }\n    }\n\n    result", "    s.chars().fold(String::new(), |mut acc, c| {\n\
    \        if c.is_ascii_uppercase() {\n            *acc += c.to_ascii_lowercase()\n\
    \        } else {\n            *acc += c\n        }\n    })", "    let mut s =\
    \ s;\n    if s.is_empty() {\n        return s;\n    }\n    let mut chars = s.chars();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_letter() {\n        \
    \    if c.is_lowercase() {\n                s = s.chars().collect::<String>().rev().collect::<String>()\
    \ \n                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\
    \ \n                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            } else if c.is_uppercase() {\n                s = s.chars().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            } else {\n                s = s.chars().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            }\n        } else if c.is_digit() {\n            let s = String::from(&s);\n\
    \            let s = s.chars().collect::<String>().rev().collect::<String>() \n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\
    \ \n                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            return String::from(&s)\n        }\n    }\n    return s", "    let\
    \ mut s = s;\n    let mut res = \"\";\n    for ch in s.chars() {\n        if ch.is_ascii_letter()\
    \ {\n            if ch.to_ascii_lowercase() == ch {\n                res += ch.to_ascii_uppercase();\n\
    \            } else {\n                res += ch.to_ascii_lowercase();\n     \
    \       }\n        } else {\n            res += ch;\n        }\n    }\n    if\
    \ res == \"\" {\n        res = s.clone();\n    }\n    return res;", "    \n  \
    \  if s.is_empty() {\n        return s;\n    }\n    \n    \n    let mut reversed\
    \ = String::new();\n    \n    let mut first_character = s.chars().next().unwrap();\n\
    \    \n    match first_character.to_ascii_lowercase() {\n        None => (),\n\
    \        Some('a') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some('z') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some(' ') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some('0'..='9') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        _ => {\n            reversed.push(\"\\\"\");\n          \
    \  reversed.push(\"\\\\\");\n            reversed.push(first_character.to_string());\n\
    \        }\n    }\n    \n    let mut second_character = s.chars().next().unwrap();\n\
    \    \n    match second_character.to_ascii_lowercase() {\n        None => (),\n\
    \        Some('a') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some('z') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some(' ') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some('0'..='9') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        _ => {\n            reversed.push(\"\\\"\");\n          \
    \  reversed.push(\"\\\\\");\n            reversed.push(second_character.to_string());\n\
    \        }\n    }\n    \n    reversed.reverse();\n    reversed", '    solve(&s)',
  "    let mut result = String::new();\n    for c in s.chars() {\n        if c.is_uppercase()\
    \ {\n            result.push_str(c.to_lowercase());\n        } else {\n      \
    \      result.push_str(c);\n        }\n    }\n    result.reverse();\n    result",
  "    let mut res = s.to_string();\n    if s.chars().count() == 0 {\n        return\
    \ res;\n    }\n    for i in s.chars() {\n        if i.is_letter() {\n        \
    \    if !res.contains(i.to_string().to_string()) {\n                res = res.replace(i.to_string(),\
    \ i.to_ascii_uppercase());\n            } else {\n                res = res.replace(i.to_string(),\
    \ i.to_ascii_lowercase());\n            }\n        } else {\n            res =\
    \ res.replace(i.to_string(), i.to_string());\n        }\n    }\n    return res.to_string();",
  "    if s.is_empty() {\n        return s\n    }\n\n    let mut s = s.to_string();\n\
    \n    for &c in s.chars() {\n        match c {\n            'A' => s.swapcase(),\n\
    \            'a' => s.swapcase(),\n            '#' => s.swapcase(),\n        \
    \    _ => (),\n        }\n    }\n\n    s", "    if s.is_empty() {\n        return\
    \ \"\"\n    }\n    if s.chars().any(|c| c.is_letter()) {\n        solve(s.chars().map(|c|\
    \ if c.is_lower() c else c.to_upper()).collect::<String>())\n    } else {\n  \
    \      solve(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>())\n\
    \    }", "    s.chars().map(|x|\n        match (x.to_ascii_lowercase(), x.to_ascii_uppercase())\
    \ {\n            (Some(lower), Some(upper)) => \n                match match s.chars().find(|y|\
    \ y.to_ascii_lowercase() == lower || y.to_ascii_uppercase() == upper) {\n    \
    \                None => x,\n                    Some(other) => other.to_ascii_lowercase()\
    \ + x.to_ascii_lowercase(),\n                },\n            (None, Some(other))\
    \ => other.to_ascii_uppercase() + x.to_ascii_uppercase(),\n            (Some(lower),\
    \ None) => x.to_ascii_lowercase() + other.to_ascii_uppercase(),\n            (None,\
    \ Some(_)) => x.to_ascii_uppercase() + other.to_ascii_lowercase(),\n        }\n\
    \    ).collect::<String>().to_string()", "    let mut new: String = s;\n    let\
    \ mut len = s.len();\n\n    while len > 0 {\n        if s[len - 1] == &'a' ||\
    \ s[len - 1] == &'A' {\n            new.push(s[len - 2]);\n            new.push(s[len\
    \ - 1]);\n            new.pop();\n            new.pop();\n            len -= 2;\n\
    \        } else {\n            new.push(s[len - 2]);\n            len -= 2;\n\
    \        }\n    }\n    new.reverse();\n    new", "    if s.is_empty() {\n    \
    \    \"\"\n    } else {\n        let mut result = String::new();\n        for\
    \ c in s.chars() {\n            if c.is_ascii_lowercase() {\n                result.push_str(c.to_ascii_uppercase());\n\
    \            } else if c.is_ascii_uppercase() {\n                result.push_str(c.to_ascii_lowercase());\n\
    \            } else {\n                result.push_str(c);\n            }\n  \
    \      }\n        result\n    }", "    if s.is_empty() {\n        return s\n \
    \   }\n    let mut new_s = s;\n    for i in s.chars() {\n        match i {\n \
    \           c if c.is_uppercase() => new_s = new_s.to_ascii_uppercase().to_string(),\n\
    \            c if c.is_lowercase() => new_s = new_s.to_ascii_lowercase().to_string(),\n\
    \            _ => new_s = i\n        }\n    }\n    new_s", "    let mut s = s;\n\
    \    let mut result = String::new();\n\n    for (i, _) in s.chars().enumerate()\
    \ {\n        if s.chars().skip(i).any(|c| !ascii_lowercase().contains(&c)) {\n\
    \            s.push_str(&s.chars().reverse().collect::<String>());\n         \
    \   s.push_str(&String::from(ascii_lowercase()[s.len() - i]));\n        }\n  \
    \  }\n    result.push_str(&s);\n    result", "    s.chars().filter(|x| x.is_alphanumeric()).map(|x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>().reverse()\n        .concat()\n \
    \       .chars().filter(|x| x.is_alphanumeric()).map(|x| x.to_ascii_uppercase()).collect::<Vec<_>>()\n\
    \        .concat()\n        .concat()\n        .collect::<Vec<_>>()\n        .to_string()",
  "    if s.is_empty() {\n        return \"#\";\n    }\n    let mut s = String::from(s);\n\
    \    for i in 0..s.len() {\n        if let Some(m) = s.chars().position(|c| c\
    \ == i) {\n            swap(s, i, m);\n        }\n    }\n    s", "    s.chars().filter(|c|\n\
    \        match c.to_ascii_lowercase() {\n            Some(a) => a == c.to_ascii_uppercase(),\n\
    \            _ => false,\n        }\n    ).fold(String::new(), |accum, ch| {\n\
    \        accum.append(if ch.to_ascii_lowercase() == ch.to_ascii_uppercase() {\n\
    \            ch.to_ascii_lowercase()\n        } else {\n            ch.to_ascii_uppercase()\n\
    \        })\n        accum\n    })", "    let mut s = s;\n    s.chars().filter(|&c|\
    \ c == 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C' || c ==\
    \ 'd' || c == 'D' || c == 'e' || c == 'E' || c == 'f' || c == 'F' || c == 'g'\
    \ || c == 'G' || c == 'h' || c == 'H' || c == 'i' || c == 'I' || c == 'j' || c\
    \ == 'J' || c == 'k' || c == 'K' || c == 'l' || c == 'L' || c == 'm' || c == 'M'\
    \ || c == 'n' || c == 'N' || c == 'o' || c == 'O' || c == 'p' || c == 'P' || c\
    \ == 'q' || c == 'Q' || c == 'r' || c == 'R' || c == 's' || c == 'S' || c == 't'\
    \ || c == 'T' || c == 'u' || c == 'U' || c == 'v' || c == 'V' || c == 'w' || c\
    \ == 'W' || c == 'x' || c == 'X' || c == 'y' || c == 'Y' || c == 'z' || c == 'Z').for_each(|c|\
    \ { \n        s = s.to_string().chars().rev().collect();\n    });\n    \n    if\
    \ s.is_empty() {\n        return s;\n    }\n    \n    return s", "    let mut\
    \ s = s;\n    let mut res = String::new();\n    let mut i = 0;\n    loop {\n \
    \       match s.chars().nth(i) {\n            Some('a')| Some('b')| Some('c')|\
    \ Some('d')| Some('e')| Some('f') |\n            Some('g')| Some('h')| Some('i')|\
    \ Some('j')| Some('k')| Some('l')|\n            Some('m')| Some('n')| Some('o')|\
    \ Some('p')| Some('q')| Some('r')|\n            Some('s')| Some('t')| Some('u')|\
    \ Some('v')| Some('w')| Some('x')|\n            Some('y')| Some('z')| Some('_')=>\
    \ {\n                res += &s[..i];\n                res += &String::from(\"\
    A\") + &s[..i];\n                i += 2;\n            }\n            Some('0')|\
    \ Some('1')| Some('2')| Some('3')| Some('4')| Some('5')|\n            Some('6')|\
    \ Some('7')| Some('8')| Some('9')=> {\n                res += &s[..i];\n     \
    \           res += &String::from(\"a\") + &s[..i];\n                i += 2;\n\
    \            }\n            _=> {\n                res += &s[..i];\n         \
    \       i += 1;\n            }\n        }\n    }\n    res ", '    ', "    let\
    \ mut s = s;\n    let mut chars_map = HashMap::new();\n    for c in s.chars()\
    \ {\n        chars_map.insert(c, true);\n    }\n\n    for c in s.chars().rev()\
    \ {\n        if chars_map.get(c) {\n            let mut new_char: String = c.to_uppercase();\n\
    \            new_char.push(c.to_lowercase());\n            chars_map.insert(c,\
    \ false);\n            s = s.replace_str(c, new_char);\n        }\n    }\n   \
    \ s", "    let mut s = s;\n    let mut s = &mut s[0..s.len()];\n    s.reverse();\n\
    \    String::from_utf8(s).unwrap()", "    s.chars().fold(&mut \"\".to_string(),\
    \ |mut res, c| {\n        match c.to_lowercase() {\n            true => res.swap(c.to_string()),\n\
    \            false => res.swap(c.to_string()),\n        };\n        res\n    })",
  "    let mut s = String::from(s);\n    let mut chars = s.chars();\n    if chars.next().is_none()\
    \ {\n        s.reverse();\n    } else {\n        while chars.next().is_some()\
    \ {\n            let pos = chars.next().unwrap().as_str().len();\n           \
    \ let char = chars.next().unwrap().as_str()[pos..];\n            let mut pos =\
    \ 0;\n            let mut res = &s[..pos];\n            while res != char {\n\
    \                pos = pos + 1;\n                res = &s[..pos];\n          \
    \  }\n            let mut res = &s[pos..];\n            while let Some(pos) =\
    \ chars.next() {\n                let mut res = &s[..pos];\n                let\
    \ mut len = pos + 1;\n                while let Some(match) = res.get(len).unwrap().as_str().find(char)\
    \ {\n                    res = &s[..len];\n                    len = match + 1;\n\
    \                }\n            }\n            s = res.concat(&s[..pos]);\n  \
    \      }\n    }\n    s", "    let mut result = String::new();\n    let mut res\
    \ = String::new();\n    for ch in s {\n        match ch {\n            'a' =>\
    \ res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".to_owned()),\n\
    \            'b' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'c' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'd' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'e' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'f' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'g' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'h' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'i' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'j' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'k' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'l' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'm' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'n' => res.push_str(\"ABCDEFGHIJKLMNOPQRST", "    if\
    \ s.chars().any(|c| c.is_digit()) {\n        return s.to_string();\n    }\n  \
    \  if s.chars().any(|c| c.is_ascii_letter()) {\n        let mut res = s.to_string();\n\
    \        res.chars().rev().for_each(|c| {\n            if !c.is_ascii_letter()\
    \ {\n                res.append(c.to_ascii_uppercase());\n            } else {\n\
    \                res.append(c.to_ascii_lowercase());\n            }\n        });\n\
    \        return res;\n    }\n    s[..].rev().to_ascii_lowercase()", "    let mut\
    \ s = s;\n    let mut res: String = \"\";\n    for c in s.chars() {\n        if\
    \ let Some(low) = c {\n            if let Some(upper) = c.map(|x| x.to_uppercase())\
    \ {\n                s = s.replace(&low, &upper);\n            } else {\n    \
    \            res = c;\n                break;\n            }\n        } else {\n\
    \            res = c;\n            break;\n        }\n    }\n    res", "    if\
    \ s.is_empty() { return \"#{}\" }\n    let mut res = String::with_capacity(s.len());\n\
    \    let mut pos = 0;\n    for c in s.chars() {\n        if c.is_ascii_uppercase()\
    \ {\n            res.push_str(&s[pos..pos+1].to_lowercase());\n            pos\
    \ += 1;\n        } else if c.is_ascii_lowercase() {\n            res.push_str(&s[pos..pos+1].to_uppercase());\n\
    \            pos += 1;\n        } else {\n            res.push_str(&s[pos]);\n\
    \            pos += 1;\n        }\n    }\n    res.push_str(&s[pos..]);\n    res",
  "    let mut s = s;\n    s.chars().for_each(|c|{\n        let i = c.to_lowercase().find(|c|{\n\
    \            c.is_alpha()\n        })\n        if i != std::string::npos {\n \
    \           let j = c.to_uppercase().find(|c|{\n                c.is_alpha()\n\
    \            })\n            if j != std::string::npos {\n                s.swap(i,\
    \ j)\n            }\n        }\n    })\n    s", "    if let Some(first) = s.chars().next()\
    \ {\n        if first.to_ascii_lowercase().contains(&\"a\"..=&\"z\") {\n     \
    \       solve(&s.chars().rev().collect::<String>())\n        } else {\n      \
    \      solve(&s[1..].to_ascii_lowercase().collect::<String>())\n        }\n  \
    \  } else {\n        s\n    }", "    let mut s = String::from(s);\n    for &c\
    \ in s.chars() {\n        if c.is_ascii_lowercase() {\n            s = s.into_lowercase();\n\
    \        } else if c.is_ascii_uppercase() {\n            s = s.into_uppercase();\n\
    \        } else {\n            continue;\n        }\n    }\n    s", "    if s.is_empty()\
    \ {\n        return \"\".to_owned();\n    }\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        let upper = if c >= 'a' && c <= 'z' { c - 'a'\
    \ + 'A' } else { c };\n        let lower = if c >= 'A' && c <= 'Z' { c - 'A' +\
    \ 'a' } else { c };\n        let mut res = if upper <= lower {\n            upper.to_string()\
    \ + lower.to_string()\n        } else {\n            lower.to_string() + upper.to_string()\n\
    \        };\n        res.reverse();\n        result.push_str(&res);\n    }\n \
    \   result", "    s.chars().for_each(|c|{\n        let mut low = c;\n        let\
    \ mut high = c;\n\n        loop {\n            match c {\n                'a'\
    \ => low = low.to_ascii_lowercase().to_vec(),\n                'b' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'c' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'd' => high = high.to_ascii_lowercase().to_vec(),\n                'e' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'f' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'g' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'h' => high = high.to_ascii_lowercase().to_vec(),\n                'i' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'j' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'k' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'l' => high = high.to_ascii_lowercase().to_vec(),\n                'm' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'n' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'o' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'p' => high = high.to_ascii_lowercase().to_vec(),\n                'q' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'r' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                's' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     't' => high = high.to_ascii_lowercase().to_vec(),\n                'u' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'v' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'w' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'x' => high = high.to_ascii_lowercase().to_vec(),\n                'y' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'z' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'A' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'B' => high = high.to_ascii_lowercase().to_vec(),\n                'C' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'D' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'E' => low = low.to_ascii_lowercase().to_vec(),\n           \
    \     'F' => high = high.to_ascii_lowercase().to_vec(),\n                'G' =>\
    \ low = low.to_ascii_lowercase().to_vec(),\n                'H' => high = high.to_ascii_lowercase().to_vec(),\n\
    \                'I' => ", "    s.chars().map(|c| match c {\n        'A' ... 'Z'\
    \ => c.to_string().to_uppercase(),\n        'a' ... 'z' => c.to_string().to_lowercase(),\n\
    \        _ => c,\n    }).collect::<String>().to_string()", "    if s.is_empty()\
    \ || s.chars().count() == 0 {\n        return s\n    }\n    let mut result = String::with_capacity(s.len());\n\
    \    for i in s.chars() {\n        if i.is_lowercase() {\n            result.push(i.to_uppercase());\n\
    \        } else {\n            result.push(i.to_lowercase());\n        }\n   \
    \ }\n    result", "    let mut res: String = \"\";\n    for i in s.chars() {\n\
    \        if let Some(letter) = i.to_lowercase() {\n            res += letter;\n\
    \        } else {\n            res += i.to_uppercase();\n        }\n    }\n  \
    \  res.into_owned()", "    let mut s = s.chars().fold(String::new(), |mut acc,\
    \ x| {\n        match x {\n            'A' | 'a' => acc.insert(0, &*x.to_lowercase()),\n\
    \            'B' | 'b' => acc.insert(0, &*x.to_uppercase()),\n            _ =>\
    \ acc,\n        }\n    });\n    let mut res = s.chars().fold(String::new(), |mut\
    \ acc, x| {\n        match x {\n            'a' | 'A' => acc.insert(0, &*x.to_lowercase()),\n\
    \            'b' | 'B' => acc.insert(0, &*x.to_uppercase()),\n            _ =>\
    \ acc,\n        }\n    });\n    if s.chars().filter(|x| x.is_ascii_alphanumeric()).count()\
    \ == 0 {\n        res.insert(0, &s[..s.len()]);\n    } else {\n        res\n \
    \   }", "    use std::ascii::AsciiExt;\n    use std::ascii::IsLower;\n    let\
    \ mut res = String::new();\n    for c in s.chars().filter_map(|x| if IsLower(x)\
    \ {\n            Some(x.to_ascii_lowercase())\n        } else {\n            Some(x.to_ascii_uppercase())\n\
    \        }) {\n        if c <= 'z' || c >= 'A' {\n            let c = c.to_ascii_lowercase();\n\
    \            if c <= 'z' {\n                res.push(c);\n            } else {\n\
    \                res.push(c);\n            }\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res.chars().collect::<String>().reverse().collect()", " \
    \   match s.chars() {\n        &[char::from('a'), char::from('z')] => solve(&s.to_string().swapcase()[..]),\n\
    \        _ => s,\n    }", "    let mut s = s.to_lowercase().to_string();\n   \
    \ let mut lower = false;\n    for (i, ch) in s.chars().enumerate().filter(|&x|\
    \ !x.is_alphabetic(::std::ascii::AsciiExt)).enumerate() {\n        if !lower {\n\
    \            s.swap(0, i);\n        } else {\n            s.swap(i, 0);\n    \
    \    }\n        lower = x.is_alphabetic(::std::ascii::AsciiExt);\n    }\n    s",
  "    if s.is_empty() {\n        return String::new();\n    }\n    let mut res =\
    \ String::new();\n    let mut str = String::from(s);\n    let mut first_run =\
    \ true;\n    let mut cur_char = String::from(\"\");\n    let mut index = str.len()\
    \ - 1;\n    let mut cur_char_upper = String::from(\"\");\n    while index >= 0\
    \ {\n        let mut cur_pos = index;\n        let mut cur_char_lower = String::from(\"\
    \");\n        while index >= 0 {\n            cur_char.push(str[cur_pos]);\n \
    \           cur_char_upper.push(cur_char.chars().next().unwrap().to_uppercase());\n\
    \            cur_char_lower.push(cur_char.chars().next().unwrap().to_lowercase());\n\
    \            index -= 1;\n        }\n        if cur_char_upper.end() != cur_char_lower\n\
    \            || (cur_char_upper.len() == 0\n                && cur_char_lower.len()\
    \ != 0) {\n            break;\n        }\n        res.insert(0, cur_char_upper);\n\
    \        res.insert(0, cur_char_lower);\n        res.insert(0, cur_char);\n  \
    \      first_run = false;\n    }\n    if index == 0 && cur_char_upper.len() !=\
    \ 0 {\n        res.insert(0, cur_char_upper);\n    }\n    if index == 0 && cur_char_lower.len()\
    \ != 0 {\n        res.insert(0, cur_char_lower);\n    }\n    if index != 0 ||\
    \ first_run {\n        res.insert(0, cur_char);\n    }\n    return res.to_string();",
  "    let mut l = s.chars().count();\n    \n    let mut s = s;\n    while l > 0 {\n\
    \        s = s.chars().rev().collect();\n        l -= 1;\n    }\n    if l == 0\
    \ {\n        s = s.chars().rev().collect();\n    }\n    s", "    let mut s = s;\n\
    \    for (i, c) in s.chars().enumerate() {\n        if !is_letter_cased(c) &&\
    \ !is_letter_cased(&s[i - 1]) {\n            s = s.replace(&s[i..i].to_string(),\
    \ String::from(&s[i..i].to_lowercase()));\n        }\n    }\n    s", "    \n \
    \   let mut s = s.chars();\n    let mut i = 0;\n    let mut res = String::new();\n\
    \    \n    loop {\n        if i >= s.len() {\n            return res;\n      \
    \  }\n        let c = s.next().unwrap();\n        if c == c.to_lowercase() {\n\
    \            res = res.to_uppercase();\n        } else if c == c.to_uppercase()\
    \ {\n            res = res.to_lowercase();\n        } else {\n            res\
    \ = res + c;\n        }\n        i += 1;\n    }", "    let mut res = String::new();\n\
    \    for i in s.chars() {\n        if i.is_ascii_uppercase() {\n            res.push_str(i.to_ascii_lowercase());\n\
    \        } else {\n            res.push_str(i);\n        }\n    }\n    res", " \
    \   s.chars().filter(|c| c.is_ascii()).fold(String::new(), |mut accum, next| {\n\
    \        match next {\n            b'a' .. b'z' => accum.push(b'A'),\n       \
    \     b'A' .. b'Z' => accum.push(b'a'),\n            _ => accum\n        }\n \
    \   })", "    if s.is_empty() {\n        return String::from(\"123\");\n    }\n\
    \n    let mut new_s = s;\n\n    let mut new_s = s.chars().enumerate().filter(|(_,\
    \ c)| {\n        let char = c.to_ascii_lowercase();\n        if char != c.to_ascii_uppercase()\
    \ {\n            new_s = new_s.to_string();\n            return false;\n     \
    \   }\n        true\n    }).map(|(_, c)| c.to_ascii_uppercase()).collect::<String>();\n\
    \n    new_s.chars().for_each(|c|{\n        if !s.contains(&c) {\n            new_s\
    \ = new_s.to_string();\n        }\n    });\n\n    new_s.chars().for_each(|c|{\n\
    \        if s.contains(&c) {\n            new_s = new_s.to_string();\n       \
    \ }\n    });\n\n    new_s.chars().for_each(|c|{\n        if s.contains(&c.to_ascii_lowercase())\
    \ {\n            new_s = new_s.to_string();\n        }\n    });\n\n    new_s",
  "    if s.is_empty() {\n        return s.to_string();\n    }\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let char = s[i..].chars().next().unwrap();\n\
    \        let mut index = char.len() - 1;\n        if index >= 0 {\n          \
    \  if char[index].is_lowercase() {\n                if char[index..].chars().next().unwrap().is_lowercase()\
    \ {\n                    index = index - 1;\n                }\n            }\n\
    \        }\n        s[i] = char[index].to_string();\n        i += 1;\n    }\n\
    \    s.reverse();\n    \n    \n    return s", "    if s.chars().count() != s.len()\
    \ {\n        return s.to_string();\n    }\n    let mut chars = s.chars();\n  \
    \  let mut chars = chars.collect();\n    let mut res = String::new();\n    while\
    \ let Some(c) = chars.pop() {\n        if c.is_uppercase() {\n            chars.push(c.to_lowercase());\n\
    \        } else {\n            chars.push(c.to_uppercase());\n        }\n    }\n\
    \    res = res.concat(chars);\n    if res.chars().count() == 0 {\n        return\
    \ s.to_string();\n    }\n    res", "    let mut result = \"\";\n    let mut iter\
    \ = s.chars().enumerate();\n    for (ix, char) in iter {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += String::from(char - 'a' + 1);\n    \
    \    } else if char >= 'A' && char <= 'Z' {\n            result += String::from(char\
    \ - 'A' + 1);\n        } else {\n            result += char;\n        }\n    }\n\
    \    result", "    let mut res = s.to_string();\n    let mut i = 0;\n    while\
    \ i < res.len() {\n        if res[i].is_ascii() {\n            let mut j = i;\n\
    \            while j + 1 < res.len() {\n                if res[j + 1] == 65 {\n\
    \                    if res[j] != 67 {\n                        break;\n     \
    \               }\n                    j += 1;\n                } else {\n   \
    \                 if res[j] != 97 {\n                        break;\n        \
    \            }\n                    j += 1;\n                }\n            }\n\
    \            if j + 1 < res.len() {\n                res[i] = res[j].to_string();\n\
    \            } else {\n                res = \"0\".to_string() + res.to_string();\n\
    \            }\n        } else {\n            res = \"0\".to_string() + res.to_string();\n\
    \        }\n        i += 1;\n    }\n    return res.to_string();", "    let mut\
    \ s = String::from(s);\n    for c in s.chars() {\n        if c.is_alpha() {\n\
    \            if c.to_ascii_lowercase().contains(&c) {\n                s = s.replace(c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase())\n            } else {\n                s = s.replace(c.to_ascii_uppercase(),\
    \ c.to_ascii_lowercase())\n            }\n        } else {\n            s = s.replace(c,c);\n\
    \        }\n    }\n    s", "    s.chars().map(|c| if c.is_letter() {\n       \
    \ match c.to_lowercase() {\n            \"A\" => c.to_uppercase(),\n         \
    \   \"a\" => c.to_lowercase(),\n            _ => c,\n        }\n    } else {\n\
    \        c\n    }).collect()", "    match s.chars().filter(|x|x.is_letter()) {\n\
    \        Some(x) => {\n            let mut s = String::new();\n            for\
    \ i in x.to_lowercase().rev() {\n                s = &s[i..] + s;\n          \
    \  }\n            s.to_owned()\n        },\n        None => s.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().join(),\n\
    \    }", "    if s.is_empty() {\n        s\n    } else {\n        match s.chars().next()\
    \ {\n            Some(c) => match c.to_lowercase().as_byte() {\n             \
    \   b'a' => {\n                    c.to_uppercase().to_ascii_lowercase().to_string()\n\
    \                }\n                b'A' => {\n                    c.to_lowercase().to_ascii_uppercase().to_string()\n\
    \                }\n                _ => {\n                    c\n          \
    \      }\n            }\n            None => {\n                s.to_ascii_lowercase().to_string()\n\
    \            }\n        }\n    }", "    let mut s = s;\n    let mut t = s.to_lowercase();\n\
    \    let mut res = t;\n    while t.len() > 0 {\n        match t.chars().next()\
    \ {\n            Some(c) if !c.is_alphanumeric() => (),\n            Some(c) =>\
    \ {\n                if c != c.to_uppercase() {\n                    t = t.replace(c.to_uppercase(),\
    \ c);\n                } else {\n                    t = t.replace(c.to_lowercase(),\
    \ c);\n                }\n            }\n            None => ()\n        }\n \
    \   }\n    if s != t {\n        res = t.to_string();\n    }\n    return res.to_string();",
  "    let mut s = &s;\n    let mut res = String::new();\n    for c in s.chars().cloned()\
    \ {\n        if c.is_alpha() {\n            if c.is_lower() {\n              \
    \  res.push((c as i32).to_string().to_uppercase());\n            } else {\n  \
    \              res.push((c as i32).to_string().to_lowercase());\n            }\n\
    \        } else {\n            res.push(*c);\n        }\n    }\n    res.reverse();\n\
    \    return res.to_string();", "    \n    let mut s = s\n    .chars()\n    .fold(String::new(),\
    \ |res, &c| {\n        if c.is_ascii_lowercase() {\n            res.push_str(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push_str(c.to_ascii_lowercase());\n       \
    \ }\n        res\n    });\n    \n    if s.len() == 0 {\n        \"\".to_string()\n\
    \    } else {\n        s\n    }", "    if s.is_empty() {\n        return \"\"\n\
    \    }\n    let mut c = s.chars().enumerate();\n    let mut newc = c.clone();\n\
    \    for (i, _) in newc {\n        if newc.next().unwrap().1.is_lowercase() {\n\
    \            newc.next().unwrap().1.to_uppercase();\n        } else {\n      \
    \      newc.next().unwrap().1.to_lowercase();\n        }\n    }\n    String::from_utf8(c.collect()).unwrap()",
  '    s.chars().filter_map(|c| c.is_alphanumeric()).collect::<Vec<_>>().reverse().join::<String>()',
  "    // your code here\n    ", "    if s.is_empty() { return String::new(); }\n\
    \    let mut out = String::new();\n    for i in s.chars() {\n        if i.is_alphanumeric()\
    \ {\n            if i.is_lowercase() {\n                out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i.to_ascii_lowercase() {\n                    None\n          \
    \      } else {\n                    Some(String::from(*i))\n                }).collect();\n\
    \            } else {\n                out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i.to_ascii_uppercase() {\n                    None\n          \
    \      } else {\n                    Some(String::from(*i))\n                }).collect();\n\
    \            }\n        } else {\n            out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i {\n                None\n            } else {\n             \
    \   Some(String::from(*i))\n            }).collect();\n        }\n    }\n    if\
    \ out.is_empty() {\n        return s.to_string();\n    }\n    out.rev()", "  \
    \  let mut res = String::new();\n    let mut lower = false;\n    for ch in s.chars()\
    \ {\n        match ch {\n            'a' => if lower { res.append('A'); lower\
    \ = false; } else { res.append('a'); lower = true; },\n            'A' => if lower\
    \ { res.append('a'); lower = false; } else { res.append('A'); lower = true; },\n\
    \            _ => res.append(ch),\n        }\n    }\n    res.reverse()", "   \
    \ // Write your code here\n    let mut result = String::new();\n    for i in s.chars()\
    \ {\n        if i.is_ascii_lowercase() {\n            result.push_str(i.to_uppercase());\n\
    \        } else {\n            result.push_str(i.to_lowercase());\n        }\n\
    \    }\n    if result.len() == 0 {\n        result\n    } else {\n        result\n\
    \    }", "    let mut str = s.to_lowercase();\n    let mut res = \"\";\n    match\
    \ str {\n        \"a\" => \"b\",\n        \"b\" => \"a\",\n        \"c\" => \"\
    d\",\n        \"d\" => \"c\",\n        _ => str,\n    }", "    let mut s = s.to_lowercase();\n\
    \    s.chars().for_each(|c| {\n        if !c.is_ascii_uppercase() {\n        \
    \    s = s.to_lowercase().chars().fold(s, |s, c| s.chars().rev().next().unwrap().to_string().chars().collect::<String>()\
    \ + c.to_string());\n        } else {\n            s = s.to_uppercase().chars().fold(s,\
    \ |s, c| s.chars().rev().next().unwrap().to_string().chars().collect::<String>()\
    \ + c.to_string());\n        }\n    });\n    s", "    \n    if s.len() == 0 {\n\
    \        return \"\"\n    }\n    \n    let mut s = String::from(s);\n    let mut\
    \ res = String::from(\"\");\n    \n    for i in 0..s.len() {\n        match &s[i]\
    \ {\n            'a'..'z' => res = res.push_str(&(s[i] - 'a' + 10).to_string()),\n\
    \            'A'..'Z' => res = res.push_str(&(s[i] - 'A' + 10).to_string()),\n\
    \            _ => {}\n        }\n    }\n    \n    match res {\n        \n    \
    \    s => s.to_string(),\n        \n        _ => \"\"\n    }", "    \n    if s.len()\
    \ == 0 {\n        \"\"\n    } else if s.chars().all(|c| is_letter(c)) {\n    \
    \    \n        let mut chars = s.chars();\n        let mut result = s.to_string();\n\
    \        let mut i = 0;\n        loop {\n            if chars[i] != chars[i].to_ascii_lowercase()\
    \ {\n                result.push_str(&chars[i]);\n                break;\n   \
    \         } else if chars[i] == chars[i].to_ascii_lowercase() {\n            \
    \    chars[i] = chars[i].to_ascii_uppercase();\n            } else {\n       \
    \         chars[i] = chars[i].to_ascii_lowercase();\n            }\n         \
    \   i += 1;\n        }\n        result\n    } else {\n        let mut chars =\
    \ s.chars();\n        let mut result = s.to_string();\n        let mut i = 0;\n\
    \        loop {\n            if chars[i] != chars[i].to_ascii_uppercase() {\n\
    \                result.push_str(&chars[i]);\n                break;\n       \
    \     } else if chars[i] == chars[i].to_ascii_uppercase() {\n                chars[i]\
    \ = chars[i].to_ascii_lowercase();\n            } else {\n                chars[i]\
    \ = chars[i].to_ascii_uppercase();\n            }\n            i += 1;\n     \
    \   }\n        result\n    }", "    let mut reversed_string = String::new();\n\
    \    for i in s.chars() {\n        reversed_string.push(i);\n    }\n    if s.chars().count()\
    \ == 0 {\n        reversed_string.push(c);\n    }\n    reversed_string.swap();\n\
    \    reversed_string.to_string()", "    let mut s = s.chars();\n    loop {\n \
    \       let c = match s.next() {\n            None => break,\n            Some(_c)\
    \ => _c,\n        };\n        if c.is_alphabetical() {\n            if c.is_lowercase()\
    \ {\n                s = s.map(|c| c.to_uppercase()).collect();\n            }\
    \ else {\n                s = s.map(|c| c.to_lowercase()).collect();\n       \
    \     }\n        }\n    }\n    \"\".to_string()\n        .join(s)", "    s.chars().map(|c|\
    \ {\n        let is_letter = c.is_ascii_letter();\n        if is_letter {\n  \
    \          (c.to_ascii_lowercase(), c.to_ascii_uppercase())\n        } else {\n\
    \            c\n        }\n    }).fold(\"\", |mut acc, (c1, c2)| {\n        match\
    \ c1 { \n            // c1 is not equal to c2\n            Some(c1_) => {\n  \
    \              let c2_ = match c2 {\n                    // if c2 is not equal\
    \ to c2_, do nothing\n                    Some(c2_) => c2_,\n                \
    \    // if c2 is equal to c2_, just return the c2_\n                    None =>\
    \ c2_,\n                };\n                let c1_ = match c1_ {\n          \
    \          // if c1 is not equal to c1_, do nothing\n                    Some(c1_)\
    \ => c1_,\n                    // if c1 is equal to c1_, just return the c1_\n\
    \                    None => c1_,\n                };\n                let mut\
    \ c1_ = c1.clone();\n                c1_ += c2_;\n                c1_\n      \
    \      },\n            // both c1 and c2 are equal to c1_\n            None =>\
    \ c2,\n        }\n    }).collect()", "    if s.is_empty() {\n        return s.to_string();\n\
    \    }\n\n    let mut s = String::from(s);\n\n    while !s.is_empty() {\n    \
    \    let c = s.chars().next().unwrap().to_ascii_uppercase();\n        s = &s[1..s.len()\
    \ - 1].to_ascii_lowercase()[1..].to_string();\n        s = c + (&s[1..s.len()\
    \ - 1].to_ascii_lowercase()[1..]).to_string();\n    }\n\n    return s.to_string();",
  "    \n    let mut newS = String::from(s);\n    for ch in s.chars() {\n        if\
    \ ch.is_ascii() {\n            newS = newS.replace_range(ch.start(), ch.end(),\
    \ \n                (ch.to_ascii_lowercase() + ch.to_ascii_uppercase()).to_string());\n\
    \        }\n    }\n    return newS", "    s.chars().\n        filter(|c| c.is_ascii_ascii_case()).\n\
    \        map(|c| c.to_ascii_ascii_case()).\n        collect()", "    s.chars().fold(String::new(),\
    \ |mut acc, c| match c {\n        'a' .. 'z' => {\n            *acc.push_str(&c.to_uppercase());\n\
    \            acc\n        }\n        'A' .. 'Z' => {\n            *acc.push_str(&c.to_lowercase());\n\
    \            acc\n        }\n        _ => acc,\n    }).to_string()", "    let\
    \ mut result = String::with_capacity(s.len());\n\n    for c in s.chars() {\n \
    \       let i = match c.to_ascii_lowercase() {\n            'A' => 0,\n      \
    \      'a' => 1,\n            'B' => 2,\n            'b' => 3,\n            'C'\
    \ => 4,\n            'c' => 5,\n            _ => continue,\n        };\n\n   \
    \     let j = match c.to_ascii_uppercase() {\n            'A' => 0,\n        \
    \    'a' => 1,\n            'B' => 2,\n            'b' => 3,\n            'C'\
    \ => 4,\n            'c' => 5,\n            _ => continue,\n        };\n\n   \
    \     result.push_str(&s[i as usize..j as usize].to_lowercase());\n    }\n\n \
    \   result", "    if s.is_empty() {\n        String::new()\n    } else {\n   \
    \     let mut s = String::from(s);\n        let mut res = String::new();\n   \
    \     for c in s.chars() {\n            if c.is_letter() {\n                let\
    \ mut revc = c;\n                if revc <= 'Z' {\n                    revc +=\
    \ 'a' - 'A';\n                } else {\n                    revc -= 'a' - 'A';\n\
    \                }\n                res += &revc;\n            } else {\n    \
    \            res += &c;\n            }\n        }\n        res\n    }", "    let\
    \ mut input = s.to_string();\n    if input.chars().all(|c| !c.is_letter()) {\n\
    \        return input.to_owned();\n    }\n    let mut reversed = s.clone();\n\
    \    reversed.chars().rev().for_each(|c| {\n        reversed.push_str(c.to_ascii_lowercase());\n\
    \    });\n    reversed.to_string()", "    for &c in s.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase();\n        } else if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase();\n        } else {\n            c\n  \
    \      }\n    }\n    s", "    let mut new_s = s;\n    new_s = new_s.chars().filter_map(|c|{\n\
    \        match c {\n            'A'..='Z' => Some(c.to_string() + c.to_string()),\n\
    \            'a'..='z' => Some(c.to_string() + c.to_string()),\n            _\
    \ => None,\n        }\n    }).collect();\n    new_s.reverse();\n    new_s.join(\"\
    \");", "    match s.len() {\n        1 => s.to_string(),\n        _ => {\n   \
    \         let mut s = s;\n            let mut l = s.chars().count();\n       \
    \     let mut c = 1;\n            for i in s.chars().rev().skip(l) {\n       \
    \         if c.is_even() {\n                    c = 1;\n                    l\
    \ = l - 1;\n                } else {\n                    c = 0;\n           \
    \     }\n                s = i.to_string() + s;\n            }\n            s.to_string()\n\
    \        }\n    }", "    let mut s: String = s;\n    for ch in s.chars() {\n \
    \       if ch.is_ascii() {\n            let mut i = ch.as_bytes();\n         \
    \   match i.len() {\n                1 => {\n                    let (mut a, mut\
    \ b) = (*i.rbegin(), *i.rend());\n                    if *a >= 'a' && *a <= 'z'\
    \ && *b >= 'a' && *b <= 'z' {\n                        *a = 'Z';\n           \
    \             *b = 'z';\n                    }\n                    else if *a\
    \ >= 'A' && *a <= 'Z' && *b >= 'A' && *b <= 'Z' {\n                        *a\
    \ = 'z';\n                        *b = 'Z';\n                    }\n         \
    \           else {\n                        *a = 'A';\n                      \
    \  *b = 'a';\n                    }\n                }\n                2 => {\n\
    \                    let (mut a, mut b) = (*i.rbegin(), *i.rbegin());\n      \
    \              if *a >= 'a' && *a <= 'z' && *b >= 'a' && *b <= 'z' {\n       \
    \                 *a = 'Z';\n                        *b = 'z';\n             \
    \       }\n                    else if *a >= 'A' && *a <= 'Z' && *b >= 'A' &&\
    \ *b <= 'Z' {\n                        *a = 'z';\n                        *b =\
    \ 'Z';\n                    }\n                    else {\n                  \
    \      *a = 'A';\n                        *b = 'a';\n                    }\n \
    \               }\n                3 => {\n                    let (mut a, mut\
    \ b) = (*i.rbegin(), *i.rbegin());\n                    if *a >= 'a' && *a <=\
    \ 'z' && *b >= 'a' && *b <= 'z' {\n                        *a = 'Z';\n       \
    \                 *b = 'z';\n                    }\n                    else if\
    \ *a >= 'A' && *a <= 'Z' && *b >= 'A' && *b <= 'Z' {\n                       \
    \ *a = 'z';\n                        *b = 'Z';\n                    }\n      \
    \              else {\n                        *a = 'A';\n                   \
    \     *b = 'a';\n                    }\n                }\n                4 =>\
    \ {\n                    let (mut a, mut b) = (*i.rbegin(), *i.rbegin());\n  \
    \                  if *a >= 'a' && *a <= 'z' && *b >= 'a' && *b <= 'z' {\n   \
    \                     *a", "    match s.chars().count() {\n        0 => String::from(\"\
    \"),\n        1 => String::from(s.to_lowercase()),\n        _ => String::from(s.to_lowercase().chars().collect::<String>().reverse().collect::<String>()),\n\
    \    }", "    let mut s = s;\n    for i in s.chars() {\n        if i.is_lowercase()\
    \ || i.is_uppercase() {\n            let mut tmp = i;\n            tmp = tmp.to()\
    \ as char;\n            tmp.swap(i);\n        }\n    }\n    s", "    let mut str\
    \ = s.to_string();\n    for i in 0..str.len() {\n        let ch = str.chars().nth(i).unwrap();\n\
    \        if ch.is_uppercase() {\n            let char_int = ch.to_digit(10).unwrap();\n\
    \            str = str.chars().map(|&ch| ch.to_ascii_lowercase().unwrap()).collect();\n\
    \            let char_upper = Char::from_u32(char_int + 1).unwrap();\n       \
    \     str = str.replace(i, i, char_upper);\n        } else if ch.is_lowercase()\
    \ {\n            let char_int = ch.to_digit(10).unwrap();\n            str = str.chars().map(|&ch|\
    \ ch.to_ascii_uppercase().unwrap()).collect();\n            let char_lower = Char::from_u32(char_int\
    \ + 1).unwrap();\n            str = str.replace(i, i, char_lower);\n        }\
    \ else {\n            str = str.chars().collect();\n        }\n    }\n    str",
  "    let mut res = String::new();\n    let mut s_iter = s.chars().map(|c| c.to_string());\n\
    \    loop {\n        if let Some(letter) = s_iter.next() {\n            let mut\
    \ new_letter = letter;\n            if letter.is_lowercase() {\n             \
    \   new_letter += 'a' - 'A';\n            } else {\n                new_letter\
    \ += 'A' - 'a';\n            }\n            res += new_letter;\n        } else\
    \ {\n            break;\n        }\n    }\n    res", "    let mut s = s;\n   \
    \ let mut result = s;\n    let mut char_iter = s.chars();\n    loop {\n      \
    \  match char_iter.next() {\n            None => break,\n            Some(c) if\
    \ c.is_alphanumeric() => result += c.to_ascii_uppercase(),\n            Some(c)\
    \ => result += c,\n        }\n    }\n    result", "    let mut s = String::new();\n\
    \    for c in s {\n        if !c.is_alphanumeric() {\n            s.push_str(c.to_lowercase());\n\
    \        } else {\n            s.push_str(c.to_uppercase());\n        }\n    }\n\
    \    s.to_owned()", "    let mut res = String::new();\n    for i in s.chars()\
    \ {\n        if let Some(c) = i.to_ascii_lowercase() {\n            res.push_str(&c.to_string());\n\
    \        } else {\n            res.push_str(&i.to_string());\n        }\n    }\n\
    \    if res.is_empty() {\n        res = \"#\";\n    }\n    res", "    if s.is_empty()\
    \ {\n        return s;\n    }\n    \n    let mut s = s.chars().collect::<String>();\n\
    \    \n    let mut s = String::from(s);\n    \n    loop {\n        if s.chars().all(|c|\
    \ *c == '#') {\n            break;\n        }\n        \n        if s.chars().all(|c|\
    \ *c >= 'a' && *c <= 'z') {\n            s = s.chars().collect::<String>().collect::<String>().to_string().to_lowercase();\n\
    \        } else {\n            s = s.chars().collect::<String>().collect::<String>().to_string();\n\
    \        }\n    }\n    \n    s", "    s.chars().map(|c| if c.is_ascii_alphanumeric()\
    \ || c.is_ascii() {\n        char::to_upper(c)\n    } else if c.is_ascii_lower()\
    \ {\n        char::to_lower(c)\n    } else {\n        c\n    }).collect()", " \
    \   if s.len() == 0 {\n        return s.clone();\n    }\n\n    let mut s = s.clone();\n\
    \n    for i in 0..s.len() {\n        if s.chars().any(|c| c == '#' || c == '@'\
    \ || c == '.') {\n            s.swap(i, i + 1);\n        }\n        if s.chars().any(|c|\
    \ c == ' ') {\n            s.swap(i, i + 1);\n        }\n        if s.chars().any(|c|\
    \ c == '-') {\n            s.swap(i, i + 1);\n        }\n    }\n\n    s[0..s.len()\
    \ - 1]", "    if s.is_empty() {\n        return \"\";\n    }\n    \n    let mut\
    \ s = String::from(s);\n    for i in 0..s.len() {\n        let ch = s.chars().nth(i);\n\
    \        if ch.is_some() {\n            let mut ch = ch.unwrap();\n          \
    \  if ch.is_lowercase() {\n                ch = ch.to_uppercase();\n         \
    \   } else if ch.is_uppercase() {\n                ch = ch.to_lowercase();\n \
    \           } else {\n                let mut j = i;\n                while j\
    \ != i && s.chars().nth(j).is_none() {\n                    j += 1;\n        \
    \        }\n                let mut ch = ch.to_string();\n                let\
    \ mut j = i;\n                while j != i && s.chars().nth(j).is_none() {\n \
    \                   j += 1;\n                }\n                for k in i..j\
    \ {\n                    ch = s.chars().nth(k).unwrap().to_string() + ch;\n  \
    \              }\n            }\n            s.insert(i, ch);\n        } else\
    \ {\n            s.insert(i, s.chars().nth(i).unwrap().to_string());\n       \
    \ }\n    }\n    \n    s", "    let mut new_s = \"\".to_string();\n\n    for c\
    \ in s {\n        if !c.is_ascii() {\n            new_s += char::ToLower(c).to_string();\n\
    \        } else {\n            new_s += c;\n        }\n    }\n\n    let mut iter\
    \ = new_s.chars();\n\n    while let Some(c) = (iter.next()) {\n        let new_c\
    \ = match c {\n            char::ToLower(c) => char::ToUpper(c),\n           \
    \ c => c,\n        };\n\n        new_s += new_c.to_string();\n    }\n\n    new_s",
  "    \n    let mut s1 = s.to_string();\n    let mut s2 = s.to_string();\n    for\
    \ i in s1.chars() {\n        if i.is_lowercase() {\n            i = i.to_upper().to_string();\n\
    \        } else {\n            i = i.to_lowercase().to_string();\n        }\n\
    \        s2.push_str(&i);\n    }\n    s2.to_string()", "    s.chars()\n      \
    \  .filter_map(|&x| x.is_ascii_lowercase() || x.is_ascii_uppercase())\n      \
    \  .map(|&x| if x.is_ascii_lowercase() { x.to_string().to_upper() } else { x.to_string()\
    \ })\n        .collect::<Vec<_>>()\n        .into_iter()\n        .fold(String::new(),\
    \ |mut s, x| s.push_str(x).unwrap());\n    s", "    s.chars().map(|c| match c\
    \ {\n        'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n        _ => c.to_string(),\n\
    \    }).join(\"\").chars().fold(s.chars().map(|c| match c {\n        'a' .. 'z'\
    \ => c.to_string().to_ascii_lowercase(),\n        _ => c.to_string(),\n    }).collect(),\
    \ |mut s1, s2| {\n        s1.chars().fold(s2.chars().map(|c| match c {\n     \
    \       'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n            _ => c.to_string(),\n\
    \        }).collect(), |mut s2, s1| {\n            if s2.is_empty() {\n      \
    \          s1\n            } else {\n                s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                    'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \                    _ => c.to_string(),\n                }).collect(), |mut s1,\
    \ s2| {\n                    s2.chars().fold(s1.chars().map(|c| match c {\n  \
    \                      'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n   \
    \                     _ => c.to_string(),\n                    }).collect(), |mut\
    \ s1, s2| {\n                        s2.chars().fold(s1.chars().map(|c| match\
    \ c {\n                            'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \                            _ => c.to_string(),\n                        }).collect(),\
    \ |mut s1, s2| {\n                            s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                                'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n\
    \                                _ => c.to_string(),\n                       \
    \     }).collect(), |mut s1, s2| {\n                                s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                                    'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \                                    _ => c.to_string(),\n                   \
    \             }).collect(), |mut s1, s2| {\n                                 \
    \   s2.chars().fold(s1.chars().map(|c| match c {\n                           \
    \             'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n            \
    \                            _ => c.to_string(),\n                           \
    \         }).collect(), |mut s1, s2| {\n                                     \
    \   s2.chars().fold(s1.chars().map(|c| match c {\n                           \
    \                 'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n        \
    \                                    _ => c.to_string(),\n                   \
    \                     }).collect(), |mut s1, s2| {\n                         \
    \                   s2.char", "    let mut chars = s.chars();\n    chars.rev();\n\
    \    let mut res = String::new();\n    chars.for_each(|c| match c {\n        Some(c)\
    \ => {\n            match c.to_ascii_lowercase() {\n                Some(c) =>\
    \ c.to_ascii_uppercase().unwrap().append(&mut res),\n                None => c.append(&mut\
    \ res),\n            }\n        },\n        None => c.append(&mut res),\n    });\n\
    \    res", "    if s.chars().all(|c| c.is_ascii_letter()) {\n        solve2(s.chars().filter(|c|\
    \ !c.is_ascii_letter()).collect::<String>())\n    } else {\n        solve2(s.chars().collect::<String>())\n\
    \    }", "    let mut res = String::with_capacity(s.len());\n\n    for ch in s.chars()\
    \ {\n        if let Some(letter) = Letter::from(ch) {\n            res.push_str(letter.to_uppercase());\n\
    \        } else {\n            res.push(*ch);\n        }\n    }\n    res", " \
    \   match s.chars().cloned() {\n        &[&c] => if c.is_letter() {\n        \
    \    c.to_uppercase().to_string().to_string()\n        } else {\n            c.to_string().to_string()\n\
    \        },\n        _ => s.to_string(),\n    }", "    let mut a = s.to_lowercase();\n\
    \    let mut b = s.to_lowercase();\n    for i in 0..a.len() {\n        if a[i]\
    \ >= 'a' && a[i] <= 'z' {\n            let c = a[i] - 'a' + 10;\n            b\
    \ = b.chars().map(|x| *x - c).collect::<String>();\n        }\n        if a[i]\
    \ >= 'A' && a[i] <= 'Z' {\n            let c = a[i] - 'A' + 10;\n            a\
    \ = a.chars().map(|x| *x - c).collect::<String>();\n        }\n    }\n    return\
    \ a + \"#\" + b;", "    if s.is_empty() {\n        s\n    } else {\n        let\
    \ mut str = String::new();\n        for ch in s.chars() {\n            if ch.is_uppercase()\
    \ {\n                str = format!(\"{}{}\", ch, str);\n            } else {\n\
    \                str = format!(\"{}{}\", str.to_lowercase(), ch);\n          \
    \  }\n        }\n        str\n    }", "    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            match c {\n                'a' =>\
    \ s.push_str(c.to_lowercase()),\n                'A' => s.push_str(c.to_uppercase()),\n\
    \                '#' => s.push_str(\"##\"),\n                '$' => s.push_str(\"\
    $$\"),\n                _ => (),\n            }\n        } else {\n          \
    \  match c {\n                'a' => s.push_str(c.to_uppercase()),\n         \
    \       'A' => s.push_str(c.to_lowercase()),\n                '#' => s.push_str(\"\
    ##\"),\n                '$' => s.push_str(\"$$\"),\n                _ => (),\n\
    \            }\n        }\n    });\n    s", "    s.chars().fold(String::new(),\
    \ |mut s, c| match c {\n        'a' => {\n            s.push_str(s.chars().filter(|c|\
    \ c.is_ascii_letter()).collect());\n            s.push_str(s.chars().filter(|c|\
    \ !c.is_ascii_letter()).collect())\n        }\n        'A' => {\n            s.push_str(s.chars().filter(|c|\
    \ c.is_ascii_letter()).collect());\n            s.push_str(s.chars().filter(|c|\
    \ !c.is_ascii_letter()).collect())\n        }\n        _ => s.push(c),\n    })",
  "    s.chars().map(|c| match c {\n        'a' => if c.is_uppercase() { c.to_ascii_lowercase()\
    \ } else { c.to_ascii_uppercase() },\n        'A' => if c.is_lowercase() { c.to_ascii_uppercase()\
    \ } else { c.to_ascii_lowercase() },\n        _ => c,\n    }).collect()", "  \
    \  let mut res = String::new();\n    for (i, char) in s.chars().enumerate() {\n\
    \        if char >= 'a' && char <= 'z' {\n            match char {\n         \
    \       'a' => res.push_str(\"A\"),\n                'b' => res.push_str(\"B\"\
    ),\n                'c' => res.push_str(\"C\"),\n                'd' => res.push_str(\"\
    D\"),\n                'e' => res.push_str(\"E\"),\n                'f' => res.push_str(\"\
    F\"),\n                'g' => res.push_str(\"G\"),\n                'h' => res.push_str(\"\
    H\"),\n                'i' => res.push_str(\"I\"),\n                'j' => res.push_str(\"\
    J\"),\n                'k' => res.push_str(\"K\"),\n                'l' => res.push_str(\"\
    L\"),\n                'm' => res.push_str(\"M\"),\n                'n' => res.push_str(\"\
    N\"),\n                'o' => res.push_str(\"O\"),\n                'p' => res.push_str(\"\
    P\"),\n                'q' => res.push_str(\"Q\"),\n                'r' => res.push_str(\"\
    R\"),\n                's' => res.push_str(\"S\"),\n                't' => res.push_str(\"\
    T\"),\n                'u' => res.push_str(\"U\"),\n                'v' => res.push_str(\"\
    V\"),\n                'w' => res.push_str(\"W\"),\n                'x' => res.push_str(\"\
    X\"),\n                'y' => res.push_str(\"Y\"),\n                'z' => res.push_str(\"\
    Z\"),\n                _ => res\n            }\n        } else {\n           \
    \ match char {\n                'A' => res.push_str(\"a\"),\n                'B'\
    \ => res.push_str(\"b\"),\n                'C' => res.push_str(\"c\"),\n     \
    \           'D' => res.push_str(\"d\"),\n                'E' => res.push_str(\"\
    e\"),\n                'F' => res.push_str(\"f\"),\n                'G' => res.push_str(\"\
    g\"),\n                'H' => res.push_str(\"h\"),\n                'I' => res.push_str(\"\
    i\"),\n                'J' => res.push_str(\"j\"),\n                'K' => res.push_str(\"\
    k\"),\n                'L' => res.push_str(\"l\"),\n                'M' => res.push_str(\"\
    m\"),\n                'N' => res.push_str(\"n\"),\n                'O' => res.push_str(\"\
    o\"),\n                'P' => res.push_str(\"p\"),\n                'Q' => res.push_str(\"\
    q\"),\n                'R' => res.push_str(\"r\"),\n                'S' => res.push_str(\"\
    s\"),\n                'T' => res.push_str(\"t\"),\n                'U' => res.push_str(\"\
    u\"),\n                'V' => res.push_str(\"v\"),\n                'W' => res.push_str(\"\
    w\"),\n                'X' => res.push_str(\"x\"),\n                'Y' => res.push_str(\"\
    y\"),\n                'Z", "    if s.len() == 0 {\n        return \"\";\n   \
    \ }\n    let mut reversed = false;\n    let mut res = String::new();\n    for\
    \ i in s.chars() {\n        if let Some(letter) = i.to_ascii_lowercase() {\n \
    \           reversed = !reversed;\n            letter = String::from(letter.to_ascii_uppercase());\n\
    \            res.append(&letter);\n        } else {\n            res.append(&i);\n\
    \        }\n    }\n    if reversed {\n        let mut reverse = String::new();\n\
    \        for i in res.chars() {\n            let mut temp: String = String::new();\n\
    \            let mut last: String = String::new();\n            for j in i.chars()\
    \ {\n                match j {\n                    Some('a'..'z') => temp.push(*j),\n\
    \                    Some('A'..'Z') => temp.push(*j),\n                    _ =>\
    \ last.append(j)\n                }\n            }\n            res.append(&temp);\n\
    \            res.append(&last);\n        }\n    }\n    res", '    s.chars().rev().collect()',
  "    let mut new_str: String = \"\";\n    let mut cnt: usize = 0;\n    for c in\
    \ s.chars() {\n        if c.is_ascii_letter() {\n            new_str += c.to_ascii_uppercase();\n\
    \        } else {\n            new_str += c.to_ascii_lowercase();\n        }\n\
    \        cnt += 1;\n    }\n    if cnt == 0 {\n        new_str = new_str.to_ascii_lowercase();\n\
    \    }\n    new_str", "    let mut res = String::new();\n    for i in s.chars()\
    \ {\n        res.push_str(i.to_ascii_lowercase());\n    }\n    if res.chars().count()\
    \ > 0 {\n        res.push_str(s.chars().count());\n    } else {\n        res.push_str(s);\n\
    \    }\n    return res;", "    s.chars().fold(\"\", |mut acc, c| if c.is_ascii_uppercase()\
    \ {\n        acc.push_str(&c.to_ascii_lowercase())\n    } else {\n        acc.push_str(&c.to_ascii_uppercase())\n\
    \    })", "    s.chars().fold(s.to_owned(), |acc, c| match c {\n        'a' =>\
    \ acc.to_owned().to_string().to_string().to_lowercase() + c.to_string(),\n   \
    \     'A' => acc.to_owned().to_string().to_string().to_uppercase() + c.to_string(),\n\
    \        _ => c,\n    })", "    let mut s = s.chars().collect::<Vec<_>>();\n \
    \   let mut res = s.clone();\n    for i in 0..s.len() {\n        if s.len() ==\
    \ 1 {\n            break;\n        }\n        match s.chars().nth(i).unwrap()\
    \ {\n            'A' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            'a' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            '0' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            '#' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            _ => (),\n        };\n    }\n    res", "    s.chars().map(|c| match\
    \ c {\n        'a' | 'A' => c.to_uppercase(),\n        'b' | 'B' => c.to_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    s.chars().map(|&c| match c {\n     \
    \   'a' .. 'z' => c.to_string().to_uppercase().to_string(),\n        'A' .. 'Z'\
    \ => c.to_string().to_lowercase().to_string(),\n        _ => c.to_string(),\n\
    \    }).collect::<String>() + s.chars().last().to_string()", "    let mut ans\
    \ = \"\";\n    let mut i = 0;\n    while i < s.len() {\n        if char::is_ascii_lowercase(&s[i..])\
    \ {\n            ans.push_str(&s[i ..].rev());\n        } else if char::is_ascii_uppercase(&s[i..])\
    \ {\n            ans.push_str(&s[i ..].rev());\n        } else {\n           \
    \ ans.push_str(&s[i ..]);\n        }\n        i += 1;\n    }\n    ans", "    let\
    \ mut res = String::from(s);\n    for i in 0..s.len() {\n        if s[i].is_ascii()\
    \ {\n            res.swap(i, s.len() - i);\n        } else {\n            res.swap(i,\
    \ s.len() - i - 1);\n        }\n    }\n    res", "    s.chars()\n        .filter(|c|\
    \ c.is_alphabetic())\n        .map(|c| match c {\n            c @ _ => c.to_ascii_uppercase().to_string(),\n\
    \            _ => c,\n        })\n        .collect::<Vec<_>>()\n        .join::<String>()",
  "    let mut res = s.to_string();\n    let mut new_chars = s.chars().collect::<Vec<_>>();\n\
    \    new_chars.sort();\n    let mut i = 0;\n    while i < new_chars.len() {\n\
    \        match new_chars[i] {\n            Some(letter) => {\n               \
    \ let new_letter = match letter {\n                    'a' => char::from('Z'),\n\
    \                    'b' => char::from('Y'),\n                    'c' => char::from('X'),\n\
    \                    'd' => char::from('W'),\n                    'e' => char::from('V'),\n\
    \                    'f' => char::from('U'),\n                    'g' => char::from('T'),\n\
    \                    'h' => char::from('S'),\n                    'i' => char::from('R'),\n\
    \                    'j' => char::from('Q'),\n                    'k' => char::from('P'),\n\
    \                    'l' => char::from('O'),\n                    'm' => char::from('N'),\n\
    \                    'n' => char::from('M'),\n                    'o' => char::from('A'),\n\
    \                    'p' => char::from('D'),\n                    'q' => char::from('H'),\n\
    \                    'r' => char::from('F'),\n                    's' => char::from('C'),\n\
    \                    't' => char::from('G'),\n                    'u' => char::from('E'),\n\
    \                    'v' => char::from('J'),\n                    'w' => char::from('I'),\n\
    \                    'x' => char::from('H'),\n                    'y' => char::from('K'),\n\
    \                    'z' => char::from('J'),\n                    'A' => char::from('O'),\n\
    \                    'B' => char::from('N'),\n                    'C' => char::from('M'),\n\
    \                    'D' => char::from('P'),\n                    'E' => char::from('Q'),\n\
    \                    'F' => char::from('R'),\n                    'G' => char::from('S'),\n\
    \                    'H' => char::from('T'),\n                    'I' => char::from('U'),\n\
    \                    'J' => char::from('V'),\n                    'K' => char::from('W'),\n\
    \                    'L' => char::from('X'),\n                    'M' => char::from('Y'),\n\
    \                    'N' => char::from('Z'),\n                    _ => letter\n\
    \                };\n                let new_i = new_chars.len() - i;\n      \
    \          let mut new_chars2 = new_chars.clone();\n                let mut new_chars3\
    \ = new_chars.clone();\n                *new_chars", "    if s.is_empty() {\n\
    \        return \"\"\n    }\n\n    if s[0].isalpha() {\n        let mut res =\
    \ s.clone();\n        for (i, c) in res.chars().enumerate() {\n            if\
    \ i != 0 && c.is_lowercase() {\n                res.swap(i - 1, i);\n        \
    \    } else if i != 0 && c.is_uppercase() {\n                res.swap(i, i - 1);\n\
    \            }\n        }\n        res\n    } else {\n        s\n    }", "   \
    \ let mut s = s;\n    let mut new_s = s;\n\n    for &ch in s {\n        if !ch.is_lowercase()\
    \ {\n            new_s = new_s.swapcase();\n        }\n    }\n\n    new_s", " \
    \   let mut result = s.to_string();\n    \n    for i in s.chars() {\n        match\
    \ i {\n            c if c.is_alphanumeric() => (i.to_ascii_lowercase()) + result.to_ascii_lowercase(),\n\
    \            _ => result,\n        }\n    }\n    \n    result", "    for &c in\
    \ s.chars() {\n        if let Some(old) = c.to_ascii_lowercase() {\n         \
    \   c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }\n    }\n    s", "    if s.is_empty() {\n        return s;\n    }\n\
    \    let mut res = String::new();\n    \n    for ch in s {\n        if ch.is_alpha()\
    \ {\n            \n            if let Some(m) = m.to_lowercase().find() {\n  \
    \              res.push_str(&s[..m]);\n                res.push_str(&s[m + 1].to_uppercase());\n\
    \            } else {\n                res.push_str(&s[..m.to_uppercase().len()]);\n\
    \                res.push_str(&s[m.to_uppercase().len()].to_lowercase());\n  \
    \          }\n        } else {\n            res.push_str(&s[..]);\n        }\n\
    \    }\n\n    res", "    s.chars().fold(\"\".to_string(), |acc: String, c: char|\
    \ {\n        match c {\n            'a' => acc.to_string().to_lowercase(),\n \
    \           'b' => acc.to_string().to_uppercase(),\n            '#' => acc.to_string(),\n\
    \            '@' => acc.to_string().to_lowercase(),\n            _ => acc,\n \
    \       }\n    })", "    let mut string = s.to_owned();\n    for c in string.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            string = string.to_lowercase();\n\
    \        }\n        else if c.is_ascii_uppercase() {\n            string = string.to_uppercase();\n\
    \        }\n        else {\n            string = string.replace(c, c);\n     \
    \   }\n    }\n    return string;", "    let mut s = s.replace(\" \", \"\");\n\
    \    for i in s.chars() {\n        if i != ' ' {\n            s = s.chars().map(|x|\n\
    \                if x == 'A' || x == 'a' {\n                    'B'\n        \
    \        } else {\n                    x.to_string()\n                }\n    \
    \        ).collect::<String>();\n        }\n    }\n    s.to_uppercase().to_string()",
  "    s.chars().rev().fold(s, |s, c| s.chars().map(|c| match c {\n        'a' | 'A'\
    \ => {\n            if c != s.chars().next().unwrap() {\n                s.swap(0,\
    \ s.len());\n                s.swap(s.len() - 1, s.len() - 1);\n            }\n\
    \            s\n        }\n        'b' | 'B' => {\n            if c != s.chars().next().unwrap()\
    \ {\n                s.swap(0, s.len());\n                s.swap(s.len() - 1,\
    \ s.len() - 1);\n            }\n            s\n        }\n        _ => s,\n  \
    \  }))", "    let mut s = s;\n    let len = s.len();\n    let mut letters = false;\n\
    \    \n    for i in 0..len {\n        if s[i] == '#' {\n            letters =\
    \ true;\n            continue;\n        }\n        if letters {\n            if\
    \ s[i].is_lower() {\n                s = s.swap(i+1, i+1); // 'swap' the letter\n\
    \            }\n            else if s[i].is_upper() {\n                s = s.swap(i+1,\
    \ len-i-1); // 'swap' the letter\n            }\n            else {\n        \
    \        s = s.swap(i+1, i); // 'swap' the letter\n            }\n        }\n\
    \        letters = false;\n    }\n    \n    s", "    let mut res = String::new();\n\
    \    s.chars().for_each(|x|\n        if x.is_ascii() {\n            if x.is_lowercase()\
    \ {\n                res.append(x.to_upper());\n            } else {\n       \
    \         res.append(x.to_lower());\n            }\n        } else {\n       \
    \     res.append(x);\n        }\n    );\n    if res.chars().any(|x| !x.is_ascii())\
    \ {\n        res.chars().for_each(|x| res.append(x.to_ascii_lowercase()));\n \
    \   }\n    res.chars().for_each(|x| res.append(x.to_string()));\n    res.chars().for_each(|x|\
    \ res.append(x.to_ascii_lowercase()));\n    res.trim();\n    res", "    if s.is_empty()\
    \ {\n        return \"\";\n    }\n    if let Some(first) = s.chars().next() {\n\
    \        let mut result = s.clone();\n        result = result.replace(&first,\
    \ &first.to_lowercase());\n        result = result.replace(&first, &first.to_uppercase());\n\
    \        result = result.replace(&first, &first.to_lowercase().rev());\n     \
    \   result = result.replace(&first, &first.to_uppercase().rev());\n        return\
    \ result;\n    }\n    s.to_lowercase().rev().to_uppercase().rev()", "    s.chars().map(|c|\
    \ {\n        match c {\n            'A'...'Z' => c.to_uppercase().to_string(),\n\
    \            'a'...'z' => c.to_lowercase().to_string(),\n            _ => c,\n\
    \        }\n    }).collect::<Vec<_>>().join(\"\").to_string()", "    let mut result\
    \ = String::new();\n    s.chars().for_each(|c|\n        match c {\n          \
    \  'a' => result.push_str(&String::from(\"A\")),\n            'A' => result.push_str(&String::from(\"\
    a\")),\n            '#' => result.push_str(&String::from(\"@\")),\n          \
    \  '@' => result.push_str(&String::from(\"#\")),\n            _ => result.push_str(&c.to_string()),\n\
    \        }\n    );\n    result", "    s.chars().enumerate().filter(|(_, i), _|\
    \ i % 2 != 0).map(|(index, char)| char.swapcase()).collect()\n        .iter().fold1(\"\
    \"){|state, i| state + i.to_string()}", "    s.chars().fold(s, |mut result, c|\
    \ {\n        if c.is_lowercase() {\n            result.append(c.to_uppercase());\n\
    \        } else {\n            result.append(c.to_lowercase());\n        }\n \
    \       result\n    })", "    s.chars()\n        .filter(|c| c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase())\n        .map(|c| if c.is_ascii_lowercase() { 'a'\
    \ - 'A' else c.to_ascii_lowercase() })\n        .fold(String::new(), |mut acc,\
    \ c| {\n            acc.push_str(&c + 'A' - 'a');\n            acc\n        });",
  "    if s.chars().any(|c| c.is_letter()) {\n        solve_rev(s)\n    } else {\n\
    \        s\n    }", "    let mut s = s;\n    match chars.chars().position(|c|\
    \ c.is_alphanumeric()) {\n        None => s,\n        Some(_) => s.chars().map(|c|\
    \ if c.is_alphanumeric() { c.to_ascii_lowercase() } else { c.to_ascii_uppercase()\
    \ }).collect::<String>() + s,\n    }", "    s.chars()\n        .filter(|c| c.is_ascii_letter())\n\
    \        .map(|c| c.to_ascii_lowercase().unwrap())\n        .collect::<Vec<_>>()\n\
    \        .concat()\n        .reverse()\n        .collect::<String>()", '    //
    TODO: Write your code here.', "    s.chars()\n        .map(|c|{\n            match\
    \ c {\n                'A' => char::Up,\n                'a' => char::Low,\n \
    \               '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => char::Lower,\n\
    \                _ => c,\n            }\n        })\n        .collect::<String>()",
  "    let mut newString = String::new();\n    for c in s.chars() {\n        let mut\
    \ newChar: Char = c.clone();\n        if c.is_ascii_uppercase() {\n          \
    \  newChar = Char::to_ascii_lowercase();\n        } else if c.is_ascii_lowercase()\
    \ {\n            newChar = Char::to_ascii_uppercase();\n        }\n        newString.push(newChar);\n\
    \    }\n    newString.reverse();\n    newString", "    let mut res = String::new();\n\
    \    let mut tmp = 0;\n    for i in s.chars() {\n        let mut ch = (*i as u32).to_ascii_lowercase();\n\
    \        if let Some(i) = ch.rev() {\n            res.push_str(&i);\n        }\
    \ else {\n            res.push_str(&ch);\n        }\n    }\n    res.push_str(\"\
    _\");\n    res", "    let mut s = String::new();\n    \n    for c in s.chars()\
    \ {\n        let mut is_upper = true;\n        if c.to_ascii_lowercase()[0].is_ascii()\
    \ {\n            if c != c.to_ascii_lowercase()[0].to_ascii_lowercase()[0] { is_upper\
    \ = false; }\n        }\n        else if c.to_ascii_uppercase()[0].is_ascii()\
    \ {\n            if c != c.to_ascii_uppercase()[0].to_ascii_uppercase()[0] { is_upper\
    \ = false; }\n        }\n        else if is_upper { s.push(c); }\n        else\
    \ { s.push((c - 'a').to_ascii_lowercase()); }\n    }\n    \n    String::from_utf8(s.into_bytes())",
  "    if s.is_empty() {\n        return \"\";\n    }\n    let mut s = s;\n    let\
    \ mut res = \"\";\n    for char in s.chars() {\n        if char.ascii_lowercase().is_some()\
    \ {\n            res.push_str(char.ascii_uppercase());\n        } else if char.ascii_uppercase().is_some()\
    \ {\n            res.push_str(char.ascii_lowercase());\n        } else {\n   \
    \         res.push_str(char);\n        }\n    }\n    res.trim_end_matches(\"\\\
    n\");\n    return res;", "    if s.is_empty() {\n        return \"\"\n    }\n\
    \    let mut res = String::from(s);\n    let mut last: Vec<char> = Vec::new();\n\
    \    for ch in s.chars() {\n        if ch.is_lowercase() {\n            last.push(ch);\n\
    \        } else {\n            last.push((*ch.to_uppercase()).to_string());\n\
    \        }\n    }\n    res.push_str(&last);\n    return res;", "    let mut s\
    \ = s;\n    if s.is_empty() {\n        return s;\n    }\n    let mut s = String::from(s);\n\
    \    for pos in 0..s.len() {\n        if s.chars().any(|c| *c >= 'a' && *c <=\
    \ 'z') {\n            s = s.chars().rev().collect::<String>().to_string() + s;\n\
    \        }\n        else {\n            s = s.chars().collect::<String>().to_string()\
    \ + s;\n        }\n    }\n    s", "    \n    let mut s = s;\n    let mut len =\
    \ s.len();\n    let mut chars = s.chars();\n    \n    let mut buffer = Vec::new();\n\
    \    \n    while let Some(Character(c)) = chars.next() {\n        if c.is_ascii_lowercase()\
    \ {\n            buffer.push(c);\n        } else {\n            buffer.push(\"\
    A\".to_string());\n        }\n    }\n    \n    let mut new_s = &s[0];\n    \n\
    \    for index in 0..len {\n        if buffer[index] == buffer[index + len] {\n\
    \            new_s[..index] = new_s[..index].chars();\n            new_s[..index].push((buffer[index][..].to_string()\
    \ + buffer[index + 1].to_string() + buffer[index + 2].to_string()[..]).to_lowercase());\n\
    \            buffer[index + len] = ('Z' - 'A' + 1).to_string();\n            buffer[index\
    \ + 2] = buffer[index + 1].to_string() + buffer[index + 2].to_string();\n    \
    \    }\n    }\n    \n    new_s", "    s.chars().map(|c| c as u32).collect()\n\
    \        .iter()\n        .filter(|c| c.is_ascii_letter())\n        .map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect::<String>()\n        .reduce(|mut acc, c| {\n            if\
    \ *acc == \"\" {\n                *acc += c;\n            } else {\n         \
    \       *acc += c.to_ascii_uppercase().to_string();\n            }\n         \
    \   *acc\n        }).to_string()", "    let mut res = String::new();\n    for\
    \ c in s.chars() {\n        if c.is_uppercase() {\n            res.push_str(c.to_lowercase());\n\
    \        } else {\n            res.push_str(c.to_uppercase());\n        }\n  \
    \  }\n    return res;", "    if s.len() < 2 {\n        return s\n    }\n\n   \
    \ let mut s = s;\n    let mut cur = s.len() - 1;\n    while cur >= 0 {\n     \
    \   let char = s[cur];\n        match char {\n            'a' as char => s.swap(cur,\
    \ cur - 1),\n            'A' as char => s.swap(cur, cur - 1),\n            '#'\
    \ as char => s.swap(cur, cur + 1),\n            '@' as char => s.swap(cur, cur\
    \ + 1),\n            _ => {}\n        }\n        cur -= 1;\n    }\n    s", " \
    \   if s.is_empty() {\n        return s;\n    }\n    \n    let mut chars = s.chars();\n\
    \    let mut i = 0;\n    let mut result: Vec<char> = Vec::new();\n\n    loop {\n\
    \        if chars.next().is_some() {\n            let char = chars.next().unwrap();\n\
    \            let index = char.chars().next().unwrap().unwrap() - 'a' as usize;\n\
    \            char.chars().rev().for_each(|c| {\n                if c >= 'a' &&\
    \ c <= 'z' {\n                    result.push((c - 'a' + index) % 26 + 'a');\n\
    \                } else {\n                    result.push(c);\n             \
    \   }\n            });\n        } else {\n            chars.next().unwrap().for_each(|c|\
    \ {\n                result.push(c);\n            });\n            break;\n  \
    \      }\n        i += 1;\n    }\n    result.rev()\n        .join(\"\")\n    \
    \    .replace(&s[..i],\"\")", "    let mut str = s.to_string();\n    for i in\
    \ 0..str.len() {\n        if str[i].is_letter() {\n            let r = str[i].to_ascii_lowercase();\n\
    \            str = str.chars().map(|c| if c == r { c } else { c ^ r }).collect();\n\
    \        } else {\n            str = str.chars().map(|c| if c == i { c } else\
    \ { c ^ i }).collect();\n        }\n    }\n    str", "    \n    fn reverse_case(x:\
    \ char) -> char {\n        match x {\n            'a' => {\n                if\
    \ x.to_lowercase() == 'a' {\n                    'A'\n                } else {\n\
    \                    x.to_uppercase()\n                }\n            }\n    \
    \        'b' => {\n                if x.to_lowercase() == 'b' {\n            \
    \        'B'\n                } else {\n                    x.to_uppercase()\n\
    \                }\n            }\n            'c' => {\n                if x.to_lowercase()\
    \ == 'c' {\n                    'C'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'd' =>\
    \ {\n                if x.to_lowercase() == 'd' {\n                    'D'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'e' => {\n                if x.to_lowercase()\
    \ == 'e' {\n                    'E'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'f' =>\
    \ {\n                if x.to_lowercase() == 'f' {\n                    'F'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'g' => {\n                if x.to_lowercase()\
    \ == 'g' {\n                    'G'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'h' =>\
    \ {\n                if x.to_lowercase() == 'h' {\n                    'H'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'i' => {\n                if x.to_lowercase()\
    \ == 'i' {\n                    'I'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'j' =>\
    \ {\n                if x.to_lowercase() == 'j' {\n                    'J'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'k' => {\n                if x.to_lowercase()\
    \ == 'k' {\n                    'K'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'l' =>\
    \ {\n                if x.to_lowercase() == 'l' {\n                    'L'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'm' => {\n                if x.to_lowercase()\
    \ == 'm' {\n                    'M'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'n' =>\
    \ {\n                if x.to_lowercase() == 'n' {\n                    'N'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'o' => {\n                if x.to_lowercase()\
    \ == 'o' {\n                    'O'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'p' =>\
    \ {\n                if x.to_lowercase() == 'p' {\n                    'P'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'q' => {\n                if x.to_lowercase()\
    \ == 'q' {\n                    '", "    if !s.is_empty() {\n        let mut new_s\
    \ = String::from(s);\n        new_s.chars().for_each(|c| {\n            match\
    \ c {\n                'a' => new_s.swap(0, 1, 'A'),\n                'b' => new_s.swap(0,\
    \ 1, 'B'),\n                'c' => new_s.swap(0, 1, 'C'),\n                'd'\
    \ => new_s.swap(0, 1, 'D'),\n                'e' => new_s.swap(0, 1, 'E'),\n \
    \               'f' => new_s.swap(0, 1, 'F'),\n                'g' => new_s.swap(0,\
    \ 1, 'G'),\n                'h' => new_s.swap(0, 1, 'H'),\n                'i'\
    \ => new_s.swap(0, 1, 'I'),\n                'j' => new_s.swap(0, 1, 'J'),\n \
    \               'k' => new_s.swap(0, 1, 'K'),\n                'l' => new_s.swap(0,\
    \ 1, 'L'),\n                'm' => new_s.swap(0, 1, 'M'),\n                'n'\
    \ => new_s.swap(0, 1, 'N'),\n                'o' => new_s.swap(0, 1, 'O'),\n \
    \               'p' => new_s.swap(0, 1, 'P'),\n                'q' => new_s.swap(0,\
    \ 1, 'Q'),\n                'r' => new_s.swap(0, 1, 'R'),\n                's'\
    \ => new_s.swap(0, 1, 'S'),\n                't' => new_s.swap(0, 1, 'T'),\n \
    \               'u' => new_s.swap(0, 1, 'U'),\n                'v' => new_s.swap(0,\
    \ 1, 'V'),\n                'w' => new_s.swap(0, 1, 'W'),\n                'x'\
    \ => new_s.swap(0, 1, 'X'),\n                'y' => new_s.swap(0, 1, 'Y'),\n \
    \               'z' => new_s.swap(0, 1, 'Z'),\n                _ => (),\n    \
    \        }\n        });\n        new_s\n    } else {\n        String::from(\"\
    0\")\n    }", "    s.chars().map(|c|\n        match c.to_ascii_lowercase().as_ref()\
    \ {\n            Some('z') => c.to_ascii_uppercase().as_ref(),\n            Some('a')\
    \ => c.to_ascii_uppercase().as_ref(),\n            _ => c\n        }\n    ).collect::<String>().into_iter().collect::<Vec<String>>().join(\"\
    \").to_string()", "    s.chars().fold(s, |s, c| {\n        if let Some(ch) = c.to_ascii_uppercase()\
    \ {\n            *s = ch.to_string();\n        } else {\n            *s = c.to_string();\n\
    \        }\n        s + &*s.chars().skip_while(|c| c.is_whitespace()).collect::<String>();\n\
    \    });", "    s.chars().map(|c| if c.is_letter() { c.to_upper() } else { c.to_lower()\
    \ }).collect()\n        .fold(String::new(), |result, n| {\n            result.push_str(n);\n\
    \            result.push(n);\n            result\n        })", "    let mut s\
    \ = s;\n    if s.is_empty() {\n        return \"#\";\n    }\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let c = s.chars().next().unwrap();\n       \
    \ if c.is_ascii() {\n            if c.ascii_upper() {\n                s = s.chars().take(i).chain(c.chars().map(|c|\
    \ c.to_ascii_lowercase()));\n                i += c.len_utf8();\n            }\
    \ else {\n                s = s.chars().take(i).chain(c.chars().map(|c| c.to_ascii_uppercase()));\n\
    \                i += c.len_utf8();\n            }\n        } else {\n       \
    \     i += 1;\n        }\n    }\n    s", "    let mut s = s;\n    let mut len\
    \ = s.len();\n    for i in 0..(len - 1) {\n        let c = s.chars().nth(i).unwrap();\n\
    \        if c.is_ascii() {\n            if c.is_lowercase() {\n              \
    \  s = s.chars().nth(i).unwrap().to_ascii_lowercase().to_string() + &s.chars().nth(len\
    \ - 1 - i).unwrap().to_ascii_uppercase().to_string();\n            } else {\n\
    \                s = s.chars().nth(i).unwrap().to_ascii_uppercase().to_string()\
    \ + &s.chars().nth(len - 1 - i).unwrap().to_ascii_lowercase().to_string();\n \
    \           }\n        } else {\n            if c.is_lowercase() {\n         \
    \       s = s.chars().nth(i).unwrap().to_string().to_ascii_lowercase() + &s.chars().nth(len\
    \ - 1 - i).unwrap().to_string().to_ascii_uppercase().to_string();\n          \
    \  } else {\n                s = s.chars().nth(i).unwrap().to_string().to_ascii_uppercase()\
    \ + &s.chars().nth(len - 1 - i).unwrap().to_string().to_ascii_lowercase().to_string();\n\
    \            }\n        }\n    }\n    s", "    s.chars().map(|c| {\n        if\
    \ c.is_ascii_lowercase() {\n            let mut c = c.to_ascii_lowercase();\n\
    \            c.swap(0,1);\n            c\n        } else if c.is_ascii_uppercase()\
    \ {\n            let mut c = c.to_ascii_uppercase();\n            c.swap(0,1);\n\
    \            c\n        } else {\n            c\n        }\n    }).collect()",
  "    let mut result = String::new();\n    for c in s.chars() {\n        if c.is_alphanumeric()\
    \ {\n            if let Ok(c) = (c.to_ascii_lowercase(), c.to_ascii_uppercase())\
    \ {\n                result.push(c);\n            } else {\n                result.push(c.to_string());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result.rev().to_string()", "    let mut s = s.to_string();\n    loop\
    \ {\n        let mut c = s.chars().collect::<Vec<_>>();\n        c.reverse();\n\
    \        s = c.collect::<String>();\n        if s.len() == 0 {\n            break;\n\
    \        }\n        let mut i = 0;\n        while i < c.len() {\n            if\
    \ c.is_alphabetic(s[i]) {\n                let a = c.split_at(i).collect::<Vec<_>>();\n\
    \                let c = a.join();\n                i = a.len();\n           \
    \     s = c.to_string();\n                break;\n            }\n            i\
    \ += 1;\n        }\n    }\n    s", "    let mut s = s.chars();\n    let mut ret\
    \ = \"\".to_string();\n    for c in s {\n        let c = c.to_lowercase();\n \
    \       if c.is_ascii_lowercase() {\n            let c = c.to_uppercase();\n \
    \           if c != \"#\" {\n                ret += c;\n            } else {\n\
    \                ret += \"#\";\n            }\n        } else {\n            ret\
    \ += c;\n        }\n    }\n    ret", "    if s.is_empty() {\n        return s\n\
    \    }\n    let mut l = s.chars().filter(|x| x.is_letter()).count();\n    let\
    \ mut u = 0\n    if l > 0 {\n        u = l - 1\n    }\n    let mut new_s = String::with_capacity(s.len());\n\
    \    for ch in s.chars() {\n        if ch.is_letter() {\n            new_s.push_str(String::from(ch.to_lowercase()));\n\
    \        } else {\n            new_s.push_str(&ch);\n        }\n    }\n    new_s.push_str(&s[u..])",
  "    let mut res = String::new();\n    let mut pos = 0;\n    for i in s.chars()\
    \ {\n        if i == ' ' {\n            pos = 0;\n        }\n        if i > 'z'\
    \ && i < 'Z' {\n            pos += 2;\n        }\n        if i > 'z' && i < 'Z'\
    \ {\n            pos += 1;\n        }\n        res.push_str(&s[pos : i + 1].to_uppercase());\n\
    \        pos = i;\n    }\n    res"]
stop_tokens:
- "\n}"
