name: HumanEval_76_is_simple_power
language: rust
results:
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = true;\n\
    \    for i in 1..=n {\n        if x % i == 0 {\n            result = false;\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpneagaejh.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut xp = 1;\n    for\
    \ _ in 0..n {\n        xp *= x;\n    }\n    xp == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp75g9n5r2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n    let\
    \ mut power: isize = n;\n    while power != 0 {\n        if x%power = 0 {\n  \
    \          return true;\n        }\n        power = power*n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfc8jlmlq.rs:15:12\n   |\n\
    15 |         if x%power = 0 {\n   |            ^^^^^^^^^^^ expected `bool`, found\
    \ `()`\n   |\nhelp: you might have meant to use pattern matching\n   |\n15 | \
    \        if let x%power = 0 {\n   |            +++\nhelp: you might have meant\
    \ to compare for equality\n   |\n15 |         if x%power == 0 {\n   |        \
    \            ~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    if n % x ==\
    \ 0 {\n        return is_simple_power(x, n / x);\n    }\n    else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp083thkxq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ true;\n    }\n\n    if n & 1 == 1 {\n        if x == n {\n            return\
    \ true;\n        }\n        return is_simple_power(x, n - 1);\n    }\n\n    if\
    \ n%2 == 0 {\n        return is_simple_power(x, n/2);\n    }\n\n    if n%3 ==\
    \ 0 {\n        return is_simple_power(x, n/3);\n    }\n\n    if n%5 == 0 {\n \
    \       return is_simple_power(x, n/5);\n    }\n\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6k3x9cwg.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = n;\n    while\
    \ i != 1 {\n        i *= x;\n        if i != 1 {\n            return false;\n\
    \        }\n        i /= x;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc4xaty96.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n\n    if n == 1 {\n        return false;\n    }\n\n    if n %\
    \ 2 != 0 {\n        return false;\n    }\n\n    if x == n {\n        return true;\n\
    \    }\n\n    let mut x = x;\n    let mut n = n;\n    while n > 1 {\n        if\
    \ n % 2 == 0 {\n            x /= 2;\n            n /= 2;\n        } else {\n \
    \           x *= x;\n            n /= 2;\n        }\n    }\n\n    x == n\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi2kw5bc5.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ true;\n    }\n\n    if n <= x {\n        return false;\n    }\n\n    if x ==\
    \ 1 {\n        return true;\n    }\n\n    if x > 1 {\n        let mut a = x;\n\
    \        let mut b = n - 1;\n\n        while b > 0 {\n            let c = b /\
    \ a;\n            let mut d = 0;\n\n            if c > 1 {\n                d\
    \ = 1;\n            }\n\n            if c == 1 {\n                d = 1;\n   \
    \         }\n\n            if d != 0 {\n                if d != 1 {\n        \
    \            return false;\n                }\n\n                if a % d == 0\
    \ {\n                    return false;\n                }\n            }\n\n \
    \           a = b;\n            b /= a;\n        }\n\n        return true;\n \
    \   }\n\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppks_eca9.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        if\
    \ n == 1 {\n            return true;\n        } else {\n            return false;\n\
    \        }\n    } else {\n        let mut x: isize = x;\n        let mut n: int\
    \ = x * (x >> 1);\n        let mut z: int = 1;\n        while n > 2 {\n      \
    \      if n % 2 == 1 {\n                z <<= 1;\n                z |= 1;\n  \
    \          }\n            n /= 2;\n        }\n        return x == z;\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `int` in this scope\n  --> /tmp/tmpelbxtp1g.rs:20:20\n\
    \   |\n20 |         let mut n: int = x * (x >> 1);\n   |                    ^^^\n\
    \   |                    |\n   |                    not found in this scope\n\
    \   |                    help: perhaps you intended to use this type: `i32`\n\n\
    error[E0412]: cannot find type `int` in this scope\n  --> /tmp/tmpelbxtp1g.rs:21:20\n\
    \   |\n21 |         let mut z: int = 1;\n   |                    ^^^\n   |   \
    \                 |\n   |                    not found in this scope\n   |   \
    \                 help: perhaps you intended to use this type: `i32`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n <= 1 {\n        return\
    \ false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    let mut x =\
    \ x;\n    loop {\n        if x%n == 0 {\n            return true;\n        }\n\
    \        x = x / n;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp454jf5qa.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x % n == 0 {\n      \
    \  return true;\n    }\n    else if n == 1 {\n        return false;\n    }\n \
    \   else {\n        return is_simple_power(x, n / 2);\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmpe2um46.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n % x == 0 {\n      \
    \  return true;\n    }\n    for d in &[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\
    \ {\n        if n % d == 0 {\n            return false;\n        }\n    }\n  \
    \  false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3j2cnwlr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x > 0 && n > 0 && n % x\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4he_no3h.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x < 1 ||\n        x > n\
    \ ||\n        n & 1 != 0 ||\n        n % x == 0 ||\n        !(n % x != 0 && (n\
    \ % x).checked_pow(x, n as usize).is_some())\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpcvxtko9s.rs:16:33\n    |\n16  |         !(n % x != 0 && (n % x).checked_pow(x,\
    \ n as usize).is_some())\n    |                                 ^^^^^^^^^^^ -\
    \  ---------- supplied 2 arguments\n    |                                 |\n\
    \    |                                 expected 1 argument\n    |\nnote: associated\
    \ function defined here\n    = note: this error originates in the macro `int_impl`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n==1 {\n        true\n\
    \    } else if n%2 == 1 {\n        is_simple_power(x, n//2)\n    } else {\n  \
    \      is_simple_power(x, n//2)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmprqv03mo4.rs:15:24\n\
    \   |\n14 |     } else if n%2 == 1 {\n   |                        - closing delimiter\
    \ possibly meant for this\n15 |         is_simple_power(x, n//2)\n   |       \
    \                 ^ unclosed delimiter\n16 |     } else {\n   |     ^ mismatched\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmprqv03mo4.rs:17:24\n\
    \   |\n16 |     } else {\n   |            - closing delimiter possibly meant for\
    \ this\n17 |         is_simple_power(x, n//2)\n   |                        ^ unclosed\
    \ delimiter\n18 |     }\n   |     ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1usize << n as usize)**x\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpkul9x7si.rs:12:28\n\
    \   |\n12 |     (1usize << n as usize)**x == x\n   |                         \
    \   ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkul9x7si.rs:12:34\n  \
    \ |\n12 |     (1usize << n as usize)**x == x\n   |                           \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     (1usize\
    \ << n as usize)**x == x.try_into().unwrap()\n   |                           \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO: Your code here\n\
    \    let mut result = true;\n    for i in 0..n.n+1 {\n        if pow(x, i, n)\
    \ != x {\n            result = false;\n        }\n    }\n    return result;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpe4g6swxb.rs:15:12\n\
    \   |\n15 |         if pow(x, i, n) != x {\n   |            ^^^ not found in this\
    \ scope\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpe4g6swxb.rs:14:19\n   |\n14 |     for i in 0..n.n+1 {\n\
    \   |                   ^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x.pow(n as isize);\n\
    \    while n > 0 {\n        if x % n == 0 {\n            return true;\n      \
    \  }\n        x = x / n;\n        n = n - 1;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnagrxbxq.rs:12:23\n   |\n\
    12 |     let mut x = x.pow(n as isize);\n   |                       ^^^^^^^^^^\
    \ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     let mut x = x.pow((n\
    \ as isize).try_into().unwrap());\n   |                       +          +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (&n).cmp(&x.pow(3)) < 0\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppncv13i8.rs:12:27\n   |\n\
    12 |     (&n).cmp(&x.pow(3)) < 0\n   |                           ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if n % x == 0 {\n        false\n    } else {\n        x != 1\n   \
    \         && is_simple_power(x, n - 1)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpltr08yda.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 0;\n    while\
    \ i < n {\n        if (x == n * i) {\n            return true;\n        }\n  \
    \      i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk9t3ls4b.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let max_power_of_n = n as\
    \ isize;\n    let mut result = true;\n    for i in 0..max_power_of_n {\n     \
    \   if ((x & (1 << (n - 1)))) == 0 {\n            result = false;\n          \
    \  break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1glsayot.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 { return x ==\
    \ 0 }\n    if n == 0 { return false }\n    if x == 0 { return false }\n    if\
    \ n == x { return true }\n    let mut y = n;\n    while y == x {\n        y *=\
    \ x;\n    }\n    for _ in 0..(x - 1) {\n        if y == n {\n            return\
    \ true;\n        }\n        y /= n;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpukfjgfgv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n == 0 {\n        return false;\n    }\n    if n % 2 !=\
    \ 0 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n \
    \   }\n    if n % 4 == 0 {\n        return true;\n    }\n    if n <= 6 {\n   \
    \     return is_simple_power(x, n - 1);\n    }\n    if x <= 16 {\n        return\
    \ is_simple_power(x, n - 2);\n    }\n    if x <= 64 {\n        return is_simple_power(x,\
    \ n - 4);\n    }\n    if x <= 512 {\n        return is_simple_power(x, n - 8);\n\
    \    }\n    if x <= 4096 {\n        return is_simple_power(x, n - 16);\n    }\n\
    \    if x <= 32768 {\n        return is_simple_power(x, n - 32);\n    }\n    if\
    \ x <= 65536 {\n        return is_simple_power(x, n - 64);\n    }\n    if x <=\
    \ 131072 {\n        return is_simple_power(x, n - 128);\n    }\n    if x <= 262144\
    \ {\n        return is_simple_power(x, n - 256);\n    }\n    if x <= 524288 {\n\
    \        return is_simple_power(x, n - 512);\n    }\n    if x <= 1048576 {\n \
    \       return is_simple_power(x, n - 1024);\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmp1fuuavqp.rs:57:5\n\
    \   |\n11 |   fn is_simple_power(x: isize, n: isize) -> bool {\n   |         \
    \                                    ---- expected `bool` because of this return\
    \ type\n...\n57 | /     if x <= 1048576 {\n58 | |         return is_simple_power(x,\
    \ n - 1024);\n59 | |     }\n   | |_____^ expected `bool`, found `()`\n   |\n \
    \  = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppvc379z_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n <= 1 {\n        return false;\n    }\n    if n % 2 ==\
    \ 0 {\n        return is_simple_power(x, n - 1);\n    }\n    if n % 3 == 0 {\n\
    \        return is_simple_power(x, n / 2);\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjq6p7gtq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x * n) % n == 0\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyku71ybu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= n {\n        return\
    \ true;\n    }\n\n    if n == 1 {\n        return false;\n    }\n\n    if n ==\
    \ 2 {\n        if x == 1 {\n            return true;\n        }\n        return\
    \ false;\n    }\n\n    if n == 3 {\n        if x == 1 {\n            return false;\n\
    \        }\n        return false;\n    }\n\n    if x == 1 {\n        if n == 1\
    \ {\n            return false;\n        }\n        return false;\n    }\n\n  \
    \  let x_mod_3 = x % 3;\n\n    if x_mod_3 == 0 {\n        return is_simple_power(x,\
    \ n - 1);\n    }\n\n    if x_mod_3 == 1 {\n        return is_simple_power(x, n\
    \ - 2);\n    }\n\n    if x_mod_3 == 2 {\n        return is_simple_power(x, n -\
    \ 3);\n    }\n\n    if x_mod_3 == 3 {\n        return true;\n    }\n\n    if x_mod_3\
    \ == 4 {\n        return is_simple_power(x, n - 4);\n    }\n\n    if x_mod_3 ==\
    \ 5 {\n        return is_simple_power(x, n - 5);\n    }\n\n    if x_mod_3 == 6\
    \ {\n        return is_simple_power(x, n - 6);\n    }\n\n    if x_mod_3 == 7 {\n\
    \        return is_simple_power(x, n - 7);\n    }\n\n    if x_mod_3 == 8 {\n \
    \       return is_simple_power(x, n - 8);\n    }\n\n    if x_mod_3 == 9 {\n  \
    \      return is_simple_power(x, n - 9);\n    }\n\n    if x_mod_3 == 10 {\n  \
    \      return is_simple_power(x, n - 10);\n    }\n\n    if x_mod_3 == 11 {\n \
    \       return is_simple_power(x, n - 11);\n    }\n\n    if x_mod_3 == 12 {\n\
    \        return is_simple_power(x, n - 12);\n    }\n\n    if x_mod_3 == 13 {\n\
    \        return is_simple_power(x, n - 13);\n    }\n\n    if x_mod_3 == 14 {\n\
    \        return is_simple_power(x, n - 14);\n    }\n\n    if x_mod_3 == 15 {\n\
    \        return is_simple_power(x, n - 15);\n    }\n\n    if x_mod_3 == 16 {\n\
    \        return is_simple_power(x, n - 16);\n    }\n\n    if x_mod_3 == 17 {\n\
    \        return is_simple_power(x, n - 17);\n    }\n\n    if x_mod_3 == 18 {\n\
    \        return is_simple_power(x, n - 18);\n    }\n\n    if x_mod_3 == 19 {\n\
    \        return is_simple_power(x, n - 19);\n    }\n\n    if x_mod_3 == 20 {\n\
    \        return is_simple_power(x, n - 20);\n    }\n\n    if x_mod_3 == 21 {\n\
    \        return is_simple_power(x, n - 21);\n    }\n\n    if x_mod_3 == 22 {\n\
    \        return is_simple_power(x, n - 22);\n    }\n\n    if x_mod_3 == 23 {\n\
    \        return is_simple_power(x, n - 23);\n    }\n\n    if x_mod_3 == 24 {\n\
    \        return is_simple_power(x, n - 24);\n    }\n\n    if x_mod_3 == 25 {\n\
    \        return is_simple_power(x, n - 25);\n\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp062wplf4.rs:160:3\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n...\n143 |    \
    \ if x_mod_3 == 25 {\n    |                      - this delimiter might not be\
    \ properly closed...\n...\n146 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n160 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp062wplf4.rs:11:43\n   |\n11 | fn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n   |    ---------------                        ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n%2 == 1 {\n        return false;\n    }\n    if n%3 ==\
    \ 1 {\n        return false;\n    }\n    if n%5 == 1 {\n        return false;\n\
    \    }\n    let m = ((n%5 + 1)*5) / 4;\n    if m*n == x {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpscccob8f.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    \n    \n    if x == 1 {\n\
    \        return true;\n    }\n    \n    if x == 0 {\n        return false;\n \
    \   }\n    \n    if n == 1:\n        return true;\n    \n    if n % 2 == 0 {\n\
    \        return is_simple_power(x, n / 2);\n    }\n    \n    let y = n - 1;\n\
    \    let mut z = x * x;\n    \n    while z < y {\n        z = z * x;\n       \
    \ y = y - 1;\n    }\n    \n    if z == y {\n        return true;\n    }\n    \n\
    \    return false;\n    \n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmpfsmbc2u8.rs:23:9\n\
    \   |\n23 |         return true;\n   |         ^^^^^^ expected identifier, found\
    \ keyword\n\nerror: expected type, found keyword `return`\n  --> /tmp/tmpfsmbc2u8.rs:23:9\n\
    \   |\n22 |     if n == 1:\n   |              - help: try using a semicolon: `;`\n\
    23 |         return true;\n   |         ^^^^^^ expected type\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in 0..n {\n        sum += x.pow(i as usize);\n    }\n    sum == x\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixhz3qru.rs:14:22\n   |\n\
    14 |         sum += x.pow(i as usize);\n   |                      ^^^^^^^^^^ expected\
    \ `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32` and panic\
    \ if the converted value doesn't fit\n   |\n14 |         sum += x.pow((i as usize).try_into().unwrap());\n\
    \   |                      +          +++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut n = n;\n    while x > n {\n        x *= n;\n        n /= n;\n    }\n   \
    \ if x == n {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).contains(&x * n)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxoiil52.rs:12:22\n   |\n\
    12 |     (1..=n).contains(&x * n)\n   |                      ^^^^^^\n   |    \
    \                  |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&(&x * n)`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x < n && x * n == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgfif23l4.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    let mut x = x;\n    while x > 0 {\n        if x % n == 0 {\n\
    \            x = x / n;\n            return true;\n        }\n        x = x *\
    \ n;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp46cmw80e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n < x {\n        return false;\n    }\n    if n % x !=\
    \ 0 {\n        return false;\n    }\n    let mut y = x;\n    while y != 1 {\n\
    \        if y % n != 0 {\n            return false;\n        }\n        y /= n;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdz4mcl9h.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = to_i64(x);\n   \
    \ let n = to_i64(n);\n    if x == 0 || n == 0 || x == n {\n        return true;\n\
    \    }\n    if x != n {\n        return false;\n    }\n    let mut r = x;\n  \
    \  while r < n {\n        if (r % n == 0) {\n            return false;\n     \
    \   }\n        r = r * n;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_i64` in this scope\n  --> /tmp/tmpwisv4tts.rs:12:13\n\
    \   |\n12 |     let x = to_i64(x);\n   |             ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `to_i64` in this scope\n  --> /tmp/tmpwisv4tts.rs:13:13\n\
    \   |\n13 |     let n = to_i64(n);\n   |             ^^^^^^ not found in this\
    \ scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwisv4tts.rs:22:12\n\
    \   |\n22 |         if (r % n == 0) {\n   |            ^          ^\n   |\n  \
    \ = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n22 -         if (r % n == 0) {\n22 +         if r % n == 0 {\n   | \n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    n % x == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphr8j4wj7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x % n == 0 || is_simple_power(x,\
    \ n / 2)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa200secb.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n % x) == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6zice0oc.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n as i64).pow(x) == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzst0mnrz.rs:12:20\n   |\n\
    12 |     (n as i64).pow(x) == x\n   |                    ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n12 |     (n as i64).pow(x.try_into().unwrap())\
    \ == x\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzst0mnrz.rs:12:26\n   |\n12 |     (n as i64).pow(x) ==\
    \ x\n   |                          ^ expected `i64`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to an `i64` and panic if the converted value doesn't\
    \ fit\n   |\n12 |     (n as i64).pow(x) == x.try_into().unwrap()\n   |       \
    \                    ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n as u64)**x == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpso0b_6t4.rs:12:16\n\
    \   |\n12 |     (n as u64)**x == x\n   |                ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpso0b_6t4.rs:12:22\n   |\n12 |     (n as u64)**x == x\n\
    \   |                      ^ expected `u64`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `u64` and panic if the converted value doesn't fit\n\
    \   |\n12 |     (n as u64)**x == x.try_into().unwrap()\n   |                 \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match x {\n        0 =>\
    \ n == 0,\n        1 => n == 1,\n        _ => n * is_simple_power(x, n - 1) ==\
    \ 0\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `isize` by `bool`\n  --> /tmp/tmpmt27v_bh.rs:15:16\n\
    \   |\n15 |         _ => n * is_simple_power(x, n - 1) == 0\n   |            \
    \    ^ no implementation for `isize * bool`\n   |\n   = help: the trait `Mul<bool>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n % x == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6rs3g93m.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.pow(n as u32) == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprk26zo6x.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut num = 0;\n    for\
    \ &n in &n.to_str() {\n        *num += *n as isize;\n    }\n    x % n == 0\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_str` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpd7zwcpsh.rs:13:18\n   |\n13 |     for &n in &n.to_str()\
    \ {\n   |                  ^^^^^^ method not found in `isize`\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpd7zwcpsh.rs:14:9\n  \
    \ |\n14 |         *num += *n as isize;\n   |         ^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    let mut result = false;\n    for i in 1..n {\n        result\
    \ = result || pow(x, i) == x;\n    }\n    result && x == pow(x, n);\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpnbns2qsk.rs:17:28\n\
    \   |\n17 |         result = result || pow(x, i) == x;\n   |                 \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `pow` in this scope\n  --> /tmp/tmpnbns2qsk.rs:19:20\n   |\n19 |     result\
    \ && x == pow(x, n);\n   |                    ^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnbns2qsk.rs:11:43\n   |\n11 | fn\
    \ is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------     \
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n19 |     result\
    \ && x == pow(x, n);\n   |                             - help: remove this semicolon\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ true;\n    }\n\n    if n == 1 {\n        return is_power_of_2(x);\n    }\n\n\
    \    if n % 2 == 0 {\n        return is_simple_power(x * 2, n);\n    }\n\n   \
    \ if is_power_of_2(x * 2 + 1) {\n        return true;\n    }\n\n    if is_power_of_2(x\
    \ * n - 1) {\n        return true;\n    }\n\n    if is_simple_power(x * n, n)\
    \ {\n        return true;\n    }\n\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_2` in this scope\n  -->\
    \ /tmp/tmp2ejze2k2.rs:17:16\n   |\n17 |         return is_power_of_2(x);\n   |\
    \                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_power_of_2` in this scope\n  --> /tmp/tmp2ejze2k2.rs:24:8\n\
    \   |\n24 |     if is_power_of_2(x * 2 + 1) {\n   |        ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_power_of_2` in this\
    \ scope\n  --> /tmp/tmp2ejze2k2.rs:28:8\n   |\n28 |     if is_power_of_2(x * n\
    \ - 1) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let xpower = x ** n;\n \
    \   (xpower == x).unwrap_or(false)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp99u56i4_.rs:12:21\n\
    \   |\n12 |     let xpower = x ** n;\n   |                     ^^^\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `bool` in the current scope\n  -->\
    \ /tmp/tmp99u56i4_.rs:13:19\n   |\n13 |     (xpower == x).unwrap_or(false)\n \
    \  |                   ^^^^^^^^^ method not found in `bool`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x==1 {\n        return\
    \ true;\n    } else if n==1 {\n        return false;\n    } else if x*n == x {\n\
    \        let mut z = x;\n        while z < n {\n            z = z * n;\n     \
    \   }\n        return z==x;\n    } else {\n        return false;\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn7bib5bd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO: write your code\
    \ here\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnh2yj6st.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // base case\n    if n ==\
    \ 1 {\n        return true;\n    }\n    // recursive case\n    if x * n == x {\n\
    \        return true;\n    }\n    // the number is not a simple power of n\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphcifu0zq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n % x) == 0 && is_simple_power(x,\
    \ n/x) == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9b5zd13h.rs:12:48\n   |\n\
    12 |     (n % x) == 0 && is_simple_power(x, n/x) == 0\n   |                  \
    \                              ^ expected `bool`, found integer\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO: write your solution\
    \ here\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4nb9qcei.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgey3knml.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut rem = x;\n    for\
    \ _ in 0..n {\n        if rem == 0 {\n            return true;\n        }\n  \
    \      rem %= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpahdbq1lz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // ...\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdo6z8m2.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = true;\n\
    \    while n > 1 {\n        if n % x == 0 {\n            result = false;\n   \
    \         break;\n        }\n        n /= x;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp03txja81.rs:18:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    18 |         n /= x;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1:\n        return\
    \ true;\n    if x <= n / 2 {\n        return false;\n    }\n    if x > n {\n \
    \       return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmpnd252qp4.rs:13:9\n\
    \   |\n13 |         return true;\n   |         ^^^^^^ expected identifier, found\
    \ keyword\n\nerror: expected type, found keyword `return`\n  --> /tmp/tmpnd252qp4.rs:13:9\n\
    \   |\n12 |     if n == 1:\n   |              - help: try using a semicolon: `;`\n\
    13 |         return true;\n   |         ^^^^^^ expected type\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = x * x;\n    return\
    \ (x == n || x == n * n);\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprzhu048v.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == n {\n        true\n\
    \    } else if x <= n && n % x == 0 {\n        false\n    } else {\n        is_simple_power(x,\
    \ n//x)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpooag1gfn.rs:17:24\n\
    \   |\n16 |     } else {\n   |            - closing delimiter possibly meant for\
    \ this\n17 |         is_simple_power(x, n//x)\n   |                        ^ unclosed\
    \ delimiter\n18 |     }\n   |     ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 0 || n > x || n % x\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuzs36lh5.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x ** n) == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp1xm6xmhi.rs:12:9\n\
    \   |\n12 |     (x ** n) == x\n   |         ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n\n    if n % x == 0 {\n        return false;\n    }\n\n    if\
    \ n % x == -1 {\n        return is_simple_power(x, n - 1);\n    }\n\n    if n\
    \ % x == 2 {\n        return is_simple_power(x, n / 2);\n    }\n\n    if n % x\
    \ == 3 {\n        return is_simple_power(x, n / 3);\n    }\n\n    if n % x ==\
    \ 4 {\n        return is_simple_power(x, n / 4);\n    }\n\n    if n % x == 5 {\n\
    \        return is_simple_power(x, n / 5);\n    }\n\n    if n % x == 6 {\n   \
    \     return is_simple_power(x, n / 6);\n    }\n\n    if n % x == 7 {\n      \
    \  return is_simple_power(x, n / 7);\n    }\n\n    if n % x == 8 {\n        return\
    \ is_simple_power(x, n / 8);\n    }\n\n    if n % x == 9 {\n        return is_simple_power(x,\
    \ n / 9);\n    }\n\n    if n % x == 10 {\n        return is_simple_power(x, n\
    \ / 10);\n    }\n\n    if n % x == 11 {\n        return is_simple_power(x, n /\
    \ 11);\n    }\n\n    if n % x == 12 {\n        return is_simple_power(x, n / 12);\n\
    \    }\n\n    if n % x == 13 {\n        return is_simple_power(x, n / 13);\n \
    \   }\n\n    if n % x == 14 {\n        return is_simple_power(x, n / 14);\n  \
    \  }\n\n    if n % x == 15 {\n        return is_simple_power(x, n / 15);\n   \
    \ }\n\n    if n % x == 16 {\n        return is_simple_power(x, n / 16);\n    }\n\
    \n    if n % x == 17 {\n        return is_simple_power(x, n / 17);\n    }\n\n\
    \    if n % x == 18 {\n        return is_simple_power(x, n / 18);\n    }\n\n \
    \   if n % x == 19 {\n        return is_simple_power(x, n / 19);\n    }\n\n  \
    \  if n % x == 20 {\n        return is_simple_power(x, n / 20);\n    }\n\n   \
    \ if n % x == 21 {\n        return is_simple_power(x, n / 21);\n    }\n\n    if\
    \ n % x == 22 {\n        return is_simple_power(x, n / 22);\n    }\n\n    if n\
    \ % x == 23 {\n        return is_simple_power(x, n / 23);\n    }\n\n    if n %\
    \ x == 24 {\n        return is_simple_power(x, n / 24);\n    }\n\n    if n % x\
    \ == 25 {\n        return is_simple_power(x, n / 25);\n    }\n\n    if n % x ==\
    \ 26 {\n        return is_simple_power(x, n / 26);\n    }\n\n    if n % x == 27\
    \ {\n        return is_simple_power(x, n / 27);\n    }\n\n    if n % x == 28 {\n\
    \        return is_simple_power(x, n / 28);\n    }\n\n    if n % x == 29 {\n \
    \       return is_simple_power(x, \n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpm92qcg63.rs:148:3\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n...\n132 |    \
    \ if n % x == 29 {\n    |                    - this delimiter might not be properly\
    \ closed...\n133 |         return is_simple_power(x, \n134 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n148 | }\n    |   ^\n\n\
    error: mismatched closing delimiter: `}`\n   --> /tmp/tmpm92qcg63.rs:133:31\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - closing delimiter possibly meant for\
    \ this\n...\n133 |         return is_simple_power(x, \n    |                 \
    \              ^ unclosed delimiter\n134 | }\n    | ^ mismatched closing delimiter\n\
    \nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpm92qcg63.rs:133:16\n    |\n133 |         return is_simple_power(x,\
    \ \n    |                ^^^^^^^^^^^^^^^ - supplied 1 argument\n    |        \
    \        |\n    |                expected 2 arguments\n    |\nnote: function defined\
    \ here\n   --> /tmp/tmpm92qcg63.rs:11:4\n    |\n11  | fn is_simple_power(x: isize,\
    \ n: isize) -> bool {\n    |    ^^^^^^^^^^^^^^^ --------  --------\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm92qcg63.rs:11:43\n   |\n11 | fn is_simple_power(x:\
    \ isize, n: isize) -> bool {\n   |    ---------------                        ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..n).contains(|&i| x*i\
    \ == x) // simple power\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeglcl4vv.rs:12:21\n   |\n\
    12 |     (1..n).contains(|&i| x*i == x) // simple power\n   |                \
    \     ^^^^^^^^^^^^^ expected `&isize`, found closure\n   |\n   = note: expected\
    \ reference `&isize`\n                found closure `[closure@/tmp/tmpeglcl4vv.rs:12:21:\
    \ 12:34]`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n != 1 && (n % x == 0) ||\
    \ n * is_simple_power(x, n - 1) == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `isize` by `bool`\n  --> /tmp/tmpn91gkwrd.rs:12:33\n\
    \   |\n12 |     n != 1 && (n % x == 0) || n * is_simple_power(x, n - 1) == 0\n\
    \   |                                 ^ no implementation for `isize * bool`\n\
    \   |\n   = help: the trait `Mul<bool>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut res = false;\n \
    \   for i in 0..n {\n        if x == ipow(x, n) {\n            res = true;\n \
    \           break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ipow` in this scope\n  --> /tmp/tmphhzrywbs.rs:14:17\n\
    \   |\n14 |         if x == ipow(x, n) {\n   |                 ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        1 =>\
    \ x == 1,\n        2 => x == 2,\n        3 => x == 1,\n        4 => x == 4,\n\
    \        5 => x == 2,\n        6 => x == 8,\n        7 => x == 6,\n        8 =>\
    \ x == 4,\n        9 => x == 4,\n        10 => x == 8,\n        11 => x == 16,\n\
    \        12 => x == 16,\n        13 => x == 32,\n        14 => x == 32,\n    \
    \    15 => x == 32,\n        16 => x == 16,\n        17 => x == 128,\n       \
    \ 18 => x == 128,\n        19 => x == 128,\n        20 => x == 256,\n        21\
    \ => x == 256,\n        22 => x == 256,\n        23 => x == 256,\n        24 =>\
    \ x == 256,\n        25 => x == 256,\n        26 => x == 256,\n        27 => x\
    \ == 256,\n        28 => x == 256,\n        29 => x == 256,\n        30 => x ==\
    \ 256,\n        31 => x == 256,\n        32 => x == 256,\n        33 => x == 512,\n\
    \        34 => x == 512,\n        35 => x == 512,\n        36 => x == 512,\n \
    \       37 => x == 512,\n        38 => x == 512,\n        39 => x == 512,\n  \
    \      40 => x == 512,\n        41 => x == 512,\n        42 => x == 512,\n   \
    \     43 => x == 512,\n        44 => x == 512,\n        45 => x == 512,\n    \
    \    46 => x == 512,\n        47 => x == 512,\n        48 => x == 512,\n     \
    \   49 => x == 512,\n        50 => x == 512,\n        51 => x == 512,\n      \
    \  52 => x == 512,\n        53 => x == 512,\n        54 => x == 512,\n       \
    \ 55 => x == 512,\n        56 => x == 512,\n        57 => x == 512,\n        58\
    \ => x == 512,\n        59 => x == 512,\n        60 => x == 512,\n        61 =>\
    \ x == 512,\n        62 => x == 512,\n        63 => x == 512,\n        64 => x\
    \ == 512,\n        65 => x == 512,\n        66 => x == 512,\n        67 => x ==\
    \ 512,\n        68 => x == 512,\n        69 => x == 512,\n        70 => x == 512,\n\
    \        71 => x == 512,\n        72 => x == 512,\n        73 => x == 512,\n \
    \       74 => x == 512,\n        75 => x == 512,\n        76 => x == 512,\n  \
    \      77 => x == 512,\n        78 => x == 512,\n        79 => x == 512,\n\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1v97l5q9.rs:107:3\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n12  |     match\
    \ n {\n    |             - this delimiter might not be properly closed...\n...\n\
    93  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    107 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1v97l5q9.rs:12:5\n\
    \   |\n12 | /     match n {\n13 | |         1 => x == 1,\n14 | |         2 =>\
    \ x == 2,\n15 | |         3 => x == 1,\n...  |\n92 | |\n93 | | }\n   | | ^- help:\
    \ consider using a semicolon here\n   | |_|\n   |   expected `()`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1v97l5q9.rs:11:43\n   |\n11 |\
    \ fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------  \
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n < 2 {\n        return false;\n    }\n\n    let pow_x\
    \ = powi(x); // pow(x, int)\n    let pow_n = powi(n); // pow(n, int)\n\n    if\
    \ pow_n == pow_x {\n        return false;\n    }\n    let div_x = x % pow_n;\n\
    \    let div_n = n % pow_n;\n    if div_x > pow_n {\n        return false;\n \
    \   }\n    let result = is_simple_power(x, div_n);\n    if result {\n        return\
    \ is_simple_power(div_x, div_n);\n    }\n    return result;\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `powi` in this scope\n  --> /tmp/tmpzdr83na9.rs:19:17\n\
    \   |\n19 |     let pow_x = powi(x); // pow(x, int)\n   |                 ^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `powi` in this\
    \ scope\n  --> /tmp/tmpzdr83na9.rs:20:17\n   |\n20 |     let pow_n = powi(n);\
    \ // pow(n, int)\n   |                 ^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n < 2 {\n        return\
    \ false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n == 1 {\n\
    \        return false;\n    }\n    if n % 2 == 1 {\n        return is_simple_power(x\
    \ * x, n / 2);\n    }\n    return is_simple_power(x * x, n - 1);\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpp00wja_3.rs:22:32\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut n = n;\n    while *n < x {\n        *n += 1;\n    }\n    x <= n * n\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpbcpwqqqa.rs:14:11\n\
    \   |\n14 |     while *n < x {\n   |           ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpbcpwqqqa.rs:15:9\n   |\n15 |         *n\
    \ += 1;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 1 ||\n    x <= n ||\n\
    \    (x <= n &&\n    x == pow(x, n))\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp0w2kj_xx.rs:15:10\n\
    \   |\n15 |     x == pow(x, n))\n   |          ^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < n {\n        return\
    \ false\n    }\n    if n == 1 {\n        return true\n    }\n    if n % x == 0\
    \ {\n        return false\n    }\n    if x > n {\n        return true\n    }\n\
    \    let mut y = x;\n    loop {\n        let tmp = y % n;\n        if tmp == 0\
    \ {\n            break;\n        }\n        y /= n;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqvdrtwpj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    let\
    \ mut result = true;\n    while i * i < x && n * i < x {\n        i += 1;\n  \
    \      n += 1;\n    }\n    result = result && n == x;\n    return result;\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpq0k8060q.rs:16:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    16 |         n += 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = n - 1;\n   \
    \ while i {\n        if x&1 == 1 {\n            return true;\n        }\n    \
    \    if i%2 != 0 {\n            x = x>>1;\n        }\n        i = i / 2;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgk8g9n8w.rs:13:11\n   |\n\
    13 |     while i {\n   |           ^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = pow(x, n);\n   \
    \ let n: isize = n;\n    x.is_power_of_two() &&\n        n.is_power_of_two() &&\n\
    \        ((x.bit_count() >= n.bit_count()) && (x.trailing_zeros() == n.trailing_zeros()))\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmptbvzz3hb.rs:12:13\n\
    \   |\n12 |     let x = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmptbvzz3hb.rs:15:11\n   |\n15 |         n.is_power_of_two()\
    \ &&\n   |           ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `bit_count` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmptbvzz3hb.rs:16:30\n   |\n16 |         ((x.bit_count() >= n.bit_count())\
    \ && (x.trailing_zeros() == n.trailing_zeros()))\n   |                       \
    \       ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ false;\n    }\n    let n = *n as usize;\n    let r = n**x;\n    if r == x {\n\
    \        return true;\n    }\n    if r < x {\n        false\n    } else {\n  \
    \      is_simple_power(x, n - 1)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpx920cul2.rs:15:13\n\
    \   |\n15 |     let n = *n as usize;\n   |             ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpx920cul2.rs:16:15\n   |\n16 |\
    \     let r = n**x;\n   |               ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        true\n\
    \    } else {\n        x == n ** (n - 1)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp90irjjz7.rs:15:17\n\
    \   |\n15 |         x == n ** (n - 1)\n   |                 ^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).all(|i| x%i == 0)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnyryz_9l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n <= 1 {\n        true\n\
    \    } else if n == 2 {\n        x == x**2\n    } else {\n        let m = x as\
    \ f64;\n        m < n\n            || (m == (n * n) as f64 && is_simple_power(x,\
    \ n - 1))\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp0fkelbta.rs:15:16\n\
    \   |\n15 |         x == x**2\n   |                ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0fkelbta.rs:18:13\n   |\n18 |         m < n\n   |     \
    \        ^ expected `f64`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to an `f64`, producing the floating point representation of the integer, rounded\
    \ if necessary\n   |\n18 |         m < n as f64\n   |               ++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n == 0 {\n        return false;\n    }\n    \n    let mut\
    \ x: isize = x;\n    loop {\n        if x%n == 0 {\n            return true;\n\
    \        }\n        x /= n;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpurkhhzpz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n ** int(x) == x) as bool\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmppqvzzkvo.rs:12:11\n\
    \   |\n12 |     (n ** int(x) == x) as bool\n   |           ^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n\n    if x == n {\n        return true;\n    }\n\n    if n % x\
    \ == 0 {\n        n /= x;\n\n        return is_simple_power(x, n);\n    }\n\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpoj744zqe.rs:21:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    21 |         n /= x;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgf22d_2a.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        true\n\
    \    } else if n % 2 == 0 {\n        // 2 is an even power\n        !((x * x)\
    \ == n)\n    } else if n / 2 <= x {\n        // n is odd\n        !((x * x) ==\
    \ n) || is_simple_power(x, n / 2)\n    } else {\n        // n is even\n      \
    \  !((x * x) == n) || is_simple_power(x, n / 2)\n    }\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfrt44fnx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).any(|&n| {\n   \
    \     // power of n\n        x **= n as isize;\n        // if the product is equal\
    \ to x, then power of n is a simple power\n        x == x * x;\n    })\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `*=`\n  --> /tmp/tmpj529lgst.rs:14:12\n\
    \   |\n14 |         x **= n as isize;\n   |            ^^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj529lgst.rs:12:18\n   |\n12 |\
    \     (1..=n).any(|&n| {\n   |                  ^--\n   |                  ||\n\
    \   |                  |expected due to this\n   |                  expected `isize`,\
    \ found reference\n   |                  help: did you mean `n`: `&isize`\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n    (1..x).any(|i|\
    \ i * n == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzmtx2wrz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Fill in the code here.\n\
    \    return false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqvotjil_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).contains(&x**n)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp63q7zlhy.rs:12:25\n\
    \   |\n12 |     (1..=n).contains(&x**n)\n   |                         ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp63q7zlhy.rs:12:22\n   |\n12 |     (1..=n).contains(&x**n)\n\
    \   |                      ^^^^^\n   |                      |\n   |          \
    \            expected `&isize`, found `isize`\n   |                      help:\
    \ consider borrowing here: `&(&x**n)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    pow(x, n, &0) == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpkejuv0d4.rs:12:5\n\
    \   |\n12 |     pow(x, n, &0) == x\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n % x {\n        0\
    \ => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdeb6842d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        0 =>\
    \ true,\n        _ => n % x == 0,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6xh6zjpb.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ true;\n    }\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\
    \ // if n**int=x\n        return true;\n    }\n\n    // if n is square\n    if\
    \ n % 2 == 0 {\n        return is_simple_power(x, n / 2);\n    }\n    \n    //\
    \ if n is not square\n    let mut a = x;\n    while a % n == 0 {\n        a /=\
    \ n;\n    }\n    \n    // if n is prime\n    if a == x {\n        return true;\n\
    \    }\n    \n    // if n is composite\n    let mut a = x;\n    while a % n ==\
    \ 0 {\n        a /= n;\n    }\n    \n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp59j141uk.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    let\
    \ mut j = 1;\n\n    while i < n {\n        j *= x;\n        if i == n {\n    \
    \        i += 1;\n            continue;\n        }\n        if j == x {\n    \
    \        return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvfudnb3t.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..n).contains(&x)\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpemahphje.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if is_power_of_2(n) && is_power_of_2(x)\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_2` in this scope\n  -->\
    \ /tmp/tmpfvp5nkep.rs:12:8\n   |\n12 |     if is_power_of_2(n) && is_power_of_2(x)\
    \ {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_power_of_2` in this scope\n  --> /tmp/tmpfvp5nkep.rs:12:28\n\
    \   |\n12 |     if is_power_of_2(n) && is_power_of_2(x) {\n   |              \
    \              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        1 =>\
    \ true,\n        _ => x*n == x,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5xq5bb_9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut r = 1;\n    while\
    \ r < x {\n        r *= n;\n    }\n    r == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut n = n;\n    while n != 0 {\n        if n % 2 == 0 {\n            x /= 2;\n\
    \            n /= 2;\n        } else {\n            n = n - 1;\n        }\n  \
    \  }\n    n == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppxas6624.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (&x ** &n == &x) && is_power_of_two(n)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmp759nvit6.rs:12:25\n   |\n12 |     (&x ** &n == &x) && is_power_of_two(n)\n\
    \   |                         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp759nvit6.rs:12:18\n   |\n12 |     (&x ** &n\
    \ == &x) && is_power_of_two(n)\n   |                  ^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider removing the borrow\n   |\n12 -     (&x ** &n\
    \ == &x) && is_power_of_two(n)\n12 +     (&x ** &n == x) && is_power_of_two(n)\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    let mut counter = 1;\n    while counter <=\
    \ n {\n        if n % counter == 0 {\n            counter += 1;\n            continue;\n\
    \        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_p98j26y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = 1u64;\n    let x\
    \ = x << n;\n    (x == x) & ((x & (x - 1)) == 0)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa8s6soya.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < n {\n        return\
    \ false;\n    }\n    x.pow(n as i32) == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfopt1n80.rs:15:11\n   |\n\
    15 |     x.pow(n as i32) == x\n   |           ^^^^^^^^ expected `u32`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n15 |     x.pow((n as i32).try_into().unwrap()) == x\n   |\
    \           +        +++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = pow(x, n);\n\
    \n    for i in 1..=n {\n        if x != pow(x, i) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpocm3931u.rs:12:17\n\
    \   |\n12 |     let mut x = pow(x, n);\n   |                 ^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `pow` in this scope\n  -->\
    \ /tmp/tmpocm3931u.rs:15:17\n   |\n15 |         if x != pow(x, i) {\n   |    \
    \             ^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    fn check1(n: isize) -> bool\
    \ {\n        if n % 1 == 0 {\n            false\n        } else {\n          \
    \  check1(n / 1)\n        }\n    }\n\n    fn check2(n: isize) -> bool {\n    \
    \    if n % 2 == 0 {\n            true\n        } else {\n            check2(n\
    \ / 2)\n        }\n    }\n\n    fn check3(n: isize) -> bool {\n        if n %\
    \ 3 == 0 {\n            true\n        } else {\n            check3(n / 3)\n  \
    \      }\n    }\n\n    fn check4(n: isize) -> bool {\n        if n % 4 == 0 {\n\
    \            true\n        } else {\n            check4(n / 4)\n        }\n  \
    \  }\n\n    fn check5(n: isize) -> bool {\n        if n % 5 == 0 {\n         \
    \   true\n        } else {\n            check5(n / 5)\n        }\n    }\n\n  \
    \  fn check6(n: isize) -> bool {\n        if n % 6 == 0 {\n            true\n\
    \        } else {\n            check6(n / 6)\n        }\n    }\n\n    fn check7(n:\
    \ isize) -> bool {\n        if n % 7 == 0 {\n            true\n        } else\
    \ {\n            check7(n / 7)\n        }\n    }\n\n    fn check8(n: isize) ->\
    \ bool {\n        if n % 8 == 0 {\n            true\n        } else {\n      \
    \      check8(n / 8)\n        }\n    }\n\n    fn check9(n: isize) -> bool {\n\
    \        if n % 9 == 0 {\n            true\n        } else {\n            check9(n\
    \ / 9)\n        }\n    }\n\n    fn check10(n: isize) -> bool {\n        if n %\
    \ 10 == 0 {\n            true\n        } else {\n            check10(n / 10)\n\
    \        }\n    }\n\n    fn check11(n: isize) -> bool {\n        if n % 11 ==\
    \ 0 {\n            true\n        } else {\n            check11(n / 11)\n     \
    \   }\n    }\n\n    fn check12(n: isize) -> bool {\n        if n % 12 == 0 {\n\
    \            true\n        } else {\n            check12(n / 12)\n        }\n\
    \    }\n\n    fn check13(n: isize) -> bool {\n        if n % 13 == 0 {\n     \
    \       true\n        } else {\n            check13(n / 13)\n        }\n    }\n\
    \n    fn check14(n: isize) -> bool {\n        if n % 14 == 0 {\n            true\n\
    \        } else {\n            check14(n / 14)\n        }\n    }\n\n    fn check15(n:\
    \ isize) -> bool {\n        if n % 15 == 0 {\n            true\n        } else\
    \ {\n            check15(n / 15)\n\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4swko0oj.rs:144:3\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n...\n124 |    \
    \ fn check15(n: isize) -> bool {\n    |                                  - unclosed\
    \ delimiter\n...\n127 |         } else {\n    |                - this delimiter\
    \ might not be properly closed...\n...\n130 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n144 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4swko0oj.rs:11:43\n   |\n11 | fn is_simple_power(x: isize,\
    \ n: isize) -> bool {\n   |    ---------------                        ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp4swko0oj.rs:126:13\n\
    \    |\n125 | /         if n % 15 == 0 {\n126 | |             true\n    | |  \
    \           ^^^^ expected `()`, found `bool`\n127 | |         } else {\n128 |\
    \ |             check15(n / 15)\n129 | |\n130 | | }\n    | |_- expected this to\
    \ be `()`\n    |\nhelp: you might have meant to return this value\n    |\n126\
    \ |             return true;\n    |             ++++++     +\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp4swko0oj.rs:128:13\n    |\n125 | /        \
    \ if n % 15 == 0 {\n126 | |             true\n127 | |         } else {\n128 |\
    \ |             check15(n / 15)\n    | |             ^^^^^^^^^^^^^^^ expected\
    \ `()`, found `bool`\n129 | |\n130 | | }\n    | |_- expected this to be `()`\n\
    \    |\nhelp: consider using a semicolon here\n    |\n128 |             check15(n\
    \ / 15);\n    |                            +\nhelp: consider using a semicolon\
    \ here\n    |\n130 | };\n    |  +\nhelp: you might have meant to return this value\n\
    \    |\n128 |             return check15(n / 15);\n    |             ++++++  \
    \              +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp4swko0oj.rs:124:29\n\
    \    |\n124 |     fn check15(n: isize) -> bool {\n    |        -------       \
    \       ^^^^ expected `bool`, found `()`\n    |        |"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ n == 0;\n    }\n    n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1ddms_8o.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut r = x;\n    for\
    \ _ in 0..n {\n        r *= x;\n    }\n    r == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgunqz3jy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x % n) == 0 || is_simple_power(x\
    \ / n, n)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpispjqu62.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if is_power_of_two(n) &&\
    \ is_power_of_two(x) {\n        if x == n ** (n - 1) {\n            true\n   \
    \     } else {\n            false\n        }\n    } else {\n        false\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmppbi1r99t.rs:12:8\n   |\n12 |     if is_power_of_two(n) && is_power_of_two(x)\
    \ {\n   |        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_power_of_two` in this scope\n  --> /tmp/tmppbi1r99t.rs:12:30\n\
    \   |\n12 |     if is_power_of_two(n) && is_power_of_two(x) {\n   |          \
    \                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmppbi1r99t.rs:13:20\n   |\n\
    13 |         if x == n ** (n - 1) {\n   |                    ^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0614.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == n { true }\n   \
    \ else if n < 0 { false }\n    else if x == 1 {\n        (1..=n).contains(&x)\n\
    \    }\n    else {\n        (2..=n).contains(&(x % n))\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7aydqo12.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n<2 || n==1 {\n     \
    \   return true;\n    }\n    \n    if x==1 || x==n {\n        return true;\n \
    \   }\n    \n    let mut i = 3*n+1;\n    while i <= x {\n        if x % i == 0\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    \n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd1nawf8u.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n ** x == x {\n     \
    \   true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp0cw4me7.rs:12:11\n\
    \   |\n12 |     if n ** x == x {\n   |           ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    pow(x, n) == x\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp81ty6slk.rs:12:5\n\
    \   |\n12 |     pow(x, n) == x\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ x.is_power_of_two();\n    }\n\n    let mut y: isize = 1;\n\n    while n != 0\
    \ {\n        y *= n;\n        n /= 2;\n    }\n\n    y == x\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpwou0auoy.rs:13:18\n   |\n13 |         return\
    \ x.is_power_of_two();\n   |                  ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if is_power_of_two(n) &&\
    \ is_power_of_two(x) {\n        return n == x;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpq3eot78v.rs:12:8\n   |\n12 |     if is_power_of_two(n) && is_power_of_two(x)\
    \ {\n   |        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_power_of_two` in this scope\n  --> /tmp/tmpq3eot78v.rs:12:30\n\
    \   |\n12 |     if is_power_of_two(n) && is_power_of_two(x) {\n   |          \
    \                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n % x == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplklqfluk.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    debug_assert_eq!(n.is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x == (x >> 1), true);\n    debug_assert_eq!(x.is_power_of_two(),\
    \ true);\n    debug_assert_eq!(n == (n >> 1), true);\n    debug_assert_eq!(n.is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.is_power_of_two(), false);\n    debug_assert_eq!(nx.is_power_of_two(),\
    \ false);\n    debug_assert_eq!(!x.is_power_of_two(), false);\n    debug_assert_eq!(!n.is_power_of_two(),\
    \ false);\n    debug_assert_eq!(x.pow(n).is_power_of_two(), true);\n    debug_assert_eq!(x\
    \ == x.pow(n), true);\n    debug_assert_eq!(n == n.pow(x), true);\n    debug_assert_eq!(x.is_power_of_two(),\
    \ true);\n    debug_assert_eq!(nx.is_power_of_two(), true);\n    debug_assert_eq!(!x.is_power_of_two(),\
    \ true);\n    debug_assert_eq!(!n.is_power_of_two(), true);\n    debug_assert_eq!((x\
    \ >> 1) == (n >> 1), true);\n    debug_assert_eq!((x >> 1).is_power_of_two(),\
    \ true);\n    debug_assert_eq!((n >> 1).is_power_of_two(), true);\n    debug_assert_eq!(x.pow(n).is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.pow(n).is_power_of_two(), true);\n    debug_assert_eq!(x.pow(n).is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.pow(n).is_power_of_two(), true);\n    debug_assert_eq!((x\
    \ >> 1).pow(n).is_power_of_two(), true);\n    debug_assert_eq!((x >> 1).pow(n).is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n   \
    \ debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n    debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n   \
    \ debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n    debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(),\
    \ true);\n    debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n   \
    \ debug_assert_eq!(x.pow(n).pow(n).is_power_of_two(), true);\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `nx` in this scope\n  --> /tmp/tmp18az6s9n.rs:18:22\n\
    \   |\n18 |     debug_assert_eq!(nx.is_power_of_two(), false);\n   |         \
    \             ^^ help: a local variable with a similar name exists: `n`\n\nerror[E0425]:\
    \ cannot find value `nx` in this scope\n  --> /tmp/tmp18az6s9n.rs:25:22\n   |\n\
    25 |     debug_assert_eq!(nx.is_power_of_two(), true);\n   |                 \
    \     ^^ help: a local variable with a similar name exists: `n`\n\nerror[E0599]:\
    \ no method named `is_power_of_two` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp18az6s9n.rs:12:24\n   |\n12 |     debug_assert_eq!(n.is_power_of_two(),\
    \ true);\n   |                        ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp18az6s9n.rs:14:24\n   |\n14 |     debug_assert_eq!(x.is_power_of_two(),\
    \ true);\n   |                        ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp18az6s9n.rs:16:24\n   |\n16 |     debug_assert_eq!(n.is_power_of_two(),\
    \ true);\n   |                        ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp18az6s9n.rs:17:24\n   |\n17 |     debug_assert_eq!(x.is_power_of_two(),\
    \ false);\n   |                        ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp18az6s9n.rs:19:25\n   |\n19 |     debug_assert_eq!(!x.is_power_of_two(),\
    \ false);\n   |                         ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_power_of_two` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp18az6s9n.rs:20:25\n   |\n20 |     debug_assert_eq!(!n.is_power_of_two(),\
    \ false);\n   |                         ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp18a"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x: i64 = x;\n    let\
    \ n: i64 = n;\n    if x == 1i64 {\n        return n == 1i64;\n    }\n    if x\
    \ == 2i64 {\n        return n == 0i64;\n    }\n    if x == 3i64 {\n        return\
    \ n == 1i64;\n    }\n    if x == 5i64 {\n        return n == 0i64;\n    }\n  \
    \  if x == 6i64 {\n        return n == 1i64;\n    }\n    if x == 8i64 {\n    \
    \    return n == 0i64;\n    }\n    if x > 8i64 && n < 8i64 {\n        return n\
    \ == 1i64;\n    }\n    if x == 8i64 {\n        return n == 1i64;\n    }\n    if\
    \ x == 10i64 {\n        return n == 2i64;\n    }\n    if x == 10i64 + 1 {\n  \
    \      return n == 0i64;\n    }\n    if x == 11i64 + 1 {\n        return n ==\
    \ 1i64;\n    }\n    if x == 12i64 + 1 {\n        return n == 0i64;\n    }\n  \
    \  if x == 15i64 + 1 {\n        return n == 1i64;\n    }\n    if x == 15i64 +\
    \ 2 {\n        return n == 0i64;\n    }\n    if x == 20i64 + 2 {\n        return\
    \ n == 1i64;\n    }\n    if x == 20i64 + 3 {\n        return n == 0i64;\n    }\n\
    \    if x == 30i64 + 3 {\n        return n == 1i64;\n    }\n    if x == 30i64\
    \ + 4 {\n        return n == 0i64;\n    }\n    if x == 40i64 + 4 {\n        return\
    \ n == 1i64;\n    }\n    if x == 50i64 + 4 {\n        return n == 0i64;\n    }\n\
    \    if x == 60i64 + 4 {\n        return n == 1i64;\n    }\n    if x == 70i64\
    \ + 4 {\n        return n == 0i64;\n    }\n    if x == 80i64 + 4 {\n        return\
    \ n == 1i64;\n    }\n    if x == 90i64 + 4 {\n        return n == 0i64;\n    }\n\
    \    if x == 10i64 + 5 {\n        return n == 2i64;\n    }\n    if x == 10i64\
    \ + 6 {\n        return n == 0i64;\n    }\n    if x == 11i64 + 6 {\n        return\
    \ n == 1i64;\n    }\n    if x == 12i64 + 6 {\n        return n == 0i64;\n    }\n\
    \    if x == 15i64 + 6 {\n        return n == 1i64;\n    }\n    if x == 15i\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `i` for number literal\n   --> /tmp/tmph080q1bh.rs:101:13\n\
    \    |\n101 |     if x == 15i\n    |             ^^^ invalid suffix `i`\n    |\n\
    \    = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`,\
    \ etc.)\n\nerror: expected `{`, found `}`\n   --> /tmp/tmph080q1bh.rs:102:1\n\
    \    |\n101 |     if x == 15i\n    |     -- this `if` expression has a condition,\
    \ but no block\n102 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph080q1bh.rs:12:18\n   |\n12 |     let x: i64 = x;\n   |       \
    \     ---   ^ expected `i64`, found `isize`\n   |            |\n   |         \
    \   expected due to this\n   |\nhelp: you can convert an `isize` to an `i64` and\
    \ panic if the converted value doesn't fit\n   |\n12 |     let x: i64 = x.try_into().unwrap();\n\
    \   |                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph080q1bh.rs:13:18\n   |\n13 |     let n: i64 = n;\n   |       \
    \     ---   ^ expected `i64`, found `isize`\n   |            |\n   |         \
    \   expected due to this\n   |\nhelp: you can convert an `isize` to an `i64` and\
    \ panic if the converted value doesn't fit\n   |\n13 |     let n: i64 = n.try_into().unwrap();\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).contains(|i| x *\
    \ i == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwmuim82u.rs:12:22\n   |\n\
    12 |     (1..=n).contains(|i| x * i == x)\n   |                      ^^^^^^^^^^^^^^\
    \ expected `&isize`, found closure\n   |\n   = note: expected reference `&isize`\n\
    \                found closure `[closure@/tmp/tmpwmuim82u.rs:12:22: 12:36]`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n as usize {\n   \
    \     0 => true,\n        1 => x == 1,\n        _ => {\n            match (n >>\
    \ 1) as usize {\n                0 => x == 1,\n                _ => is_simple_power(x\
    \ ** 2, n),\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpv8iqaxt7.rs:18:41\n\
    \   |\n18 |                 _ => is_simple_power(x ** 2, n),\n   |           \
    \                              ^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n * (n - 1)).is_power_of_2()\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_2` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp9oc3h21f.rs:12:19\n   |\n12 |     (n * (n -\
    \ 1)).is_power_of_2()\n   |                   ^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let exp = pow(10, n as f64);\n\
    \    let mul = x.mul(exp);\n    let ans = mul.eq(x);\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpcal9keir.rs:12:15\n\
    \   |\n12 |     let exp = pow(10, n as f64);\n   |               ^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `mul` found for type `isize`\
    \ in the current scope\n   --> /tmp/tmpcal9keir.rs:13:17\n    |\n13  |     let\
    \ mul = x.mul(exp);\n    |                 ^^^ method not found in `isize`\n \
    \   |\n    = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n    |\n1   | use std::ops::Mul;\n    |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut m = 1;\n    for\
    \ i in (0..=n)\n    {\n        m *= i;\n    }\n    if x == n ** m {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `for` iterator expression\n  -->\
    \ /tmp/tmpv9e_ds0w.rs:13:14\n   |\n13 |     for i in (0..=n)\n   |           \
    \   ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n13 -     for i in (0..=n)\n13 +     for i in 0..=n\n\
    \   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpv9e_ds0w.rs:17:16\n\
    \   |\n17 |     if x == n ** m {\n   |                ^^^\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n    //\
    \ \n    // let mut power = 1;\n    // while power <= n {\n    //     if power*x\
    \ == x {\n    //         return true;\n    //     }\n    //     power = power\
    \ + 1;\n    // }\n    // return false;\n    // \n    // if (x * n == x) {\n  \
    \  //     return true;\n    // }\n    // return false;\n    \n    let mut power\
    \ = 1;\n    while power <= n {\n        if power == 1 {\n            return true;\n\
    \        }\n        if x * power == x {\n            return true;\n        }\n\
    \        power = power + 1;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzql69frw.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        true\n\
    \    } else if n == 1 {\n        true\n    } else if n % 2 == 0 {\n        x ==\
    \ (x * x)\n    } else {\n        x == (x * x) / is_simple_power(x, n - 1)\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `isize` by `bool`\n  --> /tmp/tmpbp19c757.rs:19:22\n\
    \   |\n19 |         x == (x * x) / is_simple_power(x, n - 1)\n   |           \
    \           ^ no implementation for `isize / bool`\n   |\n   = help: the trait\
    \ `Div<bool>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n          \
    \   <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n            \
    \ <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a\
    \ i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a isize\
    \ as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ n == 1;\n    }\n    let mut product = x;\n    let mut exponent = 0;\n    while\
    \ exponent < n {\n        product *= x;\n        exponent++;\n    }\n    product\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpg5_y7_6_.rs:19:17\n\
    \   |\n19 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n19 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n19 -\
    \         exponent++;\n19 +         exponent += 1;\n   | \n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let n = pow(x, n);\n   \
    \ n == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp316nap1k.rs:12:13\n\
    \   |\n12 |     let n = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if is_positive(x) && is_positive(n)\
    \ {\n        for z in 0..n {\n            let a = x*z;\n            if is_positive(a)\
    \ { return true; }\n        }\n        return false;\n    }\n    // we never get\
    \ here because x and n are positive\n    return false;\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_positive` in this scope\n  --> /tmp/tmpd3yxf_0g.rs:12:8\n\
    \   |\n12 |     if is_positive(x) && is_positive(n) {\n   |        ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_positive`\
    \ in this scope\n  --> /tmp/tmpd3yxf_0g.rs:12:26\n   |\n12 |     if is_positive(x)\
    \ && is_positive(n) {\n   |                          ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_positive` in this scope\n\
    \  --> /tmp/tmpd3yxf_0g.rs:15:16\n   |\n15 |             if is_positive(a) { return\
    \ true; }\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.pow(n).eq(x)\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3ry9vhc.rs:12:11\n   |\n\
    12 |     x.pow(n).eq(x)\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n12 |     x.pow(n.try_into().unwrap()).eq(x)\n   |            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw3ry9vhc.rs:12:17\n   |\n12 |\
    \     x.pow(n).eq(x)\n   |                 ^\n   |                 |\n   |   \
    \              expected `&isize`, found `isize`\n   |                 help: consider\
    \ borrowing here: `&x`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n == x {\n        return true;\n    }\n    if n % x ==\
    \ 0 {\n        return is_simple_power(x, n/x);\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcybjv171.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        true\n\
    \    } else if n == 2 {\n        x % 1 == 0\n    } else {\n        x == ((n**x\
    \ - 1) % n) == 0\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpyqwi_5cx.rs:17:11\n\
    \   |\n17 |         x == ((n**x - 1) % n) == 0\n   |           ^^            \
    \      ^^\n   |\nhelp: split the comparison into two\n   |\n17 |         x ==\
    \ ((n**x - 1) % n) && ((n**x - 1) % n) == 0\n   |                            \
    \   +++++++++++++++++++\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpyqwi_5cx.rs:17:18\n   |\n17 |         x == ((n**x - 1) % n) ==\
    \ 0\n   |                  ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqwi_5cx.rs:17:34\n\
    \   |\n17 |         x == ((n**x - 1) % n) == 0\n   |                         \
    \         ^ expected `bool`, found integer\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n <= 0 || x == 0 || x\
    \ == 1 {\n        return true;\n    }\n    if n == 1 {\n        return true;\n\
    \    }\n    if n % 2 != 0 {\n        return false;\n    }\n    if n % 3 == 0 {\n\
    \        return false;\n    }\n    if x <= n {\n        fn is_simple_power_aux(x:\
    \ isize, n: isize, acc: bool) -> bool {\n            if n == 0 {\n           \
    \     return acc;\n            }\n            if n % 2 != 0 {\n              \
    \  return false;\n            }\n            if n % 3 == 0 {\n               \
    \ return false;\n            }\n            if x <= n {\n                return\
    \ is_simple_power_aux(x - 1, n, acc && x == 1);\n            }\n            false\n\
    \        }\n        return is_simple_power_aux(x, n, true)\n    } else {\n   \
    \     fn is_simple_power_aux(x: isize, n: isize, acc: bool) -> bool {\n      \
    \      if n % 2 != 0 {\n                return false;\n            }\n       \
    \     if n % 3 == 0 {\n                return false;\n            }\n        \
    \    if x <= n {\n                return is_simple_power_aux(x - 1, n, acc &&\
    \ x == 1);\n            }\n            false\n        }\n        return is_simple_power_aux(x,\
    \ n, true)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8k466rvu.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        2 | 4\
    \ | 8 | 16 => x == 1,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi9dk5gi1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    debug_assert!((1..=n).contains(&x));\n\
    \    (n ** x) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp15sl25u4.rs:13:9\n\
    \   |\n13 |     (n ** x) == x\n   |         ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = x as i64;\n    let\
    \ n = n as i64;\n    match (x, n) {\n        (x_, _) | (_, n_) => x_ == n_,\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0408]: variable `x_` is not bound in all patterns\n  --> /tmp/tmp1tqvgkc_.rs:15:19\n\
    \   |\n15 |         (x_, _) | (_, n_) => x_ == n_,\n   |          --       ^^^^^^^\
    \ pattern doesn't bind `x_`\n   |          |\n   |          variable not in all\
    \ patterns\n\nerror[E0408]: variable `n_` is not bound in all patterns\n  -->\
    \ /tmp/tmp1tqvgkc_.rs:15:9\n   |\n15 |         (x_, _) | (_, n_) => x_ == n_,\n\
    \   |         ^^^^^^^       -- variable not in all patterns\n   |         |\n\
    \   |         pattern doesn't bind `n_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0408`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match (&n, &x) {\n     \
    \   (&1, _) => true,\n        (&2, _) => true,\n        (&3, _) => true,\n   \
    \     (&3, &x) => true,\n        (&4, &x) => x == 1,\n        (&5, &x) => x ==\
    \ 1,\n        (&6, &x) => x == 1,\n        (&7, &x) => x == 1,\n        (&8, &x)\
    \ => x == 1,\n        (&9, &x) => x == 1,\n        (&10, &x) => x == 1,\n    \
    \    (&11, &x) => x == 1,\n        (&12, &x) => x == 1,\n        (&14, &x) =>\
    \ x == 1,\n        (&15, &x) => x == 1,\n        (&16, &x) => x == 1,\n      \
    \  (&18, &x) => x == 1,\n        (&20, &x) => x == 1,\n        (&2i, &x) => x\
    \ == 1,\n        (&3i, &x) => x == 1,\n        (&4i, &x) => x == 1,\n        (&5i,\
    \ &x) => x == 1,\n        (&6i, &x) => x == 1,\n        (&7i, &x) => x == 1,\n\
    \        (&8i, &x) => x == 1,\n        (&9i, &x) => x == 1,\n        (&10i, &x)\
    \ => x == 1,\n        (&11i, &x) => x == 1,\n        (&12i, &x) => x == 1,\n \
    \       (&13i, &x) => x == 1,\n        (&14i, &x) => x == 1,\n        (&15i, &x)\
    \ => x == 1,\n        (&16i, &x) => x == 1,\n        (&18i, &x) => x == 1,\n \
    \       (&20i, &x) => x == 1,\n        (&25i, &x) => x == 1,\n        (&27i, &x)\
    \ => x == 1,\n        (&30i, &x) => x == 1,\n        (&33i, &x) => x == 1,\n \
    \       (&36i, &x) => x == 1,\n        (&39i, &x) => x == 1,\n        (&42i, &x)\
    \ => x == 1,\n        (&45i, &x) => x == 1,\n        (&48i, &x) => x == 1,\n \
    \       (&51i, &x) => x == 1,\n        (&54i, &x) => x == 1,\n        (&57i, &x)\
    \ => x == 1,\n        (&60i, &x) => x == 1,\n        (&63i, &x) => x == 1,\n \
    \       (&66i, &x) => x == 1,\n        (&69i, &x) => x == 1,\n        (&72i, &x)\
    \ => x == 1,\n        (&75i, &x) => x == 1,\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdkw5jtji.rs:80:3\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                                     - unclosed delimiter\n12 |     match (&n,\
    \ &x) {\n   |                    - this delimiter might not be properly closed...\n\
    ...\n66 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    80 | }\n   |   ^\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:31:11\n\
    \   |\n31 |         (&2i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:32:11\n\
    \   |\n32 |         (&3i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:33:11\n\
    \   |\n33 |         (&4i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:34:11\n\
    \   |\n34 |         (&5i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:35:11\n\
    \   |\n35 |         (&6i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:36:11\n\
    \   |\n36 |         (&7i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `i` for number literal\n  --> /tmp/tmpdkw5jtji.rs:37:11\n\
    \   |\n37 |         (&8i, &x) => x == 1,\n   |           ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix "
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ true;\n    }\n    if x == 1 {\n        return true;\n    }\n    if x == n {\n\
    \        return true;\n    }\n    if n % x == 0 {\n        return true;\n    }\n\
    \    if n == 1 {\n        return false;\n    }\n    if n**int::pow(x, n) == x\
    \ {\n        return true;\n    }\n    if n != 1 {\n        if n**int::pow(x, n\
    \ - 1) == x {\n            return true;\n        }\n    }\n    if n > 1 {\n  \
    \      if n**int::pow(x, n - 2) == x {\n            return true;\n        }\n\
    \    }\n    if n > 2 {\n        if n**int::pow(x, n - 3) == x {\n            return\
    \ true;\n        }\n    }\n    if n > 3 {\n        if n**int::pow(x, n - 4) ==\
    \ x {\n            return true;\n        }\n    }\n    if n > 4 {\n        if\
    \ n**int::pow(x, n - 5) == x {\n            return true;\n        }\n    }\n \
    \   if n > 5 {\n        if n**int::pow(x, n - 6) == x {\n            return true;\n\
    \        }\n    }\n    if n > 6 {\n        if n**int::pow(x, n - 7) == x {\n \
    \           return true;\n        }\n    }\n    if n > 7 {\n        if n**int::pow(x,\
    \ n - 8) == x {\n            return true;\n        }\n    }\n    if n > 8 {\n\
    \        if n**int::pow(x, n - 9) == x {\n            return true;\n        }\n\
    \    }\n    if n > 9 {\n        if n**int::pow(x, n - 10) == x {\n           \
    \ return true;\n        }\n    }\n    if n > 10 {\n        if n**int::pow(x, n\
    \ - 11) == x {\n            return true;\n        }\n    }\n    if n > 11 {\n\
    \        if n**int::pow(x, n - 12) == x {\n            return true;\n        }\n\
    \    }\n    if n > 12 {\n        if n**int::pow(x, n - 13) == x {\n          \
    \  return true;\n        }\n    }\n    if n > 13 {\n        if n**int::pow(x,\
    \ n - 14) == x {\n            return true;\n        }\n    }\n    if n > 14 {\n\
    \        if n**int::pow(x, n - 15) == x {\n            return true;\n        }\n\
    \    }\n    if n > 15 {\n        if n**int::pow(x, n - 16) == x {\n          \
    \  return true;\n        }\n    }\n    if n > 16 {\n        if n**int::pow(x,\
    \ n - 17) == x {\n            return true;\n        }\n    }\n    if n > 17 {\n\
    \        if n**int::pow(x, n - 18) == x {\n            return true;\n        }\n\
    \    }\n    if n > 18 {\n        if n**int\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4lrs0atm.rs:136:3\n\
    \    |\n11  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n...\n120 |    \
    \ if n > 18 {\n    |               - this delimiter might not be properly closed...\n\
    121 |         if n**int\n122 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n136 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmp4lrs0atm.rs:122:1\n    |\n121 |         if n**int\n    |         --\
    \ this `if` expression has a condition, but no block\n122 | }\n    | ^ expected\
    \ `{`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `int`\n\
    \  --> /tmp/tmp4lrs0atm.rs:27:11\n   |\n27 |     if n**int::pow(x, n) == x {\n\
    \   |           ^^^ use of undeclared crate or module `int`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `int`\n  --> /tmp/tmp4lrs0atm.rs:31:15\n\
    \   |\n31 |         if n**int::pow(x, n - 1) == x {\n   |               ^^^ use\
    \ of undeclared crate or module `int`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `int`\n  --> /tmp/tmp4lrs0atm.rs:36:15\n   |\n\
    36 |         if n**int::pow(x, n - 2) == x {\n   |               ^^^ use of undeclared\
    \ crate or module `int`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `int`\n  --> /tmp/tmp4lrs0atm.rs:41:15\n   |\n41 |         if\
    \ n**int::pow(x, n - 3) == x {\n   |               ^^^ use of undeclared crate\
    \ or module `int`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `int`\n  --> /tmp/tmp4lrs0atm.rs:46:15\n   |\n46 |         if n**int::pow(x,\
    \ n - 4) == x {\n   |               ^^^ use of undeclared crate or module `int`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `int`\n \
    \ --> /tmp/tmp4lrs0atm.rs:51:15\n   |\n51 |         if n**int::pow(x, n - 5) ==\
    \ x {\n   |               ^^^ use of undeclared crate or module `int`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `int`\n  --> /tmp/tmp4lrs0atm.rs:56:15\n\
    \   |\n56 |         if"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        true\n\
    \    } else if n % x == 0 {\n        true\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0sctzs_c.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x != 0\n    && x != 1\n\
    \    && n != 1\n    && n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuc0qwls0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n % 2 == 0 {\n        return x == 1;\n    }\n    let x\
    \ = x * x;\n    let y = n ** x;\n    let y = y % n;\n    return x == y;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpb_30hp50.rs:19:16\n\
    \   |\n19 |     let y = n ** x;\n   |                ^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    fn is_pow(x: isize, n: isize)\
    \ -> bool {\n        if x == n {\n            return true;\n        }\n      \
    \  if n % x != 0 {\n            return false;\n        }\n        let mut m =\
    \ x;\n        while m > 1 {\n            m -= 1;\n            if n % m != 0 {\n\
    \                return false;\n            }\n        }\n        return true;\n\
    \    }\n    is_pow(x, n) == is_pow(x * x, n)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6rvbl2mu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n % x == 0 && n == x * x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps6xudoeb.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO: implement a more\
    \ efficient solution\n    let mut result = true;\n    for (i, &x) in n.iter().zip(x.iter()).filter(|&(x,\
    \ &n)| n == x).enumerate() {\n        if *x != i {\n            result = false;\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5d60xu1h.rs:14:22\n   |\n14 |     for (i, &x) in n.iter().zip(x.iter()).filter(|&(x,\
    \ &n)| n == x).enumerate() {\n   |                      ^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `iter` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp5d60xu1h.rs:14:35\n   |\n14 |     for (i, &x)\
    \ in n.iter().zip(x.iter()).filter(|&(x, &n)| n == x).enumerate() {\n   |    \
    \                               ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if is_power2(n) {\n    \
    \    return x == pow2(n);\n    }\n    for i in (0..(n - 1)).step_by(n) {\n   \
    \     if x != pow2(i) {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power2` in this scope\n  --> /tmp/tmpz09uic8f.rs:12:8\n\
    \   |\n12 |     if is_power2(n) {\n   |        ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmpz09uic8f.rs:13:21\n\
    \   |\n13 |         return x == pow2(n);\n   |                     ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow2` in this scope\n \
    \ --> /tmp/tmpz09uic8f.rs:16:17\n   |\n16 |         if x != pow2(i) {\n   |  \
    \               ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz09uic8f.rs:15:35\n   |\n15 |     for i in (0..(n - 1)).step_by(n)\
    \ {\n   |                                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     for i in (0..(n - 1)).step_by(n.try_into().unwrap())\
    \ {\n   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        true\n\
    \    } else if x == 1 {\n        true\n    } else {\n        n == x * n\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdxqv9ggv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n    let\
    \ mut res = true;\n    for i in (1..n).rev() {\n        res &= is_power_of_two(x)\
    \ && (x % i == 0);\n    }\n    res\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpvvixcjhw.rs:15:16\n   |\n15 |         res &= is_power_of_two(x) && (x\
    \ % i == 0);\n   |                ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    pow(x, n) == x\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpdbrvpf3y.rs:12:5\n\
    \   |\n12 |     pow(x, n) == x\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if x == n {\n        return true;\n    }\n    if x < n {\n\
    \        return false;\n    }\n    fn helper(x: isize, n: isize) -> bool {\n \
    \       if n >= 1 {\n            if x == n {\n                return true;\n \
    \           }\n            return helper(x - 1, n ** x);\n        } else {\n \
    \           return false;\n        }\n    }\n    helper(x, n);\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptjr0i2h0.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n...\n\
    31 |     helper(x, n);\n   |                 - help: remove this semicolon\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptjr0i2h0.rs:26:37\n\
    \   |\n26 |             return helper(x - 1, n ** x);\n   |                  \
    \                   ^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 || (n == 1 &&\
    \ x == 1) || (n == -1 && x == -1) {\n        return true;\n    }\n    if n % 2\
    \ == 0 {\n        let xpow: isize = x * x;\n        if xpow == x {\n         \
    \   return true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_ja175_c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n % n {\n        0\
    \ => n == 0,\n        _ => n % x == 0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_vh6zpqo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut acc = true;\n  \
    \  for i in 1..n {\n        if i ** x == x {\n            acc = false;\n     \
    \       break;\n        }\n    }\n    acc\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpl1cy5vyr.rs:14:15\n\
    \   |\n14 |         if i ** x == x {\n   |               ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return x == 1;\n    }\n    let mut x\
    \ = x;\n    while x > n {\n        x = x / n;\n    }\n    x == n * n\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5rmgtcvq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n\n    if n == 1 {\n        return false;\n    }\n\n    if n %\
    \ x == 0 {\n        return is_simple_power(x, n - 1);\n    } else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzcz3r94r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).contains(&(pow(x,\
    \ n)))\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpqfb__sn_.rs:12:24\n\
    \   |\n12 |     (1..=n).contains(&(pow(x, n)))\n   |                        ^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 0 ||\n    n > x ||\n\
    \    !((n % x) == 0 && (n % x) == x && (n/x) % x == 0 && n % x == 0)\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7p4_o55d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n <= 1 {\n        return\
    \ true;\n    }\n    // TODO: Write code here\n    let mut a = x;\n    let mut\
    \ b = n;\n    let mut c = 1;\n    while b > 0 {\n        if a > 0 {\n        \
    \    a %= b;\n        }\n        else {\n            a *= b;\n        }\n    \
    \    c += a;\n        b = c / b;\n    }\n    c = x;\n    while c > 1 {\n     \
    \   if c % n == 0 {\n            return true;\n        }\n        c /= n;\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp48fcgrao.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n < 1 {\n        return\
    \ false;\n    }\n\n    if x == n {\n        return true;\n    }\n\n    if x ==\
    \ n * (n - 1) {\n        return true;\n    }\n\n    if n % x == 0 {\n        return\
    \ false;\n    }\n\n    if n % x == 1 {\n        return is_simple_power(x, n -\
    \ 1);\n    }\n\n    if x < n {\n        return false;\n    }\n\n    if is_simple_power(x,\
    \ n - 1) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 2) {\n\
    \        return true;\n    }\n\n    if is_simple_power(x, n - 3) {\n        return\
    \ true;\n    }\n\n    if x > n {\n        return false;\n    }\n\n    if is_simple_power(x,\
    \ n - 4) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 5) {\n\
    \        return true;\n    }\n\n    if is_simple_power(x, n - 6) {\n        return\
    \ true;\n    }\n\n    if is_simple_power(x, n - 7) {\n        return true;\n \
    \   }\n\n    if is_simple_power(x, n - 8) {\n        return true;\n    }\n\n \
    \   if is_simple_power(x, n - 9) {\n        return true;\n    }\n\n    if x >\
    \ n {\n        return false;\n    }\n\n    if is_simple_power(x, n - 10) {\n \
    \       return true;\n    }\n\n    if is_simple_power(x, n - 11) {\n        return\
    \ true;\n    }\n\n    if is_simple_power(x, n - 12) {\n        return true;\n\
    \    }\n\n    if is_simple_power(x, n - 13) {\n        return true;\n    }\n\n\
    \    if is_simple_power(x, n - 14) {\n        return true;\n    }\n\n    if is_simple_power(x,\
    \ n - 15) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 16)\
    \ {\n        return true;\n    }\n\n    if is_simple_power(x, n - 17) {\n    \
    \    return true;\n    }\n\n    if is_simple_power(x, n - 18) {\n        return\
    \ true;\n    }\n\n    if is_simple_power(x, n - 19) {\n        return true;\n\
    \    }\n\n    if is_simple_power(x, n - 20) {\n        return true;\n    }\n\n\
    \    if x > n {\n        return false;\n    }\n\n    if is_simple_power(x, n -\
    \ 21) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 22) {\n\
    \        return true;\n    }\n\n    if is_simple_power(x, n - 23) {\n        return\
    \ true;\n    }\n\n    if is_simple_power(x, n - 24) {\n        return true;\n\
    \    }\n\n    if is_simple_power(x, n - 25) {\n        return true;\n    }\n\n\
    \    if is_simple_power(x, n - 26) {\n        return true;\n    }\n\n    if is_simple_power(x,\
    \ n - 27) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 28)\
    \ {\n        return true;\n    }\n\n    if is_simple_power(x, n - 29) {\n    \
    \    return true;\n    }\n\n    if is_simple_power(x, n - 30) {\n        return\
    \ true;\n    }\n\n    if is_simple_power(x, n - 31) {\n        return true;\n\
    \    }\n\n    if is_simple_power(x, n - 32) {\n        return true;\n    }\n\n\
    \    if is_simple_power(x, n - 33) {\n        return true;\n    }\n\n    if is_simple_power(x,\
    \ n - 34) {\n        return true;\n    }\n\n    if is_simple_power(x, n - 35)\
    \ {\n        return true;\n    }\n\n    if is_simple_power(x, n - 36\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpbsm5_bry.rs:189:1\n    |\n\
    188 |     if is_simple_power(x, n - 36\n    |     -- this `if` expression has\
    \ a condition, but no block\n189 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmpbsm5_bry.rs:188:23\n    |\n11  | fn is_simple_power(x:\
    \ isize, n: isize) -> bool {\n    |                                          \
    \      - closing delimiter possibly meant for this\n...\n188 |     if is_simple_power(x,\
    \ n - 36\n    |                       ^ unclosed delimiter\n189 | }\n    | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 1 || (n % x == 0 &&\
    \ is_simple_power(x, n / x))\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpedh9kh2o.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n % x == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjbe3_s2b.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..n)\n        .filter(|&_|\
    \ x * &_ == x)\n        .count() == n\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpnmsh0n6h.rs:13:27\n   |\n13 |         .filter(|&_|\
    \ x * &_ == x)\n   |                           ^ `_` not allowed here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnmsh0n6h.rs:14:21\n   |\n14 |         .count()\
    \ == n\n   |                     ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |         .count() == n.try_into().unwrap()\n   |            \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // TODO: Your code here\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiukssn_s.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x % n == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxrpal7gn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        1 =>\
    \ true,\n        _ => x**n==x,\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpdchhb6qq.rs:14:16\n\
    \   |\n14 |         _ => x**n==x,\n   |                ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n % x {\n        0\
    \ => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3e_nem45.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.is_power_of_two() && pow(x,\
    \ n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp428b7phn.rs:12:28\n\
    \   |\n12 |     n.is_power_of_two() && pow(x, n) == x\n   |                  \
    \          ^^^ not found in this scope\n\nerror[E0599]: no method named `is_power_of_two`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp428b7phn.rs:12:7\n\
    \   |\n12 |     n.is_power_of_two() && pow(x, n) == x\n   |       ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let m = x % n;\n    m ==\
    \ 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_zv5f8dr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n ** x == x {\n     \
    \   return true;\n    }\n    else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpl0lueanr.rs:12:11\n\
    \   |\n12 |     if n ** x == x {\n   |           ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x = pow(x, n);\n   \
    \ if x == 1 {\n        true\n    } else {\n        x < 1\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpe1xvlalx.rs:12:13\n\
    \   |\n12 |     let x = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = true;\n\
    \    while n != 0 {\n        if n % x == 0 {\n            result = false;\n  \
    \          break;\n        }\n        n /= x;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfcbkmlz7.rs:18:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    18 |         n /= x;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ true;\n    }\n    if n == 0 {\n        return false;\n    }\n    if n % x ==\
    \ 0 {\n        return is_simple_power(x, n-1);\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp50dzs483.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut counter = 1;\n \
    \   while counter <= n {\n        if x * counter != n {\n            return false;\n\
    \        }\n        counter += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf3ito23s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i: isize = 1;\n\
    \    while i * i <= n {\n        if x * i > n {\n            return false;\n \
    \       }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq7v5yy9z.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if x < n && n % x == 0 {\n        is_simple_power(x, n / x)\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfs_aqox3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = true;\n\
    \    let mut i = 1;\n    while i <= n {\n        if x * i == x {\n           \
    \ result = true;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjo1rd7q9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        true\n\
    \    } else if x == 1 {\n        false\n    } else {\n        is_simple_power(x,\
    \ n - 1)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0autrd3r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    while\
    \ i <= n {\n        if x ** i == x {\n            return true;\n        }\n  \
    \      i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpksuh6zd3.rs:14:15\n\
    \   |\n14 |         if x ** i == x {\n   |               ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n {\n        1 =>\
    \ true\n        _ => x % n == 0,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found reserved\
    \ identifier `_`\n  --> /tmp/tmppg1ubsfu.rs:14:9\n   |\n13 |         1 => true\n\
    \   |           --     - expected one of `,`, `.`, `?`, `}`, or an operator\n\
    \   |           |\n   |           while parsing the `match` arm starting here\n\
    14 |         _ => x % n == 0,\n   |         ^ unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    use std::cmp::Ordering;\n\
    \n    // We need to check if n == 0, since 2**0 = 2\n    match n {\n        0\
    \ => true\n        _ => n == x && (n == 1 || n == x),\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found reserved\
    \ identifier `_`\n  --> /tmp/tmpaxvko_m_.rs:17:9\n   |\n16 |         0 => true\n\
    \   |           --     - expected one of `,`, `.`, `?`, `}`, or an operator\n\
    \   |           |\n   |           while parsing the `match` arm starting here\n\
    17 |         _ => n == x && (n == 1 || n == x),\n   |         ^ unexpected token\n\
    \nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpaxvko_m_.rs:12:9\n\
    \   |\n12 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.powi(n) == x\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `powi` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqesuzj_e.rs:12:7\n   |\n12 |     x.powi(n) == x\n   | \
    \      ^^^^ help: there is an associated function with a similar name: `pow`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n ** (n - 1)).is_eq(x)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp587vpqe1.rs:12:9\n\
    \   |\n12 |     (n ** (n - 1)).is_eq(x)\n   |         ^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `is_eq` found for type `isize` in the current scope\n  --> /tmp/tmp587vpqe1.rs:12:20\n\
    \   |\n12 |     (n ** (n - 1)).is_eq(x)\n   |                    ^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in n..=1 {\n        sum += x;\n        if sum > isize {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp07wqr87y.rs:15:18\n\
    \   |\n15 |         if sum > isize {\n   |                  ^^^^^ not a value\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n < 0 {\n        return\
    \ false;\n    }\n    if n == 1 {\n        return true;\n    }\n    \n    if n\
    \ < 2 {\n        return false;\n    }\n    \n    if x == n {\n        return true;\n\
    \    }\n    \n    if n % x == 0 {\n        return is_simple_power(x, n - 1);\n\
    \    }\n    \n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpke96if_5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Write code here\n   \
    \ if n < 1 {\n        return false;\n    }\n    let mut res = true;\n    let mut\
    \ power = 0;\n    while n != 0 {\n        power += 1;\n        if power == n {\n\
    \            return true;\n        }\n        n /= x;\n    }\n    res &= false;\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7ielhrd.rs:23:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    23 |         n /= x;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == n {\n        return\
    \ true;\n    }\n    if x > n {\n        return false;\n    }\n    if n % x ==\
    \ 0 {\n        return is_simple_power(x, n - 1);\n    }\n    return false;\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_qnk8j4o.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmperno4o9h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % x == 0 {\n            x += 1;\n\
    \            n = n / x;\n        } else {\n            x = 1;\n            n =\
    \ n;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy0jfy_g1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n < 0 {\n        false\n\
    \    } else if n == 0 {\n        true\n    } else {\n        x == x * n\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp33s1vydf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return\
    \ true;\n    }\n    if n == 0 {\n        return false;\n    }\n    if x == 0 {\n\
    \        return false;\n    }\n    if x % n == 0 {\n        return is_simple_power(x\
    \ / n, n) ? true : false;\n    }\n    return is_simple_power(x, n-1) ? true :\
    \ false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `true`\n  --> /tmp/tmp0yc754iz.rs:22:44\n   |\n22 |         return is_simple_power(x\
    \ / n, n) ? true : false;\n   |                                            ^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of\
    \ `.`, `;`, `?`, `}`, or an operator, found keyword `true`\n  --> /tmp/tmp0yc754iz.rs:24:38\n\
    \   |\n24 |     return is_simple_power(x, n-1) ? true : false;\n   |         \
    \                             ^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut a = x;\n    loop\
    \ {\n        if a == n ** 2 {\n            return true;\n        }\n        a\
    \ %= n;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpua452_3o.rs:14:20\n\
    \   |\n14 |         if a == n ** 2 {\n   |                    ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 1 && n % x == 0\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk8z47ind.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // write your logic here\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqmbhka8a.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n % x).is_none() && is_simple_power(x,\
    \ n / x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_none` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpzsgpypuu.rs:12:13\n   |\n12 |     (n % x).is_none() &&\
    \ is_simple_power(x, n / x)\n   |             ^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        false\n\
    \    } else {\n        let mut i = 0;\n        let mut x2 = x;\n        while\
    \ i < n {\n            if x2 == 0 {\n                return false;\n         \
    \   }\n            x2 /= 2;\n            i += 1;\n        }\n        x2 == x\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9m6ejdxb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n    let\
    \ result = x * (x - 1) % n == 1;\n    println!(\"result {}\", result);\n    result\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: "result false\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9hkt_ie7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if n < 2 {\n        return\
    \ false;\n    }\n    let mut power = n;\n    let mut product = 1;\n    while power\
    \ < x as isize {\n        product *= power;\n        power *= n;\n    }\n    product\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61v4a2dx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false\n    }\n    if n == 1 {\n        return true\n    }\n  \
    \  let mut i = 1;\n    while i <= n {\n        if x%i == 0 {\n            if n\
    \ == i {\n                return true\n            }\n            return false\n\
    \        }\n        i += 1;\n    }\n    return false\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcd9ypt88.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Your code here\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpndtruy3z.rs:11:43\n   |\n\
    11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x <= 0 || n == 0 || x ==\
    \ 1 || n == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5wdpjm15.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == n {\n        return\
    \ true;\n    }\n    for _ in 0..=n {\n        x /= n;\n        if x != 1 {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpmkkrjtfq.rs:16:9\n\
    \   |\n11 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n16 |   \
    \      x /= n;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
