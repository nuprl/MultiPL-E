name: HumanEval_161_solve
language: rust
results:
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c| {\n\
    \        if c.is_ascii_lowercase() || c.is_ascii_uppercase() {\n            s.insert_len(1,\
    \ c.to_ascii_lowercase());\n        } else {\n            s.insert_len(1, c.to_ascii_uppercase());\n\
    \        }\n    });\n    match s.chars().count() {\n        0 => s,\n        _\
    \ => s.chars().cloned().reverse().collect::<String>().into(),\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `insert_len` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp664741jx.rs:14:15\n   |\n14 |             s.insert_len(1,\
    \ c.to_ascii_lowercase());\n   |               ^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `insert`\n\nerror[E0599]: no method named `insert_len`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp664741jx.rs:16:15\n\
    \   |\n16 |             s.insert_len(1, c.to_ascii_uppercase());\n   |       \
    \        ^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `insert`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp664741jx.rs:21:24\n     |\n21   |         _ => s.chars().cloned().reverse().collect::<String>().into(),\n\
    \     |                        ^^^^^^ expected reference, found `char`\n     |\n\
    \     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmp664741jx.rs:21:33\n\
    \   |\n21 |         _ => s.chars().cloned().reverse().collect::<String>().into(),\n\
    \   |                                 ^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().count() > 0 {\n        if s.chars().any(|c| match\
    \ c {\n            'a' => String::from(\"A\"),\n            'b' => String::from(\"\
    B\"),\n            'c' => String::from(\"C\"),\n            'd' => String::from(\"\
    D\"),\n            'e' => String::from(\"E\"),\n            'f' => String::from(\"\
    F\"),\n            'g' => String::from(\"G\"),\n            'h' => String::from(\"\
    H\"),\n            'i' => String::from(\"I\"),\n            'j' => String::from(\"\
    J\"),\n            'k' => String::from(\"K\"),\n            'l' => String::from(\"\
    L\"),\n            'm' => String::from(\"M\"),\n            'n' => String::from(\"\
    N\"),\n            'o' => String::from(\"O\"),\n            'p' => String::from(\"\
    P\"),\n            'q' => String::from(\"Q\"),\n            'r' => String::from(\"\
    R\"),\n            's' => String::from(\"S\"),\n            't' => String::from(\"\
    T\"),\n            'u' => String::from(\"U\"),\n            'v' => String::from(\"\
    V\"),\n            'w' => String::from(\"W\"),\n            'x' => String::from(\"\
    X\"),\n            'y' => String::from(\"Y\"),\n            'z' => String::from(\"\
    Z\"),\n            _ => String::from(\"_\"),\n        }) {\n            reverse(s.chars().collect::<String>())\n\
    \        } else {\n            reverse(s.chars().collect::<String>())\n      \
    \  }\n    } else {\n        reverse(s)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmptnogsvpr.rs:41:13\n\
    \   |\n41 |             reverse(s.chars().collect::<String>())\n   |         \
    \    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `reverse`\
    \ in this scope\n  --> /tmp/tmptnogsvpr.rs:43:13\n   |\n43 |             reverse(s.chars().collect::<String>())\n\
    \   |             ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `reverse` in this scope\n  --> /tmp/tmptnogsvpr.rs:46:9\n   |\n46 |\
    \         reverse(s)\n   |         ^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptnogsvpr.rs:13:20\n   |\n13 |             'a'\
    \ => String::from(\"A\"),\n   |                    ^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found struct `String`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'a' => c.to_ascii_lowercase().rev(),\n\
    \        'A' => c.to_ascii_uppercase().rev(),\n        _ => c,\n    }).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpbrcqh000.rs:12:39\n\
    \   |\n12 |         'a' => c.to_ascii_lowercase().rev(),\n   |               \
    \                        ^^^ `char` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `char: Iterator`\n           which\
    \ is required by `&mut char: Iterator`\n\nerror[E0599]: `char` is not an iterator\n\
    \  --> /tmp/tmpbrcqh000.rs:13:39\n   |\n13 |         'A' => c.to_ascii_uppercase().rev(),\n\
    \   |                                       ^^^ `char` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().enumerate().filter (|(i,c)| {\n        c == 'a' ||\
    \ c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C'\n    }).map (|(i,c)|\
    \ {\n        if c == 'a' || c == 'A' {\n            return c + c.to_uppercase().to_string();\n\
    \        }\n        if c == 'b' || c == 'B' {\n            return c + c.to_lowercase().to_string();\n\
    \        }\n        if c == 'c' || c == 'C' {\n            return c.to_string();\n\
    \        }\n    }).fold(\"\".to_string(), |s, c| s + &c)\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:11\n\
    \   |\n12 |         c == 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c' ||\
    \ c == 'C'\n   |           ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:23\n   |\n12 |         c ==\
    \ 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C'\n   |      \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:35\n   |\n12 |         c == 'a' ||\
    \ c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C'\n   |             \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:47\n   |\n12 |         c == 'a' ||\
    \ c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C'\n   |             \
    \                                  ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:59\n   |\n12 |   \
    \      c == 'a' || c == 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C'\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqeh6t8dd.rs:12:71\n\
    \   |\n12 |         c == 'a' || c == 'A' || c == 'b' || c =="
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.to_string();\n    let mut i = 0;\n    while i\
    \ < s.len() {\n        match s[i] {\n            c @ _ => s[i] = c.to_ascii_uppercase(),\n\
    \            _ => s[i] = c.to_ascii_lowercase(),\n        }\n        i += 1;\n\
    \    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpqrdg4jqa.rs:16:25\n\
    \   |\n16 |             _ => s[i] = c.to_ascii_lowercase(),\n   |            \
    \             ^ help: a local variable with a similar name exists: `i`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqrdg4jqa.rs:14:15\n\
    \   |\n14 |         match s[i] {\n   |               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqrdg4jqa.rs:15:22\n   |\n15 |             c @ _ => s[i] = c.to_ascii_uppercase(),\n\
    \   |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqrdg4jqa.rs:16:18\n\
    \   |\n16 |             _ => s[i] = c.to_ascii_lowercase(),\n   |            \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars = s.chars().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < chars.len() {\n        match chars[i] {\n            'a'\
    \ as char => {\n                if chars.len() > i + 1 {\n                   \
    \ if chars[i + 1] == 'z' {\n                        chars[i] = 'a';\n        \
    \                chars[i + 1] = 'A';\n                    } else if chars[i +\
    \ 1] == 'Z' {\n                        chars[i] = 'A';\n                     \
    \   chars[i + 1] = 'a';\n                    }\n                }\n          \
    \      i += 1;\n            },\n            'A' as char => {\n               \
    \ if chars.len() > i + 1 {\n                    if chars[i + 1] == 'z' {\n   \
    \                     chars[i] = 'A';\n                        chars[i + 1] =\
    \ 'a';\n                    } else if chars[i + 1] == 'Z' {\n                \
    \        chars[i] = 'a';\n                        chars[i + 1] = 'A';\n      \
    \              }\n                }\n                i += 1;\n            },\n\
    \            _ => {\n                i += 1;\n            }\n        }\n    }\n\
    \    chars.iter().map(|c| c.to_string()).collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmp9g9qk7sm.rs:15:17\n   |\n15 |             'a' as char =>\
    \ {\n   |                 ^^ expected one of `...`, `..=`, `..`, `=>`, `if`, or\
    \ `|`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars();\n    \n    while let Some(item) = s.next()\
    \ {\n        if item.is_uppercase() {\n            s = s.map(|c| *c ^ (c as u32).to_string()).collect();\n\
    \        } else if item.is_lowercase() {\n            s = s.map(|c| *c ^ (c as\
    \ u32).to_string()).collect();\n        }\n    }\n    s.collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp_iyu5cdq.rs:15:27\n\
    \   |\n15 |             s = s.map(|c| *c ^ (c as u32).to_string()).collect();\n\
    \   |                           ^^\n\nerror[E0277]: a value of type `Chars<'_>`\
    \ cannot be built from an iterator over elements of type `_`\n    --> /tmp/tmp_iyu5cdq.rs:15:56\n\
    \     |\n15   |             s = s.map(|c| *c ^ (c as u32).to_string()).collect();\n\
    \     |                                                        ^^^^^^^ value of\
    \ type `Chars<'_>` cannot be built from `std::iter::Iterator<Item=_>`\n     |\n\
    \     = help: the trait `FromIterator<_>` is not implemented for `Chars<'_>`\n\
    note: required by a bound in `collect`\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmp_iyu5cdq.rs:17:27\n   |\n17 |             s = s.map(|c|\
    \ *c ^ (c as u32).to_string()).collect();\n   |                           ^^\n\
    \nerror[E0277]: a value of type `Chars<'_>` cannot be built from an iterator over\
    \ elements of type `_`\n    --> /tmp/tmp_iyu5cdq.rs:17:56\n     |\n17   |    \
    \         s = s.map(|c| *c ^ (c as u32).to_string()).collect();\n     |      \
    \                                                  ^^^^^^^ value of type `Chars<'_>`\
    \ cannot be built from `std::iter::Iterator<Item=_>`\n     |\n     = help: the\
    \ trait `FromIterator<_>` is not implemented for `Chars<'_>`\nnote: required by\
    \ a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = s;\n    while !new_s.is_empty()\
    \ {\n        let mut i = new_s.len() - 1;\n        let mut j = new_s.len() - 1;\n\
    \        while i >= 0 && j >= 0 {\n            if new_s[i] == new_s[j] {\n   \
    \             new_s[i..] = new_s[i..].reverse();\n                i -= 1;\n  \
    \              j -= 1;\n            } else {\n                i -= 1;\n      \
    \      }\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp49fn0mha.rs:17:16\n\
    \   |\n17 |             if new_s[i] == new_s[j] {\n   |                ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp49fn0mha.rs:17:28\n   |\n17 |             if new_s[i] == new_s[j]\
    \ {\n   |                            ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for type `str` in\
    \ the current scope\n  --> /tmp/tmp49fn0mha.rs:18:41\n   |\n18 |             \
    \    new_s[i..] = new_s[i..].reverse();\n   |                                \
    \         ^^^^^^^ method not found in `str`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp49fn0mha.rs:18:17\n\
    \   |\n18 |                 new_s[i..] = new_s[i..].reverse();\n   |         \
    \        ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars();\n    s.reverse();\n    let mut res =\
    \ s.collect::<String>();\n    if s.is_empty() {\n        res.reverse();\n    }\n\
    \    res.chars().collect();\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp8cneseez.rs:12:7\n   |\n12 |     s.reverse();\n\
    \   |       ^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `is_empty` found for struct `Chars` in the current scope\n  --> /tmp/tmp8cneseez.rs:14:10\n\
    \   |\n14 |     if s.is_empty() {\n   |          ^^^^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8cneseez.rs:15:13\n   |\n15 |         res.reverse();\n\
    \   |             ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cneseez.rs:10:24\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n17 |     res.chars().collect();\n\
    \   |                          - help: remove this semicolon\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if let Some(c_upper) = (c.to_ascii_uppercase()).chars() {\n           \
    \ if c_upper.len() > 0 {\n                res += c_upper.last().to_string();\n\
    \            }\n        }\n        else {\n            res += c.to_string();\n\
    \        }\n    }\n    if res.is_empty() {\n        res = \"#\".to_string();\n\
    \    }\n    res.to_string()\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdueiis_6.rs:13:57\n   |\n13 |         if let Some(c_upper)\
    \ = (c.to_ascii_uppercase()).chars() {\n   |                                 \
    \                        ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdueiis_6.rs:19:20\n   |\n19 |             res += c.to_string();\n\
    \   |                    ^^^^^^^^^^^^^\n   |                    |\n   |      \
    \              expected `&str`, found struct `String`\n   |                  \
    \  help: consider borrowing here: `&c.to_string()`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\".to_string();\n    }\n\
    \n    let mut res = String::new();\n\n    for c in s.chars() {\n        match\
    \ c.to_ascii_lowercase() {\n            None => continue,\n            Some(c)\
    \ => {\n                if c.is_uppercase() {\n                    res.push((*c).to_ascii_uppercase());\n\
    \                } else {\n                    res.push((*c).to_ascii_lowercase());\n\
    \                }\n            }\n        }\n    }\n\n    res.reverse();\n\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3eu5jfom.rs:19:13\n   |\n\
    18 |         match c.to_ascii_lowercase() {\n   |               ----------------------\
    \ this expression has type `char`\n19 |             None => continue,\n   |  \
    \           ^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3eu5jfom.rs:20:13\n   |\n18 |         match c.to_ascii_lowercase()\
    \ {\n   |               ---------------------- this expression has type `char`\n\
    19 |             None => continue,\n20 |             Some(c) => {\n   |      \
    \       ^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmp3eu5jfom.rs:30:9\n\
    \   |\n30 |     res.reverse();\n   |         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // your code goes here\n    let mut reversed_s = String::new();\n\
    \    let mut s = s.chars().collect::<Vec<char>>();\n    \n    loop {\n       \
    \ if s.len() == 0 {\n            break;\n        }\n        if s.last().unwrap().is_lowercase()\
    \ {\n            s.last_mut().unwrap().to_uppercase();\n        } else {\n   \
    \         s.last_mut().unwrap().to_lowercase();\n        }\n        reversed_s.extend(s.clone());\n\
    \    }\n    reversed_s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n        if c.is_uppercase()\
    \ {\n            s = s.to_lowercase().to_uppercase().to_string();\n        } else\
    \ {\n            s = s.to_lowercase().to_string();\n        }\n    });\n    s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpacgqcf1f.rs:12:24\n   |\n12 |     s.chars().for_each(|c|\
    \ {\n   |     --------- -------- ^^^ mutable borrow occurs here\n   |     |  \
    \       |\n   |     |         immutable borrow later used by call\n   |     immutable\
    \ borrow occurs here\n13 |         if c.is_uppercase() {\n14 |             s =\
    \ s.to_lowercase().to_uppercase().to_string();\n   |             - second borrow\
    \ occurs due to use of `s` in closure\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_alphabetic() || c == '#' {\n    \
    \    c ^ c.to_ascii_lowercase()\n    } else {\n        c ^ c.to_ascii_uppercase()\n\
    \    }).collect::<String>().to_owned()\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmpo3r_bjod.rs:12:11\n\
    \   |\n12 |         c ^ c.to_ascii_lowercase()\n   |         - ^ ----------------------\
    \ char\n   |         |\n   |         char\n\nerror[E0369]: no implementation for\
    \ `char ^ char`\n  --> /tmp/tmpo3r_bjod.rs:14:11\n   |\n14 |         c ^ c.to_ascii_uppercase()\n\
    \   |         - ^ ---------------------- char\n   |         |\n   |         char\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        s\n    } else {\n        match s.chars()\
    \ {\n            [] => s,\n            c => {\n                let i = s.find(|c|\
    \ c.is_letter());\n                if i > 0 {\n                    if i >= s.len()\
    \ - 1 {\n                        s\n                    } else {\n           \
    \             let mut s = \"\";\n                        for i in 0..i + 1 {\n\
    \                            if i != i {\n                                s =\
    \ s.to_string().swapcase() + s.to_string().swapcase();\n                     \
    \       }\n                        }\n                        s\n            \
    \        }\n                } else {\n                    s\n                }\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0529]: expected an array or slice, found `Chars<'_>`\n  --> /tmp/tmp3nakwdyn.rs:15:13\n\
    \   |\n15 |             [] => s,\n   |             ^^ pattern cannot match with\
    \ input type `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3nakwdyn.rs:18:24\n\
    \   |\n18 |                 if i > 0 {\n   |                        ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |                 if i > Some(0) {\n   |                        +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3nakwdyn.rs:19:29\n   |\n\
    19 |                     if i >= s.len() - 1 {\n   |                         \
    \    ^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n19 |                     if i >= Some(s.len() -\
    \ 1) {\n   |                             +++++           +\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmp3nakwdyn.rs:23:39\n   |\n\
    23 |                         for i in 0..i + 1 {\n   |                       \
    \              - ^ - {integer}\n   |                                     |\n \
    \  |                                     Option<usize>\n\nerror[E0599]: no method\
    \ named `swapcase` found for struct `String` in the current scope\n  --> /tmp/tmp3nakwdyn.rs:25:51\n\
    \   |\n25 | ...                   s = s.to_string().swapcase() + s.to_string().swapcase();\n\
    \   |                                         ^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swapcase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp3nakwdyn.rs:25:78\n   |\n25 | ...                   s =\
    \ s.to_string().swapcase() + s.to_string().swapcase();\n   |                 \
    \                                                   ^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3nakwdyn.rs:28:25\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                        -----"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let len = s.len();\n    for i in 0..len\
    \ {\n        if s[i] > 'z' {\n            s = s.chars().map(|c| c as u8 ).collect::<Vec<u8>>().to_string();\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8m84wehx.rs:14:12\n\
    \   |\n14 |         if s[i] > 'z' {\n   |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `Vec<u8>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp8m84wehx.rs:15:66\n    |\n15  |               s = s.chars().map(|c|\
    \ c as u8 ).collect::<Vec<u8>>().to_string();\n    |                         \
    \                                           ^^^^^^^^^ `Vec<u8>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<u8>: std::fmt::Display`\n            which\
    \ is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut new_s: String = s.to_owned();\n    for i in s.chars()\
    \ {\n        let new_i = i as char;\n        if new_i != new_s.chars().next().unwrap()\
    \ {\n            new_s.insert(new_i, new_s.chars().next().unwrap());\n       \
    \ }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_93a7ik7.rs:16:26\n   |\n\
    16 |             new_s.insert(new_i, new_s.chars().next().unwrap());\n   |   \
    \                       ^^^^^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|x| if x.is_alphabetic() || x.is_numeric() {\n\
    \        let y = x.to_lowercase();\n        x.to_lowercase()\n    } else if x.is_alphanumeric()\
    \ {\n        let y = x.to_uppercase();\n        x.to_uppercase()\n    } else if\
    \ x.is_punctuation() {\n        let y = x.to_lowercase();\n        x.to_uppercase()\n\
    \    }\n    else if x.is_empty() {\n        let y = x.to_lowercase();\n      \
    \  x.to_uppercase()\n    }\n    else { x }).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_punctuation` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpdv8mryio.rs:17:17\n   |\n17 |     } else if\
    \ x.is_punctuation() {\n   |                 ^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0599]:\
    \ no method named `is_empty` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpdv8mryio.rs:21:15\n   |\n21 |     else if x.is_empty() {\n   |     \
    \          ^^^^^^^^ method not found in `char`\n\nerror[E0308]: `if` and `else`\
    \ have incompatible types\n  --> /tmp/tmpdv8mryio.rs:25:12\n   |\n21 |       else\
    \ if x.is_empty() {\n   |  __________-\n22 | |         let y = x.to_lowercase();\n\
    23 | |         x.to_uppercase()\n   | |         ---------------- expected because\
    \ of this\n24 | |     }\n25 | |     else { x }).collect::<String>().to_string()\n\
    \   | |____________^_- `if` and `else` have incompatible types\n   |         \
    \     |\n   |              expected struct `ToUppercase`, found `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().collect()\n        .filter_map(|c| {\n          \
    \  if !c.is_alpha() {\n                Some(c.to_ascii_lowercase())\n        \
    \    } else {\n                Some(c.to_ascii_uppercase())\n            }\n \
    \       })\n        .map(|x| x.join())\n        .collect::<Vec<_>>()\n       \
    \ .join();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpkhpath3v.rs:11:15\n\
    \   |\n11 |     s.chars().collect()\n   |               ^^^^^^^ cannot infer type\
    \ for type parameter `B` declared on the associated function `collect`\n   |\n\
    \   = note: type must be known at this point\nhelp: consider specifying the type\
    \ argument in the method call\n   |\n11 |     s.chars().collect::<B>()\n   | \
    \                     +++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkhpath3v.rs:10:24\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_string = s.clone();\n    let mut flag = true;\n\
    \n    for c in s.chars() {\n        if !flag {\n            new_string = new_string.replace_range(c.start(),\
    \ c.end(), c.to_uppercase());\n            flag = true;\n        } else {\n  \
    \          new_string = new_string.replace_range(c.start(), c.end(), c.to_lowercase());\n\
    \            flag = false;\n        }\n    }\n    new_string\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `start` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppy6x0f1o.rs:16:53\n   |\n16 |             new_string =\
    \ new_string.replace_range(c.start(), c.end(), c.to_uppercase());\n   |      \
    \                                               ^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `end` found for type `char` in the current scope\n\
    \  --> /tmp/tmppy6x0f1o.rs:16:64\n   |\n16 |             new_string = new_string.replace_range(c.start(),\
    \ c.end(), c.to_uppercase());\n   |                                          \
    \                      ^^^ method not found in `char`\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmppy6x0f1o.rs:16:37\n\
    \     |\n16   |             new_string = new_string.replace_range(c.start(), c.end(),\
    \ c.to_uppercase());\n     |                                     ^^^^^^^^^^^^^\
    \ ---------  -------  ---------------- supplied 3 arguments\n     |          \
    \                           |\n     |                                     expected\
    \ 2 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppy6x0f1o.rs:16:26\n   |\n11 |     let mut new_string\
    \ = s.clone();\n   |                          --------- expected due to this value\n\
    ...\n16 |             new_string = new_string.replace_range(c.start(), c.end(),\
    \ c.to_uppercase());\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmppy6x0f1o.rs:16:37\n   |\n16 |         \
    \    new_string = new_string.replace_range(c.start(), c.end(), c.to_uppercase());\n\
    \   |                          ---------- ^^^^^^^^^^^^^ this call modifies `new_string`\
    \ in-place\n   |                          |\n   |                          you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `replace_range`\n\nerror[E0599]: no method named\
    \ `start` found for type `char` i"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.to_lowercase();\n    s.chars().for_each(|c| {\n\
    \        if let Some(mut c) = c {\n            let mut lower = false;\n      \
    \      if c.is_lowercase() {\n                lower = true;\n                c\
    \ = c.to_uppercase();\n            } else {\n                c = c.to_lowercase();\n\
    \            }\n            if !s.contains(&c) {\n                s = s.replace(&c,\
    \ &c).to_string();\n                lower = !lower;\n            }\n         \
    \   c = Some(c);\n            c.unwrap().set_not(lower);\n        }\n    });\n\
    \    s.to_string()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbzbz_6r.rs:13:16\n   |\n\
    13 |         if let Some(mut c) = c {\n   |                ^^^^^^^^^^^   - this\
    \ expression has type `char`\n   |                |\n   |                expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // write your code here\n    let mut s = s.replace(\" \",\"\
    \").to_lowercase();\n    let mut result = s.clone();\n    if s.len() > 0 {\n \
    \       if s.chars().any(|c| c.is_ascii_lowercase()) {\n            let mut char\
    \ = s.chars().filter(|c| c.is_ascii_lowercase()).next();\n            let mut\
    \ i = 1;\n            while i < s.len() {\n                if char == None {\n\
    \                    s = s.replace(&s[i], &s[i]);\n                } else {\n\
    \                    let mut j = i;\n                    while j > 0 && j > 0\
    \ {\n                        s = s.remove(&s[j-1],&s[i]);\n                  \
    \      j--;\n                    }\n                    s = s.remove(&i,&s[i]);\n\
    \                    s = s.remove(&char.unwrap(),&s[i]);\n                }\n\
    \                i = i + 1;\n                char = s.chars().filter(|c| c.is_ascii_lowercase()).next();\n\
    \            }\n        } else {\n            let mut char = s.chars().filter(|c|\
    \ !c.is_ascii_lowercase()).next();\n            let mut i = 1;\n            while\
    \ i < s.len() {\n                if char == None {\n                    s = s.replace(&s[i],\
    \ &s[i]);\n                } else {\n                    let mut j = i;\n    \
    \                while j > 0 && j > 0 {\n                        s = s.remove(&s[j-1],&s[i]);\n\
    \                        j--;\n                    }\n                    s =\
    \ s.remove(&i,&s[i]);\n                    s = s.remove(&char.unwrap(),&s[i]);\n\
    \                }\n                i = i + 1;\n                char = s.chars().filter(|c|\
    \ !c.is_ascii_lowercase()).next();\n            }\n        }\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmphfyxhmz_.rs:25:28\n\
    \   |\n25 |                         j--;\n   |                            ^ expected\
    \ expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmphfyxhmz_.rs:43:28\n\
    \   |\n43 |                         j--;\n   |                            ^ expected\
    \ expression\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphfyxhmz_.rs:20:36\n   |\n20 |                     s = s.replace(&s[i],\
    \ &s[i]);\n   |                                    ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphfyxhmz_.rs:20:43\n   |\n20 |                     s = s.replace(&s[i],\
    \ &s[i]);\n   |                                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphfyxhmz_.rs:24:39\n   |\n24 |                         s = s.remove(&s[j-1],&s[i]);\n\
    \   |                                       ^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not i"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() { return \"\"; }\n    let mut chars = s.chars().collect::<Vec<_>>();\n\
    \    chars.sort();\n    chars.reverse();\n    chars.dedup();\n    chars.iter().map(|&x|\
    \ x.to_ascii_lowercase()).collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0sbn4twk.rs:11:30\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() { return \"\"; }\n\
    \   |                              ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut s = s.chars();\n\
    \    while let Some(first) = s.next() {\n        match first {\n            c\
    \ if c.is_alpha() => res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n\
    \            _ => res.push(c),\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpa2774spq.rs:16:27\n\
    \   |\n16 |             _ => res.push(c),\n   |                           ^ help:\
    \ a local variable with a similar name exists: `s`\n\nerror[E0599]: no method\
    \ named `is_alpha` found for type `char` in the current scope\n  --> /tmp/tmpa2774spq.rs:15:20\n\
    \   |\n15 |             c if c.is_alpha() => res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n\
    \   |                    ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_alphabetic`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpa2774spq.rs:15:44\n   |\n15 |             c if c.is_alpha() =>\
    \ res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n \
    \  |                                            ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpa2774spq.rs:15:70\n   |\n\
    15 |             c if c.is_alpha() => res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n\
    \   |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: a value of type `char` cannot be built from an iterator over elements\
    \ of type `_`\n    --> /tmp/tmpa2774spq.rs:15:95\n     |\n15   |             c\
    \ if c.is_alpha() => res.push((*c.to_ascii_lowercase()..=*c.to_ascii_uppercase()).collect()),\n\
    \     |                                                                      \
    \                         ^^^^^^^ value of type `char` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `char`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425, E0599, E0614.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    for i in s.chars().filter(|x| x.is_letter())\
    \ {\n        if i.is_uppercase() {\n            s = s.to_uppercase() + &s[i..].to_string();\n\
    \        } else {\n            s = s.to_lowercase() + &s[i..].to_string();\n \
    \       }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpdygeec9p.rs:12:37\n   |\n12 |     for i in\
    \ s.chars().filter(|x| x.is_letter()) {\n   |                                \
    \     ^^^^^^^^^ method not found in `&char`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `RangeFrom<char>`\n  --> /tmp/tmpdygeec9p.rs:14:37\n  \
    \ |\n14 |             s = s.to_uppercase() + &s[i..].to_string();\n   |      \
    \                               ^^^^^^ `String` cannot be indexed by `RangeFrom<char>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<char>`\n\
    \  --> /tmp/tmpdygeec9p.rs:16:37\n   |\n16 |             s = s.to_lowercase()\
    \ + &s[i..].to_string();\n   |                                     ^^^^^^ `String`\
    \ cannot be indexed by `RangeFrom<char>`\n   |\n   = help: the trait `Index<RangeFrom<char>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|x| if is_letter(x.to_lowercase()) \n\t\t   \
    \ then x.to_uppercase()\n\t\t    else x.to_lowercase()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp_dyr4l2c.rs:12:7\n   |\n\
    11 |     s.chars().map(|x| if is_letter(x.to_lowercase()) \n   |             \
    \          -- this `if` expression has a condition, but no block\n12 |       \
    \      then x.to_uppercase()\n   |             ^^^^ expected `{`\n   |\nhelp:\
    \ try placing this code inside a block\n   |\n12 |             { then } x.to_uppercase()\n\
    \   |             +      +\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s.clone();\n    }\n    if\
    \ let Some(first) = s.chars().next()? {\n        let mut c = first;\n        for\
    \ c in s.chars().skip_while(|c| !c.is_ascii() || c.is_ascii_letter()) {\n    \
    \        let mut v = c.to_ascii_lowercase();\n            if let Some(first) =\
    \ c.to_ascii_uppercase().clone() {\n                v = v.to_ascii_uppercase();\n\
    \            }\n            c.write_to(&mut v)?;\n        }\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmp6s1guexx.rs:14:42\n   |\n10 | / fn solve(s: String) -> String {\n11\
    \ | |     if s.is_empty() {\n12 | |         return s.clone();\n13 | |     }\n\
    14 | |     if let Some(first) = s.chars().next()? {\n   | |                  \
    \                        ^ cannot use the `?` operator in a function that returns\
    \ `String`\n...  |\n24 | |     s\n25 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6s1guexx.rs:14:12\n\
    \   |\n14 |     if let Some(first) = s.chars().next()? {\n   |            ^^^^^^^^^^^\
    \   ----------------- this expression has type `char`\n   |            |\n   |\
    \            expected `char`, found enum `Option`\n   |\n   = note: expected type\
    \ `char`\n              found enum `Option<_>`\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for reference `&char` in the current scope\n  --> /tmp/tmp6s1guexx.rs:16:62\n\
    \   |\n16 |         for c in s.chars().skip_while(|c| !c.is_ascii() || c.is_ascii_letter())\
    \ {\n   |                                                              ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6s1guexx.rs:18:20\n   |\n18 |             if\
    \ let Some(first) = c.to_ascii_uppercase().clone() {\n   |                   \
    \ ^^^^^^^^^^^   ------------------------------ this expression has type `char`\n\
    \   |                    |\n   |                    expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0599]: no method named `write_to` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6s1guexx.rs:21:15\n   |\n21 |             c.write_to(&mut\
    \ v)?;\n   |               ^^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a fun"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c.is_alphanumeric() || c.is_ascii_letter())\n\
    \        .map(|c| if c.is_ascii_letter() || c.is_ascii_uppercase() {\n       \
    \     c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        })\n        .collect()\n        .join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp55n2f0rj.rs:12:46\n   |\n12 |         .filter(|c|\
    \ c.is_alphanumeric() || c.is_ascii_letter())\n   |                          \
    \                    ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp55n2f0rj.rs:13:23\n\
    \   |\n13 |         .map(|c| if c.is_ascii_letter() || c.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.len() == 0 {\n        return s\n    }\n    let mut reversed:\
    \ String = \"\".to_string();\n    let mut has_letter = false;\n    for ch in s.chars()\
    \ {\n        if let Some(_) = ch.to_ascii_lowercase() {\n            has_letter\
    \ = true;\n            reversed.push_str(ch.to_ascii_uppercase());\n        }\n\
    \        else {\n            reversed.push_str(ch.to_string());\n        }\n \
    \   }\n    if !has_letter {\n        reversed.reverse();\n    }\n    reversed\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpys16d65o.rs:17:16\n   |\n\
    17 |         if let Some(_) = ch.to_ascii_lowercase() {\n   |                ^^^^^^^\
    \   ----------------------- this expression has type `char`\n   |            \
    \    |\n   |                expected `char`, found enum `Option`\n   |\n   = note:\
    \ expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpys16d65o.rs:19:31\n   |\n19 |             reversed.push_str(ch.to_ascii_uppercase());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpys16d65o.rs:22:31\n\
    \   |\n22 |             reversed.push_str(ch.to_string());\n   |             \
    \                  ^^^^^^^^^^^^^^\n   |                               |\n   |\
    \                               expected `&str`, found struct `String`\n   | \
    \                              help: consider borrowing here: `&ch.to_string()`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpys16d65o.rs:26:18\n   |\n26 |         reversed.reverse();\n\
    \   |                  ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c| match c {\n            'a' => c,\n\
    \            'b' => c,\n            'c' => c,\n            'd' => c,\n       \
    \     'e' => c,\n            'f' => c,\n            'g' => c,\n            'h'\
    \ => c,\n            'i' => c,\n            'j' => c,\n            'k' => c,\n\
    \            'l' => c,\n            'm' => c,\n            'n' => c,\n       \
    \     'o' => c,\n            'p' => c,\n            'q' => c,\n            'r'\
    \ => c,\n            's' => c,\n            't' => c,\n            'u' => c,\n\
    \            'v' => c,\n            'w' => c,\n            'x' => c,\n       \
    \     'y' => c,\n            'z' => c,\n            _ => c,\n        })\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"AsDf\"`,\n right: `\"aSdF\"`', /tmp/tmp39lgzlfm.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::with_capacity(s.size());\n    for ch\
    \ in s.chars() {\n        if let Some(ascii_ch) = char::to_ascii_lowercase(ch)\
    \ {\n            res.push_str(&ascii_ch);\n        } else {\n            res.push_str(&ch);\n\
    \        }\n    }\n    solve(&res)\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbsrbf4xo.rs:11:43\n   |\n11 |     let mut res = String::with_capacity(s.size());\n\
    \   |                                           ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbsrbf4xo.rs:13:58\n   |\n13 |\
    \         if let Some(ascii_ch) = char::to_ascii_lowercase(ch) {\n   |       \
    \                                                   ^^\n   |                 \
    \                                         |\n   |                            \
    \                              expected `&char`, found `char`\n   |          \
    \                                                help: consider borrowing here:\
    \ `&ch`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbsrbf4xo.rs:13:16\n \
    \  |\n13 |         if let Some(ascii_ch) = char::to_ascii_lowercase(ch) {\n  \
    \ |                ^^^^^^^^^^^^^^   ---------------------------- this expression\
    \ has type `char`\n   |                |\n   |                expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<_>`\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n  --> /tmp/tmpbsrbf4xo.rs:13:21\n   |\n13 |     \
    \    if let Some(ascii_ch) = char::to_ascii_lowercase(ch) {\n   |            \
    \         ^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmpbsrbf4xo.rs:13:16\n    |\n13  |  \
    \       if let Some(ascii_ch) = char::to_ascii_lowercase(ch) {\n    |        \
    \        ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n   \
    \ = help: the trait `Sized` is not implemented for `str`\nnote: required by a\
    \ bound in `Some`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbsrbf4xo.rs:16:26\n\
    \   |\n16 |             res.push_str(&ch);\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut rev = s.chars().fold(String::new(), |mut acc, c| {\n\
    \        if c.is_lowercase() {\n            acc.push((*c).to_uppercase());\n \
    \           acc.push((*c).to_lowercase());\n        } else {\n            acc.push(c);\n\
    \        }\n        acc\n    });\n    rev.push(b'\\0');\n    rev\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt00gv9s4.rs:13:22\n\
    \   |\n13 |             acc.push((*c).to_uppercase());\n   |                 \
    \     ^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt00gv9s4.rs:14:22\n\
    \   |\n14 |             acc.push((*c).to_lowercase());\n   |                 \
    \     ^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt00gv9s4.rs:20:14\n\
    \   |\n20 |     rev.push(b'\\0');\n   |              ^^^^^ expected `char`, found\
    \ `u8`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = s.to_string();\n    let mut result = s.clone();\n\
    \n    for i in 0..str.len() {\n        if str.chars().any(|c| c.is_alpha()) {\n\
    \            if let Some(mut i) = str.chars().find(|c| c.is_alpha()) {\n     \
    \           if str[i] = 'A' {\n                    str[i] = 'a';\n           \
    \     } else if str[i] = 'a' {\n                    str[i] = 'A';\n          \
    \      }\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_alpha` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp9jxqagl0.rs:15:34\n   |\n15 |         if str.chars().any(|c|\
    \ c.is_alpha()) {\n   |                                  ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_alphabetic`\n\nerror[E0599]:\
    \ no method named `is_alpha` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp9jxqagl0.rs:16:57\n   |\n16 |             if let Some(mut i) =\
    \ str.chars().find(|c| c.is_alpha()) {\n   |                                 \
    \                        ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_alphabetic`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9jxqagl0.rs:17:20\n\
    \   |\n17 |                 if str[i] = 'A' {\n   |                    ^^^^^^^^^^^^\
    \ expected `bool`, found `()`\n   |\nhelp: you might have meant to compare for\
    \ equality\n   |\n17 |                 if str[i] == 'A' {\n   |              \
    \             ~~\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n\
    \  --> /tmp/tmp9jxqagl0.rs:17:20\n   |\n17 |                 if str[i] = 'A' {\n\
    \   |                    ^^^^^^ `String` cannot be indexed by `char`\n   |\n \
    \  = help: the trait `Index<char>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `char`\n  --> /tmp/tmp9jxqagl0.rs:18:21\n\
    \   |\n18 |                     str[i] = 'a';\n   |                     ^^^^^^\
    \ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as I"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(String::new(), |mut acc, c| {\n        if c.is_ascii_uppercase()\
    \ {\n            *acc += c.to_ascii_lowercase()\n        } else {\n          \
    \  *acc += c\n        }\n    })\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `str`\n  --> /tmp/tmpgiep6130.rs:13:13\n   |\n13 |             *acc += c.to_ascii_lowercase()\n\
    \   |             ----^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   |   \
    \          cannot use `+=` on type `str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `str`\n  --> /tmp/tmpgiep6130.rs:15:13\n   |\n\
    15 |             *acc += c\n   |             ----^^^^^\n   |             |\n \
    \  |             cannot use `+=` on type `str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    if s.is_empty() {\n        return s;\n\
    \    }\n    let mut chars = s.chars();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_letter() {\n            if c.is_lowercase() {\n             \
    \   s = s.chars().collect::<String>().rev().collect::<String>() \n           \
    \         + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\
    \ \n                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            } else if c.is_uppercase() {\n                s = s.chars().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            } else {\n                s = s.chars().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            }\n        } else if c.is_digit() {\n            let s = String::from(&s);\n\
    \            let s = s.chars().collect::<String>().rev().collect::<String>() \n\
    \                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\
    \ \n                    + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \            return String::from(&s)\n        }\n    }\n    return s\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `return`\n  --> /tmp/tmp265ur0cq.rs:35:98\n\
    \   |\n35 |                     + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \   |                                                                        \
    \                          ^ help: add `;` here\n36 |             return String::from(&s)\n\
    \   |             ------ unexpected token\n\nerror[E0599]: no method named `is_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp265ur0cq.rs:17:14\n\
    \   |\n17 |         if c.is_letter() {\n   |              ^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmp265ur0cq.rs:19:51\n\
    \    |\n19  |                   s = s.chars().collect::<String>().rev().collect::<String>()\
    \ \n    |                                                     ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp265ur0cq.rs:20:53\n    |\n20  |         \
    \              + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\
    \ \n    |                                                       ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmp265ur0cq.rs:21:53\n    |\n21  |         \
    \              + s.chars().collect::<String>().collect::<String>().rev().collect::<String>()\n\
    \    |                                                       ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait b"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut res = \"\";\n    for ch in s.chars()\
    \ {\n        if ch.is_ascii_letter() {\n            if ch.to_ascii_lowercase()\
    \ == ch {\n                res += ch.to_ascii_uppercase();\n            } else\
    \ {\n                res += ch.to_ascii_lowercase();\n            }\n        }\
    \ else {\n            res += ch;\n        }\n    }\n    if res == \"\" {\n   \
    \     res = s.clone();\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpt8_38dih.rs:14:15\n   |\n14 |         if ch.is_ascii_letter()\
    \ {\n   |               ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpt8_38dih.rs:16:17\n   |\n\
    16 |                 res += ch.to_ascii_uppercase();\n   |                 ---^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpt8_38dih.rs:18:17\n   |\n18 |                 res += ch.to_ascii_lowercase();\n\
    \   |                 ---^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                 |\n\
    \   |                 cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpt8_38dih.rs:21:13\n\
    \   |\n21 |             res += ch;\n   |             ---^^^^^^\n   |         \
    \    |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt8_38dih.rs:25:15\n   |\n12 |     let mut res = \"\";\n\
    \   |                   -- expected due to this value\n...\n25 |         res =\
    \ s.clone();\n   |               ^^^^^^^^^\n   |               |\n   |       \
    \        expected `&str`, found struct `String`\n   |               help: consider\
    \ borrowing here: `&s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt8_38dih.rs:27:12\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                        ------\
    \ expected `String` because of return type\n...\n27 |     return res;\n   |  \
    \          ^^^- help: try using a conversion method: `.to_string()`\n   |    \
    \        |\n   |            expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    if s.is_empty() {\n        return s;\n    }\n    \n \
    \   \n    let mut reversed = String::new();\n    \n    let mut first_character\
    \ = s.chars().next().unwrap();\n    \n    match first_character.to_ascii_lowercase()\
    \ {\n        None => (),\n        Some('a') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some('z') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some(' ') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        Some('0'..='9') => {\n            reversed.push(first_character.to_string());\n\
    \        },\n        _ => {\n            reversed.push(\"\\\"\");\n          \
    \  reversed.push(\"\\\\\");\n            reversed.push(first_character.to_string());\n\
    \        }\n    }\n    \n    let mut second_character = s.chars().next().unwrap();\n\
    \    \n    match second_character.to_ascii_lowercase() {\n        None => (),\n\
    \        Some('a') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some('z') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some(' ') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        Some('0'..='9') => {\n            reversed.push(second_character.to_string());\n\
    \        },\n        _ => {\n            reversed.push(\"\\\"\");\n          \
    \  reversed.push(\"\\\\\");\n            reversed.push(second_character.to_string());\n\
    \        }\n    }\n    \n    reversed.reverse();\n    reversed\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpimjcnars.rs:22:9\n   |\n\
    21 |     match first_character.to_ascii_lowercase() {\n   |           ------------------------------------\
    \ this expression has type `char`\n22 |         None => (),\n   |         ^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpimjcnars.rs:23:9\n   |\n21 |     match first_character.to_ascii_lowercase()\
    \ {\n   |           ------------------------------------ this expression has type\
    \ `char`\n22 |         None => (),\n23 |         Some('a') => {\n   |        \
    \ ^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected type\
    \ `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpimjcnars.rs:26:9\n   |\n21 |     match first_character.to_ascii_lowercase()\
    \ {\n   |           ------------------------------------ this expression has type\
    \ `char`\n...\n26 |         Some('z') => {\n   |         ^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpimjcnars.rs:29:9\n\
    \   |\n21 |     match first_character.to_ascii_lowercase() {\n   |           ------------------------------------\
    \ this expression has type `char`\n...\n29 |         Some(' ') => {\n   |    \
    \     ^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpimjcnars.rs:32:9\n   |\n21 |     match first_character.to_ascii_lowercase()\
    \ {\n   |           ------------------------------------ this expression has type\
    \ `char`\n...\n32 |         Some('0'..='9') => {\n   |         ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpimjcnars.rs:24:27\n   |\n24 |             reversed.push(first_character.to_string());\n\
    \   |                           ^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    solve(&s)\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_j8j274h.rs:11:11\n   |\n\
    11 |     solve(&s)\n   |           ^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n11 -     solve(&s)\n11 +    \
    \ solve(s)\n   | \n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_uppercase() {\n            result.push_str(c.to_lowercase());\n\
    \        } else {\n            result.push_str(c);\n        }\n    }\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmporljpyh4.rs:14:29\n   |\n\
    14 |             result.push_str(c.to_lowercase());\n   |                    \
    \         ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmporljpyh4.rs:16:29\n   |\n16 |             result.push_str(c);\n\
    \   |                             ^ expected `&str`, found `char`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmporljpyh4.rs:19:12\n   |\n19 |     result.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = s.to_string();\n    if s.chars().count() == 0\
    \ {\n        return res;\n    }\n    for i in s.chars() {\n        if i.is_letter()\
    \ {\n            if !res.contains(i.to_string().to_string()) {\n             \
    \   res = res.replace(i.to_string(), i.to_ascii_uppercase());\n            } else\
    \ {\n                res = res.replace(i.to_string(), i.to_ascii_lowercase());\n\
    \            }\n        } else {\n            res = res.replace(i.to_string(),\
    \ i.to_string());\n        }\n    }\n    return res.to_string();\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz_i0dir9.rs:16:14\n   |\n16 |         if i.is_letter()\
    \ {\n   |              ^^^^^^^^^ method not found in `char`\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpz_i0dir9.rs:17:30\n\
    \     |\n17   |             if !res.contains(i.to_string().to_string()) {\n  \
    \   |                     -------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                     |\n     |               \
    \      required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider borrowing here\n\
    \     |\n17   |             if !res.contains(&i.to_string().to_string()) {\n \
    \    |                              +\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n   --> /tmp/tmpz_i0dir9.rs:18:27\n    |\n18  |    \
    \             res = res.replace(i.to_string(), i.to_ascii_uppercase());\n    |\
    \                           ^^^^^^^ expected an `FnMut<(char,)>` closure, found\
    \ `String`\n    |\n    = help: the trait `FnMut<(char,)>` is not implemented for\
    \ `String`\n    = help: the following other types implement trait `Pattern<'a>`:\n\
    \              &'b String\n              &'b str\n              &'c &'b str\n\
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz_i0dir9.rs:18:50\n   |\n18 |              \
    \   res = res.replace(i.to_string(), i.to_ascii_uppercase());\n   |          \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \   --> /tmp/tmpz_i0dir9.rs:20:27\n    |\n20  |                 res = res.replace(i.to_string(),\
    \ i.to_ascii_lowercase());\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s\n    }\n\n    let mut s\
    \ = s.to_string();\n\n    for &c in s.chars() {\n        match c {\n         \
    \   'A' => s.swapcase(),\n            'a' => s.swapcase(),\n            '#' =>\
    \ s.swapcase(),\n            _ => (),\n        }\n    }\n\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbf6imj4q.rs:17:9\n   |\n\
    17 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpbf6imj4q.rs:19:22\n   |\n19 |             'A' => s.swapcase(),\n\
    \   |                      ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpbf6imj4q.rs:20:22\n   |\n20 |             'a' => s.swapcase(),\n\
    \   |                      ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpbf6imj4q.rs:21:22\n   |\n21 |             '#' => s.swapcase(),\n\
    \   |                      ^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\"\n    }\n    if s.chars().any(|c|\
    \ c.is_letter()) {\n        solve(s.chars().map(|c| if c.is_lower() c else c.to_upper()).collect::<String>())\n\
    \    } else {\n        solve(s.chars().map(|c| c.to_ascii_lowercase()).collect::<String>())\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `c`\n  --> /tmp/tmp_bcbpyu5.rs:15:49\n   |\n\
    15 |         solve(s.chars().map(|c| if c.is_lower() c else c.to_upper()).collect::<String>())\n\
    \   |                                 --              ^ expected `{`\n   |   \
    \                              |\n   |                                 this `if`\
    \ expression has a condition, but no block\n   |\nhelp: try placing this code\
    \ inside a block\n   |\n15 |         solve(s.chars().map(|c| if c.is_lower() {\
    \ c } else c.to_upper()).collect::<String>())\n   |                          \
    \                       +   +\n\nerror: expected one of `.`, `;`, `?`, `}`, or\
    \ an operator, found `)`\n  --> /tmp/tmp_bcbpyu5.rs:15:89\n   |\n15 |        \
    \ solve(s.chars().map(|c| if c.is_lower() c else c.to_upper()).collect::<String>())\n\
    \   |                                                                        \
    \                 ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_bcbpyu5.rs:12:16\n   |\n10 | fn solve(s: String)\
    \ -> String {\n   |                        ------ expected `String` because of\
    \ return type\n11 |     if s.is_empty() {\n12 |         return \"\"\n   |    \
    \            ^^- help: try using a conversion method: `.to_string()`\n   |   \
    \             |\n   |                expected struct `String`, found `&str`\n\n\
    error[E0599]: no method named `is_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_bcbpyu5.rs:14:28\n   |\n14 |     if s.chars().any(|c|\
    \ c.is_letter()) {\n   |                            ^^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|x|\n        match (x.to_ascii_lowercase(), x.to_ascii_uppercase())\
    \ {\n            (Some(lower), Some(upper)) => \n                match match s.chars().find(|y|\
    \ y.to_ascii_lowercase() == lower || y.to_ascii_uppercase() == upper) {\n    \
    \                None => x,\n                    Some(other) => other.to_ascii_lowercase()\
    \ + x.to_ascii_lowercase(),\n                },\n            (None, Some(other))\
    \ => other.to_ascii_uppercase() + x.to_ascii_uppercase(),\n            (Some(lower),\
    \ None) => x.to_ascii_lowercase() + other.to_ascii_uppercase(),\n            (None,\
    \ Some(_)) => x.to_ascii_uppercase() + other.to_ascii_lowercase(),\n        }\n\
    \    ).collect::<String>().to_string()\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `,`\n  -->\
    \ /tmp/tmpnl9sakcp.rs:17:18\n   |\n13 |             (Some(lower), Some(upper))\
    \ => \n   |                                        -- while parsing the `match`\
    \ arm starting here\n14 |                 match match s.chars().find(|y| y.to_ascii_lowercase()\
    \ == lower || y.to_ascii_uppercase() == upper) {\n   |                 ----- while\
    \ parsing this `match` expression\n...\n17 |                 },\n   |        \
    \          ^ expected one of `.`, `?`, `{`, or an operator\n\nerror[E0277]: a\
    \ value of type `String` cannot be built from an iterator over elements of type\
    \ `()`\n    --> /tmp/tmpnl9sakcp.rs:22:7\n     |\n22   |     ).collect::<String>().to_string()\n\
    \     |       ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=()>`\n\
    \     |\n     = help: the trait `FromIterator<()>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new: String = s;\n    let mut len = s.len();\n\n  \
    \  while len > 0 {\n        if s[len - 1] == &'a' || s[len - 1] == &'A' {\n  \
    \          new.push(s[len - 2]);\n            new.push(s[len - 1]);\n        \
    \    new.pop();\n            new.pop();\n            len -= 2;\n        } else\
    \ {\n            new.push(s[len - 2]);\n            len -= 2;\n        }\n   \
    \ }\n    new.reverse();\n    new\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq4s_av76.rs:15:12\n\
    \   |\n15 |         if s[len - 1] == &'a' || s[len - 1] == &'A' {\n   |      \
    \      ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq4s_av76.rs:15:34\n   |\n15 |         if s[len - 1] == &'a' ||\
    \ s[len - 1] == &'A' {\n   |                                  ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq4s_av76.rs:16:22\n   |\n16 |             new.push(s[len - 2]);\n\
    \   |                      ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<st"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        \"\"\n    } else {\n        let\
    \ mut result = String::new();\n        for c in s.chars() {\n            if c.is_ascii_lowercase()\
    \ {\n                result.push_str(c.to_ascii_uppercase());\n            } else\
    \ if c.is_ascii_uppercase() {\n                result.push_str(c.to_ascii_lowercase());\n\
    \            } else {\n                result.push_str(c);\n            }\n  \
    \      }\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8c6r8uut.rs:12:9\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         \"\
    \"\n   |         ^^- help: try using a conversion method: `.to_string()`\n   |\
    \         |\n   |         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8c6r8uut.rs:17:33\n   |\n17 |              \
    \   result.push_str(c.to_ascii_uppercase());\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8c6r8uut.rs:19:33\n   |\n19 |                 result.push_str(c.to_ascii_lowercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8c6r8uut.rs:21:33\n\
    \   |\n21 |                 result.push_str(c);\n   |                        \
    \         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s\n    }\n    let mut new_s\
    \ = s;\n    for i in s.chars() {\n        match i {\n            c if c.is_uppercase()\
    \ => new_s = new_s.to_ascii_uppercase().to_string(),\n            c if c.is_lowercase()\
    \ => new_s = new_s.to_ascii_lowercase().to_string(),\n            _ => new_s =\
    \ i\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8gna3dm.rs:19:26\n   |\n\
    14 |     let mut new_s = s;\n   |                     - expected due to this value\n\
    ...\n19 |             _ => new_s = i\n   |                          ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |                          expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut result = String::new();\n\n   \
    \ for (i, _) in s.chars().enumerate() {\n        if s.chars().skip(i).any(|c|\
    \ !ascii_lowercase().contains(&c)) {\n            s.push_str(&s.chars().reverse().collect::<String>());\n\
    \            s.push_str(&String::from(ascii_lowercase()[s.len() - i]));\n    \
    \    }\n    }\n    result.push_str(&s);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ascii_lowercase` in this scope\n  -->\
    \ /tmp/tmpgn9uspqk.rs:15:39\n   |\n15 |         if s.chars().skip(i).any(|c| !ascii_lowercase().contains(&c))\
    \ {\n   |                                       ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `ascii_lowercase` in this scope\n\
    \  --> /tmp/tmpgn9uspqk.rs:17:38\n   |\n17 |             s.push_str(&String::from(ascii_lowercase()[s.len()\
    \ - i]));\n   |                                      ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `reverse` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpgn9uspqk.rs:16:35\n   |\n16 |          \
    \   s.push_str(&s.chars().reverse().collect::<String>());\n   |              \
    \                     ^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().filter(|x| x.is_alphanumeric()).map(|x| x.to_ascii_lowercase()).collect::<Vec<_>>().reverse()\n\
    \        .concat()\n        .chars().filter(|x| x.is_alphanumeric()).map(|x| x.to_ascii_uppercase()).collect::<Vec<_>>()\n\
    \        .concat()\n        .concat()\n        .collect::<Vec<_>>()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `concat` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpwpiwxd2n.rs:12:10\n   |\n12 |         .concat()\n\
    \   |          ^^^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"#\";\n    }\n    let mut\
    \ s = String::from(s);\n    for i in 0..s.len() {\n        if let Some(m) = s.chars().position(|c|\
    \ c == i) {\n            swap(s, i, m);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp62mbi3kx.rs:17:13\n\
    \   |\n17 |             swap(s, i, m);\n   |             ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp62mbi3kx.rs:12:16\n   |\n10 | fn solve(s: String) -> String {\n   |\
    \                        ------ expected `String` because of return type\n11 |\
    \     if s.is_empty() {\n12 |         return \"#\";\n   |                ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp62mbi3kx.rs:16:54\n   |\n16 |         if let Some(m) =\
    \ s.chars().position(|c| c == i) {\n   |                                     \
    \                 ^ expected `char`, found `usize`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().filter(|c|\n        match c.to_ascii_lowercase()\
    \ {\n            Some(a) => a == c.to_ascii_uppercase(),\n            _ => false,\n\
    \        }\n    ).fold(String::new(), |accum, ch| {\n        accum.append(if ch.to_ascii_lowercase()\
    \ == ch.to_ascii_uppercase() {\n            ch.to_ascii_lowercase()\n        }\
    \ else {\n            ch.to_ascii_uppercase()\n        })\n        accum\n   \
    \ })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `accum`\n  --> /tmp/tmpfdyy3szf.rs:21:11\n \
    \  |\n21 |         })\n   |           ^ help: add `;` here\n22 |         accum\n\
    \   |         ----- unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfdyy3szf.rs:13:13\n   |\n12 |         match c.to_ascii_lowercase() {\n\
    \   |               ---------------------- this expression has type `char`\n13\
    \ |             Some(a) => a == c.to_ascii_uppercase(),\n   |             ^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpfdyy3szf.rs:17:15\n\
    \   |\n17 |         accum.append(if ch.to_ascii_lowercase() == ch.to_ascii_uppercase()\
    \ {\n   |               ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().filter(|&c| c == 'a' || c ==\
    \ 'A' || c == 'b' || c == 'B' || c == 'c' || c == 'C' || c == 'd' || c == 'D'\
    \ || c == 'e' || c == 'E' || c == 'f' || c == 'F' || c == 'g' || c == 'G' || c\
    \ == 'h' || c == 'H' || c == 'i' || c == 'I' || c == 'j' || c == 'J' || c == 'k'\
    \ || c == 'K' || c == 'l' || c == 'L' || c == 'm' || c == 'M' || c == 'n' || c\
    \ == 'N' || c == 'o' || c == 'O' || c == 'p' || c == 'P' || c == 'q' || c == 'Q'\
    \ || c == 'r' || c == 'R' || c == 's' || c == 'S' || c == 't' || c == 'T' || c\
    \ == 'u' || c == 'U' || c == 'v' || c == 'V' || c == 'w' || c == 'W' || c == 'x'\
    \ || c == 'X' || c == 'y' || c == 'Y' || c == 'z' || c == 'Z').for_each(|c| {\
    \ \n        s = s.to_string().chars().rev().collect();\n    });\n    \n    if\
    \ s.is_empty() {\n        return s;\n    }\n    \n    return s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `c`\n  --> /tmp/tmpxv738xy6.rs:12:659\n   |\n\
    12 | ...| c == 'z' || c == 'Z').for_each(|c| { \n   |                        \
    \              ^ help: if this is intentional, prefix it with an underscore: `_c`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot\
    \ borrow `s` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpxv738xy6.rs:12:658\n\
    \   |\n12 |     s.chars().filter(|&c| c == 'a' || c == 'A' || c == 'b' || c ==\
    \ 'B' || c == 'c' || c == 'C' || c == 'd' || c == 'D' || c == 'e' || c == 'E'\
    \ || c == 'f' || c == 'F' || c == 'g' || c == 'G' || c == 'h' || c == 'H' || c\
    \ == 'i' || c == 'I' || c == 'j' || c == 'J' || c == 'k' || c == 'K' || c == 'l'\
    \ || c == 'L' || c == 'm' || c == 'M' || c == 'n' || c == 'N' || c == 'o' || c\
    \ == 'O' || c == 'p' || c == 'P' || c == 'q' || c == 'Q' || c == 'r' || c == 'R'\
    \ || c == 's' || c == 'S' || c == 't' || c == 'T' || c == 'u' || c == 'U' || c\
    \ == 'v' || c == 'V' || c == 'w' || c == 'W' || c == 'x' || c == 'X' || c == 'y'\
    \ || c == 'Y' || c == 'z' || c == 'Z').for_each(|c|...\n   |     ---------   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                        -------- ^^^ mutable borrow occurs here\n   |     | \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut res = String::new();\n    let mut\
    \ i = 0;\n    loop {\n        match s.chars().nth(i) {\n            Some('a')|\
    \ Some('b')| Some('c')| Some('d')| Some('e')| Some('f') |\n            Some('g')|\
    \ Some('h')| Some('i')| Some('j')| Some('k')| Some('l')|\n            Some('m')|\
    \ Some('n')| Some('o')| Some('p')| Some('q')| Some('r')|\n            Some('s')|\
    \ Some('t')| Some('u')| Some('v')| Some('w')| Some('x')|\n            Some('y')|\
    \ Some('z')| Some('_')=> {\n                res += &s[..i];\n                res\
    \ += &String::from(\"A\") + &s[..i];\n                i += 2;\n            }\n\
    \            Some('0')| Some('1')| Some('2')| Some('3')| Some('4')| Some('5')|\n\
    \            Some('6')| Some('7')| Some('8')| Some('9')=> {\n                res\
    \ += &s[..i];\n                res += &String::from(\"a\") + &s[..i];\n      \
    \          i += 2;\n            }\n            _=> {\n                res += &s[..i];\n\
    \                i += 1;\n            }\n        }\n    }\n    res \n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&str` to `&String`\n  --> /tmp/tmpxcz_entl.rs:22:43\n\
    \   |\n22 |                 res += &String::from(\"A\") + &s[..i];\n   |     \
    \                   ------------------ ^ ------- &str\n   |                  \
    \      |                  |\n   |                        |                  `+`\
    \ cannot be used to concatenate two `&str` strings\n   |                     \
    \   &String\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: remove the borrow to obtain an owned `String`\n   |\n22 -\
    \                 res += &String::from(\"A\") + &s[..i];\n22 +               \
    \  res += String::from(\"A\") + &s[..i];\n   | \n\nerror[E0369]: cannot add `&str`\
    \ to `&String`\n  --> /tmp/tmpxcz_entl.rs:28:43\n   |\n28 |                 res\
    \ += &String::from(\"a\") + &s[..i];\n   |                        ------------------\
    \ ^ ------- &str\n   |                        |                  |\n   |     \
    \                   |                  `+` cannot be used to concatenate two `&str`\
    \ strings\n   |                        &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: remove the borrow to obtain an\
    \ owned `String`\n   |\n28 -                 res += &String::from(\"a\") + &s[..i];\n\
    28 +                 res += String::from(\"a\") + &s[..i];\n   | \n\nwarning:\
    \ unreachable expression\n  --> /tmp/tmpxcz_entl.rs:37:5\n   |\n14 | /     loop\
    \ {\n15 | |         match s.chars().nth(i) {\n16 | |             Some('a')| Some('b')|\
    \ Some('c')| Some('d')| Some('e')| Some('f') |\n17 | |             Some('g')|\
    \ Some('h')| Some('i')| Some('j')| Some('k')| Some('l')|\n...  |\n35 | |     \
    \    }\n36 | |     }\n   | |_____- any code following this expression is unreachable\n\
    37 |       res \n   |       ^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd5kgc5lq.rs:10:24\n   |\n\
    10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut chars_map = HashMap::new();\n \
    \   for c in s.chars() {\n        chars_map.insert(c, true);\n    }\n\n    for\
    \ c in s.chars().rev() {\n        if chars_map.get(c) {\n            let mut new_char:\
    \ String = c.to_uppercase();\n            new_char.push(c.to_lowercase());\n \
    \           chars_map.insert(c, false);\n            s = s.replace_str(c, new_char);\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9sshlsm_.rs:12:25\n   |\n12 |     let mut chars_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9sshlsm_.rs:19:40\n   |\n19 |             let\
    \ mut new_char: String = c.to_uppercase();\n   |                             \
    \  ------   ^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |        |\n   |                         \
    \      |        expected struct `String`, found struct `ToUppercase`\n   |   \
    \                            expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9sshlsm_.rs:20:27\n   |\n20 |             new_char.push(c.to_lowercase());\n\
    \   |                           ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `ToLowercase`\n\nerror[E0599]: no method named `replace_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp9sshlsm_.rs:22:19\n   |\n22 | \
    \            s = s.replace_str(c, new_char);\n   |                   ^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `replace`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut s = &mut s[0..s.len()];\n    s.reverse();\n\
    \    String::from_utf8(s).unwrap()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpi3ujclc8.rs:13:7\n   |\n13 |     s.reverse();\n\
    \   |       ^^^^^^^ method not found in `&mut str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi3ujclc8.rs:14:23\n   |\n14 |     String::from_utf8(s).unwrap()\n\
    \   |                       ^ expected struct `Vec`, found `&mut str`\n   |\n\
    \   = note:         expected struct `Vec<u8>`\n           found mutable reference\
    \ `&mut str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(&mut \"\".to_string(), |mut res, c| {\n    \
    \    match c.to_lowercase() {\n            true => res.swap(c.to_string()),\n\
    \            false => res.swap(c.to_string()),\n        };\n        res\n    })\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp14k5xpej.rs:11:20\n   |\n\
    11 |     s.chars().fold(&mut \"\".to_string(), |mut res, c| {\n   |          \
    \          ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&mut String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n11 -     s.chars().fold(&mut\
    \ \"\".to_string(), |mut res, c| {\n11 +     s.chars().fold(\"\".to_string(),\
    \ |mut res, c| {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14k5xpej.rs:13:13\n\
    \   |\n12 |         match c.to_lowercase() {\n   |               ----------------\
    \ this expression has type `ToLowercase`\n13 |             true => res.swap(c.to_string()),\n\
    \   |             ^^^^ expected struct `ToLowercase`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp14k5xpej.rs:14:13\n   |\n12 |         match\
    \ c.to_lowercase() {\n   |               ---------------- this expression has\
    \ type `ToLowercase`\n13 |             true => res.swap(c.to_string()),\n14 |\
    \             false => res.swap(c.to_string()),\n   |             ^^^^^ expected\
    \ struct `ToLowercase`, found `bool`\n\nerror[E0599]: no method named `swap` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp14k5xpej.rs:13:25\n\
    \   |\n13 |             true => res.swap(c.to_string()),\n   |               \
    \          ^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `swap` found for struct `String` in the current scope\n  --> /tmp/tmp14k5xpej.rs:14:26\n\
    \   |\n14 |             false => res.swap(c.to_string()),\n   |              \
    \            ^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    let mut chars = s.chars();\n\
    \    if chars.next().is_none() {\n        s.reverse();\n    } else {\n       \
    \ while chars.next().is_some() {\n            let pos = chars.next().unwrap().as_str().len();\n\
    \            let char = chars.next().unwrap().as_str()[pos..];\n            let\
    \ mut pos = 0;\n            let mut res = &s[..pos];\n            while res !=\
    \ char {\n                pos = pos + 1;\n                res = &s[..pos];\n \
    \           }\n            let mut res = &s[pos..];\n            while let Some(pos)\
    \ = chars.next() {\n                let mut res = &s[..pos];\n               \
    \ let mut len = pos + 1;\n                while let Some(match) = res.get(len).unwrap().as_str().find(char)\
    \ {\n                    res = &s[..len];\n                    len = match + 1;\n\
    \                }\n            }\n            s = res.concat(&s[..pos]);\n  \
    \      }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `match`\n  --> /tmp/tmptvnful70.rs:29:32\n\
    \   |\n29 |                 while let Some(match) = res.get(len).unwrap().as_str().find(char)\
    \ {\n   |                                ^^^^^ expected identifier, found keyword\n\
    \   |\nhelp: escape `match` to use it as an identifier\n   |\n29 |           \
    \      while let Some(r#match) = res.get(len).unwrap().as_str().find(char) {\n\
    \   |                                ++\n\nerror: leading `+` is not supported\n\
    \  --> /tmp/tmptvnful70.rs:31:33\n   |\n31 |                     len = match +\
    \ 1;\n   |                                 ^ unexpected `+`\n   |\nhelp: try removing\
    \ the `+`\n   |\n31 -                     len = match + 1;\n31 +             \
    \        len = match  1;\n   | \n\nerror: expected one of `.`, `?`, `{`, or an\
    \ operator, found `;`\n  --> /tmp/tmptvnful70.rs:31:36\n   |\n31 |           \
    \          len = match + 1;\n   |                           -----    ^ expected\
    \ one of `.`, `?`, `{`, or an operator\n   |                           |\n   |\
    \                           while parsing this `match` expression\n   |      \
    \                     help: try removing this `match`\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmptvnful70.rs:14:11\n\
    \   |\n14 |         s.reverse();\n   |           ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0599]: no method named `as_str`\
    \ found for type `char` in the current scope\n  --> /tmp/tmptvnful70.rs:17:45\n\
    \   |\n17 |             let pos = chars.next().unwrap().as_str().len();\n   |\
    \                                             ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `as_str` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptvnful70.rs:18:46\n   |\n18 |             let char = chars.next().unwrap().as_str()[pos..];\n\
    \   |                                              ^^^^^^ method not found in\
    \ `char`\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \  --> /tmp/tmptvnful70.rs:27:32\n   |\n27 |                 let "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut res = String::new();\n\
    \    for ch in s {\n        match ch {\n            'a' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'b' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'c' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'd' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'e' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'f' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'g' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'h' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'i' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'j' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'k' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'l' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'm' => res.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .to_owned()),\n            'n' => res.push_str(\"ABCDEFGHIJKLMNOPQRST\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpdittio7b.rs:40:67\n\
    \   |\n40 |       assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n   |  ___________________________________________________________________^\n\
    41 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|c| c.is_digit()) {\n        return s.to_string();\n\
    \    }\n    if s.chars().any(|c| c.is_ascii_letter()) {\n        let mut res =\
    \ s.to_string();\n        res.chars().rev().for_each(|c| {\n            if !c.is_ascii_letter()\
    \ {\n                res.append(c.to_ascii_uppercase());\n            } else {\n\
    \                res.append(c.to_ascii_lowercase());\n            }\n        });\n\
    \        return res;\n    }\n    s[..].rev().to_ascii_lowercase()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpjek8r8ql.rs:11:28\n    |\n11  |     if s.chars().any(|c| c.is_digit())\
    \ {\n    |                            ^^^^^^^^- supplied 0 arguments\n    |  \
    \                          |\n    |                            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmpjek8r8ql.rs:14:28\n\
    \   |\n14 |     if s.chars().any(|c| c.is_ascii_letter()) {\n   |            \
    \                ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpjek8r8ql.rs:17:19\n\
    \   |\n17 |             if !c.is_ascii_letter() {\n   |                   ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjek8r8ql.rs:18:21\n   |\n18 |                 res.append(c.to_ascii_uppercase());\n\
    \   |                     ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjek8r8ql.rs:20:21\n   |\n20 |                 res.append(c.to_ascii_lowercase());\n\
    \   |                     ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ `str` is not an iterator\n  --> /tmp/tmpjek8r8ql.rs:25:11\n   |\n25 |     s[..].rev().to_ascii_lowercase()\n\
    \   |           ^^^ `str` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `str: Iterator`\n           which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut res: String = \"\";\n    for c\
    \ in s.chars() {\n        if let Some(low) = c {\n            if let Some(upper)\
    \ = c.map(|x| x.to_uppercase()) {\n                s = s.replace(&low, &upper);\n\
    \            } else {\n                res = c;\n                break;\n    \
    \        }\n        } else {\n            res = c;\n            break;\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyk1jv07k.rs:12:27\n   |\n\
    12 |     let mut res: String = \"\";\n   |                  ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |     \
    \   |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyk1jv07k.rs:14:16\n   |\n14 |         if let Some(low) = c {\n\
    \   |                ^^^^^^^^^   - this expression has type `char`\n   |     \
    \           |\n   |                expected `char`, found enum `Option`\n   |\n\
    \   = note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0599]:\
    \ `char` is not an iterator\n  --> /tmp/tmpyk1jv07k.rs:15:36\n   |\n15 |     \
    \        if let Some(upper) = c.map(|x| x.to_uppercase()) {\n   |            \
    \                        ^^^ `char` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `char: Iterator`\n           which\
    \ is required by `&mut char: Iterator`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmpyk1jv07k.rs:15:25\n\
    \   |\n15 |             if let Some(upper) = c.map(|x| x.to_uppercase()) {\n \
    \  |                         ^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpyk1jv07k.rs:15:20\n\
    \    |\n15  |             if let Some(upper) = c.map(|x| x.to_uppercase()) {\n\
    \    |                    ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Some`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyk1jv07k.rs:18:23\n\
    \   |\n12 |     let mut res: String = \"\";\n   |                  ------ expected\
    \ due to this type\n...\n18 |                 res = c;\n   |   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() { return \"#{}\" }\n    let mut res = String::with_capacity(s.len());\n\
    \    let mut pos = 0;\n    for c in s.chars() {\n        if c.is_ascii_uppercase()\
    \ {\n            res.push_str(&s[pos..pos+1].to_lowercase());\n            pos\
    \ += 1;\n        } else if c.is_ascii_lowercase() {\n            res.push_str(&s[pos..pos+1].to_uppercase());\n\
    \            pos += 1;\n        } else {\n            res.push_str(&s[pos]);\n\
    \            pos += 1;\n        }\n    }\n    res.push_str(&s[pos..]);\n    res\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqia4fzi.rs:11:30\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() { return \"#{}\" }\n\
    \   |                              ^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                              |\n   |                  \
    \            expected struct `String`, found `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpvqia4fzi.rs:22:27\n   |\n\
    22 |             res.push_str(&s[pos]);\n   |                           ^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().for_each(|c|{\n        let i\
    \ = c.to_lowercase().find(|c|{\n            c.is_alpha()\n        })\n       \
    \ if i != std::string::npos {\n            let j = c.to_uppercase().find(|c|{\n\
    \                c.is_alpha()\n            })\n            if j != std::string::npos\
    \ {\n                s.swap(i, j)\n            }\n        }\n    })\n    s\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp0ohb8t7d.rs:15:11\n\
    \   |\n15 |         })\n   |           ^ help: add `;` here\n16 |         if i\
    \ != std::string::npos {\n   |         -- unexpected token\n\nerror: expected\
    \ `;`, found keyword `if`\n  --> /tmp/tmp0ohb8t7d.rs:19:15\n   |\n19 |       \
    \      })\n   |               ^ help: add `;` here\n20 |             if j != std::string::npos\
    \ {\n   |             -- unexpected token\n\nerror: expected `;`, found `s`\n\
    \  --> /tmp/tmp0ohb8t7d.rs:24:7\n   |\n24 |     })\n   |       ^ help: add `;`\
    \ here\n25 |     s\n   |     - unexpected token\n\nerror[E0425]: cannot find value\
    \ `npos` in module `std::string`\n  --> /tmp/tmp0ohb8t7d.rs:16:30\n   |\n16 |\
    \         if i != std::string::npos {\n   |                              ^^^^\
    \ not found in `std::string`\n\nerror[E0425]: cannot find value `npos` in module\
    \ `std::string`\n  --> /tmp/tmp0ohb8t7d.rs:20:34\n   |\n20 |             if j\
    \ != std::string::npos {\n   |                                  ^^^^ not found\
    \ in `std::string`\n\nerror[E0599]: no method named `is_alpha` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp0ohb8t7d.rs:14:15\n   |\n14 |  \
    \           c.is_alpha()\n   |               ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_alphabetic`\n\nerror[E0599]: no method named\
    \ `is_alpha` found for reference `&char` in the current scope\n  --> /tmp/tmp0ohb8t7d.rs:18:19\n\
    \   |\n18 |                 c.is_alpha()\n   |                   ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_alphabetic`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp0ohb8t7d.rs:21:19\n   |\n21 |                 s.swap(i, j)\n   |   \
    \                ^^^^ method not found in `String`\n\nerror: aborting due to 8\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if let Some(first) = s.chars().next() {\n        if first.to_ascii_lowercase().contains(&\"\
    a\"..=&\"z\") {\n            solve(&s.chars().rev().collect::<String>())\n   \
    \     } else {\n            solve(&s[1..].to_ascii_lowercase().collect::<String>())\n\
    \        }\n    } else {\n        s\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpb4ysdfpm.rs:12:39\n   |\n12 |         if first.to_ascii_lowercase().contains(&\"\
    a\"..=&\"z\") {\n   |                                       ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4ysdfpm.rs:13:19\n\
    \   |\n13 |             solve(&s.chars().rev().collect::<String>())\n   |    \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n13 -      \
    \       solve(&s.chars().rev().collect::<String>())\n13 +             solve(s.chars().rev().collect::<String>())\n\
    \   | \n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpb4ysdfpm.rs:15:48\n\
    \    |\n15  |               solve(&s[1..].to_ascii_lowercase().collect::<String>())\n\
    \    |                                                  ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    for &c in s.chars() {\n \
    \       if c.is_ascii_lowercase() {\n            s = s.into_lowercase();\n   \
    \     } else if c.is_ascii_uppercase() {\n            s = s.into_uppercase();\n\
    \        } else {\n            continue;\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvzrdvqly.rs:12:9\n   |\n\
    12 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `into_lowercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpvzrdvqly.rs:14:19\n   |\n14 |             s = s.into_lowercase();\n\
    \   |                   ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror[E0599]: no method named `into_uppercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpvzrdvqly.rs:16:19\n\
    \   |\n16 |             s = s.into_uppercase();\n   |                   ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\".to_owned();\n    }\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let upper\
    \ = if c >= 'a' && c <= 'z' { c - 'a' + 'A' } else { c };\n        let lower =\
    \ if c >= 'A' && c <= 'Z' { c - 'A' + 'a' } else { c };\n        let mut res =\
    \ if upper <= lower {\n            upper.to_string() + lower.to_string()\n   \
    \     } else {\n            lower.to_string() + upper.to_string()\n        };\n\
    \        res.reverse();\n        result.push_str(&res);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpi_1xfwrm.rs:16:49\n\
    \   |\n16 |         let upper = if c >= 'a' && c <= 'z' { c - 'a' + 'A' } else\
    \ { c };\n   |                                               - ^ --- char\n  \
    \ |                                               |\n   |                    \
    \                           char\n\nerror[E0369]: cannot subtract `char` from\
    \ `char`\n  --> /tmp/tmpi_1xfwrm.rs:17:49\n   |\n17 |         let lower = if c\
    \ >= 'A' && c <= 'Z' { c - 'A' + 'a' } else { c };\n   |                     \
    \                          - ^ --- char\n   |                                \
    \               |\n   |                                               char\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().for_each(|c|{\n        let mut low = c;\n       \
    \ let mut high = c;\n\n        loop {\n            match c {\n               \
    \ 'a' => low = low.to_ascii_lowercase().to_vec(),\n                'b' => high\
    \ = high.to_ascii_lowercase().to_vec(),\n                'c' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'd' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'e' => low = low.to_ascii_lowercase().to_vec(),\n                'f' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'g' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'h' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'i' => low = low.to_ascii_lowercase().to_vec(),\n                'j' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'k' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'l' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'm' => low = low.to_ascii_lowercase().to_vec(),\n                'n' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'o' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'p' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'q' => low = low.to_ascii_lowercase().to_vec(),\n                'r' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                's' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                't' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'u' => low = low.to_ascii_lowercase().to_vec(),\n                'v' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'w' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'x' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'y' => low = low.to_ascii_lowercase().to_vec(),\n                'z' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'A' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'B' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'C' => low = low.to_ascii_lowercase().to_vec(),\n                'D' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'E' => low = low.to_ascii_lowercase().to_vec(),\n\
    \                'F' => high = high.to_ascii_lowercase().to_vec(),\n         \
    \       'G' => low = low.to_ascii_lowercase().to_vec(),\n                'H' =>\
    \ high = high.to_ascii_lowercase().to_vec(),\n                'I' => \n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp04snqxo1.rs:64:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n11 |     s.chars().for_each(|c|{\n   |             \
    \          -   - unclosed delimiter\n   |                       |\n   |      \
    \                 unclosed delimiter\n...\n15 |         loop {\n   |         \
    \     - unclosed delimiter\n16 |             match c {\n   |                 \
    \    - this delimiter might not be properly closed...\n...\n52 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n64 | }\n   |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmp04snqxo1.rs:52:1\n   |\n\
    51 |                 'I' => \n   |                     -- while parsing the `match`\
    \ arm starting here\n52 | }\n   | ^ expected expression\n\nerror[E0599]: no method\
    \ named `to_vec` found for type `char` in the current scope\n  --> /tmp/tmp04snqxo1.rs:17:55\n\
    \   |\n17 |                 'a' => low = low.to_ascii_lowercase().to_vec(),\n\
    \   |                                                       ^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `to_vec` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp04snqxo1.rs:18:57\n   |\n18 |          \
    \       'b' => high = high.to_ascii_lowercase().to_vec(),\n   |              \
    \                                           ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `to_vec` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp04snqxo1.rs:19:55\n   |\n19 |                 'c' => low\
    \ = low.to_ascii_lowercase().to_vec(),\n   |                                 \
    \                      ^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `to_vec` found for type `char` in the current scope\n  --> /tmp/tmp04snqxo1.rs:20:57\n\
    \   |\n20 |                 'd' => high = high.to_ascii_lowercase().to_vec(),\n\
    \   |                                                         ^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `to_vec` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp04snqxo1.rs"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'A' ... 'Z' => c.to_string().to_uppercase(),\n\
    \        'a' ... 'z' => c.to_string().to_lowercase(),\n        _ => c,\n    }).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpt018uk9h.rs:12:13\n\
    \   |\n12 |         'A' ... 'Z' => c.to_string().to_uppercase(),\n   |       \
    \      ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpt018uk9h.rs:13:13\n\
    \   |\n13 |         'a' ... 'z' => c.to_string().to_lowercase(),\n   |       \
    \      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is\
    \ accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpt018uk9h.rs:14:14\n\
    \   |\n11 |       s.chars().map(|c| match c {\n   |  _______________________-\n\
    12 | |         'A' ... 'Z' => c.to_string().to_uppercase(),\n   | |          \
    \              ---------------------------- this is found to be of type `String`\n\
    13 | |         'a' ... 'z' => c.to_string().to_lowercase(),\n   | |          \
    \              ---------------------------- this is found to be of type `String`\n\
    14 | |         _ => c,\n   | |              ^- help: try using a conversion method:\
    \ `.to_string()`\n   | |              |\n   | |              expected struct `String`,\
    \ found `char`\n15 | |     }).collect::<String>().to_string()\n   | |_____- `match`\
    \ arms have incompatible types\n\nerror: aborting due to previous error; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() || s.chars().count() == 0 {\n        return\
    \ s\n    }\n    let mut result = String::with_capacity(s.len());\n    for i in\
    \ s.chars() {\n        if i.is_lowercase() {\n            result.push(i.to_uppercase());\n\
    \        } else {\n            result.push(i.to_lowercase());\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpupg44217.rs:17:25\n   |\n\
    17 |             result.push(i.to_uppercase());\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupg44217.rs:19:25\n   |\n19 |             result.push(i.to_lowercase());\n\
    \   |                         ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res: String = \"\";\n    for i in s.chars() {\n   \
    \     if let Some(letter) = i.to_lowercase() {\n            res += letter;\n \
    \       } else {\n            res += i.to_uppercase();\n        }\n    }\n   \
    \ res.into_owned()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8id9pp2.rs:11:27\n   |\n\
    11 |     let mut res: String = \"\";\n   |                  ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |     \
    \   |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw8id9pp2.rs:13:16\n   |\n13 |         if let Some(letter) = i.to_lowercase()\
    \ {\n   |                ^^^^^^^^^^^^   ---------------- this expression has type\
    \ `ToLowercase`\n   |                |\n   |                expected struct `ToLowercase`,\
    \ found enum `Option`\n   |\n   = note: expected struct `ToLowercase`\n      \
    \          found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw8id9pp2.rs:16:20\n\
    \   |\n16 |             res += i.to_uppercase();\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToUppercase`\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpw8id9pp2.rs:19:9\n\
    \   |\n19 |     res.into_owned()\n   |         ^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars().fold(String::new(), |mut acc, x| {\n\
    \        match x {\n            'A' | 'a' => acc.insert(0, &*x.to_lowercase()),\n\
    \            'B' | 'b' => acc.insert(0, &*x.to_uppercase()),\n            _ =>\
    \ acc,\n        }\n    });\n    let mut res = s.chars().fold(String::new(), |mut\
    \ acc, x| {\n        match x {\n            'a' | 'A' => acc.insert(0, &*x.to_lowercase()),\n\
    \            'b' | 'B' => acc.insert(0, &*x.to_uppercase()),\n            _ =>\
    \ acc,\n        }\n    });\n    if s.chars().filter(|x| x.is_ascii_alphanumeric()).count()\
    \ == 0 {\n        res.insert(0, &s[..s.len()]);\n    } else {\n        res\n \
    \   }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `ToLowercase` cannot be dereferenced\n  --> /tmp/tmpcubqiqdf.rs:13:41\n\
    \   |\n13 |             'A' | 'a' => acc.insert(0, &*x.to_lowercase()),\n   |\
    \                                         ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcubqiqdf.rs:13:26\n   |\n13 |             'A' | 'a' =>\
    \ acc.insert(0, &*x.to_lowercase()),\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpcubqiqdf.rs:13:30\n   |\n13 |             'A'\
    \ | 'a' => acc.insert(0, &*x.to_lowercase()),\n   |                          ---\
    \ ^^^^^^ this call modifies `acc` in-place\n   |                          |\n\
    \   |                          you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `insert`\n\
    \nerror[E0614]: type `ToUppercase` cannot be dereferenced\n  --> /tmp/tmpcubqiqdf.rs:14:41\n\
    \   |\n14 |             'B' | 'b' => acc.insert(0, &*x.to_uppercase()),\n   |\
    \                                         ^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `ToLowercase` cannot be dereferenced\n  --> /tmp/tmpcubqiqdf.rs:20:41\n   |\n\
    20 |             'a' | 'A' => acc.insert(0, &*x.to_lowercase()),\n   |       \
    \                                  ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcubqiqdf.rs:20:26\n   |\n20 |             'a' | 'A' =>\
    \ acc.insert(0, &*x.to_lowercase()),\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpcubqiqdf.rs:20:30\n   |\n20 |             'a'\
    \ | 'A' => acc.insert(0, &*x.to_lowercase()),\n   |                          ---\
    \ ^^^^^^ this call modifies `acc` in-place\n   |                          |\n\
    \   |                          you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `insert`\n\
    \nerror[E0614]: type `ToUppercase` cannot be dereferenced\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n    use std::ascii::IsLower;\n \
    \   let mut res = String::new();\n    for c in s.chars().filter_map(|x| if IsLower(x)\
    \ {\n            Some(x.to_ascii_lowercase())\n        } else {\n            Some(x.to_ascii_uppercase())\n\
    \        }) {\n        if c <= 'z' || c >= 'A' {\n            let c = c.to_ascii_lowercase();\n\
    \            if c <= 'z' {\n                res.push(c);\n            } else {\n\
    \                res.push(c);\n            }\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res.chars().collect::<String>().reverse().collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `std::ascii::IsLower`\n  --> /tmp/tmpdggt62rj.rs:12:9\n\
    \   |\n12 |     use std::ascii::IsLower;\n   |         ^^^^^^^^^^^^^^^^^^^ no\
    \ `IsLower` in `ascii`\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`:\
    \ use inherent methods instead\n  --> /tmp/tmpdggt62rj.rs:11:21\n   |\n11 |  \
    \   use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpdggt62rj.rs:30:37\n\
    \   |\n30 |     res.chars().collect::<String>().reverse().collect()\n   |    \
    \                                 ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nwarning: unused import: `std::ascii::AsciiExt`\n\
    \  --> /tmp/tmpdggt62rj.rs:11:9\n   |\n11 |     use std::ascii::AsciiExt;\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nSome errors have detailed explanations: E0432, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    match s.chars() {\n        &[char::from('a'), char::from('z')]\
    \ => solve(&s.to_string().swapcase()[..]),\n        _ => s,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy9yymh6v.rs:12:9\n   |\n\
    11 |     match s.chars() {\n   |           --------- this expression has type\
    \ `Chars<'_>`\n12 |         &[char::from('a'), char::from('z')] => solve(&s.to_string().swapcase()[..]),\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found\
    \ reference\n   |\n   = note: expected struct `Chars<'_>`\n           found reference\
    \ `&_`\n\nerror[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `char::from`\n  --> /tmp/tmpy9yymh6v.rs:12:11\n   |\n12 |         &[char::from('a'),\
    \ char::from('z')] => solve(&s.to_string().swapcase()[..]),\n   |           ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `char::from`\n\
    \  --> /tmp/tmpy9yymh6v.rs:12:28\n   |\n12 |         &[char::from('a'), char::from('z')]\
    \ => solve(&s.to_string().swapcase()[..]),\n   |                            ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpy9yymh6v.rs:12:69\n   |\n12 |         &[char::from('a'), char::from('z')]\
    \ => solve(&s.to_string().swapcase()[..]),\n   |                             \
    \                                        ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0164, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0164`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.to_lowercase().to_string();\n    let mut lower\
    \ = false;\n    for (i, ch) in s.chars().enumerate().filter(|&x| !x.is_alphabetic(::std::ascii::AsciiExt)).enumerate()\
    \ {\n        if !lower {\n            s.swap(0, i);\n        } else {\n      \
    \      s.swap(i, 0);\n        }\n        lower = x.is_alphabetic(::std::ascii::AsciiExt);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found trait `std::ascii::AsciiExt`\n  -->\
    \ /tmp/tmpmo8i2qvq.rs:13:71\n   |\n13 |     for (i, ch) in s.chars().enumerate().filter(|&x|\
    \ !x.is_alphabetic(::std::ascii::AsciiExt)).enumerate() {\n   |              \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ not a value\n\nerror[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmpmo8i2qvq.rs:19:17\n\
    \   |\n19 |         lower = x.is_alphabetic(::std::ascii::AsciiExt);\n   |   \
    \              ^ help: a local variable with a similar name exists: `i`\n\nerror[E0423]:\
    \ expected value, found trait `std::ascii::AsciiExt`\n  --> /tmp/tmpmo8i2qvq.rs:19:33\n\
    \   |\n19 |         lower = x.is_alphabetic(::std::ascii::AsciiExt);\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0599]:\
    \ no method named `is_alphabetic` found for tuple `(usize, char)` in the current\
    \ scope\n  --> /tmp/tmpmo8i2qvq.rs:13:57\n   |\n13 |     for (i, ch) in s.chars().enumerate().filter(|&x|\
    \ !x.is_alphabetic(::std::ascii::AsciiExt)).enumerate() {\n   |              \
    \                                           ^^^^^^^^^^^^^ method not found in\
    \ `(usize, char)`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpmo8i2qvq.rs:15:15\n   |\n15 |          \
    \   s.swap(0, i);\n   |               ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpmo8i2qvq.rs:17:15\n   |\n17 |             s.swap(i, 0);\n   |      \
    \         ^^^^ method not found in `String`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0423, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return String::new();\n    }\n \
    \   let mut res = String::new();\n    let mut str = String::from(s);\n    let\
    \ mut first_run = true;\n    let mut cur_char = String::from(\"\");\n    let mut\
    \ index = str.len() - 1;\n    let mut cur_char_upper = String::from(\"\");\n \
    \   while index >= 0 {\n        let mut cur_pos = index;\n        let mut cur_char_lower\
    \ = String::from(\"\");\n        while index >= 0 {\n            cur_char.push(str[cur_pos]);\n\
    \            cur_char_upper.push(cur_char.chars().next().unwrap().to_uppercase());\n\
    \            cur_char_lower.push(cur_char.chars().next().unwrap().to_lowercase());\n\
    \            index -= 1;\n        }\n        if cur_char_upper.end() != cur_char_lower\n\
    \            || (cur_char_upper.len() == 0\n                && cur_char_lower.len()\
    \ != 0) {\n            break;\n        }\n        res.insert(0, cur_char_upper);\n\
    \        res.insert(0, cur_char_lower);\n        res.insert(0, cur_char);\n  \
    \      first_run = false;\n    }\n    if index == 0 && cur_char_upper.len() !=\
    \ 0 {\n        res.insert(0, cur_char_upper);\n    }\n    if index == 0 && cur_char_lower.len()\
    \ != 0 {\n        res.insert(0, cur_char_lower);\n    }\n    if index != 0 ||\
    \ first_run {\n        res.insert(0, cur_char);\n    }\n    return res.to_string();\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `cur_char_lower` in this scope\n  --> /tmp/tmpp5x6tynu.rs:42:22\n\
    \   |\n42 |     if index == 0 && cur_char_lower.len() != 0 {\n   |           \
    \           ^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `cur_char_upper`\n\nerror[E0425]: cannot find value `cur_char_lower` in this\
    \ scope\n  --> /tmp/tmpp5x6tynu.rs:43:23\n   |\n43 |         res.insert(0, cur_char_lower);\n\
    \   |                       ^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `cur_char_upper`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpp5x6tynu.rs:24:27\n   |\n24 |             cur_char.push(str[cur_pos]);\n\
    \   |                           ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp5x6tynu.rs:25:33\n\
    \   |\n25 |             cur_char_upper.push(cur_char.chars().next().unwrap().to_uppercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToUppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp5x6tynu.rs:26:33\n   |\n26 |             cur_char_lower.push(cur_char.chars().next().unwrap().to_lowercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0599]: no method named\
    \ `end` found for struct `String` in the current scope\n  --> /tmp/tmpp5x6tynu.rs:29:27\n\
    \   |\n29 |         if cur_char_upper.end() != cur_char_lower\n   |          \
    \                 ^^^ method not found in `String`\n\nerror[E0308]: mism"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut l = s.chars().count();\n    \n    let mut s = s;\n\
    \    while l > 0 {\n        s = s.chars().rev().collect();\n        l -= 1;\n\
    \    }\n    if l == 0 {\n        s = s.chars().rev().collect();\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmpojinw0em.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    for (i, c) in s.chars().enumerate() {\n\
    \        if !is_letter_cased(c) && !is_letter_cased(&s[i - 1]) {\n           \
    \ s = s.replace(&s[i..i].to_string(), String::from(&s[i..i].to_lowercase()));\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_letter_cased` in this scope\n  -->\
    \ /tmp/tmp6212769h.rs:13:13\n   |\n13 |         if !is_letter_cased(c) && !is_letter_cased(&s[i\
    \ - 1]) {\n   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_letter_cased` in this scope\n  --> /tmp/tmp6212769h.rs:13:36\n\
    \   |\n13 |         if !is_letter_cased(c) && !is_letter_cased(&s[i - 1]) {\n\
    \   |                                    ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6212769h.rs:13:53\n\
    \   |\n13 |         if !is_letter_cased(c) && !is_letter_cased(&s[i - 1]) {\n\
    \   |                                                     ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6212769h.rs:14:49\n\
    \   |\n14 |             s = s.replace(&s[i..i].to_string(), String::from(&s[i..i].to_lowercase()));\n\
    \   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                 |\n   |                \
    \                                 expected `&str`, found struct `String`\n   |\
    \                                                 help: consider borrowing here:\
    \ `&String::from(&s[i..i].to_lowercase())`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut s = s.chars();\n    let mut i = 0;\n    let mut\
    \ res = String::new();\n    \n    loop {\n        if i >= s.len() {\n        \
    \    return res;\n        }\n        let c = s.next().unwrap();\n        if c\
    \ == c.to_lowercase() {\n            res = res.to_uppercase();\n        } else\
    \ if c == c.to_uppercase() {\n            res = res.to_lowercase();\n        }\
    \ else {\n            res = res + c;\n        }\n        i += 1;\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpmrcaz2ki.rs:17:19\n   |\n17 |         if i >= s.len() {\n\
    \   |                   ^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmrcaz2ki.rs:21:17\n   |\n21 |         if c == c.to_lowercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmrcaz2ki.rs:23:24\n   |\n23 |\
    \         } else if c == c.to_uppercase() {\n   |                        ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToUppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmrcaz2ki.rs:26:25\n   |\n26 |             res = res + c;\n   |\
    \                         ^ expected `&str`, found `char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for i in s.chars() {\n  \
    \      if i.is_ascii_uppercase() {\n            res.push_str(i.to_ascii_lowercase());\n\
    \        } else {\n            res.push_str(i);\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9yubyva.rs:14:26\n   |\n\
    14 |             res.push_str(i.to_ascii_lowercase());\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf9yubyva.rs:16:26\n   |\n16 |             res.push_str(i);\n\
    \   |                          ^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().filter(|c| c.is_ascii()).fold(String::new(), |mut\
    \ accum, next| {\n        match next {\n            b'a' .. b'z' => accum.push(b'A'),\n\
    \            b'A' .. b'Z' => accum.push(b'a'),\n            _ => accum\n     \
    \   }\n    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpjjfej5z8.rs:13:13\n\
    \   |\n13 |             b'a' .. b'z' => accum.push(b'A'),\n   |             ^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpjjfej5z8.rs:14:13\n   |\n14 |             b'A' .. b'Z' => accum.push(b'a'),\n\
    \   |             ^^^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjfej5z8.rs:13:13\n\
    \   |\n12 |         match next {\n   |               ---- this expression has\
    \ type `char`\n13 |             b'a' .. b'z' => accum.push(b'A'),\n   |      \
    \       ^^^^    ---- this is of type `u8`\n   |             |\n   |          \
    \   expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjfej5z8.rs:13:21\n\
    \   |\n12 |         match next {\n   |               ---- this expression has\
    \ type `char`\n13 |             b'a' .. b'z' => accum.push(b'A'),\n   |      \
    \       ----    ^^^^ expected `char`, found `u8`\n   |             |\n   |   \
    \          this is of type `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjfej5z8.rs:14:13\n\
    \   |\n12 |         match next {\n   |               ---- this expression has\
    \ type `char`\n13 |             b'a' .. b'z' => accum.push(b'A'),\n14 |      \
    \       b'A' .. b'Z' => accum.push(b'a'),\n   |             ^^^^    ---- this\
    \ is of type `u8`\n   |             |\n   |             expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjfej5z8.rs:14:21\n  \
    \ |\n12 |         match next {\n   |               ---- this expression has type\
    \ `char`\n13 |             b'a' .. b'z' => accum.push(b'A'),\n14 |           \
    \  b'A' .. b'Z' => accum.push(b'a'),\n   |             ----    ^^^^ expected `char`,\
    \ found `u8`\n   |             |\n   |             this is of type `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjjfej5z8.rs:13:40\n   |\n13 |             b'a'\
    \ .. b'z' => accum.push("
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return String::from(\"123\");\n\
    \    }\n\n    let mut new_s = s;\n\n    let mut new_s = s.chars().enumerate().filter(|(_,\
    \ c)| {\n        let char = c.to_ascii_lowercase();\n        if char != c.to_ascii_uppercase()\
    \ {\n            new_s = new_s.to_string();\n            return false;\n     \
    \   }\n        true\n    }).map(|(_, c)| c.to_ascii_uppercase()).collect::<String>();\n\
    \n    new_s.chars().for_each(|c|{\n        if !s.contains(&c) {\n            new_s\
    \ = new_s.to_string();\n        }\n    });\n\n    new_s.chars().for_each(|c|{\n\
    \        if s.contains(&c) {\n            new_s = new_s.to_string();\n       \
    \ }\n    });\n\n    new_s.chars().for_each(|c|{\n        if s.contains(&c.to_ascii_lowercase())\
    \ {\n            new_s = new_s.to_string();\n        }\n    });\n\n    new_s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpafeulzkd.rs:27:24\n\
    \     |\n27   |         if !s.contains(&c) {\n     |               -------- ^^\
    \ expected an `Fn<(char,)>` closure, found `char`\n     |               |\n  \
    \   |               required by a bound introduced by this call\n     |\n    \
    \ = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n27   |         if !s.contains(*&c)\
    \ {\n     |                        +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmpafeulzkd.rs:33:23\n     |\n33   |   \
    \      if s.contains(&c) {\n     |              -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |              |\n     |              required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n33   |         if s.contains(*&c) {\n     |                  \
    \     +\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    -->\
    \ /tmp/tmpafeulzkd.rs:39:23\n     |\n39   |         if s.contains(&c.to_ascii_lowercase())\
    \ {\n     |              -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |              |\n     |              required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the i"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s.to_string();\n    }\n \
    \   let mut i = 0;\n    while i < s.len() {\n        let char = s[i..].chars().next().unwrap();\n\
    \        let mut index = char.len() - 1;\n        if index >= 0 {\n          \
    \  if char[index].is_lowercase() {\n                if char[index..].chars().next().unwrap().is_lowercase()\
    \ {\n                    index = index - 1;\n                }\n            }\n\
    \        }\n        s[i] = char[index].to_string();\n        i += 1;\n    }\n\
    \    s.reverse();\n    \n    \n    return s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbko4b3fo.rs:17:30\n   |\n17 |         let mut index = char.len()\
    \ - 1;\n   |                              ^^^ method not found in `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpbko4b3fo.rs:19:16\n\
    \   |\n19 |             if char[index].is_lowercase() {\n   |                ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpbko4b3fo.rs:20:20\n\
    \   |\n20 |                 if char[index..].chars().next().unwrap().is_lowercase()\
    \ {\n   |                    ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmpbko4b3fo.rs:25:16\n   |\n25 |        \
    \ s[i] = char[index].to_string();\n   |                ^^^^^^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbko4b3fo.rs:25:9\n\
    \   |\n25 |         s[i] = char[index].to_string();\n   |         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbko4b3fo.rs:28:7\n   |\n28 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().count() != s.len() {\n        return s.to_string();\n\
    \    }\n    let mut chars = s.chars();\n    let mut chars = chars.collect();\n\
    \    let mut res = String::new();\n    while let Some(c) = chars.pop() {\n   \
    \     if c.is_uppercase() {\n            chars.push(c.to_lowercase());\n     \
    \   } else {\n            chars.push(c.to_uppercase());\n        }\n    }\n  \
    \  res = res.concat(chars);\n    if res.chars().count() == 0 {\n        return\
    \ s.to_string();\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp1dfwbt12.rs:17:25\n\
    \   |\n15 |     let mut chars = chars.collect();\n   |         --------- consider\
    \ giving `chars` a type\n16 |     let mut res = String::new();\n17 |     while\
    \ let Some(c) = chars.pop() {\n   |                         ^^^^^ cannot infer\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0599]: no\
    \ method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1dfwbt12.rs:24:15\n   |\n24 |     res = res.concat(chars);\n   |   \
    \            ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0282, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = \"\";\n    let mut iter = s.chars().enumerate();\n\
    \    for (ix, char) in iter {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += String::from(char - 'a' + 1);\n        } else if char >= 'A'\
    \ && char <= 'Z' {\n            result += String::from(char - 'A' + 1);\n    \
    \    } else {\n            result += char;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpioo_qc_z.rs:15:41\n\
    \   |\n15 |             result += String::from(char - 'a' + 1);\n   |        \
    \                            ---- ^ --- char\n   |                           \
    \         |\n   |                                    char\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpioo_qc_z.rs:15:13\n\
    \   |\n15 |             result += String::from(char - 'a' + 1);\n   |        \
    \     ------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |      |\n   |\
    \             |      `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |             cannot use `+=` on type `&str`\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\n\nerror[E0369]: cannot subtract `char`\
    \ from `char`\n  --> /tmp/tmpioo_qc_z.rs:17:41\n   |\n17 |             result\
    \ += String::from(char - 'A' + 1);\n   |                                    ----\
    \ ^ --- char\n   |                                    |\n   |                \
    \                    char\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmpioo_qc_z.rs:17:13\n   |\n17 |     \
    \        result += String::from(char - 'A' + 1);\n   |             ------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |      |\n   |             |      `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |             cannot use `+=` on type `&str`\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpioo_qc_z.rs:19:13\n   |\n19 |             result += char;\n   |\
    \             ------^^^^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpioo_qc_z.rs:22:5\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                        ------\
    \ expected `String` because of return type\n...\n22 |     result\n   |     ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expecte"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = s.to_string();\n    let mut i = 0;\n    while\
    \ i < res.len() {\n        if res[i].is_ascii() {\n            let mut j = i;\n\
    \            while j + 1 < res.len() {\n                if res[j + 1] == 65 {\n\
    \                    if res[j] != 67 {\n                        break;\n     \
    \               }\n                    j += 1;\n                } else {\n   \
    \                 if res[j] != 97 {\n                        break;\n        \
    \            }\n                    j += 1;\n                }\n            }\n\
    \            if j + 1 < res.len() {\n                res[i] = res[j].to_string();\n\
    \            } else {\n                res = \"0\".to_string() + res.to_string();\n\
    \            }\n        } else {\n            res = \"0\".to_string() + res.to_string();\n\
    \        }\n        i += 1;\n    }\n    return res.to_string();\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf7w441_c.rs:14:12\n\
    \   |\n14 |         if res[i].is_ascii() {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf7w441_c.rs:17:20\n   |\n17 |                 if res[j + 1] ==\
    \ 65 {\n   |                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf7w441_c.rs:18:24\n   |\n18 |                     if res[j] !=\
    \ 67 {\n   |                        ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    for c in s.chars() {\n  \
    \      if c.is_alpha() {\n            if c.to_ascii_lowercase().contains(&c) {\n\
    \                s = s.replace(c.to_ascii_lowercase(), c.to_ascii_uppercase())\n\
    \            } else {\n                s = s.replace(c.to_ascii_uppercase(), c.to_ascii_lowercase())\n\
    \            }\n        } else {\n            s = s.replace(c,c);\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_alpha` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp73m3zask.rs:13:14\n   |\n13 |         if c.is_alpha() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_alphabetic`\n\nerror[E0599]: no method named `contains` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp73m3zask.rs:14:39\n   |\n14\
    \ |             if c.to_ascii_lowercase().contains(&c) {\n   |               \
    \                        ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp73m3zask.rs:15:55\n   |\n15 |              \
    \   s = s.replace(c.to_ascii_lowercase(), c.to_ascii_uppercase())\n   |      \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73m3zask.rs:17:55\n\
    \   |\n17 |                 s = s.replace(c.to_ascii_uppercase(), c.to_ascii_lowercase())\n\
    \   |                                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73m3zask.rs:20:29\n\
    \   |\n20 |             s = s.replace(c,c);\n   |                            \
    \ ^ expected `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_letter() {\n        match c.to_lowercase()\
    \ {\n            \"A\" => c.to_uppercase(),\n            \"a\" => c.to_lowercase(),\n\
    \            _ => c,\n        }\n    } else {\n        c\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwuvmscob.rs:11:28\n   |\n11 |     s.chars().map(|c|\
    \ if c.is_letter() {\n   |                            ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwuvmscob.rs:13:13\n\
    \   |\n12 |         match c.to_lowercase() {\n   |               ----------------\
    \ this expression has type `ToLowercase`\n13 |             \"A\" => c.to_uppercase(),\n\
    \   |             ^^^ expected struct `ToLowercase`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwuvmscob.rs:14:13\n   |\n12 |         match\
    \ c.to_lowercase() {\n   |               ---------------- this expression has\
    \ type `ToLowercase`\n13 |             \"A\" => c.to_uppercase(),\n14 |      \
    \       \"a\" => c.to_lowercase(),\n   |             ^^^ expected struct `ToLowercase`,\
    \ found `&str`\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpwuvmscob.rs:14:20\n\
    \   |\n12 | /         match c.to_lowercase() {\n13 | |             \"A\" => c.to_uppercase(),\n\
    \   | |                    ---------------- this is found to be of type `ToUppercase`\n\
    14 | |             \"a\" => c.to_lowercase(),\n   | |                    ^^^^^^^^^^^^^^^^\
    \ expected struct `ToUppercase`, found struct `ToLowercase`\n15 | |          \
    \   _ => c,\n16 | |         }\n   | |_________- `match` arms have incompatible\
    \ types\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    match s.chars().filter(|x|x.is_letter()) {\n        Some(x)\
    \ => {\n            let mut s = String::new();\n            for i in x.to_lowercase().rev()\
    \ {\n                s = &s[i..] + s;\n            }\n            s.to_owned()\n\
    \        },\n        None => s.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().join(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpwk0dcbx8.rs:11:33\n   |\n11 |     match s.chars().filter(|x|x.is_letter())\
    \ {\n   |                                 ^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwk0dcbx8.rs:12:9\n   |\n11 | \
    \    match s.chars().filter(|x|x.is_letter()) {\n   |           ----------------------------------\n\
    \   |           |                |\n   |           |                the expected\
    \ closure\n   |           this expression has type `Filter<Chars<'_>, [closure@/tmp/tmpwk0dcbx8.rs:11:28:\
    \ 11:44]>`\n12 |         Some(x) => {\n   |         ^^^^^^^ expected struct `Filter`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Filter<Chars<'_>, [closure@/tmp/tmpwk0dcbx8.rs:11:28:\
    \ 11:44]>`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwk0dcbx8.rs:19:9\n   |\n11 |     match s.chars().filter(|x|x.is_letter())\
    \ {\n   |           ----------------------------------\n   |           |     \
    \           |\n   |           |                the expected closure\n   |    \
    \       this expression has type `Filter<Chars<'_>, [closure@/tmp/tmpwk0dcbx8.rs:11:28:\
    \ 11:44]>`\n...\n19 |         None => s.chars().map(|x|x.to_lowercase()).collect::<Vec<_>>().join(),\n\
    \   |         ^^^^ expected struct `Filter`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Filter<Chars<'_>, [closure@/tmp/tmpwk0dcbx8.rs:11:28: 11:44]>`\n\
    \                found enum `Option<_>`\n\nerror[E0369]: cannot add `String` to\
    \ `&str`\n  --> /tmp/tmpwk0dcbx8.rs:15:29\n   |\n15 |                 s = &s[i..]\
    \ + s;\n   |                     ------- ^ - String\n   |                    \
    \ |       |\n   |                     |       `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |                     &str\n   |\nhelp: remove\
    \ the borrow on the left and add one on the right\n   |\n15 -                \
    \ s = &s[i..] + s;\n15 +                 s = s[i..] + &s;\n   | \n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<ToLowercase>`, but its tra"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        s\n    } else {\n        match s.chars().next()\
    \ {\n            Some(c) => match c.to_lowercase().as_byte() {\n             \
    \   b'a' => {\n                    c.to_uppercase().to_ascii_lowercase().to_string()\n\
    \                }\n                b'A' => {\n                    c.to_lowercase().to_ascii_uppercase().to_string()\n\
    \                }\n                _ => {\n                    c\n          \
    \      }\n            }\n            None => {\n                s.to_ascii_lowercase().to_string()\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_byte` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpigjuq1id.rs:15:47\n   |\n15 |          \
    \   Some(c) => match c.to_lowercase().as_byte() {\n   |                      \
    \                         ^^^^^^^ method not found in `ToLowercase`\n\nerror[E0599]:\
    \ no method named `to_ascii_lowercase` found for struct `ToUppercase` in the current\
    \ scope\n  --> /tmp/tmpigjuq1id.rs:17:38\n   |\n17 |                     c.to_uppercase().to_ascii_lowercase().to_string()\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `ToUppercase`\n\nerror[E0599]: no method named `to_ascii_uppercase` found\
    \ for struct `ToLowercase` in the current scope\n  --> /tmp/tmpigjuq1id.rs:20:38\n\
    \   |\n20 |                     c.to_lowercase().to_ascii_uppercase().to_string()\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpigjuq1id.rs:23:21\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                        ------\
    \ expected `String` because of return type\n...\n23 |                     c\n\
    \   |                     ^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut t = s.to_lowercase();\n    let\
    \ mut res = t;\n    while t.len() > 0 {\n        match t.chars().next() {\n  \
    \          Some(c) if !c.is_alphanumeric() => (),\n            Some(c) => {\n\
    \                if c != c.to_uppercase() {\n                    t = t.replace(c.to_uppercase(),\
    \ c);\n                } else {\n                    t = t.replace(c.to_lowercase(),\
    \ c);\n                }\n            }\n            None => ()\n        }\n \
    \   }\n    if s != t {\n        res = t.to_string();\n    }\n    return res.to_string();\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj9o_cgoa.rs:18:25\n   |\n\
    18 |                 if c != c.to_uppercase() {\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj9o_cgoa.rs:19:53\n   |\n19 |              \
    \       t = t.replace(c.to_uppercase(), c);\n   |                            \
    \                         ^ expected `&str`, found `char`\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `ToUppercase`\n   --> /tmp/tmpj9o_cgoa.rs:19:35\n\
    \    |\n19  |                     t = t.replace(c.to_uppercase(), c);\n    | \
    \                          ------- ^^^^^^^^^^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `ToUppercase`\n    |                           |\n    |     \
    \                      required by a bound introduced by this call\n    |\n  \
    \  = help: the trait `FnMut<(char,)>` is not implemented for `ToUppercase`\n \
    \   = help: the following other types implement trait `Pattern<'a>`:\n       \
    \       &'b String\n              &'b [char; N]\n              &'b [char]\n  \
    \            &'b str\n              &'c &'b str\n              [char; N]\n   \
    \           char\n              pattern::MultiCharEqPattern<C>\n    = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `ToUppercase`\n\
    note: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj9o_cgoa.rs:21:53\n   |\n21 |                     t = t.replace(c.to_lowercase(),\
    \ c);\n   |                                                     ^ expected `&str`,\
    \ found `char`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `ToLowercase`\n\
    \   --> /tmp/tmpj9o_cgoa.rs:21:35\n    |\n21  |                     t = t.replace(c.to_lowercase(),\
    \ c);\n    |                           ------- ^^^^^^^^^^^^^^^^ expected an `FnMut<(char,)>`\
    \ closure, found `ToLowercase`\n    |                           |\n    |     \
    \                      required by a bound introduced by this call\n    |\n  \
    \  = help: the trait `FnMut<(char,)>` is not implemented for `ToLowercase`\n \
    \   = hel"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = &s;\n    let mut res = String::new();\n    for\
    \ c in s.chars().cloned() {\n        if c.is_alpha() {\n            if c.is_lower()\
    \ {\n                res.push((c as i32).to_string().to_uppercase());\n      \
    \      } else {\n                res.push((c as i32).to_string().to_lowercase());\n\
    \            }\n        } else {\n            res.push(*c);\n        }\n    }\n\
    \    res.reverse();\n    return res.to_string();\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpyve9ka63.rs:13:24\n     |\n13   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpyve9ka63.rs:13:14\n\
    \   |\n13 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpyve9ka63.rs:13:14\n   |\n13 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpyve9ka63.rs:24:9\n   |\n24 |     res.reverse();\n   | \
    \        ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut s = s\n    .chars()\n    .fold(String::new(),\
    \ |res, &c| {\n        if c.is_ascii_lowercase() {\n            res.push_str(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push_str(c.to_ascii_lowercase());\n       \
    \ }\n        res\n    });\n    \n    if s.len() == 0 {\n        \"\".to_string()\n\
    \    } else {\n        s\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtnzrbjn.rs:14:32\n   |\n\
    14 |     .fold(String::new(), |res, &c| {\n   |                              \
    \  ^--\n   |                                ||\n   |                         \
    \       |expected due to this\n   |                                expected `char`,\
    \ found reference\n   |                                help: did you mean `c`:\
    \ `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\"\n    }\n    let mut\
    \ c = s.chars().enumerate();\n    let mut newc = c.clone();\n    for (i, _) in\
    \ newc {\n        if newc.next().unwrap().1.is_lowercase() {\n            newc.next().unwrap().1.to_uppercase();\n\
    \        } else {\n            newc.next().unwrap().1.to_lowercase();\n      \
    \  }\n    }\n    String::from_utf8(c.collect()).unwrap()\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8px99at3.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\"\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `(usize, char)`\n    --> /tmp/tmp8px99at3.rs:23:23\n     |\n\
    23   |     String::from_utf8(c.collect()).unwrap()\n     |     -----------------\
    \ ^^^^^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ char)>`\n     |     |\n     |     required by a bound introduced by this call\n\
    \     |\n     = help: the trait `FromIterator<(usize, char)>` is not implemented\
    \ for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().filter_map(|c| c.is_alphanumeric()).collect::<Vec<_>>().reverse().join::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjct9lh4w.rs:11:30\n   |\n\
    11 |     s.chars().filter_map(|c| c.is_alphanumeric()).collect::<Vec<_>>().reverse().join::<String>()\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n11 |     s.chars().filter_map(|c|\
    \ Some(c.is_alphanumeric())).collect::<Vec<_>>().reverse().join::<String>()\n\
    \   |                              +++++                   +\n\nerror[E0599]:\
    \ no method named `join` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpjct9lh4w.rs:11:81\n   |\n11 |     s.chars().filter_map(|c| c.is_alphanumeric()).collect::<Vec<_>>().reverse().join::<String>()\n\
    \   |                                                                        \
    \         ^^^^ method not found in `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // your code here\n    \n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjpb7p__l.rs:10:24\n   |\n\
    10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() { return String::new(); }\n    let mut out\
    \ = String::new();\n    for i in s.chars() {\n        if i.is_alphanumeric() {\n\
    \            if i.is_lowercase() {\n                out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i.to_ascii_lowercase() {\n                    None\n          \
    \      } else {\n                    Some(String::from(*i))\n                }).collect();\n\
    \            } else {\n                out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i.to_ascii_uppercase() {\n                    None\n          \
    \      } else {\n                    Some(String::from(*i))\n                }).collect();\n\
    \            }\n        } else {\n            out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i {\n                None\n            } else {\n             \
    \   Some(String::from(*i))\n            }).collect();\n        }\n    }\n    if\
    \ out.is_empty() {\n        return s.to_string();\n    }\n    out.rev()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpotdk2obz.rs:16:70\n\
    \   |\n16 |                 out = out.chars().enumerate().filter_map(|(i, c)|\
    \ if *c != i.to_ascii_lowercase() {\n   |                                    \
    \                                  ^^\n\nerror[E0599]: no method named `to_ascii_lowercase`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpotdk2obz.rs:16:78\n\
    \   |\n16 |                 out = out.chars().enumerate().filter_map(|(i, c)|\
    \ if *c != i.to_ascii_lowercase() {\n   |                                    \
    \                                          ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `usize`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpotdk2obz.rs:19:39\n\
    \   |\n19 |                     Some(String::from(*i))\n   |                 \
    \                      ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpotdk2obz.rs:22:70\n   |\n22 |                 out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i.to_ascii_uppercase() {\n   |                                \
    \                                      ^^\n\nerror[E0599]: no method named `to_ascii_uppercase`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpotdk2obz.rs:22:78\n\
    \   |\n22 |                 out = out.chars().enumerate().filter_map(|(i, c)|\
    \ if *c != i.to_ascii_uppercase() {\n   |                                    \
    \                                          ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `usize`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpotdk2obz.rs:25:39\n\
    \   |\n25 |                     Some(String::from(*i))\n   |                 \
    \                      ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpotdk2obz.rs:29:66\n   |\n29 |             out = out.chars().enumerate().filter_map(|(i,\
    \ c)| if *c != i {\n   |                                                     \
    \             ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpotdk2obz.rs:32:35\n\
    \   |\n32 |                 Some(String::from(*i))\n   |                     \
    \              ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut lower = false;\n\
    \    for ch in s.chars() {\n        match ch {\n            'a' => if lower {\
    \ res.append('A'); lower = false; } else { res.append('a'); lower = true; },\n\
    \            'A' => if lower { res.append('a'); lower = false; } else { res.append('A');\
    \ lower = true; },\n            _ => res.append(ch),\n        }\n    }\n    res.reverse()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbyz7c75r.rs:15:35\n   |\n15 |             'a' =>\
    \ if lower { res.append('A'); lower = false; } else { res.append('a'); lower =\
    \ true; },\n   |                                   ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpbyz7c75r.rs:15:76\n   |\n15 |          \
    \   'a' => if lower { res.append('A'); lower = false; } else { res.append('a');\
    \ lower = true; },\n   |                                                     \
    \                       ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpbyz7c75r.rs:16:35\n   |\n16 |             'A' => if lower { res.append('a');\
    \ lower = false; } else { res.append('A'); lower = true; },\n   |            \
    \                       ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpbyz7c75r.rs:16:76\n   |\n16 |             'A' => if lower { res.append('a');\
    \ lower = false; } else { res.append('A'); lower = true; },\n   |            \
    \                                                                ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbyz7c75r.rs:17:22\n   |\n17 | \
    \            _ => res.append(ch),\n   |                      ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbyz7c75r.rs:20:9\n   |\n20 |  \
    \   res.reverse()\n   |         ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // Write your code here\n    let mut result = String::new();\n\
    \    for i in s.chars() {\n        if i.is_ascii_lowercase() {\n            result.push_str(i.to_uppercase());\n\
    \        } else {\n            result.push_str(i.to_lowercase());\n        }\n\
    \    }\n    if result.len() == 0 {\n        result\n    } else {\n        result\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9k7c8s0.rs:15:29\n   |\n\
    15 |             result.push_str(i.to_uppercase());\n   |                    \
    \         ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf9k7c8s0.rs:17:29\n   |\n17 |             result.push_str(i.to_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `ToLowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = s.to_lowercase();\n    let mut res = \"\";\n\
    \    match str {\n        \"a\" => \"b\",\n        \"b\" => \"a\",\n        \"\
    c\" => \"d\",\n        \"d\" => \"c\",\n        _ => str,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdiopi140.rs:14:9\n   |\n\
    13 |     match str {\n   |           --- this expression has type `String`\n14\
    \ |         \"a\" => \"b\",\n   |         ^^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdiopi140.rs:15:9\n \
    \  |\n13 |     match str {\n   |           --- this expression has type `String`\n\
    14 |         \"a\" => \"b\",\n15 |         \"b\" => \"a\",\n   |         ^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdiopi140.rs:16:9\n\
    \   |\n13 |     match str {\n   |           --- this expression has type `String`\n\
    ...\n16 |         \"c\" => \"d\",\n   |         ^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdiopi140.rs:17:9\n\
    \   |\n13 |     match str {\n   |           --- this expression has type `String`\n\
    ...\n17 |         \"d\" => \"c\",\n   |         ^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdiopi140.rs:14:16\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                        ------\
    \ expected `String` because of return type\n...\n14 |         \"a\" => \"b\",\n\
    \   |                ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.to_lowercase();\n    s.chars().for_each(|c| {\n\
    \        if !c.is_ascii_uppercase() {\n            s = s.to_lowercase().chars().fold(s,\
    \ |s, c| s.chars().rev().next().unwrap().to_string().chars().collect::<String>()\
    \ + c.to_string());\n        } else {\n            s = s.to_uppercase().chars().fold(s,\
    \ |s, c| s.chars().rev().next().unwrap().to_string().chars().collect::<String>()\
    \ + c.to_string());\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8xdjac_.rs:14:131\n   |\n\
    14 | ...ing().chars().collect::<String>() + c.to_string());\n   |            \
    \                            ^^^^^^^^^^^^^\n   |                             \
    \           |\n   |                                        expected `&str`, found\
    \ struct `String`\n   |                                        help: consider\
    \ borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw8xdjac_.rs:16:131\n\
    \   |\n16 | ...ing().chars().collect::<String>() + c.to_string());\n   |     \
    \                                   ^^^^^^^^^^^^^\n   |                      \
    \                  |\n   |                                        expected `&str`,\
    \ found struct `String`\n   |                                        help: consider\
    \ borrowing here: `&c.to_string()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    if s.len() == 0 {\n        return \"\"\n    }\n    \n\
    \    let mut s = String::from(s);\n    let mut res = String::from(\"\");\n   \
    \ \n    for i in 0..s.len() {\n        match &s[i] {\n            'a'..'z' =>\
    \ res = res.push_str(&(s[i] - 'a' + 10).to_string()),\n            'A'..'Z' =>\
    \ res = res.push_str(&(s[i] - 'A' + 10).to_string()),\n            _ => {}\n \
    \       }\n    }\n    \n    match res {\n        \n        s => s.to_string(),\n\
    \        \n        _ => \"\"\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmppc8y9uj3.rs:21:13\n\
    \   |\n21 |             'a'..'z' => res = res.push_str(&(s[i] - 'a' + 10).to_string()),\n\
    \   |             ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmppc8y9uj3.rs:22:13\n   |\n22 |             'A'..'Z' => res = res.push_str(&(s[i]\
    \ - 'A' + 10).to_string()),\n   |             ^^^^^^^^\n   |\n   = note: see issue\
    \ #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppc8y9uj3.rs:13:16\n   |\n10 |\
    \ fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n...\n13 |         return \"\"\n   |       \
    \         ^^- help: try using a conversion method: `.to_string()`\n   |      \
    \          |\n   |                expected struct `String`, found `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppc8y9uj3.rs:20:16\n\
    \   |\n20 |         match &s[i] {\n   |                ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppc8y9uj3.rs:21:46\n   |\n21 |             'a'..'z' => res = res.push_str(&(s[i]\
    \ - 'a' + 10).to_string()),\n   |                                            \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `In"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    if s.len() == 0 {\n        \"\"\n    } else if s.chars().all(|c|\
    \ is_letter(c)) {\n        \n        let mut chars = s.chars();\n        let mut\
    \ result = s.to_string();\n        let mut i = 0;\n        loop {\n          \
    \  if chars[i] != chars[i].to_ascii_lowercase() {\n                result.push_str(&chars[i]);\n\
    \                break;\n            } else if chars[i] == chars[i].to_ascii_lowercase()\
    \ {\n                chars[i] = chars[i].to_ascii_uppercase();\n            }\
    \ else {\n                chars[i] = chars[i].to_ascii_lowercase();\n        \
    \    }\n            i += 1;\n        }\n        result\n    } else {\n       \
    \ let mut chars = s.chars();\n        let mut result = s.to_string();\n      \
    \  let mut i = 0;\n        loop {\n            if chars[i] != chars[i].to_ascii_uppercase()\
    \ {\n                result.push_str(&chars[i]);\n                break;\n   \
    \         } else if chars[i] == chars[i].to_ascii_uppercase() {\n            \
    \    chars[i] = chars[i].to_ascii_lowercase();\n            } else {\n       \
    \         chars[i] = chars[i].to_ascii_uppercase();\n            }\n         \
    \   i += 1;\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpqm0tk_ls.rs:14:33\n\
    \   |\n14 |     } else if s.chars().all(|c| is_letter(c)) {\n   |            \
    \                     ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqm0tk_ls.rs:13:9\n   |\n10 | fn solve(s: String) -> String\
    \ {\n   |                        ------ expected `String` because of return type\n\
    ...\n13 |         \"\"\n   |         ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |         |\n   |         expected struct `String`, found\
    \ `&str`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  -->\
    \ /tmp/tmpqm0tk_ls.rs:20:16\n   |\n20 |             if chars[i] != chars[i].to_ascii_lowercase()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmpqm0tk_ls.rs:20:28\n   |\n20 |             if\
    \ chars[i] != chars[i].to_ascii_lowercase() {\n   |                          \
    \  ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n \
    \ --> /tmp/tmpqm0tk_ls.rs:21:34\n   |\n21 |                 result.push_str(&chars[i]);\n\
    \   |                                  ^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmpqm0tk_ls.rs:23:23\n   |\n23\
    \ |             } else if chars[i] == chars[i].to_ascii_lowercase() {\n   |  \
    \                     ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `Chars<'_>`\n  --> /tmp/tmpqm0tk_ls.rs:23:35\n   |\n23 |             } else\
    \ if chars[i] == chars[i].to_ascii_lowercase() {\n   |                       \
    \            ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpqm0tk_ls.rs:24:17\n   |\n24 |                 chars[i] = chars[i].to_ascii_uppercase();\n\
    \   |                 ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `Chars<'_>`\n  --> /tmp/tmpqm0tk_ls.rs:24:28\n   |\n24 |                 chars[i]\
    \ = chars[i].to_ascii_uppercase();\n   |                            ^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpqm0tk_ls.rs"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut reversed_string = String::new();\n    for i in s.chars()\
    \ {\n        reversed_string.push(i);\n    }\n    if s.chars().count() == 0 {\n\
    \        reversed_string.push(c);\n    }\n    reversed_string.swap();\n    reversed_string.to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmptyyobji1.rs:16:30\n\
    \   |\n16 |         reversed_string.push(c);\n   |                           \
    \   ^ help: a local variable with a similar name exists: `s`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmptyyobji1.rs:18:21\n   |\n18 |     reversed_string.swap();\n   |    \
    \                 ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars();\n    loop {\n        let c = match s.next()\
    \ {\n            None => break,\n            Some(_c) => _c,\n        };\n   \
    \     if c.is_alphabetical() {\n            if c.is_lowercase() {\n          \
    \      s = s.map(|c| c.to_uppercase()).collect();\n            } else {\n    \
    \            s = s.map(|c| c.to_lowercase()).collect();\n            }\n     \
    \   }\n    }\n    \"\".to_string()\n        .join(s)\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_alphabetical` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpsq5wabm1.rs:17:14\n   |\n17 |         if c.is_alphabetical()\
    \ {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_alphabetic`\n\nerror[E0277]: a value of type `Chars<'_>`\
    \ cannot be built from an iterator over elements of type `ToUppercase`\n    -->\
    \ /tmp/tmpsq5wabm1.rs:19:49\n     |\n19   |                 s = s.map(|c| c.to_uppercase()).collect();\n\
    \     |                                                 ^^^^^^^ value of type\
    \ `Chars<'_>` cannot be built from `std::iter::Iterator<Item=ToUppercase>`\n \
    \    |\n     = help: the trait `FromIterator<ToUppercase>` is not implemented\
    \ for `Chars<'_>`\nnote: required by a bound in `collect`\n\nerror[E0277]: a value\
    \ of type `Chars<'_>` cannot be built from an iterator over elements of type `ToLowercase`\n\
    \    --> /tmp/tmpsq5wabm1.rs:21:49\n     |\n21   |                 s = s.map(|c|\
    \ c.to_lowercase()).collect();\n     |                                       \
    \          ^^^^^^^ value of type `Chars<'_>` cannot be built from `std::iter::Iterator<Item=ToLowercase>`\n\
    \     |\n     = help: the trait `FromIterator<ToLowercase>` is not implemented\
    \ for `Chars<'_>`\nnote: required by a bound in `collect`\n\nerror[E0599]: no\
    \ method named `join` found for struct `String` in the current scope\n  --> /tmp/tmpsq5wabm1.rs:26:10\n\
    \   |\n26 |         .join(s)\n   |          ^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        let is_letter = c.is_ascii_letter();\n\
    \        if is_letter {\n            (c.to_ascii_lowercase(), c.to_ascii_uppercase())\n\
    \        } else {\n            c\n        }\n    }).fold(\"\", |mut acc, (c1,\
    \ c2)| {\n        match c1 { \n            // c1 is not equal to c2\n        \
    \    Some(c1_) => {\n                let c2_ = match c2 {\n                  \
    \  // if c2 is not equal to c2_, do nothing\n                    Some(c2_) =>\
    \ c2_,\n                    // if c2 is equal to c2_, just return the c2_\n  \
    \                  None => c2_,\n                };\n                let c1_ =\
    \ match c1_ {\n                    // if c1 is not equal to c1_, do nothing\n\
    \                    Some(c1_) => c1_,\n                    // if c1 is equal\
    \ to c1_, just return the c1_\n                    None => c1_,\n            \
    \    };\n                let mut c1_ = c1.clone();\n                c1_ += c2_;\n\
    \                c1_\n            },\n            // both c1 and c2 are equal\
    \ to c1_\n            None => c2,\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c2_` in this scope\n  --> /tmp/tmps3ghawpw.rs:26:29\n\
    \   |\n26 |                     None => c2_,\n   |                           \
    \  ^^^ help: a local variable with a similar name exists: `c1_`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmps3ghawpw.rs:12:27\n   |\n12 |         let is_letter = c.is_ascii_letter();\n\
    \   |                           ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmps3ghawpw.rs:16:13\n   |\n13 | /         if is_letter {\n\
    14 | |             (c.to_ascii_lowercase(), c.to_ascii_uppercase())\n   | |  \
    \           ------------------------------------------------ expected because\
    \ of this\n15 | |         } else {\n16 | |             c\n   | |             ^\
    \ expected tuple, found `char`\n17 | |         }\n   | |_________- `if` and `else`\
    \ have incompatible types\n   |\n   = note: expected tuple `(char, char)`\n  \
    \             found type `char`\n\nerror[E0308]: `match` arms have incompatible\
    \ types\n  --> /tmp/tmps3ghawpw.rs:32:29\n   |\n28 |                   let c1_\
    \ = match c1_ {\n   |  ___________________________-\n29 | |                  \
    \   // if c1 is not equal to c1_, do nothing\n30 | |                     Some(c1_)\
    \ => c1_,\n   | |                                  --- this is found to be of\
    \ type `_`\n31 | |                     // if c1 is equal to c1_, just return the\
    \ c1_\n32 | |                     None => c1_,\n   | |                       \
    \      ^^^ cyclic type of infinite size\n33 | |                 };\n   | |_________________-\
    \ `match` arms have incompatible types\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Option<Option<_>>`\n  --> /tmp/tmps3ghawpw.rs:35:17\n\
    \   |\n35 |                 c1_ += c2_;\n   |                 ---^^^^^^^\n   |\
    \                 |\n   |                 cannot use `+=` on type `Option<Option<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps3ghawpw.rs:36:17\n   |\n36 |\
    \                "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s.to_string();\n    }\n\n\
    \    let mut s = String::from(s);\n\n    while !s.is_empty() {\n        let c\
    \ = s.chars().next().unwrap().to_ascii_uppercase();\n        s = &s[1..s.len()\
    \ - 1].to_ascii_lowercase()[1..].to_string();\n        s = c + (&s[1..s.len()\
    \ - 1].to_ascii_lowercase()[1..]).to_string();\n    }\n\n    return s.to_string();\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw954pbfw.rs:19:13\n   |\n\
    15 |     let mut s = String::from(s);\n   |                 --------------- expected\
    \ due to this value\n...\n19 |         s = &s[1..s.len() - 1].to_ascii_lowercase()[1..].to_string();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n19 -         s = &s[1..s.len() - 1].to_ascii_lowercase()[1..].to_string();\n\
    19 +         s = s[1..s.len() - 1].to_ascii_lowercase()[1..].to_string();\n  \
    \ | \n\nerror[E0369]: cannot add `String` to `char`\n  --> /tmp/tmpw954pbfw.rs:20:15\n\
    \   |\n20 |         s = c + (&s[1..s.len() - 1].to_ascii_lowercase()[1..]).to_string();\n\
    \   |             - ^ ----------------------------------------------------------\
    \ String\n   |             |\n   |             char\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut newS = String::from(s);\n    for ch in s.chars()\
    \ {\n        if ch.is_ascii() {\n            newS = newS.replace_range(ch.start(),\
    \ ch.end(), \n                (ch.to_ascii_lowercase() + ch.to_ascii_uppercase()).to_string());\n\
    \        }\n    }\n    return newS\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `start` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpaeyword5.rs:15:42\n   |\n15 |             newS = newS.replace_range(ch.start(),\
    \ ch.end(), \n   |                                          ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `end` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpaeyword5.rs:15:54\n   |\n15 |             newS\
    \ = newS.replace_range(ch.start(), ch.end(), \n   |                          \
    \                            ^^^ method not found in `char`\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmpaeyword5.rs:16:42\n   |\n16 |          \
    \       (ch.to_ascii_lowercase() + ch.to_ascii_uppercase()).to_string());\n  \
    \ |                  ----------------------- ^ ----------------------- char\n\
    \   |                  |\n   |                  char\n\nerror[E0061]: this function\
    \ takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmpaeyword5.rs:15:25\n\
    \     |\n15   |             newS = newS.replace_range(ch.start(), ch.end(), \n\
    \     |                         ^^^^^^^^^^^^^ ----------  --------\n     |   \
    \                      |\n     |                         expected 2 arguments\n\
    16   |                 (ch.to_ascii_lowercase() + ch.to_ascii_uppercase()).to_string());\n\
    \     |                 ---------------------------------------------------------------\
    \ supplied 3 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaeyword5.rs:15:20\n   |\n12 |       let mut\
    \ newS = String::from(s);\n   |                      --------------- expected\
    \ due to this value\n...\n15 |               newS = newS.replace_range(ch.start(),\
    \ ch.end(), \n   |  ____________________^\n16 | |                 (ch.to_ascii_lowercase()\
    \ + ch.to_ascii_uppercase()).to_string());\n   | |________________________________________________________________________________^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmpaeyword5.rs:15:25\n   |\n15 |         \
    \    newS = newS.replace_rang"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().\n        filter(|c| c.is_ascii_ascii_case()).\n\
    \        map(|c| c.to_ascii_ascii_case()).\n        collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_ascii_case` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpli9g0a0_.rs:12:22\n   |\n12 |  \
    \       filter(|c| c.is_ascii_ascii_case()).\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii_lowercase`\n\
    \nerror[E0599]: no method named `to_ascii_ascii_case` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpli9g0a0_.rs:13:19\n   |\n13 |         map(|c|\
    \ c.to_ascii_ascii_case()).\n   |                   ^^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(String::new(), |mut acc, c| match c {\n    \
    \    'a' .. 'z' => {\n            *acc.push_str(&c.to_uppercase());\n        \
    \    acc\n        }\n        'A' .. 'Z' => {\n            *acc.push_str(&c.to_lowercase());\n\
    \            acc\n        }\n        _ => acc,\n    }).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpair2nn_q.rs:12:9\n\
    \   |\n12 |         'a' .. 'z' => {\n   |         ^^^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpair2nn_q.rs:16:9\n\
    \   |\n16 |         'A' .. 'Z' => {\n   |         ^^^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpair2nn_q.rs:13:27\n   |\n13 |\
    \             *acc.push_str(&c.to_uppercase());\n   |                        \
    \   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&ToUppercase`\n\n\
    error[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpair2nn_q.rs:13:13\n\
    \   |\n13 |             *acc.push_str(&c.to_uppercase());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpair2nn_q.rs:17:27\n   |\n17 |\
    \             *acc.push_str(&c.to_lowercase());\n   |                        \
    \   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&ToLowercase`\n\n\
    error[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpair2nn_q.rs:17:13\n\
    \   |\n17 |             *acc.push_str(&c.to_lowercase());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614, E0658.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::with_capacity(s.len());\n\n    for\
    \ c in s.chars() {\n        let i = match c.to_ascii_lowercase() {\n         \
    \   'A' => 0,\n            'a' => 1,\n            'B' => 2,\n            'b' =>\
    \ 3,\n            'C' => 4,\n            'c' => 5,\n            _ => continue,\n\
    \        };\n\n        let j = match c.to_ascii_uppercase() {\n            'A'\
    \ => 0,\n            'a' => 1,\n            'B' => 2,\n            'b' => 3,\n\
    \            'C' => 4,\n            'c' => 5,\n            _ => continue,\n  \
    \      };\n\n        result.push_str(&s[i as usize..j as usize].to_lowercase());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'begin <= end (1 <= 0) when slicing `AsDf`',\
    \ library/core/src/str/mod.rs:111:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        String::new()\n    } else {\n  \
    \      let mut s = String::from(s);\n        let mut res = String::new();\n  \
    \      for c in s.chars() {\n            if c.is_letter() {\n                let\
    \ mut revc = c;\n                if revc <= 'Z' {\n                    revc +=\
    \ 'a' - 'A';\n                } else {\n                    revc -= 'a' - 'A';\n\
    \                }\n                res += &revc;\n            } else {\n    \
    \            res += &c;\n            }\n        }\n        res\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpchwozsqn.rs:17:18\n   |\n17 |             if c.is_letter()\
    \ {\n   |                  ^^^^^^^^^ method not found in `char`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpchwozsqn.rs:20:33\n   |\n\
    20 |                     revc += 'a' - 'A';\n   |                            \
    \ --- ^ --- char\n   |                             |\n   |                   \
    \          char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpchwozsqn.rs:22:33\n\
    \   |\n22 |                     revc -= 'a' - 'A';\n   |                     \
    \        --- ^ --- char\n   |                             |\n   |            \
    \                 char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpchwozsqn.rs:24:24\n\
    \   |\n24 |                 res += &revc;\n   |                        ^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpchwozsqn.rs:26:24\n\
    \   |\n26 |                 res += &c;\n   |                        ^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut input = s.to_string();\n    if input.chars().all(|c|\
    \ !c.is_letter()) {\n        return input.to_owned();\n    }\n    let mut reversed\
    \ = s.clone();\n    reversed.chars().rev().for_each(|c| {\n        reversed.push_str(c.to_ascii_lowercase());\n\
    \    });\n    reversed.to_string()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpioov3avq.rs:12:33\n   |\n12 |     if input.chars().all(|c|\
    \ !c.is_letter()) {\n   |                                 ^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpioov3avq.rs:17:27\n\
    \   |\n17 |         reversed.push_str(c.to_ascii_lowercase());\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    for &c in s.chars() {\n        if c.is_ascii_lowercase() {\n\
    \            c.to_ascii_uppercase();\n        } else if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase();\n        } else {\n            c\n  \
    \      }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_97couxo.rs:11:9\n   |\n\
    11 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_s = s;\n    new_s = new_s.chars().filter_map(|c|{\n\
    \        match c {\n            'A'..='Z' => Some(c.to_string() + c.to_string()),\n\
    \            'a'..='z' => Some(c.to_string() + c.to_string()),\n            _\
    \ => None,\n        }\n    }).collect();\n    new_s.reverse();\n    new_s.join(\"\
    \");\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3g8i2m7j.rs:14:47\n   |\n\
    14 |             'A'..='Z' => Some(c.to_string() + c.to_string()),\n   |     \
    \                                          ^^^^^^^^^^^^^\n   |               \
    \                                |\n   |                                     \
    \          expected `&str`, found struct `String`\n   |                      \
    \                         help: consider borrowing here: `&c.to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3g8i2m7j.rs:15:47\n   |\n15 |  \
    \           'a'..='z' => Some(c.to_string() + c.to_string()),\n   |          \
    \                                     ^^^^^^^^^^^^^\n   |                    \
    \                           |\n   |                                          \
    \     expected `&str`, found struct `String`\n   |                           \
    \                    help: consider borrowing here: `&c.to_string()`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp3g8i2m7j.rs:19:11\n   |\n19 |     new_s.reverse();\n   |       \
    \    ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `join` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp3g8i2m7j.rs:20:11\n   |\n20 |     new_s.join(\"\");\n \
    \  |           ^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3g8i2m7j.rs:10:24\n   |\n10 | fn solve(s: String) -> String {\n\
    \   |    -----               ^^^^^^ expected struct `String`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    match s.len() {\n        1 => s.to_string(),\n        _ =>\
    \ {\n            let mut s = s;\n            let mut l = s.chars().count();\n\
    \            let mut c = 1;\n            for i in s.chars().rev().skip(l) {\n\
    \                if c.is_even() {\n                    c = 1;\n              \
    \      l = l - 1;\n                } else {\n                    c = 0;\n    \
    \            }\n                s = i.to_string() + s;\n            }\n      \
    \      s.to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmppgtavj4c.rs:18:22\n   |\n18 |                 if\
    \ c.is_even() {\n   |                      ^^^^^^^ method not found in `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppgtavj4c.rs:24:37\n   |\n24 |\
    \                 s = i.to_string() + s;\n   |                               \
    \      ^\n   |                                     |\n   |                   \
    \                  expected `&str`, found struct `String`\n   |              \
    \                       help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s: String = s;\n    for ch in s.chars() {\n       \
    \ if ch.is_ascii() {\n            let mut i = ch.as_bytes();\n            match\
    \ i.len() {\n                1 => {\n                    let (mut a, mut b) =\
    \ (*i.rbegin(), *i.rend());\n                    if *a >= 'a' && *a <= 'z' &&\
    \ *b >= 'a' && *b <= 'z' {\n                        *a = 'Z';\n              \
    \          *b = 'z';\n                    }\n                    else if *a >=\
    \ 'A' && *a <= 'Z' && *b >= 'A' && *b <= 'Z' {\n                        *a = 'z';\n\
    \                        *b = 'Z';\n                    }\n                  \
    \  else {\n                        *a = 'A';\n                        *b = 'a';\n\
    \                    }\n                }\n                2 => {\n          \
    \          let (mut a, mut b) = (*i.rbegin(), *i.rbegin());\n                \
    \    if *a >= 'a' && *a <= 'z' && *b >= 'a' && *b <= 'z' {\n                 \
    \       *a = 'Z';\n                        *b = 'z';\n                    }\n\
    \                    else if *a >= 'A' && *a <= 'Z' && *b >= 'A' && *b <= 'Z'\
    \ {\n                        *a = 'z';\n                        *b = 'Z';\n  \
    \                  }\n                    else {\n                        *a =\
    \ 'A';\n                        *b = 'a';\n                    }\n           \
    \     }\n                3 => {\n                    let (mut a, mut b) = (*i.rbegin(),\
    \ *i.rbegin());\n                    if *a >= 'a' && *a <= 'z' && *b >= 'a' &&\
    \ *b <= 'z' {\n                        *a = 'Z';\n                        *b =\
    \ 'z';\n                    }\n                    else if *a >= 'A' && *a <=\
    \ 'Z' && *b >= 'A' && *b <= 'Z' {\n                        *a = 'z';\n       \
    \                 *b = 'Z';\n                    }\n                    else {\n\
    \                        *a = 'A';\n                        *b = 'a';\n      \
    \              }\n                }\n                4 => {\n                \
    \    let (mut a, mut b) = (*i.rbegin(), *i.rbegin());\n                    if\
    \ *a >= 'a' && *a <= 'z' && *b >= 'a' && *b <= 'z' {\n                       \
    \ *a\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7xi9jrz9.rs:77:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n11 |     let mut s: String = s;\n12 |     for ch in\
    \ s.chars() {\n   |                         - unclosed delimiter\n13 |       \
    \  if ch.is_ascii() {\n   |                          - unclosed delimiter\n14\
    \ |             let mut i = ch.as_bytes();\n15 |             match i.len() {\n\
    \   |                           - unclosed delimiter\n...\n61 |              \
    \   4 => {\n   |                      - unclosed delimiter\n62 |             \
    \        let (mut a, mut b) = (*i.rbegin(), *i.rbegin());\n63 |              \
    \       if *a >= 'a' && *a <= 'z' && *b >= 'a' && *b <= 'z' {\n   |          \
    \                                                               - this delimiter\
    \ might not be properly closed...\n64 |                         *a\n65 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n77 | }\n \
    \  |   ^\n\nerror[E0599]: no method named `as_bytes` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp7xi9jrz9.rs:14:28\n   |\n14 |             let\
    \ mut i = ch.as_bytes();\n   |                            ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7xi9jrz9.rs:12:5\n\
    \   |\n10 |   fn solve(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n11 |       let mut s: String = s;\n\
    12 | /     for ch in s.chars() {\n13 | |         if ch.is_ascii() {\n14 | |  \
    \           let mut i = ch.as_bytes();\n15 | |             match i.len() {\n...\
    \  |\n76 | |     assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n77 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    match s.chars().count() {\n        0 => String::from(\"\"),\n\
    \        1 => String::from(s.to_lowercase()),\n        _ => String::from(s.to_lowercase().chars().collect::<String>().reverse().collect::<String>()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdcd2cgs6.rs:14:72\n   |\n14 |         _ => String::from(s.to_lowercase().chars().collect::<String>().reverse().collect::<String>()),\n\
    \   |                                                                        ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    for i in s.chars() {\n        if i.is_lowercase()\
    \ || i.is_uppercase() {\n            let mut tmp = i;\n            tmp = tmp.to()\
    \ as char;\n            tmp.swap(i);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to` found for type `char` in the current\
    \ scope\n  --> /tmp/tmps5j01wbb.rs:15:23\n   |\n15 |             tmp = tmp.to()\
    \ as char;\n   |                       ^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `swap` found for type `char` in the current scope\n  --> /tmp/tmps5j01wbb.rs:16:17\n\
    \   |\n16 |             tmp.swap(i);\n   |                 ^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = s.to_string();\n    for i in 0..str.len() {\n\
    \        let ch = str.chars().nth(i).unwrap();\n        if ch.is_uppercase() {\n\
    \            let char_int = ch.to_digit(10).unwrap();\n            str = str.chars().map(|&ch|\
    \ ch.to_ascii_lowercase().unwrap()).collect();\n            let char_upper = Char::from_u32(char_int\
    \ + 1).unwrap();\n            str = str.replace(i, i, char_upper);\n        }\
    \ else if ch.is_lowercase() {\n            let char_int = ch.to_digit(10).unwrap();\n\
    \            str = str.chars().map(|&ch| ch.to_ascii_uppercase().unwrap()).collect();\n\
    \            let char_lower = Char::from_u32(char_int + 1).unwrap();\n       \
    \     str = str.replace(i, i, char_lower);\n        } else {\n            str\
    \ = str.chars().collect();\n        }\n    }\n    str\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmp187pt2yl.rs:17:30\n\
    \   |\n17 |             let char_upper = Char::from_u32(char_int + 1).unwrap();\n\
    \   |                              ^^^^ use of undeclared type `Char`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmp187pt2yl.rs:22:30\n\
    \   |\n22 |             let char_lower = Char::from_u32(char_int + 1).unwrap();\n\
    \   |                              ^^^^ use of undeclared type `Char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp187pt2yl.rs:16:36\n   |\n16 |             str\
    \ = str.chars().map(|&ch| ch.to_ascii_lowercase().unwrap()).collect();\n   | \
    \                                   ^---\n   |                               \
    \     ||\n   |                                    |expected due to this\n   |\
    \                                    expected `char`, found reference\n   |  \
    \                                  help: did you mean `ch`: `&char`\n   |\n  \
    \ = note:   expected type `char`\n           found reference `&_`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp187pt2yl.rs:18:23\n\
    \    |\n18  |             str = str.replace(i, i, char_upper);\n    |        \
    \               ^^^^^^^ -  -  ---------- supplied 3 arguments\n    |         \
    \              |\n    |                       expected 2 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp187pt2yl.rs:21:36\n\
    \   |\n21 |             str = str.chars().map(|&ch| ch.to_ascii_uppercase().unwrap()).collect();\n\
    \   |                                    ^---\n   |                          \
    \          ||\n   |                                    |expected due to this\n\
    \   |                                    expected `char`, found reference\n  \
    \ |                                    help: did you mean `ch`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp187pt2yl.rs:23:23\n\
    \    |\n23  |             str = st"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut s_iter = s.chars().map(|c|\
    \ c.to_string());\n    loop {\n        if let Some(letter) = s_iter.next() {\n\
    \            let mut new_letter = letter;\n            if letter.is_lowercase()\
    \ {\n                new_letter += 'a' - 'A';\n            } else {\n        \
    \        new_letter += 'A' - 'a';\n            }\n            res += new_letter;\n\
    \        } else {\n            break;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpzps1ty1z.rs:16:23\n   |\n16 |          \
    \   if letter.is_lowercase() {\n   |                       ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_lowercase`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpzps1ty1z.rs:17:35\n   |\n\
    17 |                 new_letter += 'a' - 'A';\n   |                          \
    \     --- ^ --- char\n   |                               |\n   |             \
    \                  char\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmpzps1ty1z.rs:19:35\n   |\n19 |                 new_letter += 'A'\
    \ - 'a';\n   |                               --- ^ --- char\n   |            \
    \                   |\n   |                               char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzps1ty1z.rs:21:20\n   |\n21 |             res\
    \ += new_letter;\n   |                    ^^^^^^^^^^\n   |                   \
    \ |\n   |                    expected `&str`, found struct `String`\n   |    \
    \                help: consider borrowing here: `&new_letter`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut result = s;\n    let mut char_iter\
    \ = s.chars();\n    loop {\n        match char_iter.next() {\n            None\
    \ => break,\n            Some(c) if c.is_alphanumeric() => result += c.to_ascii_uppercase(),\n\
    \            Some(c) => result += c,\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsebywypj.rs:17:57\n   |\n\
    17 |             Some(c) if c.is_alphanumeric() => result += c.to_ascii_uppercase(),\n\
    \   |                                                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsebywypj.rs:18:34\n\
    \   |\n18 |             Some(c) => result += c,\n   |                        \
    \          ^ expected `&str`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::new();\n    for c in s {\n        if !c.is_alphanumeric()\
    \ {\n            s.push_str(c.to_lowercase());\n        } else {\n           \
    \ s.push_str(c.to_uppercase());\n        }\n    }\n    s.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpceuodttj.rs:12:14\n\
    \   |\n12 |     for c in s {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for i in s.chars() {\n  \
    \      if let Some(c) = i.to_ascii_lowercase() {\n            res.push_str(&c.to_string());\n\
    \        } else {\n            res.push_str(&i.to_string());\n        }\n    }\n\
    \    if res.is_empty() {\n        res = \"#\";\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7dpcghtr.rs:13:16\n   |\n\
    13 |         if let Some(c) = i.to_ascii_lowercase() {\n   |                ^^^^^^^\
    \   ---------------------- this expression has type `char`\n   |             \
    \   |\n   |                expected `char`, found enum `Option`\n   |\n   = note:\
    \ expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7dpcghtr.rs:20:15\n   |\n11 |     let mut res\
    \ = String::new();\n   |                   ------------- expected due to this\
    \ value\n...\n20 |         res = \"#\";\n   |               ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |               |\n   |            \
    \   expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    \n    let\
    \ mut s = s.chars().collect::<String>();\n    \n    let mut s = String::from(s);\n\
    \    \n    loop {\n        if s.chars().all(|c| *c == '#') {\n            break;\n\
    \        }\n        \n        if s.chars().all(|c| *c >= 'a' && *c <= 'z') {\n\
    \            s = s.chars().collect::<String>().collect::<String>().to_string().to_lowercase();\n\
    \        } else {\n            s = s.chars().collect::<String>().collect::<String>().to_string();\n\
    \        }\n    }\n    \n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmprga7cbbr.rs:20:30\n\
    \   |\n20 |         if s.chars().all(|c| *c == '#') {\n   |                  \
    \            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmprga7cbbr.rs:24:30\n\
    \   |\n24 |         if s.chars().all(|c| *c >= 'a' && *c <= 'z') {\n   |     \
    \                         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmprga7cbbr.rs:24:43\n   |\n24 |         if s.chars().all(|c| *c >=\
    \ 'a' && *c <= 'z') {\n   |                                           ^^\n\nerror[E0599]:\
    \ `String` is not an iterator\n   --> /tmp/tmprga7cbbr.rs:25:47\n    |\n25  |\
    \               s = s.chars().collect::<String>().collect::<String>().to_string().to_lowercase();\n\
    \    |                                                 ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmprga7cbbr.rs:27:47\n    |\n27  |         \
    \      s = s.chars().collect::<String>().collect::<String>().to_string();\n  \
    \  |                                                 ^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_ascii_alphanumeric() || c.is_ascii()\
    \ {\n        char::to_upper(c)\n    } else if c.is_ascii_lower() {\n        char::to_lower(c)\n\
    \    } else {\n        c\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `to_upper` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpksq0ppmc.rs:12:15\n   |\n12\
    \ |         char::to_upper(c)\n   |               ^^^^^^^^\n   |             \
    \  |\n   |               function or associated item not found in `char`\n   |\
    \               help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lower` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpksq0ppmc.rs:13:17\n   |\n13 |     } else if c.is_ascii_lower()\
    \ {\n   |                 ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no function or associated item\
    \ named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpksq0ppmc.rs:14:15\n\
    \   |\n14 |         char::to_lower(c)\n   |               ^^^^^^^^\n   |     \
    \          |\n   |               function or associated item not found in `char`\n\
    \   |               help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.len() == 0 {\n        return s.clone();\n    }\n\n   \
    \ let mut s = s.clone();\n\n    for i in 0..s.len() {\n        if s.chars().any(|c|\
    \ c == '#' || c == '@' || c == '.') {\n            s.swap(i, i + 1);\n       \
    \ }\n        if s.chars().any(|c| c == ' ') {\n            s.swap(i, i + 1);\n\
    \        }\n        if s.chars().any(|c| c == '-') {\n            s.swap(i, i\
    \ + 1);\n        }\n    }\n\n    s[0..s.len() - 1]\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0839iwdd.rs:19:15\n   |\n19 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current scope\n  --> /tmp/tmp0839iwdd.rs:22:15\n\
    \   |\n22 |             s.swap(i, i + 1);\n   |               ^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0839iwdd.rs:25:15\n   |\n25 |          \
    \   s.swap(i, i + 1);\n   |               ^^^^ method not found in `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0839iwdd.rs:29:5\n   |\n10 | fn\
    \ solve(s: String) -> String {\n   |                        ------ expected `String`\
    \ because of return type\n...\n29 |     s[0..s.len() - 1]\n   |     ^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\";\n    }\n    \n    let\
    \ mut s = String::from(s);\n    for i in 0..s.len() {\n        let ch = s.chars().nth(i);\n\
    \        if ch.is_some() {\n            let mut ch = ch.unwrap();\n          \
    \  if ch.is_lowercase() {\n                ch = ch.to_uppercase();\n         \
    \   } else if ch.is_uppercase() {\n                ch = ch.to_lowercase();\n \
    \           } else {\n                let mut j = i;\n                while j\
    \ != i && s.chars().nth(j).is_none() {\n                    j += 1;\n        \
    \        }\n                let mut ch = ch.to_string();\n                let\
    \ mut j = i;\n                while j != i && s.chars().nth(j).is_none() {\n \
    \                   j += 1;\n                }\n                for k in i..j\
    \ {\n                    ch = s.chars().nth(k).unwrap().to_string() + ch;\n  \
    \              }\n            }\n            s.insert(i, ch);\n        } else\
    \ {\n            s.insert(i, s.chars().nth(i).unwrap().to_string());\n       \
    \ }\n    }\n    \n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2hn_099w.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\";\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2hn_099w.rs:21:22\n   |\n19 |\
    \             let mut ch = ch.unwrap();\n   |                          -----------\
    \ expected due to this value\n20 |             if ch.is_lowercase() {\n21 |  \
    \               ch = ch.to_uppercase();\n   |                      ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToUppercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2hn_099w.rs:23:22\n   |\n19 |             let mut ch = ch.unwrap();\n\
    \   |                          ----------- expected due to this value\n...\n23\
    \ |                 ch = ch.to_lowercase();\n   |                      ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2hn_099w.rs:35:66\n   |\n35 |                     ch = s.chars().nth(k).unwrap().to_string()\
    \ + ch;\n   |                                                                \
    \  ^^\n   |                                                                  |\n\
    \   |                                                                  expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                          help: consider borrowing here: `&ch`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2hn_099w.rs:40:25\n   |\n40 |             s.insert(i,\
    \ s.chars().nth(i).unwrap().to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_s = \"\".to_string();\n\n    for c in s {\n   \
    \     if !c.is_ascii() {\n            new_s += char::ToLower(c).to_string();\n\
    \        } else {\n            new_s += c;\n        }\n    }\n\n    let mut iter\
    \ = new_s.chars();\n\n    while let Some(c) = (iter.next()) {\n        let new_c\
    \ = match c {\n            char::ToLower(c) => char::ToUpper(c),\n           \
    \ c => c,\n        };\n\n        new_s += new_c.to_string();\n    }\n\n    new_s\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmp7pee2gc8.rs:23:25\n   |\n23 |     while let Some(c) = (iter.next())\
    \ {\n   |                         ^           ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n23 -     while let Some(c)\
    \ = (iter.next()) {\n23 +     while let Some(c) = iter.next() {\n   | \n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp7pee2gc8.rs:13:14\n   |\n13 |   \
    \  for c in s {\n   |              ^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0599]: no associated item named `ToLower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp7pee2gc8.rs:15:28\n\
    \   |\n15 |             new_s += char::ToLower(c).to_string();\n   |         \
    \                   ^^^^^^^ associated item not found in `char`\n\nerror[E0599]:\
    \ no associated item named `ToLower` found for type `char` in the current scope\n\
    \  --> /tmp/tmp7pee2gc8.rs:25:19\n   |\n25 |             char::ToLower(c) => char::ToUpper(c),\n\
    \   |                   ^^^^^^^ associated item not found in `char`\n\nerror[E0599]:\
    \ no associated item named `ToUpper` found for type `char` in the current scope\n\
    \  --> /tmp/tmp7pee2gc8.rs:25:39\n   |\n25 |             char::ToLower(c) => char::ToUpper(c),\n\
    \   |                                       ^^^^^^^ associated item not found\
    \ in `char`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut s1 = s.to_string();\n    let mut s2 = s.to_string();\n\
    \    for i in s1.chars() {\n        if i.is_lowercase() {\n            i = i.to_upper().to_string();\n\
    \        } else {\n            i = i.to_lowercase().to_string();\n        }\n\
    \        s2.push_str(&i);\n    }\n    s2.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_db2n2fb.rs:16:19\n   |\n16 |             i = i.to_upper().to_string();\n\
    \   |                   ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_db2n2fb.rs:18:17\n\
    \   |\n14 |     for i in s1.chars() {\n   |         - expected due to the type\
    \ of this binding\n...\n18 |             i = i.to_lowercase().to_string();\n \
    \  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_db2n2fb.rs:20:21\n\
    \   |\n20 |         s2.push_str(&i);\n   |                     ^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .filter_map(|&x| x.is_ascii_lowercase()\
    \ || x.is_ascii_uppercase())\n        .map(|&x| if x.is_ascii_lowercase() { x.to_string().to_upper()\
    \ } else { x.to_string() })\n        .collect::<Vec<_>>()\n        .into_iter()\n\
    \        .fold(String::new(), |mut s, x| s.push_str(x).unwrap());\n    s\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7pagt130.rs:12:22\n   |\n\
    12 |         .filter_map(|&x| x.is_ascii_lowercase() || x.is_ascii_uppercase())\n\
    \   |                      ^--\n   |                      ||\n   |           \
    \           |expected due to this\n   |                      expected `char`,\
    \ found reference\n   |                      help: did you mean `x`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7pagt130.rs:12:26\n   |\n12 |  \
    \       .filter_map(|&x| x.is_ascii_lowercase() || x.is_ascii_uppercase())\n \
    \  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |         .filter_map(|&x| Some(x.is_ascii_lowercase() || x.is_ascii_uppercase()))\n\
    \   |                          +++++                                         \
    \       +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \        _ => c.to_string(),\n    }).join(\"\").chars().fold(s.chars().map(|c|\
    \ match c {\n        'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n     \
    \   _ => c.to_string(),\n    }).collect(), |mut s1, s2| {\n        s1.chars().fold(s2.chars().map(|c|\
    \ match c {\n            'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n \
    \           _ => c.to_string(),\n        }).collect(), |mut s2, s1| {\n      \
    \      if s2.is_empty() {\n                s1\n            } else {\n        \
    \        s2.chars().fold(s1.chars().map(|c| match c {\n                    'a'\
    \ .. 'z' => c.to_string().to_ascii_uppercase(),\n                    _ => c.to_string(),\n\
    \                }).collect(), |mut s1, s2| {\n                    s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                        'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n\
    \                        _ => c.to_string(),\n                    }).collect(),\
    \ |mut s1, s2| {\n                        s2.chars().fold(s1.chars().map(|c| match\
    \ c {\n                            'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \                            _ => c.to_string(),\n                        }).collect(),\
    \ |mut s1, s2| {\n                            s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                                'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n\
    \                                _ => c.to_string(),\n                       \
    \     }).collect(), |mut s1, s2| {\n                                s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n                                    'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n\
    \                                    _ => c.to_string(),\n                   \
    \             }).collect(), |mut s1, s2| {\n                                 \
    \   s2.chars().fold(s1.chars().map(|c| match c {\n                           \
    \             'a' .. 'z' => c.to_string().to_ascii_lowercase(),\n            \
    \                            _ => c.to_string(),\n                           \
    \         }).collect(), |mut s1, s2| {\n                                     \
    \   s2.chars().fold(s1.chars().map(|c| match c {\n                           \
    \                 'a' .. 'z' => c.to_string().to_ascii_uppercase(),\n        \
    \                                    _ => c.to_string(),\n                   \
    \                     }).collect(), |mut s1, s2| {\n                         \
    \                   s2.char\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2017q8hf.rs:66:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n14 |     }).join(\"\").chars().fold(s.chars().map(|c|\
    \ match c {\n   |                             - unclosed delimiter\n...\n17 |\
    \     }).collect(), |mut s1, s2| {\n   |                                - unclosed\
    \ delimiter\n18 |         s1.chars().fold(s2.chars().map(|c| match c {\n   | \
    \                       - unclosed delimiter\n...\n21 |         }).collect(),\
    \ |mut s2, s1| {\n   |                                    - unclosed delimiter\n\
    ...\n24 |             } else {\n   |                    - unclosed delimiter\n\
    25 |                 s2.chars().fold(s1.chars().map(|c| match c {\n   |      \
    \                          - unclosed delimiter\n...\n28 |                 }).collect(),\
    \ |mut s1, s2| {\n   |                                            - unclosed delimiter\n\
    29 |                     s2.chars().fold(s1.chars().map(|c| match c {\n   |  \
    \                                  - unclosed delimiter\n...\n32 |           \
    \          }).collect(), |mut s1, s2| {\n   |                                \
    \                - unclosed delimiter\n33 |                         s2.chars().fold(s1.chars().map(|c|\
    \ match c {\n   |                                        - unclosed delimiter\n\
    ...\n36 |                         }).collect(), |mut s1, s2| {\n   |         \
    \                                           - unclosed delimiter\n37 |       \
    \                      s2.chars().fold(s1.chars().map(|c| match c {\n   |    \
    \                                        - unclosed delimiter\n...\n40 |     \
    \                        }).collect(), |mut s1, s2| {\n   |                  \
    \                                      - unclosed delimiter\n41 |            \
    \                     s2.chars().fold(s1.chars().map(|c| match c {\n   |     \
    \                                           - unclosed delimiter\n...\n44 |  \
    \                               }).collect(), |mut s1, s2| {\n   |           \
    \                                           "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    chars.rev();\n    let mut res\
    \ = String::new();\n    chars.for_each(|c| match c {\n        Some(c) => {\n \
    \           match c.to_ascii_lowercase() {\n                Some(c) => c.to_ascii_uppercase().unwrap().append(&mut\
    \ res),\n                None => c.append(&mut res),\n            }\n        },\n\
    \        None => c.append(&mut res),\n    });\n    res\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5v7vcfk5.rs:15:9\n   |\n\
    14 |     chars.for_each(|c| match c {\n   |                              - this\
    \ expression has type `char`\n15 |         Some(c) => {\n   |         ^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5v7vcfk5.rs:21:9\n   |\n14 |     chars.for_each(|c| match c {\n   |\
    \                              - this expression has type `char`\n...\n21 |  \
    \       None => c.append(&mut res),\n   |         ^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0599]: no method named `append` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp5v7vcfk5.rs:21:19\n   |\n21 |         None\
    \ => c.append(&mut res),\n   |                   ^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| c.is_ascii_letter()) {\n        solve2(s.chars().filter(|c|\
    \ !c.is_ascii_letter()).collect::<String>())\n    } else {\n        solve2(s.chars().collect::<String>())\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `solve2` in this scope\n  --> /tmp/tmp464i7q9s.rs:12:9\n\
    \   |\n12 |         solve2(s.chars().filter(|c| !c.is_ascii_letter()).collect::<String>())\n\
    \   |         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `solve2` in this scope\n  --> /tmp/tmp464i7q9s.rs:14:9\n   |\n14 |         solve2(s.chars().collect::<String>())\n\
    \   |         ^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmp464i7q9s.rs:11:28\n\
    \   |\n11 |     if s.chars().all(|c| c.is_ascii_letter()) {\n   |            \
    \                ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp464i7q9s.rs:12:40\n\
    \   |\n12 |         solve2(s.chars().filter(|c| !c.is_ascii_letter()).collect::<String>())\n\
    \   |                                        ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::with_capacity(s.len());\n\n    for ch\
    \ in s.chars() {\n        if let Some(letter) = Letter::from(ch) {\n         \
    \   res.push_str(letter.to_uppercase());\n        } else {\n            res.push(*ch);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Letter`\n  -->\
    \ /tmp/tmpb9f11j1r.rs:14:31\n   |\n14 |         if let Some(letter) = Letter::from(ch)\
    \ {\n   |                               ^^^^^^ use of undeclared type `Letter`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpb9f11j1r.rs:17:22\n\
    \   |\n17 |             res.push(*ch);\n   |                      ^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0614.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    match s.chars().cloned() {\n        &[&c] => if c.is_letter()\
    \ {\n            c.to_uppercase().to_string().to_string()\n        } else {\n\
    \            c.to_string().to_string()\n        },\n        _ => s.to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpyng2e6w6.rs:11:21\n     |\n11   |     match s.chars().cloned()\
    \ {\n     |                     ^^^^^^ expected reference, found `char`\n    \
    \ |\n     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyng2e6w6.rs:12:9\n   |\n11 |     match s.chars().cloned() {\n   |  \
    \         ------------------ this expression has type `Cloned<Chars<'_>>`\n12\
    \ |         &[&c] => if c.is_letter() {\n   |         ^^^^^ expected struct `Cloned`,\
    \ found reference\n   |\n   = note: expected struct `Cloned<Chars<'_>>`\n    \
    \       found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut a = s.to_lowercase();\n    let mut b = s.to_lowercase();\n\
    \    for i in 0..a.len() {\n        if a[i] >= 'a' && a[i] <= 'z' {\n        \
    \    let c = a[i] - 'a' + 10;\n            b = b.chars().map(|x| *x - c).collect::<String>();\n\
    \        }\n        if a[i] >= 'A' && a[i] <= 'Z' {\n            let c = a[i]\
    \ - 'A' + 10;\n            a = a.chars().map(|x| *x - c).collect::<String>();\n\
    \        }\n    }\n    return a + \"#\" + b;\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpddaoxrcl.rs:14:12\n\
    \   |\n14 |         if a[i] >= 'a' && a[i] <= 'z' {\n   |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpddaoxrcl.rs:14:27\n   |\n14 |         if a[i] >= 'a' && a[i] <=\
    \ 'z' {\n   |                           ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpddaoxrcl.rs:15:21\n   |\n15 |             let c = a[i] - 'a' +\
    \ 10;\n   |                     ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        s\n    } else {\n        let mut\
    \ str = String::new();\n        for ch in s.chars() {\n            if ch.is_uppercase()\
    \ {\n                str = format!(\"{}{}\", ch, str);\n            } else {\n\
    \                str = format!(\"{}{}\", str.to_lowercase(), ch);\n          \
    \  }\n        }\n        str\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dasf\"`,\n right: `\"aSdF\"`', /tmp/tmpq0e57ip7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c| {\n\
    \        if c.is_ascii() {\n            match c {\n                'a' => s.push_str(c.to_lowercase()),\n\
    \                'A' => s.push_str(c.to_uppercase()),\n                '#' =>\
    \ s.push_str(\"##\"),\n                '$' => s.push_str(\"$$\"),\n          \
    \      _ => (),\n            }\n        } else {\n            match c {\n    \
    \            'a' => s.push_str(c.to_uppercase()),\n                'A' => s.push_str(c.to_lowercase()),\n\
    \                '#' => s.push_str(\"##\"),\n                '$' => s.push_str(\"\
    $$\"),\n                _ => (),\n            }\n        }\n    });\n    s\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkyme4ome.rs:15:35\n   |\n\
    15 |                 'a' => s.push_str(c.to_lowercase()),\n   |              \
    \                     ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkyme4ome.rs:16:35\n   |\n16 |\
    \                 'A' => s.push_str(c.to_uppercase()),\n   |                 \
    \                  ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkyme4ome.rs:23:35\n   |\n23 |\
    \                 'a' => s.push_str(c.to_uppercase()),\n   |                 \
    \                  ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkyme4ome.rs:24:35\n   |\n24 |\
    \                 'A' => s.push_str(c.to_lowercase()),\n   |                 \
    \                  ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(String::new(), |mut s, c| match c {\n      \
    \  'a' => {\n            s.push_str(s.chars().filter(|c| c.is_ascii_letter()).collect());\n\
    \            s.push_str(s.chars().filter(|c| !c.is_ascii_letter()).collect())\n\
    \        }\n        'A' => {\n            s.push_str(s.chars().filter(|c| c.is_ascii_letter()).collect());\n\
    \            s.push_str(s.chars().filter(|c| !c.is_ascii_letter()).collect())\n\
    \        }\n        _ => s.push(c),\n    })\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpzi1wkmi5.rs:13:47\n   |\n13 |          \
    \   s.push_str(s.chars().filter(|c| c.is_ascii_letter()).collect());\n   |   \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0277]: a value\
    \ of type `&str` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpzi1wkmi5.rs:13:66\n     |\n13   |             s.push_str(s.chars().filter(|c|\
    \ c.is_ascii_letter()).collect());\n     |                                   \
    \                               ^^^^^^^ value of type `&str` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `&str`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpzi1wkmi5.rs:14:48\n\
    \   |\n14 |             s.push_str(s.chars().filter(|c| !c.is_ascii_letter()).collect())\n\
    \   |                                                ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0277]: a\
    \ value of type `&str` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpzi1wkmi5.rs:14:67\n     |\n14   |             s.push_str(s.chars().filter(|c|\
    \ !c.is_ascii_letter()).collect())\n     |                                   \
    \                                ^^^^^^^ value of type `&str` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `&str`\n     = "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'a' => if c.is_uppercase()\
    \ { c.to_ascii_lowercase() } else { c.to_ascii_uppercase() },\n        'A' =>\
    \ if c.is_lowercase() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()\
    \ },\n        _ => c,\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asDf\"`,\n right: `\"aSdF\"`', /tmp/tmp9_tjttrk.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for (i, char) in s.chars().enumerate()\
    \ {\n        if char >= 'a' && char <= 'z' {\n            match char {\n     \
    \           'a' => res.push_str(\"A\"),\n                'b' => res.push_str(\"\
    B\"),\n                'c' => res.push_str(\"C\"),\n                'd' => res.push_str(\"\
    D\"),\n                'e' => res.push_str(\"E\"),\n                'f' => res.push_str(\"\
    F\"),\n                'g' => res.push_str(\"G\"),\n                'h' => res.push_str(\"\
    H\"),\n                'i' => res.push_str(\"I\"),\n                'j' => res.push_str(\"\
    J\"),\n                'k' => res.push_str(\"K\"),\n                'l' => res.push_str(\"\
    L\"),\n                'm' => res.push_str(\"M\"),\n                'n' => res.push_str(\"\
    N\"),\n                'o' => res.push_str(\"O\"),\n                'p' => res.push_str(\"\
    P\"),\n                'q' => res.push_str(\"Q\"),\n                'r' => res.push_str(\"\
    R\"),\n                's' => res.push_str(\"S\"),\n                't' => res.push_str(\"\
    T\"),\n                'u' => res.push_str(\"U\"),\n                'v' => res.push_str(\"\
    V\"),\n                'w' => res.push_str(\"W\"),\n                'x' => res.push_str(\"\
    X\"),\n                'y' => res.push_str(\"Y\"),\n                'z' => res.push_str(\"\
    Z\"),\n                _ => res\n            }\n        } else {\n           \
    \ match char {\n                'A' => res.push_str(\"a\"),\n                'B'\
    \ => res.push_str(\"b\"),\n                'C' => res.push_str(\"c\"),\n     \
    \           'D' => res.push_str(\"d\"),\n                'E' => res.push_str(\"\
    e\"),\n                'F' => res.push_str(\"f\"),\n                'G' => res.push_str(\"\
    g\"),\n                'H' => res.push_str(\"h\"),\n                'I' => res.push_str(\"\
    i\"),\n                'J' => res.push_str(\"j\"),\n                'K' => res.push_str(\"\
    k\"),\n                'L' => res.push_str(\"l\"),\n                'M' => res.push_str(\"\
    m\"),\n                'N' => res.push_str(\"n\"),\n                'O' => res.push_str(\"\
    o\"),\n                'P' => res.push_str(\"p\"),\n                'Q' => res.push_str(\"\
    q\"),\n                'R' => res.push_str(\"r\"),\n                'S' => res.push_str(\"\
    s\"),\n                'T' => res.push_str(\"t\"),\n                'U' => res.push_str(\"\
    u\"),\n                'V' => res.push_str(\"v\"),\n                'W' => res.push_str(\"\
    w\"),\n                'X' => res.push_str(\"x\"),\n                'Y' => res.push_str(\"\
    y\"),\n                'Z\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpegrewitp.rs:83:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n11 |     let mut res = String::new();\n12 |     for\
    \ (i, char) in s.chars().enumerate() {\n   |                                 \
    \           - unclosed delimiter\n...\n43 |         } else {\n   |           \
    \     - unclosed delimiter\n44 |             match char {\n   |              \
    \          - this delimiter might not be properly closed...\n...\n71 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n83 | }\n   |\
    \   ^\n\nerror: expected pattern, found `'Z`\n  --> /tmp/tmpegrewitp.rs:70:17\n\
    \   |\n70 |                 'Z\n   |                 ^^ expected pattern\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmpegrewitp.rs:41:22\n   |\n\
    14 | /             match char {\n15 | |                 'a' => res.push_str(\"\
    A\"),\n16 | |                 'b' => res.push_str(\"B\"),\n17 | |            \
    \     'c' => res.push_str(\"C\"),\n...  |\n40 | |                 'z' => res.push_str(\"\
    Z\"),\n   | |                        ----------------- this and all prior arms\
    \ are found to be of type `()`\n41 | |                 _ => res\n   | |      \
    \                ^^^ expected `()`, found struct `String`\n42 | |            \
    \ }\n   | |_____________- `match` arms have incompatible types\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpegrewitp.rs:12:5\n   |\n10 |   fn solve(s: String)\
    \ -> String {\n   |                          ------ expected `String` because\
    \ of return type\n11 |       let mut res = String::new();\n12 | /     for (i,\
    \ char) in s.chars().enumerate() {\n13 | |         if char >= 'a' && char <= 'z'\
    \ {\n14 | |             match char {\n15 | |                 'a' => res.push_str(\"\
    A\"),\n...  |\n82 | |     assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n83 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.len() == 0 {\n        return \"\";\n    }\n    let mut\
    \ reversed = false;\n    let mut res = String::new();\n    for i in s.chars()\
    \ {\n        if let Some(letter) = i.to_ascii_lowercase() {\n            reversed\
    \ = !reversed;\n            letter = String::from(letter.to_ascii_uppercase());\n\
    \            res.append(&letter);\n        } else {\n            res.append(&i);\n\
    \        }\n    }\n    if reversed {\n        let mut reverse = String::new();\n\
    \        for i in res.chars() {\n            let mut temp: String = String::new();\n\
    \            let mut last: String = String::new();\n            for j in i.chars()\
    \ {\n                match j {\n                    Some('a'..'z') => temp.push(*j),\n\
    \                    Some('A'..'Z') => temp.push(*j),\n                    _ =>\
    \ last.append(j)\n                }\n            }\n            res.append(&temp);\n\
    \            res.append(&last);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpg4dqktqt.rs:32:26\n\
    \   |\n32 |                     Some('a'..'z') => temp.push(*j),\n   |       \
    \                   ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpg4dqktqt.rs:33:26\n   |\n33 |                     Some('A'..'Z')\
    \ => temp.push(*j),\n   |                          ^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg4dqktqt.rs:12:16\n   |\n10 |\
    \ fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.len() == 0 {\n12 |         return\
    \ \"\";\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg4dqktqt.rs:17:16\n   |\n17 |\
    \         if let Some(letter) = i.to_ascii_lowercase() {\n   |               \
    \ ^^^^^^^^^^^^   ---------------------- this expression has type `char`\n   |\
    \                |\n   |                expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpg4dqktqt.rs:20:17\n   |\n20 |             res.append(&letter);\n\
    \   |                 ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpg4dqktqt.rs:22:17\n   |\n22 |             res.append(&i);\n   |    \
    \             ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpg4dqktqt.rs:30:24\n\
    \   |\n30 |             for j in i.chars() {\n   |                        ^^^^^\
    \ method not found in `char`\n\nerror[E0614]: type `Option<char>` can"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmp8v1hcq_3.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_str: String = \"\";\n    let mut cnt: usize = 0;\n\
    \    for c in s.chars() {\n        if c.is_ascii_letter() {\n            new_str\
    \ += c.to_ascii_uppercase();\n        } else {\n            new_str += c.to_ascii_lowercase();\n\
    \        }\n        cnt += 1;\n    }\n    if cnt == 0 {\n        new_str = new_str.to_ascii_lowercase();\n\
    \    }\n    new_str\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40wvwa0f.rs:11:31\n   |\n\
    11 |     let mut new_str: String = \"\";\n   |                      ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp40wvwa0f.rs:14:14\n   |\n14 |         if c.is_ascii_letter() {\n\
    \   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40wvwa0f.rs:15:24\n\
    \   |\n15 |             new_str += c.to_ascii_uppercase();\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp40wvwa0f.rs:17:24\n   |\n17 |             new_str\
    \ += c.to_ascii_lowercase();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for i in s.chars() {\n  \
    \      res.push_str(i.to_ascii_lowercase());\n    }\n    if res.chars().count()\
    \ > 0 {\n        res.push_str(s.chars().count());\n    } else {\n        res.push_str(s);\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7h63h0k1.rs:13:22\n   |\n\
    13 |         res.push_str(i.to_ascii_lowercase());\n   |                     \
    \ ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7h63h0k1.rs:16:22\n   |\n16 |         res.push_str(s.chars().count());\n\
    \   |                      ^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7h63h0k1.rs:18:22\n   |\n18 |  \
    \       res.push_str(s);\n   |                      ^\n   |                  \
    \    |\n   |                      expected `&str`, found struct `String`\n   |\
    \                      help: consider borrowing here: `&s`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(\"\", |mut acc, c| if c.is_ascii_uppercase()\
    \ {\n        acc.push_str(&c.to_ascii_lowercase())\n    } else {\n        acc.push_str(&c.to_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvvahcfrb.rs:11:20\n   |\n\
    11 |     s.chars().fold(\"\", |mut acc, c| if c.is_ascii_uppercase() {\n   | \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvvahcfrb.rs:12:22\n\
    \   |\n12 |         acc.push_str(&c.to_ascii_lowercase())\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvvahcfrb.rs:12:9\n   |\n12 |         acc.push_str(&c.to_ascii_lowercase())\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpvvahcfrb.rs:12:13\n   |\n12 |         acc.push_str(&c.to_ascii_lowercase())\n\
    \   |         --- ^^^^^^^^ this call modifies `acc` in-place\n   |         |\n\
    \   |         you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvvahcfrb.rs:14:22\n   |\n14 |         acc.push_str(&c.to_ascii_uppercase())\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvvahcfrb.rs:14:9\n   |\n14 | \
    \        acc.push_str(&c.to_ascii_uppercase())\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpvvahcfrb.rs:14:13\n   |\n14 |         acc.push_str(&c.to_ascii_uppercase())\n\
    \   |         --- ^^^^^^^^ this call modifies `acc` in-place\n   |         |\n\
    \   |         you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(s.to_owned(), |acc, c| match c {\n        'a'\
    \ => acc.to_owned().to_string().to_string().to_lowercase() + c.to_string(),\n\
    \        'A' => acc.to_owned().to_string().to_string().to_uppercase() + c.to_string(),\n\
    \        _ => c,\n    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpani23rff.rs:12:72\n   |\n\
    12 |         'a' => acc.to_owned().to_string().to_string().to_lowercase() + c.to_string(),\n\
    \   |                                                                        ^^^^^^^^^^^^^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpani23rff.rs:13:72\n   |\n13 |\
    \         'A' => acc.to_owned().to_string().to_string().to_uppercase() + c.to_string(),\n\
    \   |                                                                        ^^^^^^^^^^^^^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpani23rff.rs:14:14\n\
    \   |\n11 |       s.chars().fold(s.to_owned(), |acc, c| match c {\n   |  ___________________________________________-\n\
    12 | |         'a' => acc.to_owned().to_string().to_string().to_lowercase() +\
    \ c.to_string(),\n   | |                ---------------------------------------------------------------------\
    \ this is found to be of type `String`\n13 | |         'A' => acc.to_owned().to_string().to_string().to_uppercase()\
    \ + c.to_string(),\n   | |                ---------------------------------------------------------------------\
    \ this is found to be of type `String`\n14 | |         _ => c,\n   | |       \
    \       ^- help: try using a conversion method: `.to_string()`\n   | |       \
    \       |\n   | |              expected struct `String`, found `char`\n15 | |\
    \     })\n   | |_____- `match` arms have incompatible types\n\nerror: aborting\
    \ due to 3 pre"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars().collect::<Vec<_>>();\n    let mut res\
    \ = s.clone();\n    for i in 0..s.len() {\n        if s.len() == 1 {\n       \
    \     break;\n        }\n        match s.chars().nth(i).unwrap() {\n         \
    \   'A' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            'a' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            '0' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            '#' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \            _ => (),\n        };\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpyzrk5j8k.rs:17:17\n   |\n17 |         match s.chars().nth(i).unwrap()\
    \ {\n   |                 ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpyzrk5j8k.rs:18:30\n   |\n18 |             'A' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \   |                              ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpyzrk5j8k.rs:19:30\n   |\n19 |             'a' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \   |                              ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpyzrk5j8k.rs:20:30\n   |\n20 |             '0' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \   |                              ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpyzrk5j8k.rs:21:30\n   |\n21 |             '#' => res = res.chars().collect::<String>().reverse().collect::<String>().clone(),\n\
    \   |                              ^^^^^ method not found in `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyzrk5j8k.rs:25:5\n   |\n10 | fn solve(s: String)\
    \ -> String {\n   |                        ------ expected `String` because of\
    \ return type\n...\n25 |     res\n   |     ^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `String`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'a' | 'A' => c.to_uppercase(),\n\
    \        'b' | 'B' => c.to_lowercase(),\n        _ => c,\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp1uh11kdu.rs:13:22\n\
    \   |\n11 |       s.chars().map(|c| match c {\n   |  _______________________-\n\
    12 | |         'a' | 'A' => c.to_uppercase(),\n   | |                      ----------------\
    \ this is found to be of type `ToUppercase`\n13 | |         'b' | 'B' => c.to_lowercase(),\n\
    \   | |                      ^^^^^^^^^^^^^^^^ expected struct `ToUppercase`, found\
    \ struct `ToLowercase`\n14 | |         _ => c,\n15 | |     }).collect()\n   |\
    \ |_____- `match` arms have incompatible types\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|&c| match c {\n        'a' .. 'z' => c.to_string().to_uppercase().to_string(),\n\
    \        'A' .. 'Z' => c.to_string().to_lowercase().to_string(),\n        _ =>\
    \ c.to_string(),\n    }).collect::<String>() + s.chars().last().to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmprqebdrqc.rs:12:9\n\
    \   |\n12 |         'a' .. 'z' => c.to_string().to_uppercase().to_string(),\n\
    \   |         ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmprqebdrqc.rs:13:9\n   |\n13 |         'A' .. 'Z' => c.to_string().to_lowercase().to_string(),\n\
    \   |         ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprqebdrqc.rs:11:20\n\
    \   |\n11 |     s.chars().map(|&c| match c {\n   |                    ^--\n  \
    \ |                    ||\n   |                    |expected due to this\n   |\
    \                    expected `char`, found reference\n   |                  \
    \  help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmprqebdrqc.rs:15:47\n    |\n15  |       }).collect::<String>()\
    \ + s.chars().last().to_string()\n    |                                      \
    \           ^^^^^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: std::fmt::Display`\n            which is required by `Option<char>:\
    \ ToString`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0658.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ans = \"\";\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if char::is_ascii_lowercase(&s[i..]) {\n            ans.push_str(&s[i\
    \ ..].rev());\n        } else if char::is_ascii_uppercase(&s[i..]) {\n       \
    \     ans.push_str(&s[i ..].rev());\n        } else {\n            ans.push_str(&s[i\
    \ ..]);\n        }\n        i += 1;\n    }\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nf9mzcd.rs:14:37\n   |\n\
    14 |         if char::is_ascii_lowercase(&s[i..]) {\n   |                    \
    \                 ^^^^^^^ expected `char`, found `str`\n   |\n   = note: expected\
    \ reference `&char`\n              found reference `&str`\n\nerror[E0599]: no\
    \ method named `push_str` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmp9nf9mzcd.rs:15:17\n   |\n15 |             ans.push_str(&s[i ..].rev());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: `str`\
    \ is not an iterator\n  --> /tmp/tmp9nf9mzcd.rs:15:35\n   |\n15 |            \
    \ ans.push_str(&s[i ..].rev());\n   |                                   ^^^ `str`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9nf9mzcd.rs:16:44\n   |\n16 |\
    \         } else if char::is_ascii_uppercase(&s[i..]) {\n   |                \
    \                            ^^^^^^^ expected `char`, found `str`\n   |\n   =\
    \ note: expected reference `&char`\n              found reference `&str`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp9nf9mzcd.rs:17:17\n   |\n17 |             ans.push_str(&s[i ..].rev());\n\
    \   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: `str`\
    \ is not an iterator\n  --> /tmp/tmp9nf9mzcd.rs:17:35\n   |\n17 |            \
    \ ans.push_str(&s[i ..].rev());\n   |                                   ^^^ `str`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: no method named `push_str` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp9nf9mzcd.rs:19:17\n   |\n19 |             ans.push_str(&s[i\
    \ ..]);\n   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nf9mzcd.rs:23:5\n   |\n10 | fn solve(s: String)\
    \ -> String {\n   |           "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::from(s);\n    for i in 0..s.len() {\n\
    \        if s[i].is_ascii() {\n            res.swap(i, s.len() - i);\n       \
    \ } else {\n            res.swap(i, s.len() - i - 1);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd40tfbt9.rs:13:12\n\
    \   |\n13 |         if s[i].is_ascii() {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpd40tfbt9.rs:14:17\n   |\n14 |          \
    \   res.swap(i, s.len() - i);\n   |                 ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpd40tfbt9.rs:16:17\n   |\n16 |             res.swap(i, s.len()\
    \ - i - 1);\n   |                 ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c.is_alphabetic())\n       \
    \ .map(|c| match c {\n            c @ _ => c.to_ascii_uppercase().to_string(),\n\
    \            _ => c,\n        })\n        .collect::<Vec<_>>()\n        .join::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmplzbp1zs7.rs:15:18\n\
    \   |\n13 |           .map(|c| match c {\n   |  __________________-\n14 | |  \
    \           c @ _ => c.to_ascii_uppercase().to_string(),\n   | |             \
    \         ---------------------------------- this is found to be of type `String`\n\
    15 | |             _ => c,\n   | |                  ^- help: try using a conversion\
    \ method: `.to_string()`\n   | |                  |\n   | |                  expected\
    \ struct `String`, found `char`\n16 | |         })\n   | |_________- `match` arms\
    \ have incompatible types\n\nerror[E0277]: the trait bound `[_]: Join<String>`\
    \ is not satisfied\n  --> /tmp/tmplzbp1zs7.rs:18:10\n   |\n18 |         .join::<String>()\n\
    \   |          ^^^^ the trait `Join<String>` is not implemented for `[_]`\n  \
    \ |\n   = help: the following other types implement trait `Join<Separator>`:\n\
    \             <[S] as Join<&str>>\n             <[V] as Join<&T>>\n          \
    \   <[V] as Join<&[T]>>\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmplzbp1zs7.rs:18:10\n    |\n18  |    \
    \     .join::<String>()\n    |          ^^^^---------- supplied 0 arguments\n\
    \    |          |\n    |          expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = s.to_string();\n    let mut new_chars = s.chars().collect::<Vec<_>>();\n\
    \    new_chars.sort();\n    let mut i = 0;\n    while i < new_chars.len() {\n\
    \        match new_chars[i] {\n            Some(letter) => {\n               \
    \ let new_letter = match letter {\n                    'a' => char::from('Z'),\n\
    \                    'b' => char::from('Y'),\n                    'c' => char::from('X'),\n\
    \                    'd' => char::from('W'),\n                    'e' => char::from('V'),\n\
    \                    'f' => char::from('U'),\n                    'g' => char::from('T'),\n\
    \                    'h' => char::from('S'),\n                    'i' => char::from('R'),\n\
    \                    'j' => char::from('Q'),\n                    'k' => char::from('P'),\n\
    \                    'l' => char::from('O'),\n                    'm' => char::from('N'),\n\
    \                    'n' => char::from('M'),\n                    'o' => char::from('A'),\n\
    \                    'p' => char::from('D'),\n                    'q' => char::from('H'),\n\
    \                    'r' => char::from('F'),\n                    's' => char::from('C'),\n\
    \                    't' => char::from('G'),\n                    'u' => char::from('E'),\n\
    \                    'v' => char::from('J'),\n                    'w' => char::from('I'),\n\
    \                    'x' => char::from('H'),\n                    'y' => char::from('K'),\n\
    \                    'z' => char::from('J'),\n                    'A' => char::from('O'),\n\
    \                    'B' => char::from('N'),\n                    'C' => char::from('M'),\n\
    \                    'D' => char::from('P'),\n                    'E' => char::from('Q'),\n\
    \                    'F' => char::from('R'),\n                    'G' => char::from('S'),\n\
    \                    'H' => char::from('T'),\n                    'I' => char::from('U'),\n\
    \                    'J' => char::from('V'),\n                    'K' => char::from('W'),\n\
    \                    'L' => char::from('X'),\n                    'M' => char::from('Y'),\n\
    \                    'N' => char::from('Z'),\n                    _ => letter\n\
    \                };\n                let new_i = new_chars.len() - i;\n      \
    \          let mut new_chars2 = new_chars.clone();\n                let mut new_chars3\
    \ = new_chars.clone();\n                *new_chars\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_dh_oq_u.rs:77:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n...\n15 |     while i < new_chars.len() {\n   |    \
    \                           - unclosed delimiter\n16 |         match new_chars[i]\
    \ {\n   |                            - unclosed delimiter\n17 |             Some(letter)\
    \ => {\n   |                             - this delimiter might not be properly\
    \ closed...\n...\n65 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n77 | }\n   |   ^\n\nerror: expected identifier, found keyword `fn`\n  -->\
    \ /tmp/tmp_dh_oq_u.rs:67:1\n   |\n67 | fn main() {\n   | ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `main`\n\
    \  --> /tmp/tmp_dh_oq_u.rs:67:4\n   |\n67 | fn main() {\n   |    ^^^^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_dh_oq_u.rs:17:13\n\
    \   |\n16 |         match new_chars[i] {\n   |               ------------ this\
    \ expression has type `char`\n17 |             Some(letter) => {\n   |       \
    \      ^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_dh_oq_u.rs:64:17\n   |\n16 | /         match new_chars[i]\
    \ {\n17 | |             Some(letter) => {\n18 | |                 let new_letter\
    \ = match letter {\n19 | |                     'a' => char::from('Z'),\n...  |\n\
    64 | |                 *new_chars\n   | |                 ^^^^^^^^^^ expected\
    \ `()`, found slice `[char]`\n...  |\n76 | |     assert_eq!(candidate(String::from(\"\
    #ccc\")), String::from(\"#CCC\"));\n77 | | }\n   | |__- expected this to be `()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_dh_oq_u.rs:15:5\n   |\n10 | \
    \  fn solve(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n15 | /     while i < new_chars.len() {\n\
    16 | |         match new_chars[i] {\n17 | |             Some(letter) => {\n18\
    \ | |                 let new_le"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\"\n    }\n\n    if s[0].isalpha()\
    \ {\n        let mut res = s.clone();\n        for (i, c) in res.chars().enumerate()\
    \ {\n            if i != 0 && c.is_lowercase() {\n                res.swap(i -\
    \ 1, i);\n            } else if i != 0 && c.is_uppercase() {\n               \
    \ res.swap(i, i - 1);\n            }\n        }\n        res\n    } else {\n \
    \       s\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvwe9w6_.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\"\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwvwe9w6_.rs:15:8\n\
    \   |\n15 |     if s[0].isalpha() {\n   |        ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwvwe9w6_.rs:19:21\n   |\n19 |          \
    \       res.swap(i - 1, i);\n   |                     ^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `swap` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpwvwe9w6_.rs:21:21\n   |\n21 |             \
    \    res.swap(i, i - 1);\n   |                     ^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = s;\n\n    for &ch in s\
    \ {\n        if !ch.is_lowercase() {\n            new_s = new_s.swapcase();\n\
    \        }\n    }\n\n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdzh98g1l.rs:14:16\n\
    \   |\n14 |     for &ch in s {\n   |                ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named\
    \ `swapcase` found for struct `String` in the current scope\n  --> /tmp/tmpdzh98g1l.rs:16:27\n\
    \   |\n16 |             new_s = new_s.swapcase();\n   |                      \
    \     ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = s.to_string();\n    \n    for i in s.chars()\
    \ {\n        match i {\n            c if c.is_alphanumeric() => (i.to_ascii_lowercase())\
    \ + result.to_ascii_lowercase(),\n            _ => result,\n        }\n    }\n\
    \    \n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `String` to `char`\n  --> /tmp/tmpjpua9so5.rs:15:66\n\
    \   |\n15 |             c if c.is_alphanumeric() => (i.to_ascii_lowercase()) +\
    \ result.to_ascii_lowercase(),\n   |                                         ------------------------\
    \ ^ --------------------------- String\n   |                                 \
    \        |\n   |                                         char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    for &c in s.chars() {\n        if let Some(old) = c.to_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp775poqar.rs:11:9\n   |\n\
    11 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let mut res\
    \ = String::new();\n    \n    for ch in s {\n        if ch.is_alpha() {\n    \
    \        \n            if let Some(m) = m.to_lowercase().find() {\n          \
    \      res.push_str(&s[..m]);\n                res.push_str(&s[m + 1].to_uppercase());\n\
    \            } else {\n                res.push_str(&s[..m.to_uppercase().len()]);\n\
    \                res.push_str(&s[m.to_uppercase().len()].to_lowercase());\n  \
    \          }\n        } else {\n            res.push_str(&s[..]);\n        }\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `m` in this scope\n  --> /tmp/tmpqx_8xo1h.rs:19:30\n\
    \   |\n19 |             if let Some(m) = m.to_lowercase().find() {\n   |     \
    \                         ^ help: a local variable with a similar name exists:\
    \ `s`\n\nerror[E0425]: cannot find value `m` in this scope\n  --> /tmp/tmpqx_8xo1h.rs:23:35\n\
    \   |\n23 |                 res.push_str(&s[..m.to_uppercase().len()]);\n   |\
    \                                   ^ help: a local variable with a similar name\
    \ exists: `s`\n\nerror[E0425]: cannot find value `m` in this scope\n  --> /tmp/tmpqx_8xo1h.rs:24:33\n\
    \   |\n24 |                 res.push_str(&s[m.to_uppercase().len()].to_lowercase());\n\
    \   |                                 ^ help: a local variable with a similar\
    \ name exists: `s`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpqx_8xo1h.rs:16:15\n\
    \   |\n16 |     for ch in s {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpqx_8xo1h.rs:21:31\n   |\n21 |  \
    \               res.push_str(&s[m + 1].to_uppercase());\n   |                \
    \               ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(\"\".to_string(), |acc: String, c: char| {\n\
    \        match c {\n            'a' => acc.to_string().to_lowercase(),\n     \
    \       'b' => acc.to_string().to_uppercase(),\n            '#' => acc.to_string(),\n\
    \            '@' => acc.to_string().to_lowercase(),\n            _ => acc,\n \
    \       }\n    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"aSdF\"`', /tmp/tmp1i3r_u3r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut string = s.to_owned();\n    for c in string.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            string = string.to_lowercase();\n\
    \        }\n        else if c.is_ascii_uppercase() {\n            string = string.to_uppercase();\n\
    \        }\n        else {\n            string = string.replace(c, c);\n     \
    \   }\n    }\n    return string;\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp18zlun__.rs:20:40\n   |\n\
    20 |             string = string.replace(c, c);\n   |                        \
    \                ^ expected `&str`, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.replace(\" \", \"\");\n    for i in s.chars()\
    \ {\n        if i != ' ' {\n            s = s.chars().map(|x|\n              \
    \  if x == 'A' || x == 'a' {\n                    'B'\n                } else\
    \ {\n                    x.to_string()\n                }\n            ).collect::<String>();\n\
    \        }\n    }\n    s.to_uppercase().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpa7rt9xkd.rs:18:21\n\
    \   |\n15 | /                 if x == 'A' || x == 'a' {\n16 | |              \
    \       'B'\n   | |                     --- expected because of this\n17 | | \
    \                } else {\n18 | |                     x.to_string()\n   | |  \
    \                   ^^^^^^^^^^^^^ expected `char`, found struct `String`\n19 |\
    \ |                 }\n   | |_________________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().fold(s, |s, c| s.chars().map(|c| match c {\n\
    \        'a' | 'A' => {\n            if c != s.chars().next().unwrap() {\n   \
    \             s.swap(0, s.len());\n                s.swap(s.len() - 1, s.len()\
    \ - 1);\n            }\n            s\n        }\n        'b' | 'B' => {\n   \
    \         if c != s.chars().next().unwrap() {\n                s.swap(0, s.len());\n\
    \                s.swap(s.len() - 1, s.len() - 1);\n            }\n          \
    \  s\n        }\n        _ => s,\n    }))\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpa3vpayzc.rs:14:19\n   |\n14 |                 s.swap(0,\
    \ s.len());\n   |                   ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpa3vpayzc.rs:15:19\n   |\n15 |                 s.swap(s.len() - 1, s.len()\
    \ - 1);\n   |                   ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpa3vpayzc.rs:21:19\n   |\n21 |                 s.swap(0, s.len());\n\
    \   |                   ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current scope\n  --> /tmp/tmpa3vpayzc.rs:22:19\n\
    \   |\n22 |                 s.swap(s.len() - 1, s.len() - 1);\n   |          \
    \         ^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa3vpayzc.rs:11:36\n   |\n10 |   fn solve(s: String) -> String {\n\
    \   |                          ------ expected `String` because of return type\n\
    11 |       s.chars().rev().fold(s, |s, c| s.chars().map(|c| match c {\n   |  ____________________________________^\n\
    12 | |         'a' | 'A' => {\n13 | |             if c != s.chars().next().unwrap()\
    \ {\n14 | |                 s.swap(0, s.len());\n...  |\n26 | |         _ => s,\n\
    27 | |     }))\n   | |______^ expected struct `String`, found struct `Map`\n \
    \  |\n   = note: expected struct `String`\n              found struct `Map<Chars<'_>,\
    \ _>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let len = s.len();\n    let mut letters\
    \ = false;\n    \n    for i in 0..len {\n        if s[i] == '#' {\n          \
    \  letters = true;\n            continue;\n        }\n        if letters {\n \
    \           if s[i].is_lower() {\n                s = s.swap(i+1, i+1); // 'swap'\
    \ the letter\n            }\n            else if s[i].is_upper() {\n         \
    \       s = s.swap(i+1, len-i-1); // 'swap' the letter\n            }\n      \
    \      else {\n                s = s.swap(i+1, i); // 'swap' the letter\n    \
    \        }\n        }\n        letters = false;\n    }\n    \n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmfze7mrx.rs:16:12\n\
    \   |\n16 |         if s[i] == '#' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmfze7mrx.rs:21:16\n   |\n21 |             if s[i].is_lower() {\n\
    \   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpmfze7mrx.rs:22:23\n   |\n22 |          \
    \       s = s.swap(i+1, i+1); // 'swap' the letter\n   |                     \
    \  ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpmfze7mrx.rs:24:21\n   |\n24 |         \
    \    else if s[i].is_upper() {\n   |                     ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as I"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    s.chars().for_each(|x|\n\
    \        if x.is_ascii() {\n            if x.is_lowercase() {\n              \
    \  res.append(x.to_upper());\n            } else {\n                res.append(x.to_lower());\n\
    \            }\n        } else {\n            res.append(x);\n        }\n    );\n\
    \    if res.chars().any(|x| !x.is_ascii()) {\n        res.chars().for_each(|x|\
    \ res.append(x.to_ascii_lowercase()));\n    }\n    res.chars().for_each(|x| res.append(x.to_string()));\n\
    \    res.chars().for_each(|x| res.append(x.to_ascii_lowercase()));\n    res.trim();\n\
    \    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpntb9vu70.rs:15:21\n   |\n15 |                 res.append(x.to_upper());\n\
    \   |                     ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `to_upper` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpntb9vu70.rs:15:30\n   |\n15 |                 res.append(x.to_upper());\n\
    \   |                              ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpntb9vu70.rs:17:21\n\
    \   |\n17 |                 res.append(x.to_lower());\n   |                  \
    \   ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `to_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpntb9vu70.rs:17:30\n\
    \   |\n17 |                 res.append(x.to_lower());\n   |                  \
    \            ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpntb9vu70.rs:20:17\n   |\n20 |          \
    \   res.append(x);\n   |                 ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpntb9vu70.rs:24:38\n   |\n24 |         res.chars().for_each(|x|\
    \ res.append(x.to_ascii_lowercase()));\n   |                                 \
    \     ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpntb9vu70.rs:26:34\n\
    \   |\n26 |     res.chars().for_each(|x| res.append(x.to_string()));\n   |   \
    \                               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpntb9vu70.rs:27:34\n   |\n27 |     res.chars().for_each(|x| res.append(x.to_ascii_lowercase()));\n\
    \   |                                  ^^^^^^ method not found in `St"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\";\n    }\n    if let\
    \ Some(first) = s.chars().next() {\n        let mut result = s.clone();\n    \
    \    result = result.replace(&first, &first.to_lowercase());\n        result =\
    \ result.replace(&first, &first.to_uppercase());\n        result = result.replace(&first,\
    \ &first.to_lowercase().rev());\n        result = result.replace(&first, &first.to_uppercase().rev());\n\
    \        return result;\n    }\n    s.to_lowercase().rev().to_uppercase().rev()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg_gdxl47.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\";\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmpg_gdxl47.rs:16:25\n\
    \    |\n16  |         result = result.replace(&first, &first.to_lowercase());\n\
    \    |                         ^^^^^^^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \    = help: the trait `Pattern<'a>` is implemented for `char`\n    = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_gdxl47.rs:16:41\n   |\n16 |         result\
    \ = result.replace(&first, &first.to_lowercase());\n   |                     \
    \                    ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmpg_gdxl47.rs:17:25\n\
    \    |\n17  |         result = result.replace(&first, &first.to_uppercase());\n\
    \    |                         ^^^^^^^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \    = help: the trait `Pattern<'a>` is implemented for `char`\n    = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_gdxl47.rs:17:4"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        match c {\n            'A'...'Z'\
    \ => c.to_uppercase().to_string(),\n            'a'...'z' => c.to_lowercase().to_string(),\n\
    \            _ => c,\n        }\n    }).collect::<Vec<_>>().join(\"\").to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpuarxkf77.rs:13:16\n\
    \   |\n13 |             'A'...'Z' => c.to_uppercase().to_string(),\n   |     \
    \           ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpuarxkf77.rs:14:16\n\
    \   |\n14 |             'a'...'z' => c.to_lowercase().to_string(),\n   |     \
    \           ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpuarxkf77.rs:15:18\n\
    \   |\n12 | /         match c {\n13 | |             'A'...'Z' => c.to_uppercase().to_string(),\n\
    \   | |                          ---------------------------- this is found to\
    \ be of type `String`\n14 | |             'a'...'z' => c.to_lowercase().to_string(),\n\
    \   | |                          ---------------------------- this is found to\
    \ be of type `String`\n15 | |             _ => c,\n   | |                  ^-\
    \ help: try using a conversion method: `.to_string()`\n   | |                \
    \  |\n   | |                  expected struct `String`, found `char`\n16 | | \
    \        }\n   | |_________- `match` arms have incompatible types\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    s.chars().for_each(|c|\n\
    \        match c {\n            'a' => result.push_str(&String::from(\"A\")),\n\
    \            'A' => result.push_str(&String::from(\"a\")),\n            '#' =>\
    \ result.push_str(&String::from(\"@\")),\n            '@' => result.push_str(&String::from(\"\
    #\")),\n            _ => result.push_str(&c.to_string()),\n        }\n    );\n\
    \    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asDf\"`,\n right: `\"aSdF\"`', /tmp/tmp6hd55s6s.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().enumerate().filter(|(_, i), _| i % 2 != 0).map(|(index,\
    \ char)| char.swapcase()).collect()\n        .iter().fold1(\"\"){|state, i| state\
    \ + i.to_string()}\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n\
    \  --> /tmp/tmprf08ylzn.rs:12:26\n   |\n12 |         .iter().fold1(\"\"){|state,\
    \ i| state + i.to_string()}\n   |                          ^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(s, |mut result, c| {\n        if c.is_lowercase()\
    \ {\n            result.append(c.to_uppercase());\n        } else {\n        \
    \    result.append(c.to_lowercase());\n        }\n        result\n    })\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpffdbl7et.rs:13:20\n   |\n13 |             result.append(c.to_uppercase());\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpffdbl7et.rs:15:20\n   |\n15 |             result.append(c.to_lowercase());\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \        .map(|c| if c.is_ascii_lowercase() { 'a' - 'A' else c.to_ascii_lowercase()\
    \ })\n        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c\
    \ + 'A' - 'a');\n            acc\n        });\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `else`\n  --> /tmp/tmpa8d3gddu.rs:13:56\n   |\n13 |         .map(|c| if c.is_ascii_lowercase()\
    \ { 'a' - 'A' else c.to_ascii_lowercase() })\n   |                           \
    \                             ^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0277]: cannot add `char` to `&_`\n  --> /tmp/tmpa8d3gddu.rs:15:29\n \
    \  |\n15 |             acc.push_str(&c + 'A' - 'a');\n   |                   \
    \          ^ no implementation for `&_ + char`\n   |\n   = help: the trait `Add<char>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa8d3gddu.rs:10:24\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n17 |         });\n\
    \   |           - help: remove this semicolon\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|c| c.is_letter()) {\n        solve_rev(s)\n\
    \    } else {\n        s\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `solve_rev` in this scope\n  --> /tmp/tmp_zs_o346.rs:12:9\n\
    \   |\n12 |         solve_rev(s)\n   |         ^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `is_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_zs_o346.rs:11:28\n   |\n11 |     if s.chars().any(|c|\
    \ c.is_letter()) {\n   |                            ^^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    match chars.chars().position(|c| c.is_alphanumeric())\
    \ {\n        None => s,\n        Some(_) => s.chars().map(|c| if c.is_alphanumeric()\
    \ { c.to_ascii_lowercase() } else { c.to_ascii_uppercase() }).collect::<String>()\
    \ + s,\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `chars` in this scope\n  --> /tmp/tmpb0k04xit.rs:12:11\n\
    \   |\n12 |     match chars.chars().position(|c| c.is_alphanumeric()) {\n   |\
    \           ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb0k04xit.rs:14:143\n   |\n14 | ....to_ascii_uppercase() }).collect::<String>()\
    \ + s,\n   |                                                   ^\n   |       \
    \                                            |\n   |                         \
    \                          expected `&str`, found struct `String`\n   |      \
    \                                             help: consider borrowing here: `&s`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c.is_ascii_letter())\n     \
    \   .map(|c| c.to_ascii_lowercase().unwrap())\n        .collect::<Vec<_>>()\n\
    \        .concat()\n        .reverse()\n        .collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpeei41cr9.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpeei41cr9.rs:13:41\n\
    \   |\n13 |         .map(|c| c.to_ascii_lowercase().unwrap())\n   |          \
    \                               ^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // TODO: Write your code here.\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi805j423.rs:10:24\n   |\n\
    10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c|{\n            match c {\n     \
    \           'A' => char::Up,\n                'a' => char::Low,\n            \
    \    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => char::Lower,\n\
    \                _ => c,\n            }\n        })\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `Up` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp050yeimd.rs:14:30\n   |\n14 |                 'A'\
    \ => char::Up,\n   |                              ^^ associated item not found\
    \ in `char`\n\nerror[E0599]: no associated item named `Low` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp050yeimd.rs:15:30\n   |\n15 |          \
    \       'a' => char::Low,\n   |                              ^^^ associated item\
    \ not found in `char`\n\nerror[E0599]: no associated item named `Lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp050yeimd.rs:16:84\n   |\n\
    16 |                 '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\
    \ => char::Lower,\n   |                                                      \
    \                              ^^^^^ associated item not found in `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut newString = String::new();\n    for c in s.chars()\
    \ {\n        let mut newChar: Char = c.clone();\n        if c.is_ascii_uppercase()\
    \ {\n            newChar = Char::to_ascii_lowercase();\n        } else if c.is_ascii_lowercase()\
    \ {\n            newChar = Char::to_ascii_uppercase();\n        }\n        newString.push(newChar);\n\
    \    }\n    newString.reverse();\n    newString\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpobm5_px2.rs:15:23\n\
    \   |\n15 |             newChar = Char::to_ascii_lowercase();\n   |          \
    \             ^^^^ use of undeclared type `Char`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Char`\n  --> /tmp/tmpobm5_px2.rs:17:23\n   |\n17 | \
    \            newChar = Char::to_ascii_uppercase();\n   |                     \
    \  ^^^^ use of undeclared type `Char`\n\nerror[E0412]: cannot find type `Char`\
    \ in this scope\n  --> /tmp/tmpobm5_px2.rs:13:26\n   |\n13 |         let mut newChar:\
    \ Char = c.clone();\n   |                          ^^^^ help: a builtin type with\
    \ a similar name exists (notice the capitalization): `char`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpobm5_px2.rs:21:15\n   |\n21 |     newString.reverse();\n   |       \
    \        ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut tmp = 0;\n    for\
    \ i in s.chars() {\n        let mut ch = (*i as u32).to_ascii_lowercase();\n \
    \       if let Some(i) = ch.rev() {\n            res.push_str(&i);\n        }\
    \ else {\n            res.push_str(&ch);\n        }\n    }\n    res.push_str(\"\
    _\");\n    res\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpygaza176.rs:14:23\n\
    \   |\n14 |         let mut ch = (*i as u32).to_ascii_lowercase();\n   |     \
    \                  ^^\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpygaza176.rs:15:21\n   |\n15 |  \
    \       if let Some(i) = ch.rev() {\n   |                     ^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmpygaza176.rs:15:16\n\
    \    |\n15  |         if let Some(i) = ch.rev() {\n    |                ^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Some`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = String::new();\n    \n    for c in s.chars() {\n\
    \        let mut is_upper = true;\n        if c.to_ascii_lowercase()[0].is_ascii()\
    \ {\n            if c != c.to_ascii_lowercase()[0].to_ascii_lowercase()[0] { is_upper\
    \ = false; }\n        }\n        else if c.to_ascii_uppercase()[0].is_ascii()\
    \ {\n            if c != c.to_ascii_uppercase()[0].to_ascii_uppercase()[0] { is_upper\
    \ = false; }\n        }\n        else if is_upper { s.push(c); }\n        else\
    \ { s.push((c - 'a').to_ascii_lowercase()); }\n    }\n    \n    String::from_utf8(s.into_bytes())\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpgctxic6b.rs:15:12\n\
    \   |\n15 |         if c.to_ascii_lowercase()[0].is_ascii() {\n   |          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmpgctxic6b.rs:16:21\n   |\n16 |             if c != c.to_ascii_lowercase()[0].to_ascii_lowercase()[0]\
    \ { is_upper = false; }\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpgctxic6b.rs:18:17\n\
    \   |\n18 |         else if c.to_ascii_uppercase()[0].is_ascii() {\n   |     \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmpgctxic6b.rs:19:21\n   |\n19 |             if c\
    \ != c.to_ascii_uppercase()[0].to_ascii_uppercase()[0] { is_upper = false; }\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmpgctxic6b.rs:22:26\n   |\n22 |         else\
    \ { s.push((c - 'a').to_ascii_lowercase()); }\n   |                        - ^\
    \ --- char\n   |                        |\n   |                        char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgctxic6b.rs:25:5\n   |\n10 | fn\
    \ solve(s: String) -> String {\n   |                        ------ expected `String`\
    \ because of return type\n...\n25 |     String::from_utf8(s.into_bytes())\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Result`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Result<String, FromUtf8Error>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\";\n    }\n    let mut\
    \ s = s;\n    let mut res = \"\";\n    for char in s.chars() {\n        if char.ascii_lowercase().is_some()\
    \ {\n            res.push_str(char.ascii_uppercase());\n        } else if char.ascii_uppercase().is_some()\
    \ {\n            res.push_str(char.ascii_lowercase());\n        } else {\n   \
    \         res.push_str(char);\n        }\n    }\n    res.trim_end_matches(\"\\\
    n\");\n    return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfynv236_.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\";\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0599]: no method named `ascii_lowercase` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpfynv236_.rs:17:17\n   |\n17 |         if char.ascii_lowercase().is_some()\
    \ {\n   |                 ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii_lowercase`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpfynv236_.rs:18:17\n\
    \   |\n18 |             res.push_str(char.ascii_uppercase());\n   |          \
    \       ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `ascii_uppercase`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpfynv236_.rs:18:31\n\
    \   |\n18 |             res.push_str(char.ascii_uppercase());\n   |          \
    \                     ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii_uppercase`\n\nerror[E0599]: no method named `ascii_uppercase`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpfynv236_.rs:19:24\n\
    \   |\n19 |         } else if char.ascii_uppercase().is_some() {\n   |       \
    \                 ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii_uppercase`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpfynv236_.rs:20:17\n\
    \   |\n20 |             res.push_str(char.ascii_lowercase());\n   |          \
    \       ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `ascii_lowercase`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpfynv236_.rs:20:31\n\
    \   |\n20 |             res.push_str(char.ascii_lowercase());\n   |          \
    \                     ^^^^^^^^^^^^^^^ help: there is an assoc"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return \"\"\n    }\n    let mut\
    \ res = String::from(s);\n    let mut last: Vec<char> = Vec::new();\n    for ch\
    \ in s.chars() {\n        if ch.is_lowercase() {\n            last.push(ch);\n\
    \        } else {\n            last.push((*ch.to_uppercase()).to_string());\n\
    \        }\n    }\n    res.push_str(&last);\n    return res;\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6utofhaa.rs:12:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n11 |     if s.is_empty() {\n12 |         return\
    \ \"\"\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror[E0614]: type `ToUppercase` cannot be dereferenced\n  --> /tmp/tmp6utofhaa.rs:20:23\n\
    \   |\n20 |             last.push((*ch.to_uppercase()).to_string());\n   |   \
    \                    ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6utofhaa.rs:23:18\n   |\n23 |     res.push_str(&last);\n   |  \
    \                ^^^^^ expected `str`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&Vec<char>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    if s.is_empty() {\n        return s;\n\
    \    }\n    let mut s = String::from(s);\n    for pos in 0..s.len() {\n      \
    \  if s.chars().any(|c| *c >= 'a' && *c <= 'z') {\n            s = s.chars().rev().collect::<String>().to_string()\
    \ + s;\n        }\n        else {\n            s = s.chars().collect::<String>().to_string()\
    \ + s;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpvaym9r0_.rs:17:30\n\
    \   |\n17 |         if s.chars().any(|c| *c >= 'a' && *c <= 'z') {\n   |     \
    \                         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpvaym9r0_.rs:17:43\n   |\n17 |         if s.chars().any(|c| *c >=\
    \ 'a' && *c <= 'z') {\n   |                                           ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvaym9r0_.rs:18:67\n   |\n18 |             s\
    \ = s.chars().rev().collect::<String>().to_string() + s;\n   |               \
    \                                                    ^\n   |                 \
    \                                                  |\n   |                   \
    \                                                expected `&str`, found struct\
    \ `String`\n   |                                                             \
    \      help: consider borrowing here: `&s`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvaym9r0_.rs:21:61\n   |\n21 |             s = s.chars().collect::<String>().to_string()\
    \ + s;\n   |                                                             ^\n \
    \  |                                                             |\n   |     \
    \                                                        expected `&str`, found\
    \ struct `String`\n   |                                                      \
    \       help: consider borrowing here: `&s`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    let mut s = s;\n    let mut len = s.len();\n    let mut\
    \ chars = s.chars();\n    \n    let mut buffer = Vec::new();\n    \n    while\
    \ let Some(Character(c)) = chars.next() {\n        if c.is_ascii_lowercase() {\n\
    \            buffer.push(c);\n        } else {\n            buffer.push(\"A\"\
    .to_string());\n        }\n    }\n    \n    let mut new_s = &s[0];\n    \n   \
    \ for index in 0..len {\n        if buffer[index] == buffer[index + len] {\n \
    \           new_s[..index] = new_s[..index].chars();\n            new_s[..index].push((buffer[index][..].to_string()\
    \ + buffer[index + 1].to_string() + buffer[index + 2].to_string()[..]).to_lowercase());\n\
    \            buffer[index + len] = ('Z' - 'A' + 1).to_string();\n            buffer[index\
    \ + 2] = buffer[index + 1].to_string() + buffer[index + 2].to_string();\n    \
    \    }\n    }\n    \n    new_s\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Character` in\
    \ this scope\n  --> /tmp/tmp5v_sti_0.rs:18:20\n   |\n18 |     while let Some(Character(c))\
    \ = chars.next() {\n   |                    ^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5v_sti_0.rs:26:22\n\
    \   |\n26 |     let mut new_s = &s[0];\n   |                      ^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5v_sti_0.rs:31:66\n\
    \   |\n31 | ...][..].to_string() + buffer[index + 1].to_string() + buffer[index\
    \ + 2].to_string()[..]).to_lowercase());\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&buffer[index + 1].to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5v_sti_0.rs:31:98\n\
    \   |\n31 | ...].to_string() + buffer[index + 2].to_string()[..]).to_lowercase());\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             \
    \       |\n   |                    expected `&str`, found `str`\n   |        \
    \            help: consider borrowing here: `&buffer[index + 2].to_string()[..]`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp5v_sti_0.rs:32:40\n\
    \   |\n32 |             buffer[index + len] = ('Z' - 'A' + 1).to_string();\n \
    \  |                                    --- ^ --- char\n   |                 \
    \                   |\n   |                                    char\n\nerror[E0308]:\
    \ mismatched types"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| c as u32).collect()\n        .iter()\n  \
    \      .filter(|c| c.is_ascii_letter())\n        .map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect::<String>()\n        .reduce(|mut acc, c| {\n            if\
    \ *acc == \"\" {\n                *acc += c;\n            } else {\n         \
    \       *acc += c.to_ascii_uppercase().to_string();\n            }\n         \
    \   *acc\n        }).to_string()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpcsxxyfj8.rs:11:33\n\
    \   |\n11 |     s.chars().map(|c| c as u32).collect()\n   |                  \
    \               ^^^^^^^ cannot infer type for type parameter `B` declared on the\
    \ associated function `collect`\n   |\n   = note: type must be known at this point\n\
    help: consider specifying the type argument in the method call\n   |\n11 |   \
    \  s.chars().map(|c| c as u32).collect::<B>()\n   |                          \
    \              +++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_uppercase() {\n            res.push_str(c.to_lowercase());\n  \
    \      } else {\n            res.push_str(c.to_uppercase());\n        }\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0fu0m17x.rs:14:26\n   |\n\
    14 |             res.push_str(c.to_lowercase());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0fu0m17x.rs:16:26\n   |\n16 |             res.push_str(c.to_uppercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `ToUppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.len() < 2 {\n        return s\n    }\n\n    let mut s\
    \ = s;\n    let mut cur = s.len() - 1;\n    while cur >= 0 {\n        let char\
    \ = s[cur];\n        match char {\n            'a' as char => s.swap(cur, cur\
    \ - 1),\n            'A' as char => s.swap(cur, cur - 1),\n            '#' as\
    \ char => s.swap(cur, cur + 1),\n            '@' as char => s.swap(cur, cur +\
    \ 1),\n            _ => {}\n        }\n        cur -= 1;\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpl8iyw2q7.rs:20:17\n   |\n20 |             'a' as char =>\
    \ s.swap(cur, cur - 1),\n   |                 ^^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpl8iyw2q7.rs:18:20\n   |\n18 |         let char = s[cur];\n\
    \   |                    ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nwarning:\
    \ unreachable statement\n  --> /tmp/tmpl8iyw2q7.rs:26:9\n   |\n19 | /        \
    \ match char {\n20 | |             'a' as char => s.swap(cur, cur - 1),\n21 |\
    \ |             'A' as char => s.swap(cur, cur - 1),\n22 | |             '#' as\
    \ char => s.swap(cur, cur + 1),\n23 | |             '@' as char => s.swap(cur,\
    \ cur + 1),\n24 | |             _ => {}\n25 | |         }\n   | |_________- any\
    \ code following this expression is unreachable\n26 |           cur -= 1;\n  \
    \ |           ^^^^^^^^^ unreachable statement\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    \n    let\
    \ mut chars = s.chars();\n    let mut i = 0;\n    let mut result: Vec<char> =\
    \ Vec::new();\n\n    loop {\n        if chars.next().is_some() {\n           \
    \ let char = chars.next().unwrap();\n            let index = char.chars().next().unwrap().unwrap()\
    \ - 'a' as usize;\n            char.chars().rev().for_each(|c| {\n           \
    \     if c >= 'a' && c <= 'z' {\n                    result.push((c - 'a' + index)\
    \ % 26 + 'a');\n                } else {\n                    result.push(c);\n\
    \                }\n            });\n        } else {\n            chars.next().unwrap().for_each(|c|\
    \ {\n                result.push(c);\n            });\n            break;\n  \
    \      }\n        i += 1;\n    }\n    result.rev()\n        .join(\"\")\n    \
    \    .replace(&s[..i],\"\")\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxwsumjlu.rs:22:30\n   |\n22 |             let index = char.chars().next().unwrap().unwrap()\
    \ - 'a' as usize;\n   |                              ^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `chars` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpxwsumjlu.rs:23:18\n   |\n23 |             char.chars().rev().for_each(|c|\
    \ {\n   |                  ^^^^^ method not found in `char`\n\nerror[E0277]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpxwsumjlu.rs:25:36\n   |\n25 |   \
    \                  result.push((c - 'a' + index) % 26 + 'a');\n   |          \
    \                          ^ no implementation for `char - char`\n   |\n   = help:\
    \ the trait `Sub` is not implemented for `char`\n\nerror[E0599]: `char` is not\
    \ an iterator\n  --> /tmp/tmpxwsumjlu.rs:31:35\n   |\n31 |             chars.next().unwrap().for_each(|c|\
    \ {\n   |                                   ^^^^^^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror[E0599]:\
    \ `Vec<char>` is not an iterator\n   --> /tmp/tmpxwsumjlu.rs:38:12\n    |\n38\
    \  |       result.rev()\n    |              ^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = s.to_string();\n    for i in 0..str.len() {\n\
    \        if str[i].is_letter() {\n            let r = str[i].to_ascii_lowercase();\n\
    \            str = str.chars().map(|c| if c == r { c } else { c ^ r }).collect();\n\
    \        } else {\n            str = str.chars().map(|c| if c == i { c } else\
    \ { c ^ i }).collect();\n        }\n    }\n    str\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcrbqdd8.rs:13:12\n\
    \   |\n13 |         if str[i].is_letter() {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkcrbqdd8.rs:14:21\n   |\n14 |             let r = str[i].to_ascii_lowercase();\n\
    \   |                     ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]:\
    \ no implementation for `char ^ char`\n  --> /tmp/tmpkcrbqdd8.rs:15:64\n   |\n\
    15 |             str = str.chars().map(|c| if c == r { c } else { c ^ r }).collect();\n\
    \   |                                                              - ^ - char\n\
    \   |                                                              |\n   |   \
    \                                                           char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkcrbqdd8.rs:17:47\n   |\n17 |             str\
    \ = str.chars().map(|c| if c == i { c } else { c ^ i }).collect();\n   |     \
    \                                          ^ expected `char`, found `usize`\n\n\
    error[E0369]: no implementation for `char ^ usize`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    \n    fn reverse_case(x: char) -> char {\n        match x {\n\
    \            'a' => {\n                if x.to_lowercase() == 'a' {\n        \
    \            'A'\n                } else {\n                    x.to_uppercase()\n\
    \                }\n            }\n            'b' => {\n                if x.to_lowercase()\
    \ == 'b' {\n                    'B'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'c' =>\
    \ {\n                if x.to_lowercase() == 'c' {\n                    'C'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'd' => {\n                if x.to_lowercase()\
    \ == 'd' {\n                    'D'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'e' =>\
    \ {\n                if x.to_lowercase() == 'e' {\n                    'E'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'f' => {\n                if x.to_lowercase()\
    \ == 'f' {\n                    'F'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'g' =>\
    \ {\n                if x.to_lowercase() == 'g' {\n                    'G'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'h' => {\n                if x.to_lowercase()\
    \ == 'h' {\n                    'H'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'i' =>\
    \ {\n                if x.to_lowercase() == 'i' {\n                    'I'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'j' => {\n                if x.to_lowercase()\
    \ == 'j' {\n                    'J'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'k' =>\
    \ {\n                if x.to_lowercase() == 'k' {\n                    'K'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'l' => {\n                if x.to_lowercase()\
    \ == 'l' {\n                    'L'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'm' =>\
    \ {\n                if x.to_lowercase() == 'm' {\n                    'M'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'n' => {\n                if x.to_lowercase()\
    \ == 'n' {\n                    'N'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'o' =>\
    \ {\n                if x.to_lowercase() == 'o' {\n                    'O'\n \
    \               } else {\n                    x.to_uppercase()\n             \
    \   }\n            }\n            'p' => {\n                if x.to_lowercase()\
    \ == 'p' {\n                    'P'\n                } else {\n              \
    \      x.to_uppercase()\n                }\n            }\n            'q' =>\
    \ {\n                if x.to_lowercase() == 'q' {\n                    '\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n   --> /tmp/tmpx0l8myjt.rs:128:21\n\
    \    |\n128 |                     '\n    |                     ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if !s.is_empty() {\n        let mut new_s = String::from(s);\n\
    \        new_s.chars().for_each(|c| {\n            match c {\n               \
    \ 'a' => new_s.swap(0, 1, 'A'),\n                'b' => new_s.swap(0, 1, 'B'),\n\
    \                'c' => new_s.swap(0, 1, 'C'),\n                'd' => new_s.swap(0,\
    \ 1, 'D'),\n                'e' => new_s.swap(0, 1, 'E'),\n                'f'\
    \ => new_s.swap(0, 1, 'F'),\n                'g' => new_s.swap(0, 1, 'G'),\n \
    \               'h' => new_s.swap(0, 1, 'H'),\n                'i' => new_s.swap(0,\
    \ 1, 'I'),\n                'j' => new_s.swap(0, 1, 'J'),\n                'k'\
    \ => new_s.swap(0, 1, 'K'),\n                'l' => new_s.swap(0, 1, 'L'),\n \
    \               'm' => new_s.swap(0, 1, 'M'),\n                'n' => new_s.swap(0,\
    \ 1, 'N'),\n                'o' => new_s.swap(0, 1, 'O'),\n                'p'\
    \ => new_s.swap(0, 1, 'P'),\n                'q' => new_s.swap(0, 1, 'Q'),\n \
    \               'r' => new_s.swap(0, 1, 'R'),\n                's' => new_s.swap(0,\
    \ 1, 'S'),\n                't' => new_s.swap(0, 1, 'T'),\n                'u'\
    \ => new_s.swap(0, 1, 'U'),\n                'v' => new_s.swap(0, 1, 'V'),\n \
    \               'w' => new_s.swap(0, 1, 'W'),\n                'x' => new_s.swap(0,\
    \ 1, 'X'),\n                'y' => new_s.swap(0, 1, 'Y'),\n                'z'\
    \ => new_s.swap(0, 1, 'Z'),\n                _ => (),\n            }\n       \
    \ });\n        new_s\n    } else {\n        String::from(\"0\")\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:15:30\n   |\n15 |                 'a' => new_s.swap(0,\
    \ 1, 'A'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:16:30\n   |\n16 |                 'b' => new_s.swap(0,\
    \ 1, 'B'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:17:30\n   |\n17 |                 'c' => new_s.swap(0,\
    \ 1, 'C'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:18:30\n   |\n18 |                 'd' => new_s.swap(0,\
    \ 1, 'D'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:19:30\n   |\n19 |                 'e' => new_s.swap(0,\
    \ 1, 'E'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:20:30\n   |\n20 |                 'f' => new_s.swap(0,\
    \ 1, 'F'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:21:30\n   |\n21 |                 'g' => new_s.swap(0,\
    \ 1, 'G'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:22:30\n   |\n22 |                 'h' => new_s.swap(0,\
    \ 1, 'H'),\n   |                              ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplse2r__g.rs:23:30\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c|\n        match c.to_ascii_lowercase().as_ref()\
    \ {\n            Some('z') => c.to_ascii_uppercase().as_ref(),\n            Some('a')\
    \ => c.to_ascii_uppercase().as_ref(),\n            _ => c\n        }\n    ).collect::<String>().into_iter().collect::<Vec<String>>().join(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_ref` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4alp1jgu.rs:12:38\n   |\n12 |         match c.to_ascii_lowercase().as_ref()\
    \ {\n   |                                      ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `as_ref` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4alp1jgu.rs:13:49\n   |\n13 |             Some('z') =>\
    \ c.to_ascii_uppercase().as_ref(),\n   |                                     \
    \            ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `as_ref` found for type `char` in the current scope\n  --> /tmp/tmp4alp1jgu.rs:14:49\n\
    \   |\n14 |             Some('a') => c.to_ascii_uppercase().as_ref(),\n   |  \
    \                                               ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: the method `into_iter` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp4alp1jgu.rs:17:27\n    |\n17  |  \
    \     ).collect::<String>().into_iter().collect::<Vec<String>>().join(\"\").to_string()\n\
    \    |                             ^^^^^^^^^\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `String: IntoIterator`\n            `&String: Iterator`\n\
    \            which is required by `&String: IntoIterator`\n            `&mut String:\
    \ Iterator`\n            which is required by `&mut String: IntoIterator`\n  \
    \          `str: Sized`\n            which is required by `str: IntoIterator`\n\
    \            `str: Iterator`\n            which is required by `str: IntoIterator`\n\
    \            `&str: Iterator`\n            which is required by `&str: IntoIterator`\n\
    \            `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(s, |s, c| {\n        if let Some(ch) = c.to_ascii_uppercase()\
    \ {\n            *s = ch.to_string();\n        } else {\n            *s = c.to_string();\n\
    \        }\n        s + &*s.chars().skip_while(|c| c.is_whitespace()).collect::<String>();\n\
    \    });\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6bh49wvf.rs:12:16\n   |\n\
    12 |         if let Some(ch) = c.to_ascii_uppercase() {\n   |                ^^^^^^^^\
    \   ---------------------- this expression has type `char`\n   |             \
    \   |\n   |                expected `char`, found enum `Option`\n   |\n   = note:\
    \ expected type `char`\n              found enum `Option<_>`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp6bh49wvf.rs:13:13\n   |\n13 |             *s = ch.to_string();\n   |\
    \             ^^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: the left-hand-side of\
    \ an assignment must have a statically known size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6bh49wvf.rs:15:18\n   |\n15 |             *s = c.to_string();\n\
    \   |             --   ^^^^^^^^^^^^^ expected `str`, found struct `String`\n \
    \  |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp6bh49wvf.rs:15:13\n   |\n15 |             *s = c.to_string();\n\
    \   |             ^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6bh49wvf.rs:11:30\n   |\n11 |       s.chars().fold(s, |s,\
    \ c| {\n   |  ______________________________^\n12 | |         if let Some(ch)\
    \ = c.to_ascii_uppercase() {\n13 | |             *s = ch.to_string();\n14 | |\
    \         } else {\n...  |\n17 | |         s + &*s.chars().skip_while(|c| c.is_whitespace()).collect::<String>();\n\
    \   | |                                                                      \
    \        - help: remove this semicolon\n18 | |     });\n   | |_____^ expected\
    \ struct `String`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bh49wvf.rs:10:24\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |    -----               ^^^^^^\
    \ expected struct `"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_letter() { c.to_upper() } else {\
    \ c.to_lower() }).collect()\n        .fold(String::new(), |result, n| {\n    \
    \        result.push_str(n);\n            result.push(n);\n            result\n\
    \        })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptte4_9t3.rs:11:28\n   |\n11 |     s.chars().map(|c|\
    \ if c.is_letter() { c.to_upper() } else { c.to_lower() }).collect()\n   |   \
    \                         ^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `to_upper` found for type `char` in the current scope\n  -->\
    \ /tmp/tmptte4_9t3.rs:11:44\n   |\n11 |     s.chars().map(|c| if c.is_letter()\
    \ { c.to_upper() } else { c.to_lower() }).collect()\n   |                    \
    \                        ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmptte4_9t3.rs:11:66\n   |\n\
    11 |     s.chars().map(|c| if c.is_letter() { c.to_upper() } else { c.to_lower()\
    \ }).collect()\n   |                                                         \
    \         ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    if s.is_empty() {\n        return \"#\"\
    ;\n    }\n    let mut i = 0;\n    while i < s.len() {\n        let c = s.chars().next().unwrap();\n\
    \        if c.is_ascii() {\n            if c.ascii_upper() {\n               \
    \ s = s.chars().take(i).chain(c.chars().map(|c| c.to_ascii_lowercase()));\n  \
    \              i += c.len_utf8();\n            } else {\n                s = s.chars().take(i).chain(c.chars().map(|c|\
    \ c.to_ascii_uppercase()));\n                i += c.len_utf8();\n            }\n\
    \        } else {\n            i += 1;\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzprfh_b0.rs:13:16\n   |\n\
    10 | fn solve(s: String) -> String {\n   |                        ------ expected\
    \ `String` because of return type\n...\n13 |         return \"#\";\n   |     \
    \           ^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \             |\n   |                expected struct `String`, found `&str`\n\n\
    error[E0599]: no method named `ascii_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpzprfh_b0.rs:19:18\n   |\n19 |             if c.ascii_upper()\
    \ {\n   |                  ^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii_uppercase`\n\nerror[E0599]: no method named `chars`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpzprfh_b0.rs:20:47\n\
    \   |\n20 |                 s = s.chars().take(i).chain(c.chars().map(|c| c.to_ascii_lowercase()));\n\
    \   |                                               ^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzprfh_b0.rs:20:21\n\
    \   |\n11 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n20 |                 s = s.chars().take(i).chain(c.chars().map(|c| c.to_ascii_lowercase()));\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `std::iter::Chain`\n   |\n   = note:\
    \ expected struct `String`\n              found struct `std::iter::Chain<std::iter::Take<Chars<'_>>,\
    \ _>`\n\nerror[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpzprfh_b0.rs:23:47\n   |\n23 |                 s = s.chars().take(i).chain(c.chars().map(|c|\
    \ c.to_ascii_uppercase()));\n   |                                            \
    \   ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzprfh_b0.rs:23:21\n   |\n11 |     let mut s = s;\n   |             \
    \    - expected due to this value\n...\n23 |                 s = s.chars().take(i).chain(c.chars().map(|c|\
    \ c.to_ascii_uppercase()));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut len = s.len();\n    for i in 0..(len\
    \ - 1) {\n        let c = s.chars().nth(i).unwrap();\n        if c.is_ascii()\
    \ {\n            if c.is_lowercase() {\n                s = s.chars().nth(i).unwrap().to_ascii_lowercase().to_string()\
    \ + &s.chars().nth(len - 1 - i).unwrap().to_ascii_uppercase().to_string();\n \
    \           } else {\n                s = s.chars().nth(i).unwrap().to_ascii_uppercase().to_string()\
    \ + &s.chars().nth(len - 1 - i).unwrap().to_ascii_lowercase().to_string();\n \
    \           }\n        } else {\n            if c.is_lowercase() {\n         \
    \       s = s.chars().nth(i).unwrap().to_string().to_ascii_lowercase() + &s.chars().nth(len\
    \ - 1 - i).unwrap().to_string().to_ascii_uppercase().to_string();\n          \
    \  } else {\n                s = s.chars().nth(i).unwrap().to_string().to_ascii_uppercase()\
    \ + &s.chars().nth(len - 1 - i).unwrap().to_string().to_ascii_lowercase().to_string();\n\
    \            }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp01uusp20.rs:17:110\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if c.is_ascii_lowercase() {\n\
    \            let mut c = c.to_ascii_lowercase();\n            c.swap(0,1);\n \
    \           c\n        } else if c.is_ascii_uppercase() {\n            let mut\
    \ c = c.to_ascii_uppercase();\n            c.swap(0,1);\n            c\n     \
    \   } else {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n \
    \   let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgzujjcbo.rs:14:15\n   |\n14 |             c.swap(0,1);\n\
    \   |               ^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `swap` found for type `char` in the current scope\n  --> /tmp/tmpgzujjcbo.rs:18:15\n\
    \   |\n18 |             c.swap(0,1);\n   |               ^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphanumeric() {\n            if let Ok(c) = (c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase()) {\n                result.push(c);\n            } else\
    \ {\n                result.push(c.to_string());\n            }\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    result.rev().to_string()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp32dyy7oy.rs:14:20\n   |\n\
    14 |             if let Ok(c) = (c.to_ascii_lowercase(), c.to_ascii_uppercase())\
    \ {\n   |                    ^^^^^   ------------------------------------------------\
    \ this expression has type `(char, char)`\n   |                    |\n   |   \
    \                 expected tuple, found enum `Result`\n   |\n   = note: expected\
    \ tuple `(char, char)`\n               found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp32dyy7oy.rs:17:29\n   |\n17 |              \
    \   result.push(c.to_string());\n   |                             ^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmp32dyy7oy.rs:23:12\n    |\n23  |       result.rev().to_string()\n\
    \    |              ^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.to_string();\n    loop {\n        let mut c =\
    \ s.chars().collect::<Vec<_>>();\n        c.reverse();\n        s = c.collect::<String>();\n\
    \        if s.len() == 0 {\n            break;\n        }\n        let mut i =\
    \ 0;\n        while i < c.len() {\n            if c.is_alphabetic(s[i]) {\n  \
    \              let a = c.split_at(i).collect::<Vec<_>>();\n                let\
    \ c = a.join();\n                i = a.len();\n                s = c.to_string();\n\
    \                break;\n            }\n            i += 1;\n        }\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmp6h6kzye4.rs:15:15\n\
    \    |\n15  |           s = c.collect::<String>();\n    |                 ^^^^^^^\
    \ `Vec<char>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<char>: Iterator`\n            which is\
    \ required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n   \
    \         which is required by `&mut [char]: Iterator`\n\nerror[E0599]: no method\
    \ named `is_alphabetic` found for struct `Vec<char>` in the current scope\n  -->\
    \ /tmp/tmp6h6kzye4.rs:21:18\n   |\n21 |             if c.is_alphabetic(s[i]) {\n\
    \   |                  ^^^^^^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6h6kzye4.rs:21:32\n\
    \   |\n21 |             if c.is_alphabetic(s[i]) {\n   |                     \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `(&[char], &[char])` is not an iterator\n  --> /tmp/tmp6h6kzye4.rs:22:39\n\
    \   |\n22 |                 let a = c.split_at(i).collect::<Vec<_>>();\n   | \
    \                                      ^^^^^^^ `(&[char], &[char])` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(&[char], &[char]): Iterator`\n           which is required by `&mut\
    \ (&[char], &[char]): Iterator`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars();\n    let mut ret = \"\".to_string();\n\
    \    for c in s {\n        let c = c.to_lowercase();\n        if c.is_ascii_lowercase()\
    \ {\n            let c = c.to_uppercase();\n            if c != \"#\" {\n    \
    \            ret += c;\n            } else {\n                ret += \"#\";\n\
    \            }\n        } else {\n            ret += c;\n        }\n    }\n  \
    \  ret\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpvofooks6.rs:15:14\n   |\n15 |         if\
    \ c.is_ascii_lowercase() {\n   |              ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `ToLowercase`\n\nerror[E0599]: no method named `to_uppercase` found for struct\
    \ `ToLowercase` in the current scope\n  --> /tmp/tmpvofooks6.rs:16:23\n   |\n\
    16 |             let c = c.to_uppercase();\n   |                       ^^^^^^^^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvofooks6.rs:23:20\n\
    \   |\n23 |             ret += c;\n   |                    ^ expected `&str`,\
    \ found struct `ToLowercase`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s\n    }\n    let mut l =\
    \ s.chars().filter(|x| x.is_letter()).count();\n    let mut u = 0\n    if l >\
    \ 0 {\n        u = l - 1\n    }\n    let mut new_s = String::with_capacity(s.len());\n\
    \    for ch in s.chars() {\n        if ch.is_letter() {\n            new_s.push_str(String::from(ch.to_lowercase()));\n\
    \        } else {\n            new_s.push_str(&ch);\n        }\n    }\n    new_s.push_str(&s[u..])\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpvzejvs0b.rs:15:18\n\
    \   |\n15 |     let mut u = 0\n   |                  ^ help: add `;` here\n16\
    \ |     if l > 0 {\n   |     -- unexpected token\n\nerror[E0599]: no method named\
    \ `is_letter` found for reference `&char` in the current scope\n  --> /tmp/tmpvzejvs0b.rs:14:40\n\
    \   |\n14 |     let mut l = s.chars().filter(|x| x.is_letter()).count();\n   |\
    \                                        ^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0599]: no method named `is_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvzejvs0b.rs:21:15\n   |\n21 |         if ch.is_letter()\
    \ {\n   |               ^^^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the trait bound `String: From<ToLowercase>` is not satisfied\n  --> /tmp/tmpvzejvs0b.rs:22:28\n\
    \   |\n22 |             new_s.push_str(String::from(ch.to_lowercase()));\n   |\
    \                            ^^^^^^^^^^^^ the trait `From<ToLowercase>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzejvs0b.rs:22:28\n\
    \   |\n22 |             new_s.push_str(String::from(ch.to_lowercase()));\n   |\
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \                 |\n   |                            expected `&str`, found struct\
    \ `String`\n   |                            help: consider borrowing here: `&String::from(ch.to_lowercase())`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvzejvs0b.rs:24:28\n   |\n24 |\
    \             new_s.push_str(&ch);\n   |                            ^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvzejvs0b.rs:27:5\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut pos = 0;\n    for\
    \ i in s.chars() {\n        if i == ' ' {\n            pos = 0;\n        }\n \
    \       if i > 'z' && i < 'Z' {\n            pos += 2;\n        }\n        if\
    \ i > 'z' && i < 'Z' {\n            pos += 1;\n        }\n        res.push_str(&s[pos\
    \ : i + 1].to_uppercase());\n        pos = i;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0573]: expected type, found local variable `i`\n  --> /tmp/tmps2g3juu9.rs:23:31\n\
    \   |\n23 |         res.push_str(&s[pos : i + 1].to_uppercase());\n   |      \
    \                         ^ expecting a type here because of type ascription\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps2g3juu9.rs:24:15\n   |\n12 |\
    \     let mut pos = 0;\n   |                   - expected due to this value\n\
    ...\n24 |         pos = i;\n   |               ^ expected integer, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0573.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
