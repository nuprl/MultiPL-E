name: HumanEval_49_modp
language: rust
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ['    n - (n % p)', "    if n >= 1 {\n        return n & (p - 1);\n \
    \   }\n    return 1;", "    if p < 0 {\n        p = 0\n    }\n    let n = if n\
    \ < 0 { p } else { n };\n    (p % n) as isize", "    match n % p {\n        0\
    \ => n,\n        n => n - n % p,\n    }", '    n.wrapping_pow(p) % p.wrapping_pow(p)',
  "    assert!((p % n) == 0);\n    (p + p - 1) / p", '    MODP_TABLE[n] % p', "  \
    \  let mut remain = n;\n    let mut result = n;\n    while remain != 0 {\n   \
    \     if remain % p == 0 {\n            remain -= 1;\n        } else if remain\
    \ % p == 1 {\n            remain -= 1;\n        } else {\n            remain -=\
    \ 1;\n        }\n        result -= 1;\n    }\n    result", '    if n >= p { n
    % p } else { n / p }', "    debug_assert!(n != 0);\n    debug_assert!(p != 0);\n\
    \    let mut x = n;\n    debug_assert!(x > 0);\n    debug_assert!(p > 0);\n  \
    \  debug_assert!(p < std::i32::MAX as usize);\n\n    while x > 0 {\n        let\
    \ t = x;\n        x = (t + (p >> 31)) & -p;\n        if x == t {\n           \
    \ x = (x << 31) % p;\n        }\n    }\n\n    x", "    // we first calculate what\
    \ we need to do using the Euclidean algorithm.\n    // This gives us the greatest\
    \ common divisor.\n    let mut gcd = p;\n    let mut rem = 0;\n    while gcd !=\
    \ 1 {\n        gcd = n - rem * gcd - p;\n        rem = 0;\n        for i in 1..n\
    \ {\n            if n % i == 0 {\n                rem += i;\n                gcd\
    \ -= i;\n            }\n        }\n    }\n    rem", '    n % (p + 1) + ((p - n
    + 1) % p)', '    (n * p + p.pow(n - 1)) % p', "    if p == 0 {\n        return\
    \ 0;\n    }\n\n    n % (p - 1)", "    if n >= p {\n        n - p\n    } else {\n\
    \        n + p\n    }", "    debug_assert!(n >= 0 && p >= 0);\n    debug_assert!(p\
    \ <= 2<isize>::max_value());\n    debug_assert!((n % p) == 0);\n    n % p", " \
    \   match n % p {\n        0 => 0,\n        n if n / p >= 2 => n - n % p,\n  \
    \      _ => n,\n    }", "    if n < 0 || p < 0 {\n        p\n    } else {\n  \
    \      n % (p as isize)\n    }", '    (n - 1) % p + 1', "    if n < 0 {\n    \
    \    p\n    } else {\n        let a = pow(p, n);\n        if a < p {\n       \
    \     a - p\n        } else {\n            a\n        }\n    }", '    (p * n)
    % p', "    match n.cmp(p) {\n        Ordering::Less => 1,\n        Ordering::Equal\
    \ => 0,\n        Ordering::Greater => 2,\n    }", "    if n == 0 {\n        return\
    \ p;\n    }\n    let mut rem = n % p;\n    if rem < 0 {\n        rem += p;\n \
    \   }\n    rem", '    (n & (p - 1)) == 0 ? (n << p) as isize : 0', "    match\
    \ n % p {\n        0 => n - p,\n        x => x + modp(n - x, p),\n    }", "  \
    \  assert!((n % p) == 0);\n    n - (n % p)", "    let mut n = n as isize;\n  \
    \  let mut p = p as isize;\n    let result = n / p;\n    n %= p;\n    result *\
    \ p + n", "    if n == 0 { return 1; }\n    if n == 1 { return 0; }\n    if n\
    \ == p { return n; }\n    if p % n == 0 { return n - p; }\n    if p % n == 1 {\
    \ return p; }\n    // n might be larger than p here, so check first whether n\
    \ and p are too large or small\n    if n == p - 1 {\n        return modp(n - 1,\
    \ p);\n    }\n    if n <= p { return modp(n, p + 1); }\n    if n > p { return\
    \ modp(n - p, p); }", "    if n < 0 {\n        let mut mod = p % n;\n        if\
    \ mod < 0 {\n            mod += n;\n        }\n        mod\n    } else {\n   \
    \     (p / n) * n\n    }", "    if n < 0 {\n        0 - (n % p)\n    } else {\n\
    \        (n % p) + p\n    }", '    n & ((p - 1) << n)', "    let mut n1 = n;\n\
    \    let mut n2 = n;\n    let mut p1 = p;\n    let mut p2 = p;\n\n    while n1\
    \ != 0 {\n        n1 = n1 % p1;\n        n2 = n2 % p2;\n        p1 = p1 % p2;\n\
    \        p2 = p2 % p2;\n    }\n\n    p1", '    (n << p) | ((n & -p) != n)', " \
    \   let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n           \
    \ n /= p;\n        } else {\n            res += 1;\n        }\n    }\n    res",
  "    assert!(p);\n    (n + p + 1) / p", "    if n == 0 {\n        return 1;\n  \
    \  }\n    p %= n;\n    if p == 0 {\n        return 1;\n    }\n    return n / p;",
  '    n % (p + p)', '    (*n) % p', "    if n == 0 { return 1; }\n    if p < 2 {\
    \ n -= 1; return 1; }\n\n    fn mod2(x: isize) -> isize {\n        let mut y =\
    \ x;\n        while y > 0 { y -= 2; };\n        y\n    }\n\n    let mut q = p\
    \ / 2;\n    let mut r = p % 2;\n    if r == 0 {\n        return mod2(n - q * 2);\n\
    \    }\n    n -= q * 2;\n    mod2(n - q)", "    if n >= p {\n        return n;\n\
    \    }\n    return n % p;", '    n ^ (n & p) % p', "    let mut r = 1;\n    let\
    \ mut m = n;\n    while m != 0 {\n        if m % p == 0 {\n            m /= p;\n\
    \            r ^= 1;\n        } else {\n            m /= p;\n        }\n    }\n\
    \    r", "    if n < 0 {\n        std::mem::replace(n, -n);\n        p -= 1;\n\
    \    }\n    let n: isize = n as isize;\n    let p: isize = p as isize;\n    p\
    \ %= n;\n    if n < p { p += n; }\n    p", "    let mut n = n.to_i();\n    if\
    \ n < 0 {\n        // n < 0 is always true (mod p)\n        n = -p;\n    }\n \
    \   n = n.wrapping_mul(p).unwrap();\n    if n <= 0 { n } else { n % p }", '    n
    % (p as isize)', '    (n - p + 1) & (n - 1)', "    assert!(p != 0);\n    n & (p\
    \ - 1)", "    let mut result = n;\n    let mut remainder = p;\n\n    while result\
    \ > remainder {\n        result -= remainder;\n        remainder *= p;\n    }\n\
    \n    result", '    n & !p as isize', "    // TODO: use bigint for speed\n   \
    \ if n < p {\n        return 0;\n    }\n    let mut result = n;\n    let mut carry:\
    \ isize = 0;\n    while n > 0 {\n        carry += result % p;\n        result\
    \ = n / p;\n        if carry > 0 {\n            result += 1;\n            carry\
    \ = 1;\n        }\n    }\n    if carry > 0 {\n        result += 1;\n    }\n  \
    \  if result > 0 {\n        result -= 1;\n    }\n    return result;", "    let\
    \ mut r = p;\n    if r < 0 {\n        r += p;\n    }\n    while r != 0 {\n   \
    \     r &= (r - 1) as isize;\n    }\n    r", "    if n >= p as isize {\n     \
    \   n - p\n    } else {\n        n % p\n    }", "    // TODO: use isize::pow if\
    \ possible\n    let mut result = n;\n    let mut mask = 0x01;\n    while result\
    \ >= p {\n        result -= p;\n        mask <<= 1;\n    }\n    while mask > 0\
    \ {\n        result &= mask;\n        mask >>= 1;\n    }\n    result", "    if\
    \ n < p { return n % p; }\n    n - (n % p) + p", "    let mut rv = if n < 0 {\n\
    \        p - n\n    } else {\n        n\n    };\n    while rv > p { rv -= p; }\n\
    \    rv", '    (n % p) as isize', '    (n - 1) % p', '    n - (((p - 1) / p) *
    p)', "    if n < 0 {\n        if p < 0 {\n            p\n        } else {\n  \
    \          -p\n        }\n    } else {\n        if p < 0 {\n            p\n  \
    \      } else {\n            n % p\n        }\n    }", "    let p = p % n;\n \
    \   if p == 0 {\n        1\n    } else {\n        p\n    }", "    if p == 0 {\n\
    \        return 1;\n    }\n    let q = p * (p - 1) + (n - 1);\n    if q == p {\n\
    \        return n;\n    }\n    if q == q * p {\n        return p;\n    }\n   \
    \ if q > p {\n        p -= q;\n    }\n    return n % p;", "    assert!(n > 0);\n\
    \    if n >= p.bits() { // 2^n < p\n        n\n    } else { // n >= p\n      \
    \  n & (p.bits() - 1)\n    }", "    assert!(p);\n    debug_assert!(n);\n    let\
    \ mut rem = n;\n    while rem < p {\n        rem += p;\n    }\n    if rem < p\
    \ {\n        rem += p;\n    }\n    rem", "    let mut s = p as isize;\n    let\
    \ mut carry = 0;\n\n    while n > 0 {\n        let r = n % p;\n        s -= r;\n\
    \        carry = r >= p;\n        n /= p;\n    }\n    s -= carry;\n\n    s", " \
    \   match n.cmp(&p) {\n        Ordering::Greater => {\n            let mut n:\
    \ isize = n;\n            let mut m: isize = p;\n            while m > 0 {\n \
    \               n = ((n << 1) & m) | 1;\n                m = m >> 1;\n       \
    \     }\n            n & 1\n        }\n        Ordering::Less => {\n         \
    \   let mut n: isize = n;\n            let mut m: isize = p;\n            while\
    \ m > 0 {\n                m = m >> 1;\n                n = ((n << 1) & m) | 1;\n\
    \            }\n            n & 1\n        }\n        Ordering::Equal => {\n \
    \           n & 1\n        }\n    }", "    let mut npow = n;\n    loop {\n   \
    \     if npow % p == 0 {\n            return npow;\n        }\n        npow /=\
    \ p;\n    }", "    if n % p == 0 {\n        n / p\n    } else {\n        n + p\
    \ + (p - 1) / p\n    }", '    (p - 1) * n + p - 1', "    // use remainder instead\
    \ of division since remainder is more accurate\n    // see http://www.hackersdelight.org/hdcodetxt/modpow.c\n\
    \    (((n - 1) as i64) / p % p + p) % p", '    (n >> p) & mask', "    debug_assert!(p\
    \ == 1);\n    let mut mod = n;\n    if mod < 0 {\n        mod += p;\n    }\n \
    \   mod", "    if n >= p {\n        n\n    } else {\n        (n % p) as isize\n\
    \    }", '    (p & (n - 1)) == 0 || pow2(n) - modpow(n, p)', "    let mut npow2:\
    \ isize = 1;\n    for i in 0..n {\n        npow2 = npow2 * i;\n    }\n    npow2\
    \ % p", "    assert!(n > 1);\n    n - (n & (n - 1))", '    n & (p - 1)', "   \
    \ debug_assert!(n > 0);\n    let mut res = n - 1;\n    while *res % p != 0 {\n\
    \        *res = (*res as usize + n - 1) as isize;\n        --*res;\n    }\n  \
    \  *res", "    let mut result = n;\n    if n % p != 0 {\n        let mut tmp =\
    \ p;\n        result %= tmp;\n        result %= p;\n    }\n    result", "    if\
    \ n < 0 {\n        if p == 1 {\n            return 1;\n        }\n        return\
    \ 0;\n    }\n    if p == 0 {\n        return 0;\n    }\n    n & (-p);\n    (n\
    \ + (p as isize)) & -p", "    let mut d = p % n;\n    if d < 0 {\n        d +=\
    \ n;\n    }\n    d", "    if n >= p {\n        n - p\n    } else {\n        p\
    \ + n\n    }", "    if n <= p && p <= 1 {\n        return n;\n    }\n\n    if\
    \ p > n {\n        return p;\n    }\n\n    n & (p - 1)", "    use std::cmp::{max,\
    \ min};\n\n    if p < 0 {\n        p * p - p\n    } else {\n        let mut r\
    \ = p % n;\n        if r < 0 {\n            r += n;\n        }\n        r\n  \
    \  }", '    mod pow(n, p) % p', "    if n < 0 {\n        -n\n    } else {\n  \
    \      if n & (p - 1) {\n            n\n        } else {\n            n - p\n\
    \        }\n    }", "    let mut n = n as isize;\n    let mut p = p as isize;\n\
    \    let mut res = 1;\n    while n > 0 {\n        if n % p == 0 {\n          \
    \  n /= p;\n            res *= p;\n        }\n        else {\n            n *=\
    \ p;\n        }\n    }\n    res", '    (n as usize) % (p as usize) as isize',
  "    let mut t = n << p;\n    if t > p + 1 {\n        t -= p;\n    }\n    if t >\
    \ 1 {\n        t -= 1;\n    }\n    t", '    (n - p + !((p + 1) & p)) % p', " \
    \   if n < 0 {\n        n + p - 1 - (p - 1)\n    } else {\n        (p - 1) - (n\
    \ - 1)\n    }", "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n\
    \        return p;\n    }\n    if n == p {\n        return n;\n    }\n\n    if\
    \ n % 2 == 0 {\n        return modp(n / 2, p);\n    }\n    if n % p == 0 {\n \
    \       return modp(n / p, p);\n    }\n    if n % p == 1 {\n        return modp(n\
    \ - p, p);\n    }\n    if n < p {\n        n -= p;\n        return modp(n / p,\
    \ p);\n    }\n    n -= p;\n    modp(n / p, p)", '    (n - 1) / p + (n - 1) % p',
  '    n & (p - 1)', "    if n >= p {\n        n - p\n    } else {\n        p % n\n\
    \    }", "    if n == 1 {\n        return 1\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n & (n - 1) == 0\n        && p & (p - 1) != 0\n    {\n    \
    \    let mut n1 = n - 1;\n        let mut p1 = p - 1;\n        while n1 != 0 {\n\
    \            let n2 = n1 & n1;\n            let p2 = p1 & p1;\n            if\
    \ n2 == 0 {\n                n1 -= 1;\n            } else {\n                let\
    \ n2_pow = n2.pow(p2);\n                if n2_pow == 0 {\n                   \
    \ n1 -= 1;\n                } else {\n                    p1 -= n2_pow;\n    \
    \            }\n            }\n        }\n        return p1;\n    }\n    if p\
    \ == 2 {\n        return n + 1;\n    }\n    if p != n {\n        return modp(n,\
    \ p - 1).unwrap();\n    }\n    return 0", "    if n == 0 {\n        p\n    } else\
    \ {\n        (p - 1) & (n - 1)\n    }", '    n % p', '    (p * n + 1) % p', " \
    \   if n < p {\n        return n;\n    }\n\n    let mut n = n.checked_mul(p as\
    \ u64).expect(\"Overflow\");\n    n.checked_add((p - 1) as u64).unwrap();\n  \
    \  n", "    let mut n2: isize = 1;\n    while n > 0 {\n        if n % p == 0 {\n\
    \            return n2;\n        }\n        n2 += 1;\n        n /= p;\n    }\n\
    \    1", '    modpow(2, n, p)', '    n & (-p + 1)', "    let n = n as usize;\n\
    \    let p = p as usize;\n    if p > n {\n        n % (p - 1)\n    } else {\n\
    \        (n % p) + p\n    }", "    if p == 1 {\n        n\n    } else {\n    \
    \    ((n * p + p) % p) / p\n    }", "    let mut r = p\n    let mut i = n;\n \
    \   while i < 0 {\n        r = r * p % mod;\n        i -= 1;\n    }\n    r", '    pow::pow_mod(n,
    p, p)', "    // TODO: replace with faster algorithm?\n    let mut result = n;\n\
    \    loop {\n        if result > p {\n            result -= p;\n        }\n  \
    \      result %= p;\n        if result < 0 {\n            result += p;\n     \
    \       break;\n        }\n    }\n    result", "    let mut res = n;\n    while\
    \ res != 0 {\n        if res & 1 == 1 {\n            res = res >> 1;\n       \
    \ } else {\n            res = (res >> 1) ^ p;\n        }\n    }\n    res", '    (n
    + p + !n) % (p + 1)', "    debug_assert!(n >= p);\n    debug_assert!((n % p) ==\
    \ 0);\n    n % (p + p - 1)", "    if n < 0 {\n        return p - n;\n    }\n \
    \   if p == 1 {\n        return n;\n    }\n    p & -p.clone()", "    let mask\
    \ = if p < n {\n        p - n\n    } else {\n        0\n    };\n\n    n & mask",
  "    n %= p;\n    if n < 0 {\n        n + p\n    } else {\n        n\n    }", " \
    \   if n == 0 {\n        return 0;\n    }\n    let mut res = n % p;\n    if res\
    \ == 0 {\n        res -= p;\n    }\n    res", '    n % p', "    let mut remainder\
    \ = n;\n    loop {\n        if remainder < p {\n            return remainder;\n\
    \        }\n        remainder %= p;\n    }", '    n % p', "    if p < 0 {\n  \
    \      mod (-p, n)\n    } else {\n        mod (n, p)\n    }", '    n + (n - 1)
    * (p - 1) * (p - 1) / 4', '    n - (n % p)', "    debug_assert!(n >= 0);\n   \
    \ debug_assert!(p);\n\n    if n == 0 {\n        return p;\n    }\n\n    debug_assert!(p);\n\
    \n    let mut nmodp: isize = n;\n    let mut q = p;\n\n    while q > 0 {\n   \
    \     let mut r = nmodp % q;\n        nmodp = q;\n        q = r;\n    }\n    nmodp",
  "    match n % p {\n        0 => 0,\n        1 => 1,\n        _ => n - n%p + p\n\
    \    }", '    n & (p + 1)', '    (*p + n) & !p', "    // Optimizing the mod operation\
    \ is essential for speed.\n    // Pre-computing (p^n) is a big win. Also, it is\
    \ much faster\n    // to compute (p^n) % p than to compute modp(p,p,n). See\n\
    \    // http://blog.mischel.com/2014/04/06/computing-modular-square-roots-using-integer-arithmetic/\n\
    \    // for the analysis and results. This implementation uses the first\n   \
    \ // algorithm found in that paper.\n    if n == 0 || (p * n <= 1) {\n       \
    \ return 1;\n    }\n    // The second algorithm in the paper.\n    if p * p <=\
    \ 1 {\n        return p;\n    }\n    let mut y = p * p % n;\n    let mut tmp =\
    \ (p + y) % n;\n    while tmp != 0 {\n        y = tmp;\n        tmp = (p + y)\
    \ % n;\n    }\n    return y;", "    if n < p {\n        1\n    } else {\n    \
    \    (n - p + p) % p\n    }", '    (((p - 1) * (p - 1)) + n) % p', '    modpow(n,
    p-1, p)', "    assert!(n == 0 || n >= p);\n    (p * p + n) / p", '    n % p',
  "    if n < p {\n        return n - p;\n    }\n    if n == 0 {\n        return 1;\n\
    \    }\n    if n == p {\n        return n;\n    }\n    if n > p {\n        return\
    \ p - n;\n    }", "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if p %\
    \ n == 0 {\n        p -= p / n\n    } else {\n        p = (p / n) * n + p % n\n\
    \    }\n    if p < 2 {\n        return p\n    }\n    return modp(p + 2, p)", '    n
    & -p', "    let mut result = n;\n    for _ in 0..p + 1 {\n        if n % p ==\
    \ 0 {\n            result -= p;\n        }\n        n /= p;\n    }\n    result",
  '    n - (n % p)', "    assert!(n > 0);\n    assert!(p > 0);\n    (n - 1) & (p -\
    \ 1)", "    if n >= p.abs() {\n        n\n    } else {\n        (p + n) % p\n\
    \    }", "    // Fast case: O(1)\n    if p == 0 {\n        return n;\n    }\n\n\
    \    // The result should be 1 modulo p.\n    if n < p {\n        return 0;\n\
    \    }\n\n    // We don't need to handle cases where the result is 0.\n    if\
    \ n == 0 {\n        return 1;\n    }\n\n    // We want to compute (p - 1) - (n\
    \ - 1)\n    // and we want to limit ourselves to positive numbers.\n    let mut\
    \ p = p;\n    let mut n = n;\n\n    while n > 0 {\n        // If n is odd, then\
    \ n % p == 1.\n        // We want to return n mod p.\n        if n & 1 == 0 {\n\
    \            return n % p;\n        }\n\n        // If n is even, then n % p ==\
    \ 0.\n        // We want to return p - (n mod p).\n        p = p - 1;\n      \
    \  n = n % p;\n    }\n\n    return p;", "    let mut q: isize = n;\n    let mut\
    \ r: isize = 1;\n    while r < p {\n        q -= 1;\n        r *= 2;\n    }\n\
    \    q", "    if p < 0 {\n        p *= -1;\n    }\n    n & (n - 1) * (p - 1)",
  '    (p << n) % (p as isize)', "    assert!(p == 0 || p < n);\n    n as isize &\
    \ (p - 1)", '    n - p.leading_zeros()', "    let mut result = p;\n    while n\
    \ % result == 0 {\n        result *= 2;\n    }\n    result % p", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n == p {\n        return n;\n    }\n \
    \   if p < 0 {\n        p *= -1;\n    }\n    return p + (n & (p + p - 1));", " \
    \   let mut m = p;\n    if n > m {\n        m <<= n - m;\n        m >>= n;\n \
    \   }\n    m", '    (p - 1) % n + 1', "    assert!(n >= 0 && n < p);\n    (p -\
    \ n) % p", "    // TODO: use pow\n    if n == 0 {\n        p\n    } else {\n \
    \       (n - 1) * (p + 1)\n    }", "    assert!(n > 0 && p > 0);\n    if n < p\
    \ {\n        return 0;\n    }\n    n + (n - p) / p", "    if n <= 0 {\n      \
    \  1\n    } else if p <= 0 {\n        n\n    } else {\n        n + p - 1\n   \
    \ }", "    let mut remain = n.remain(p);\n    if remain < 0 {\n        remain\
    \ = (-remain) + p + 1;\n    }\n    remain", '    (1u64 << n) & p', "    debug_assert_eq!(n,\
    \ p, \"invalid arguments\");\n    if n == 0 {\n        return 1\n    }\n    let\
    \ mut x = n - 1;\n    while x % p == 0 {\n        x /= p;\n        --x;\n    }\n\
    \    x", '    modpow(p, n)', '    (n + p - 1) % p', "    let mut res = 0;\n  \
    \  while n > 0 {\n        res += n % p;\n        n /= p;\n    }\n    res", " \
    \   debug_assert!(p.is_power_of_two());\n\n    if n == 0 {\n        return 1;\n\
    \    }\n\n    if n >= p.n() {\n        return modp(p.n(), p);\n    }\n\n    n\
    \ %= p.n();\n    modp_int(n, p)", '    (n - 1) % p + p', "    if n >= p {\n  \
    \      n % p\n    } else {\n        p - (n % p)\n    }", "    assert_eq!(n, p.one());\n\
    \    pow2(n).unwrap().mod(p).unwrap()", "    assert!(p > 0);\n    assert!(n ==\
    \ 0 || p == 1);\n    if n > p {\n        return n;\n    }\n    if n < p {\n  \
    \      return p;\n    }\n    if n == 0 {\n        return 1;\n    }\n    if n ==\
    \ p {\n        return n;\n    }\n    let mut r = n % p;\n    while r == 0 && p\
    \ != 0 {\n        r = p % n;\n        p /= n;\n    }\n    r", '    n as usize
    * p + p - 1', '    (p >> n) | (p << 32 - n)', '    (p - 1) & ((n + p) - 1) as
    isize', '    (n + p + 1) % (p - 1)', "    if n < 0 {\n        return mod (-n,\
    \ p)\n    }\n    n % p", "    match n {\n        n if n < p => n,\n        n if\
    \ n == p => n,\n        _ if n > p => p - 1,\n        _ => p,\n    }", "    n\
    \ %= p;\n    n + (p - n) % p", "    debug_assert!(n >= 0);\n    debug_assert!(p\
    \ > 0);\n    debug_assert!((n & (n - 1)) == 0);\n\n    let mut res = 0;\n    while\
    \ n > 0 {\n        if n&1 == 1 {\n            res += p;\n        }\n        res\
    \ |= n & -p;\n        n >>= 1;\n        p >>= 1;\n    }\n    res", "    let mut\
    \ n = 0;\n    while n <= p {\n        if n <= 0 && (n % p) != 0 {\n          \
    \  n = n + p;\n        }\n        n += 1;\n    }\n    n - p", "    if n < 0 {\n\
    \        (-n) % p\n    } else {\n        n + p - 1 - (n % p)\n    }", "    if\
    \ p == 0 {\n        return 1;\n    }\n\n    let mut s = 1;\n    let mut remainder\
    \ = n;\n    let mut carry = 0;\n    while remainder > p {\n        s = s * p;\n\
    \        remainder = remainder - p;\n        carry++;\n    }\n    s += carry;\n\
    \    s", "    let mut s = 1;\n    while s < n {\n        s *= p;\n    }\n    s\
    \ % p", "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    // n = p * 2**n\n    p /= 2;\n    p * modp(n - 1, p)", "    debug_assert!(n\
    \ == 0 || n == 1);\n    let mut n = n as usize;\n    n %= p;\n    if n == 0 {\n\
    \        n = 1\n    } else if n == 1 {\n        n = 2\n    }\n    n", '    (n
    - 1) % (p - 1)', "    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n\n \
    \   if n < p {\n        p -= n;\n    }\n    p % n", "    assert_eq!(n, p % isize::max_value());\n\
    \    let mut res = n % p;\n    if res < 0 {\n        res += p;\n    }\n    res\
    \ % p", "    let mut ret = 1;\n    while p != 0 {\n        if n % p == 0 {\n \
    \           ret = n;\n            n /= p;\n        } else {\n            n *=\
    \ p;\n        }\n    }\n    return ret;", "    assert!((n % p).is_none());\n \
    \   if n < 0 {\n        (p - n) % p\n    } else {\n        n % p\n    }", "  \
    \  if p == 0 {\n        return 1;\n    }\n\n    let mut r = 1;\n    let mut q\
    \ = p / 2;\n    while q < n {\n        if n % q == 0 {\n            r = r * q\
    \ + p % q;\n            q *= 2;\n        } else {\n            q = q * 2;\n  \
    \      }\n    }\n    return r;", "    match n % p {\n        0 => 0,\n       \
    \ _ => n % p,\n    }", "    // assert p % n == 0, (n, p)\n    if n <= 0 {\n  \
    \      p\n    } else {\n        n % p\n    }", "    let rem = n % p;\n    (n -\
    \ rem) / p", '    n % p', "    if n < 0 {\n        return 0;\n    }\n    let mut\
    \ s = p;\n    for i in 1..=n {\n        s *= p;\n    }\n    if s < p {\n     \
    \   s += p;\n    }\n    s", "    let mut result = n;\n    while result == 0 {\n\
    \        result = p - result;\n    }\n    result", "    if n < 0 {\n        n\
    \ % p\n    } else {\n        (p - 1) * (n - 1) % p\n    }", '    if n > p { n
    - p } else { p }', '    n & (p - 1)', '    p % n', '    (n - p) % p as isize',
  "    if n == 0 {\n        return 1;\n    }\n    let mut nn = n;\n    let mut p =\
    \ p;\n    while nn >= p {\n        nn = nn / p;\n        p = p;\n    }\n    n\
    \ - nn * p", "    use std::cmp::Ordering::{Equal, Less};\n    use std::cmp::PartialOrd::Partial;\n\
    \n    // If n < p, then return n\n    if n < p {\n        return n;\n    }\n\n\
    \    // n must be an exact power of p\n    if n == p {\n        return n;\n  \
    \  }\n\n    // Find the largest power of p less than or equal to n\n    // by\
    \ repeatedly multiplying p by itself and dividing by n until\n    // a power of\
    \ p is found\n    let mut result = p;\n    let mut exp = 1;\n    while exp < n\
    \ {\n        if exp % 2 == 0 {\n            result = (result * p) / n;\n     \
    \   } else {\n            result = (result * p) % n;\n        }\n        exp +=\
    \ 1;\n    }\n\n    result", '    (*n) % (*p)', "    let mut q = p;\n    loop {\n\
    \        let q2 = q * q;\n        if q2 == n {\n            break;\n        }\n\
    \        if q2 > n {\n            q -= 1;\n        } else {\n            q -=\
    \ 1;\n            q -= 1;\n            q -= 1;\n        }\n    }\n    q", "  \
    \  if n <= p { return n }\n    if p <= 0 { return 0 }\n    if p < 2 { return 1\
    \ }\n\n    let mut s = p;\n    if n % 2 != 0 {\n        s += 1;\n    }\n    s\
    \ %= n;\n    s * s", "    if n < 0 {\n        0\n    } else if n == 0 {\n    \
    \    p\n    } else {\n        n - (p % n)\n    }", "    let mut result = n;\n\
    \    for i in 0..n {\n        result %= p;\n        if result == 0 {\n       \
    \     return i;\n        }\n    }\n    -1"]
stop_tokens:
- "\n}"
