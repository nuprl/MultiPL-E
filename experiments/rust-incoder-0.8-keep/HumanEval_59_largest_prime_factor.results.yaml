name: HumanEval_59_largest_prime_factor
language: rust
results:
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..=n)\n        .filter(|factor|\
    \ n % factor == 0)\n        .max().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpbcc52mxa.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut j = 2;\n    while i * j <= n {\n        if n % i == 0 {\n            i +=\
    \ 1;\n            j += 1;\n        }\n        else {\n            i += j;\n  \
    \          j = i;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp_mjiii50.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 || is_prime(n)\
    \ {\n        return n;\n    }\n\n    let mut f = 2;\n    let mut m = n;\n    while\
    \ !is_prime(m) {\n        f += 1;\n        while m % f == 0 {\n            m /=\
    \ f;\n        }\n    }\n\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpp439ot20.rs:7:17\n\
    \  |\n7 |     if n < 2 || is_prime(n) {\n  |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpp439ot20.rs:13:12\n   |\n13 |     while !is_prime(m) {\n   |  \
    \          ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max_i = i;\n    let mut j = i;\n    while i < n {\n        while j > 1 &&\
    \ n % j == 0 {\n            j += i;\n        }\n        if j == i {\n        \
    \    max_i = i;\n        }\n        i += 1;\n        j = i;\n    }\n    max_i\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `5`', /tmp/tmp5b8c9gyr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \n    let mut f = 1;\n    let mut i = 3u64;\n\n    while i * i <= n {\n      \
    \  if n % i == 0 {\n            i += 1;\n        } else {\n            f += i;\n\
    \        }\n    }\n\n    if f <= n {\n        f\n    } else {\n        n\n   \
    \ }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmp0mq2oyl_.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0mq2oyl_.rs:12:20\n   |\n12 |     while i * i <= n {\n\
    \   |                    ^ expected `u64`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `u64` and panic if the converted value doesn't fit\n\
    \   |\n12 |     while i * i <= n.try_into().unwrap() {\n   |                 \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0mq2oyl_.rs:13:16\n\
    \   |\n13 |         if n % i == 0 {\n   |                ^ expected `isize`, found\
    \ `u64`\n\nerror[E0277]: cannot mod `isize` by `u64`\n  --> /tmp/tmp0mq2oyl_.rs:13:14\n\
    \   |\n13 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % u64`\n   |\n   = help: the trait `Rem<u64>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0mq2oyl_.rs:20:13\n\
    \   |\n20 |     if f <= n {\n   |             ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     if f <= n.try_into().unwrap() {\n   |    \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0mq2oyl_.rs:21:9\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n21\
    \ |         f\n   |         ^ expected `isize`, found `u64`\n   |\nhelp: you can\
    \ convert a `u64` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n21 |         f.try_into().unwrap()\n   |          ++++++++++++++"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut ret = 1;\n  \
    \  let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            ret\
    \ = i;\n            i += 2;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp29edm8id.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: more efficient\
    \ way\n    if n % 2 == 0 {\n        n / 2\n    } else {\n        let i = 2u64;\n\
    \        n / i while i <= n / 2\n    }\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `while`\n  --> /tmp/tmpsursn1gc.rs:12:15\n   |\n12 |         n\
    \ / i while i <= n / 2\n   |               ^^^^^ expected one of 8 possible tokens\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1 {\n        let\
    \ mut i = 2;\n        while i * i <= n {\n            i += 1;\n        }\n   \
    \     if n % i == 0 {\n            i\n        } else {\n            i\n      \
    \  }\n    } else {\n        1\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmprt4xilso.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // First check that the\
    \ number is a prime.\n    if n <= 1 {\n        return 1;\n    }\n\n    // Check\
    \ if the number is composite.\n    if n%2 == 0 {\n        return 2;\n    }\n\n\
    \    let mut m = n as isize;\n    // Find the largest factor of n.\n    for _\
    \ in 0..n {\n        m += 1;\n        if m > n {\n            break;\n       \
    \ }\n    }\n    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `5`', /tmp/tmpbfvxwcuw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n\n  \
    \  // Keep finding largest prime factors, starting with i.\n    while i <= n {\n\
    \        let m = n % i;\n\n        if m != 0 {\n            return i;\n      \
    \  }\n        i += 1;\n    }\n\n    // No factors found. Return 1.\n    1\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpo5ikyw4y.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \n    let mut factors = Vec::new();\n    factors.push(2);\n\n    for &factor in\
    \ &factors {\n        if n % factor == 0 {\n            factors.push(factor);\n\
    \            n /= factor;\n        }\n    }\n\n    if n > 1 {\n        factors.push(1);\n\
    \    }\n\n    factors.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpfj7bmouo.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfj7bmouo.rs:23:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n23 |     factors.iter().max().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |     *factors.iter().max().unwrap()\n\
    \   |     +\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factor *= i;\n            n /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpcbzhxbtu.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1];\n\
    \    for num in 2..=n {\n        if n % num == 0 {\n            let factor: isize\
    \ = num;\n            factors.push(factor);\n            n /= num;\n        }\n\
    \    }\n\n    factors\n        .iter()\n        .skip(1)\n        .max()\n   \
    \     .unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqpjncbfe.rs:16:5\n   |\n\
    6  |   fn largest_prime_factor(n: isize) -> isize {\n   |                    \
    \                    ----- expected `isize` because of return type\n...\n16 |\
    \ /     factors\n17 | |         .iter()\n18 | |         .skip(1)\n19 | |     \
    \    .max()\n20 | |         .unwrap()\n   | |_________________^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \   *factors\n   |     +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 0;\n    let mut primes_taken = HashSet::new();\n    let mut i = 2;\n    while\
    \ i <= n {\n        if primes_taken.insert(&i).is_ok() {\n            if n % i\
    \ == 0 {\n                largest_factor = i;\n            }\n        }\n    \
    \    i += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpdad7awm1.rs:8:28\n  |\n8 |     let mut primes_taken = HashSet::new();\n\
    \  |                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_helper(n,\
    \ 1, 0, Vec::new())\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_helper` in this\
    \ scope\n --> /tmp/tmpois8srxn.rs:7:5\n  |\n7 |     largest_prime_factor_helper(n,\
    \ 1, 0, Vec::new())\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factor *= i;\n            n /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2bntfaz7.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return i;\n        }\n  \
    \      i += 1;\n    }\n    return n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpzvq0e9ps.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..).skip_while(|x|\
    \ *x % n != 0)\n        .skip_while(|x| *x == 0)\n        .max()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp506qbtax.rs:7:5\n  |\n6 |\
    \   fn largest_prime_factor(n: isize) -> isize {\n  |                        \
    \                ----- expected `isize` because of return type\n7 | /     (1..).skip_while(|x|\
    \ *x % n != 0)\n8 | |         .skip_while(|x| *x == 0)\n9 | |         .max()\n\
    \  | |______________^ expected `isize`, found enum `Option`\n  |\n  = note: expected\
    \ type `isize`\n             found enum `Option<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i <= n {\n        while n % i == 0 {\n            i += 1;\n        }\n     \
    \   if i == 2 {\n            break;\n        }\n        i += 1;\n    }\n    i\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpa6xs9t7k.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut factor = 1;\n    while m > 1 {\n        let p = &*m / factor;\n        if\
    \ *p == 1 {\n            return factor;\n        }\n        if p % 2 == 0 {\n\
    \            m = (*p * m) / 2;\n            factor = factor * 2;\n        } else\
    \ {\n            m = (*p * m) / 3;\n            factor = factor * 3;\n       \
    \ }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpvcuch62c.rs:10:18\n\
    \   |\n10 |         let p = &*m / factor;\n   |                  ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_factor(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_factor` in this scope\n -->\
    \ /tmp/tmpq79g__pv.rs:7:5\n  |\n7 |     largest_factor(n).unwrap()\n  |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut m = i;\n    while i <= n {\n        let p1 = i;\n        while p1 % m ==\
    \ 0 {\n            p1 /= m;\n        }\n        p1 = m;\n        while p1 % (i\
    \ * i) == 0 {\n            p1 /= i * i;\n        }\n        if p1 < n {\n    \
    \        m = p1;\n        }\n        i += 1;\n    }\n    m\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `p1`\n  --> /tmp/tmp68kb5l0s.rs:12:13\n\
    \   |\n10 |         let p1 = i;\n   |             --\n   |             |\n   |\
    \             first assignment to `p1`\n   |             help: consider making\
    \ this binding mutable: `mut p1`\n11 |         while p1 % m == 0 {\n12 |     \
    \        p1 /= m;\n   |             ^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `p1`\n  --> /tmp/tmp68kb5l0s.rs:14:9\n\
    \   |\n10 |         let p1 = i;\n   |             --\n   |             |\n   |\
    \             first assignment to `p1`\n   |             help: consider making\
    \ this binding mutable: `mut p1`\n...\n14 |         p1 = m;\n   |         ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `p1`\n  --> /tmp/tmp68kb5l0s.rs:16:13\n   |\n10 |    \
    \     let p1 = i;\n   |             --\n   |             |\n   |             first\
    \ assignment to `p1`\n   |             help: consider making this binding mutable:\
    \ `mut p1`\n...\n16 |             p1 /= i * i;\n   |             ^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n / 2;\n\
    \    while m % 2 == 0 {\n        m /= 2;\n    }\n    m\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpvb2zkzg7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut i = 2;\n\n    loop {\n        loop {\n            if n % i == 0 {\n\
    \                n /= i;\n                return i;\n            }\n\n       \
    \     i += 1;\n        }\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpusgho5__.rs:14:24\n   |\n\
    14 |                 return i;\n   |                        ^ expected `isize`,\
    \ found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n14 |                 return i.try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n).fold(1, |a, b|\
    \ {\n        if n % a == 0 {\n            a\n        } else {\n            if\
    \ n % b == 0 {\n                b\n            } else {\n                (a *\
    \ b) / b\n            }\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmppdzt14it.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    let mut m = 3;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            i += m;\n        } else {\n            i += 2;\n        }\n\
    \        m += 2;\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpkred_tnp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut k = m;\n    let mut i = 2;\n    while i <= k {\n        if n % i == 0 {\n\
    \            m = i;\n            k = n / i;\n        }\n        i += 1;\n    }\n\
    \    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpzd_zxc0s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    prime_factors(n).iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpcmiu6tqs.rs:7:5\n  |\n7 |     prime_factors(n).iter().max().unwrap()\n\
    \  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    let mut result = 1;\n    for i in 2..n {\n        if n % i == 0 {\n     \
    \       result = i;\n            break;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpglx2t0vi.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // 2 is\
    \ the smallest possible factor\n    loop {\n        while i * i <= n {\n     \
    \       if n % i == 0 {\n                n /= i;\n                break\n    \
    \        }\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "warning: unreachable expression\n  --> /tmp/tmpxabuqm99.rs:17:5\n   |\n\
    8  | /     loop {\n9  | |         while i * i <= n {\n10 | |             if n\
    \ % i == 0 {\n11 | |                 n /= i;\n...  |\n15 | |         }\n16 | |\
    \     }\n   | |_____- any code following this expression is unreachable\n17 |\
    \       n\n   |       ^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmpxabuqm99.rs:11:17\n   |\n6  | fn largest_prime_factor(n: isize) -> isize\
    \ {\n   |                         - help: consider making this binding mutable:\
    \ `mut n`\n...\n11 |                 n /= i;\n   |                 ^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_divisor =\
    \ 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n      \
    \      max_divisor = i;\n            i += 1;\n        } else {\n            i\
    \ += 2;\n        }\n    }\n    max_divisor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpzh9t7hz5.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut is_prime = true;\n\
    \    let mut max_factor = 1;\n    let mut factor = 2 * n + 1;\n    while factor\
    \ <= n {\n        if n % factor == 0 {\n            is_prime = false;\n      \
    \  }\n        factor = factor * 2 + 1;\n    }\n    if is_prime {\n        max_factor\n\
    \    } else {\n        factor\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpgrc5kfzp.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Fast path: n is small\
    \ or is not a prime\n    if n <= 2 || n % 2 == 0 {\n        return 1;\n    }\n\
    \n    // Largest prime factor is less than n\n    let mut i = 2;\n    let mut\
    \ prime_found = false;\n    while i * i < n && !prime_found {\n        if n %\
    \ i == 0 {\n            prime_found = true;\n        } else {\n            i +=\
    \ 2;\n        }\n    }\n\n    // Only prime factors larger than n are returned\n\
    \    if prime_found && i > n {\n        i\n    } else {\n        i\n    }\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp1e40f11b.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n\
    \            i -= 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = 0;\n    for\
    \ i in 2..=n {\n        if n % i == 0 {\n            m = i;\n        }\n    }\n\
    \    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpkz_geqm2.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    let\
    \ mut max = 1;\n    while i < n {\n        if n % i == 0 {\n            i += 2;\n\
    \        } else {\n            i += 1;\n            max = i;\n        }\n    }\n\
    \    max\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmprxf9ri00.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut s = i;\n    while s < n {\n        if n % i == 0 {\n            i += 2;\n\
    \        }\n        i += 1;\n        s -= i;\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 2;\n\
    \    let mut m = 0;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ i += 1;\n            m += 1;\n        } else {\n            i += 2;\n      \
    \  }\n    }\n    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpbqvd33if.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i <= sqrt(n as u64) {\n        if n % i == 0 {\n            return i;\n    \
    \    }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n --> /tmp/tmpn98pbqu7.rs:8:16\n\
    \  |\n8 |     while i <= sqrt(n as u64) {\n  |                ^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n\n    let mut i = 2;\n    while i <= n {\n        if n % i\
    \ == 0 {\n            return i;\n        }\n        i += 2;\n    }\n\n    n\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpu5dw883q.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut f = 1;\n    while i <= n {\n        if n % i == 0 {\n            i += 1;\n\
    \        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // n is prime\n    if\
    \ n < 2 {\n        return 1;\n    }\n\n    // n is a prime\n    if n == 2 {\n\
    \        return 1;\n    }\n\n    // n is a perfect power of two\n    if n == std::i32::MAX\
    \ {\n        return n;\n    }\n\n    let mut n = n; while n >= 2 {\n        if\
    \ n % 2 == 0 {\n            n /= 2;\n        } else {\n            return n;\n\
    \        }\n    }\n\n    // n isn't a prime but n != std::i32::MAX\n    n\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxfxsvp34.rs:18:13\n   |\n\
    18 |     if n == std::i32::MAX {\n   |             ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |     if n == std::i32::MAX.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 2i32;\n\
    \    let mut i = 2i32;\n    while i < n {\n        if n % i == 0 {\n         \
    \   i += 1;\n        } else {\n            res = i;\n            break;\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplrs7zyls.rs:9:15\n  |\n9 |\
    \     while i < n {\n  |               ^ expected `i32`, found `isize`\n  |\n\
    help: you can convert an `isize` to an `i32` and panic if the converted value\
    \ doesn't fit\n  |\n9 |     while i < n.try_into().unwrap() {\n  |           \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplrs7zyls.rs:10:16\n\
    \   |\n10 |         if n % i == 0 {\n   |                ^ expected `isize`, found\
    \ `i32`\n\nerror[E0277]: cannot mod `isize` by `i32`\n  --> /tmp/tmplrs7zyls.rs:10:14\n\
    \   |\n10 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % i32`\n   |\n   = help: the trait `Rem<i32>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplrs7zyls.rs:17:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n17\
    \ |     res\n   |     ^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    17 |     res.try_into().unwrap()\n   |        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    fn test_primality(n: isize) -> bool {\n        // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \        // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n\
    \        if n <= 1 {\n            return true;\n        }\n        if n % 2 ==\
    \ 0 {\n            return false;\n        }\n        for d in prime_divisors(n)\
    \ {\n            if n % d == 0 {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n    fn max_factor(n: isize) -> isize\
    \ {\n        if n % 2 == 0 {\n            return 2;\n        }\n        let mut\
    \ max_factor = 2;\n        for d in prime_divisors(n) {\n            if n % d\
    \ == 0 {\n                let new_factor = max_factor * d;\n                if\
    \ new_factor < n {\n                    return max_factor;\n                }\n\
    \                max_factor = new_factor;\n            }\n        }\n        return\
    \ max_factor;\n    }\n    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n  \
    \  if test_primality(n) {\n        return max_factor(n);\n    }\n    // https://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_number\n\
    \    // https://en.wikipedia.org/wiki/Primality_test#Test_of_prime_number\n  \
    \  for d in prime_divisors(n) {\n        if n % d == 0 {\n            return max_factor(n);\n\
    \        }\n    }\n    return 2;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_divisors` in this scope\n  -->\
    \ /tmp/tmpa_zv4rcn.rs:17:18\n   |\n17 |         for d in prime_divisors(n) {\n\
    \   |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `prime_divisors` in this scope\n  --> /tmp/tmpa_zv4rcn.rs:29:18\n\
    \   |\n29 |         for d in prime_divisors(n) {\n   |                  ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `prime_divisors`\
    \ in this scope\n  --> /tmp/tmpa_zv4rcn.rs:47:14\n   |\n47 |     for d in prime_divisors(n)\
    \ {\n   |              ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3;\n    loop\
    \ {\n        if n % i == 0 {\n            i += 1;\n        }\n        else {\n\
    \            return i;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpoycia3_s.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_factor_internal(n,\
    \ 1, n)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factor_internal`\
    \ in this scope\n --> /tmp/tmph6dvqhz_.rs:7:5\n  |\n7 |     largest_prime_factor_factor_internal(n,\
    \ 1, n)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            i *= 2;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpv_q2waf_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Look at each divisor\
    \ from 1 to sqrt(n).\n    let mut factors = Vec::new();\n    for i in (1..n).step_by(2)\
    \ {\n        let divisor = n - i;\n        if divisor % 2 == 0 {\n           \
    \ factors.push(divisor / 2);\n        } else {\n            factors.push(i);\n\
    \        }\n    }\n    // Keep the largest prime factor of n.\n    factors.iter().max().unwrap_or(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa0y8y72i.rs:18:36\n   |\n\
    18 |     factors.iter().max().unwrap_or(n)\n   |                             \
    \       ^\n   |                                    |\n   |                   \
    \                 expected `&isize`, found `isize`\n   |                     \
    \               help: consider borrowing here: `&n`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa0y8y72i.rs:18:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n18 |     factors.iter().max().unwrap_or(n)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |     *factors.iter().max().unwrap_or(n)\n\
    \   |     +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest = i;\n\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest = i;\n            i += 1;\n        } else if i != 1 {\n       \
    \     i += 1;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpgri3aofs.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = Vec::new();\n\
    \    for (i, &p) in factor(n).iter().enumerate() {\n        if i == 0 {\n    \
    \        factors.push(p as isize);\n        } else {\n            if p > factors[i\
    \ - 1].unwrap() {\n                factors.truncate(i);\n                break;\n\
    \            }\n        }\n    }\n    factors.pop()\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factor` in this scope\n --> /tmp/tmp987bneu9.rs:8:20\n\
    \  |\n8 |     for (i, &p) in factor(n).iter().enumerate() {\n  |             \
    \       ^^^^^^ help: a local variable with a similar name exists: `factors`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp987bneu9.rs:18:5\n   |\n6  | fn\
    \ largest_prime_factor(n: isize) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n18 |     factors.pop()\n\
    \   |     ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // First calculate the\
    \ squareroot of n\n    let sqrt_n = isize::sqrt(n);\n\n    // Now we calculate\
    \ the largest prime factor of the squareroot\n    let mut largest_prime_factor\
    \ = 1;\n    while sqrt_n >= 4 {\n        largest_prime_factor += 1;\n        sqrt_n\
    \ = sqrt_n / 4;\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `sqrt` found for type\
    \ `isize` in the current scope\n --> /tmp/tmp3tjqx5cu.rs:8:25\n  |\n8 |     let\
    \ sqrt_n = isize::sqrt(n);\n  |                         ^^^^ function or associated\
    \ item not found in `isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_factor_iter(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factor_iter` in\
    \ this scope\n --> /tmp/tmp6ia2iw3z.rs:7:5\n  |\n7 |     largest_prime_factor_factor_iter(n).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_divisor\
    \ = 2isize;\n    let mut prime_divisor_found = false;\n    for i in 2..=n.bit_count()\
    \ {\n        prime_divisor = i if n % i == 0 && !prime_divisor_found {\n     \
    \       prime_divisor;\n        };\n        prime_divisor_found = (prime_divisor\
    \ as bool);\n    }\n    prime_divisor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpi8tmcmf1.rs:10:27\n   |\n10 |         prime_divisor\
    \ = i if n % i == 0 && !prime_divisor_found {\n   |                          \
    \ ^^ expected one of 8 possible tokens\n\nerror[E0599]: no method named `bit_count`\
    \ found for type `isize` in the current scope\n --> /tmp/tmpi8tmcmf1.rs:9:20\n\
    \  |\n9 |     for i in 2..=n.bit_count() {\n  |                    ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            return i;\n        }\n      \
    \  i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpcxz2wfis.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1u64;\n \
    \   let mut factor = 1;\n\n    while i * factor <= n {\n        if n % i == 0\
    \ {\n            factor *= i;\n            i += 1;\n        }\n        else {\n\
    \            i += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5vpl0dyx.rs:10:25\n   |\n\
    10 |     while i * factor <= n {\n   |                         ^ expected `u64`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u64` and panic if\
    \ the converted value doesn't fit\n   |\n10 |     while i * factor <= n.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5vpl0dyx.rs:11:16\n   |\n11 |         if n % i == 0 {\n\
    \   |                ^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod\
    \ `isize` by `u64`\n  --> /tmp/tmp5vpl0dyx.rs:11:14\n   |\n11 |         if n %\
    \ i == 0 {\n   |              ^ no implementation for `isize % u64`\n   |\n  \
    \ = help: the trait `Rem<u64>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n    \
    \         <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n          \
    \   <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5vpl0dyx.rs:19:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n19 |     factor\n   |     ^^^^^^ expected\
    \ `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |     factor.try_into().unwrap()\n\
    \   |           ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 0;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n  \
    \          if max_factor < i {\n                max_factor = i;\n            }\n\
    \        }\n        i += 1;\n    }\n    max_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpqbtnw8dt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut primes: Vec<isize> = vec![0; n];\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            primes.push(i);\n            i += 2;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    if primes.len() == 1 {\n        primes[0]\n\
    \    } else {\n        let mut max = primes[0];\n        for prime in primes {\n\
    \            if prime > max {\n                max = prime;\n            }\n \
    \       }\n        max\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk0d_89wl.rs:8:42\n  |\n8 |\
    \     let mut primes: Vec<isize> = vec![0; n];\n  |                          \
    \                ^ expected `usize`, found `isize`\n  |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n  |\n\
    8 |     let mut primes: Vec<isize> = vec![0; n.try_into().unwrap()];\n  |    \
    \                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n).fold(1, |acc,\
    \ factor| {\n        if n % factor == 0 {\n            acc\n        } else {\n\
    \            acc * factor\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5811886080`,\n right: `5`', /tmp/tmp3ine7_yu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut i = 2;\n    while i <= sqrt(n as usize) {\n        if n % i == 0\
    \ {\n            factor *= i;\n            i += 1;\n        } else {\n       \
    \     i += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n --> /tmp/tmpy0taah0e.rs:9:16\n\
    \  |\n9 |     while i <= sqrt(n as usize) {\n  |                ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut prime_factor = 1;\n\n    while i * i <= n {\n        if n % i == 0 {\n \
    \           prime_factor = i;\n            i += 1;\n        } else {\n       \
    \     i += 1;\n        }\n    }\n    prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpztnzuted.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor: isize\
    \ = 0;\n    let mut n: isize = n;\n    while n > 1 {\n        max_factor = n;\n\
    \        // Find largest prime factor\n        for p in sieve(n.checked_mul(max_factor).ok())\
    \ {\n            if p.checked_mul(max_factor).is_one() {\n                max_factor\
    \ = p.checked_mul(max_factor).unwrap();\n                break;\n            }\n\
    \        }\n        // If no prime factor is found, stop\n        if max_factor\
    \ == 1 {\n            break;\n        }\n        n = n.checked_mul(max_factor).unwrap();\n\
    \    }\n    max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sieve` in this scope\n  --> /tmp/tmpy_3rpo9b.rs:12:18\n\
    \   |\n12 |         for p in sieve(n.checked_mul(max_factor).ok()) {\n   |   \
    \               ^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `ok` found for enum `Option` in the current scope\n  --> /tmp/tmpy_3rpo9b.rs:12:50\n\
    \   |\n12 |         for p in sieve(n.checked_mul(max_factor).ok()) {\n   |   \
    \                                               ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_factors(&[&n])\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factors` in this\
    \ scope\n --> /tmp/tmpouhdrv8j.rs:7:5\n  |\n7 |     largest_prime_factor_factors(&[&n])\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 0;\n\
    \    while i < n {\n        i += 2;\n        if n % i == 0 {\n            n =\
    \ n / i;\n        } else {\n            break;\n        }\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfj36n4gn.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n = n / i;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 1;\n  \
    \  while n % res == 0 {\n        n /= res;\n        res++;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpr_kteari.rs:10:12\n\
    \   |\n10 |         res++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n10 |         { let tmp = res; res += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n10 -         res++;\n\
    10 +         res += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = n;\n\
    \    let mut max_factor = 2;\n    while result == 1 {\n        if n % max_factor\
    \ == 0 {\n            max_factor += 1;\n        }\n        result /= max_factor;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpaxupafqn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // Only\
    \ odd numbers.\n    loop {\n        if n % i == 0 {\n            i += 1;\n   \
    \     } else if i * i > n { break }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n2 = 2isize;\n\
    \    let mut prime: isize = 2;\n    while n2 <= n {\n        if n % n2 == 0 {\n\
    \            prime += 2;\n            n /= n2;\n        }\n        n2 += 1;\n\
    \    }\n    prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpek61lvhm.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= n2;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ n;\n    }\n    let mut f: isize = 1;\n    while f * f <= n {\n        if n %\
    \ f == 0 {\n            break;\n        }\n        f += 1;\n    }\n    f\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp1w3z5ukb.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 3usize;\n\
    \    while n % f == 0 { f *= 2; }\n    f\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpp4rs3plh.rs:8:15\n  |\n8 |\
    \     while n % f == 0 { f *= 2; }\n  |               ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n --> /tmp/tmpp4rs3plh.rs:8:13\n\
    \  |\n8 |     while n % f == 0 { f *= 2; }\n  |             ^ no implementation\
    \ for `isize % usize`\n  |\n  = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpp4rs3plh.rs:9:5\n  |\n6 | fn largest_prime_factor(n:\
    \ isize) -> isize {\n  |                                      ----- expected `isize`\
    \ because of return type\n...\n9 |     f\n  |     ^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     f.try_into().unwrap()\n  |      ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // start\
    \ at 2 since 2 is the first prime factor of n\n\n    while i*i <= n { // while\
    \ i*i still less than n\n        if n % i == 0 { // if n%i zero, then n is not\
    \ a prime\n            break;\n        }\n        i += 1;\n    }\n    i // i is\
    \ the greatest prime factor of n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpnceb6ohx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut max_factor_size = 1;\n    let mut i = 2;\n    for factor in\
    \ prime_numbers::iter().take_while(u64::is_odd) {\n        if n < factor {\n \
    \           break;\n        }\n\n        if n % factor == 0 {\n            i -=\
    \ 1;\n            max_factor_size = factor;\n        }\n\n        if i > n / factor\
    \ {\n            max_factor = 1;\n            max_factor_size = factor;\n    \
    \    }\n\n        if max_factor > n / factor {\n            break;\n        }\n\
    \    }\n\n    assert!(\n        max_factor_size == 1,\n        \"The largest prime\
    \ factor of {} should be 1. However, the {} prime factor is {}.\",\n        n,\n\
    \        n / max_factor_size,\n        max_factor_size\n    );\n    max_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `prime_numbers`\n\
    \  --> /tmp/tmp8me7nt6p.rs:10:19\n   |\n10 |     for factor in prime_numbers::iter().take_while(u64::is_odd)\
    \ {\n   |                   ^^^^^^^^^^^^^ use of undeclared crate or module `prime_numbers`\n\
    \nerror[E0599]: no function or associated item named `is_odd` found for type `u64`\
    \ in the current scope\n  --> /tmp/tmp8me7nt6p.rs:10:57\n   |\n10 |     for factor\
    \ in prime_numbers::iter().take_while(u64::is_odd) {\n   |                   \
    \                                      ^^^^^^ function or associated item not\
    \ found in `u64`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![false;\
    \ n + 1];\n    let mut factor = 2;\n    while primes[factor] == false {\n    \
    \    primes[factor] = true;\n        factor += 1;\n    }\n    factor\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8xid2d4l.rs:7:34\n  |\n7 |\
    \     let mut primes = vec![false; n + 1];\n  |                              \
    \    ^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n  |\n7 |     let\
    \ mut primes = vec![false; (n + 1).try_into().unwrap()];\n  |                \
    \                  +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8xid2d4l.rs:13:5\n   |\n6  | fn largest_prime_factor(n: isize)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n13 |     factor\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n13 |     factor.try_into().unwrap()\n\
    \   |           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1\n    let\
    \ mut j = 2\n    while i * j <= n {\n        if n % i == 0 {\n            i +=\
    \ 1;\n            while n % i == 0 {\n                i += 1;\n            }\n\
    \            if i == n / i {\n                return i\n            }\n      \
    \  }\n        j += 1;\n    }\n    i + 1\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpxs9qmf_f.rs:7:18\n\
    \  |\n7 |     let mut i = 1\n  |                  ^ help: add `;` here\n8 |  \
    \   let mut j = 2\n  |     --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `while`\n --> /tmp/tmpxs9qmf_f.rs:8:18\n  |\n8 |     let mut j = 2\n\
    \  |                  ^ help: add `;` here\n9 |     while i * j <= n {\n  |  \
    \   ----- unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 1;\n    for i in 2..=n {\n        let mut i = i;\n        let mut limit =\
    \ 1;\n        while i * i <= n {\n            if n % i == 0 {\n              \
    \  limit = i;\n                break;\n            }\n            i += 1;\n  \
    \      }\n        if limit != 1 {\n            prime_factor = i;\n        }\n\
    \    }\n    prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmps86t7us7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1;\
    \ n];\n\n    factors.next_back()\n        .unwrap()\n        .rev()\n        .enumerate()\n\
    \        .for_each(|(i, factor)| {\n            if !is_prime(&factor) {\n    \
    \            factors.remove(i);\n            }\n        });\n\n    factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptn938g0y.rs:14:17\n\
    \   |\n14 |             if !is_prime(&factor) {\n   |                 ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmptn938g0y.rs:7:31\n\
    \  |\n7 |     let mut factors = vec![1; n];\n  |                             \
    \  ^ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n  |\n7 |     let mut\
    \ factors = vec![1; n.try_into().unwrap()];\n  |                             \
    \   ++++++++++++++++++++\n\nerror[E0599]: no method named `next_back` found for\
    \ struct `Vec<{integer}>` in the current scope\n --> /tmp/tmptn938g0y.rs:9:13\n\
    \  |\n9 |     factors.next_back()\n  |             ^^^^^^^^^ method not found\
    \ in `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptn938g0y.rs:19:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n19\
    \ |     factors.iter().max().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&{integer}`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |     *factors.iter().max().unwrap()\n   |     +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..=sqrt(n as f64)).iter().filter(|factor|\
    \ n % factor == 0).max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n --> /tmp/tmpdmn99_0o.rs:7:10\n\
    \  |\n7 |     (1..=sqrt(n as f64)).iter().filter(|factor| n % factor == 0).max()\n\
    \  |          ^^^^ not found in this scope\n\nerror[E0599]: no method named `iter`\
    \ found for struct `RangeInclusive` in the current scope\n --> /tmp/tmpdmn99_0o.rs:7:26\n\
    \  |\n7 |     (1..=sqrt(n as f64)).iter().filter(|factor| n % factor == 0).max()\n\
    \  |                          ^^^^ method not found in `RangeInclusive<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1;\
    \ n];\n\n    while n != 1 {\n        for &factor in factors.iter_mut() {\n   \
    \         if n % factor == 0 {\n                factors.swap(0, factor);\n   \
    \             n /= factor;\n                break;\n            }\n        }\n\
    \    }\n\n    factors.iter().max().unwrap_or(1)\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu9our_57.rs:7:31\n  |\n7 |\
    \     let mut factors = vec![1; n];\n  |                               ^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n7 |     let mut factors = vec![1;\
    \ n.try_into().unwrap()];\n  |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu9our_57.rs:10:13\n   |\n10 |\
    \         for &factor in factors.iter_mut() {\n   |             ^^^^^^^    ------------------\
    \ this expression has type `Option<&mut {integer}>`\n   |             |\n   |\
    \             types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `factor`\n   |\n   = note: expected mutable reference\
    \ `&mut {integer}`\n                      found reference `&_`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmpu9our_57.rs:11:18\n   |\n11 | \
    \            if n % factor == 0 {\n   |                  ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9our_57.rs:13:22\n\
    \   |\n13 |                 n /= factor;\n   |                      ^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n\
    \  --> /tmp/tmpu9our_57.rs:13:19\n   |\n13 |                 n /= factor;\n  \
    \ |                   ^^ no implementation for `isize /= usize`\n   |\n   = help:\
    \ the trait `DivAssign<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `DivAssign<Rhs>`:\n             <f32 as\
    \ DivAssign<&f32>>\n             <f32 as DivAssign>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_factors(&[2..n]).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factors` in this\
    \ scope\n --> /tmp/tmp8rqceug2.rs:7:5\n  |\n7 |     largest_prime_factor_factors(&[2..n]).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Sieve of Eratosthenes\
    \ to find all prime factors\n    let mut primes = vec![];\n    for (i, &c) in\
    \ n.into_iter().cloned().combinations(|&x| *x == 0) {\n        if !(i%c) {\n \
    \           primes.push(i);\n        }\n    }\n\n    // Sieve of Atkin's algorithm\
    \ to find the largest prime\n    primes.iter().max().unwrap_or(1)\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n --> /tmp/tmpt7fsiks_.rs:9:22\n\
    \  |\n9 |     for (i, &c) in n.into_iter().cloned().combinations(|&x| *x == 0)\
    \ {\n  |                      ^^^^^^^^^ `isize` is not an iterator\n  |\n  = note:\
    \ the following trait bounds were not satisfied:\n          `isize: Iterator`\n\
    \          which is required by `isize: IntoIterator`\n          `&isize: Iterator`\n\
    \          which is required by `&isize: IntoIterator`\n          `&mut isize:\
    \ Iterator`\n          which is required by `&mut isize: IntoIterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt7fsiks_.rs:16:35\n   |\n16 |     primes.iter().max().unwrap_or(1)\n\
    \   |                                   ^\n   |                              \
    \     |\n   |                                   expected reference, found integer\n\
    \   |                                   help: consider borrowing here: `&1`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt7fsiks_.rs:16:5\n   |\n6  | fn\
    \ largest_prime_factor(n: isize) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n16 |     primes.iter().max().unwrap_or(1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |     *primes.iter().max().unwrap_or(1)\n\
    \   |     +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    factors::largest_prime_factor(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factors`\n\
    \ --> /tmp/tmp4ifgg6lo.rs:7:5\n  |\n7 |     factors::largest_prime_factor(n)\n\
    \  |     ^^^^^^^ use of undeclared crate or module `factors`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    while n % factor == 0 {\n        factor *= 2;\n    }\n    while n > 1 {\n\
    \        factor *= 2;\n        if n % factor == 0 {\n            break;\n    \
    \    }\n        n /= factor;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpm_d85k5s.rs:16:9\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \       n /= factor;\n   |         ^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn is_prime(p: isize)\
    \ -> bool {\n        let mut i = 2;\n        while i * i <= p { i += 2; }\n  \
    \      i <= p / 2 && p % i == 0\n    }\n    let mut max = 2;\n    while max <\
    \ n {\n        if is_prime(max) {\n            max += 1;\n        }\n        else\
    \ {\n            max = max * 2;\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `18`,\n right: `5`', /tmp/tmp8xee9445.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return i;\n        }\n  \
    \      i += 1;\n    }\n    n // i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp9nl_b30n.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(&n)[0].clone()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmp6mq5h2fm.rs:7:5\n  |\n7 |     largest_prime_factors(&n)[0].clone()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n.checked_div(2).expect(\"\
    n must be positive\")\n        .checked_gcd(&n).expect(\"n must be positive\"\
    )\n        .unwrap_or(n - 1)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_gcd` found for type `isize` in the\
    \ current scope\n --> /tmp/tmp6rvgazee.rs:8:10\n  |\n8 |         .checked_gcd(&n).expect(\"\
    n must be positive\")\n  |          ^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `checked_add`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..n).find(|x| n % x\
    \ == 0).unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp1xd7c6_o.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    debug_assert!(n % 2 == 0);\n\n    for i in 2..n {\n        if n % i == 0\
    \ {\n            return i;\n        }\n    }\n\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n % 2 == 0', /tmp/tmpetflzec9.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    large_prime_factor(n,\
    \ n)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `large_prime_factor` in this scope\n\
    \ --> /tmp/tmp48mfsrz2.rs:7:5\n  |\n7 |     large_prime_factor(n, n)\n  |    \
    \ ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // 2 will\
    \ be prime and only needs to be tested once\n    let mut max = prime_factors(&mut\
    \ i, n);\n    let mut factor = max;\n    while factor != 1 {\n        if n % factor\
    \ == 0 {\n            max += 1;\n        }\n        factor += 1;\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmp288j_m33.rs:8:19\n  |\n8 |     let mut max = prime_factors(&mut i, n);\n\
    \  |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = n;\n\
    \    while i > 1 {\n        i = i / 2;\n        if n % i == 0 {\n            i\
    \ = i + 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return i;\n        }\n  \
    \      i += 1;\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp2qtxr1e2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_divisor =\
    \ 1;\n    let mut next_divisor = 2;\n    let mut prime_divisor = 1;\n\n    for\
    \ _ in 0..n / 2 {\n        if n % next_divisor == 0 {\n            prime_divisor\
    \ = next_divisor;\n            next_divisor += 1;\n        } else {\n        \
    \    max_divisor = next_divisor;\n            next_divisor += 1;\n        }\n\
    \    }\n\n    max_divisor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `5`', /tmp/tmp1pc8m49r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as isize;\n\
    \    fn isPrime(n: isize) -> bool {\n        n <= 1\n    }\n    let mut i = 2;\n\
    \    while i * i < n && isPrime(i) {\n        i += 1;\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpszuwpdde.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 1;\n    let\
    \ mut p = 2;\n    while p * p <= n {\n        if n % p == 0 {\n            f *=\
    \ p;\n        }\n        p *= 3;\n    }\n    f\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpanh41vmj.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor: isize\
    \ = 1;\n    while n % factor == 0 {\n        factor *= 2;\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpfl7ek3vm.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ n;\n    }\n    let mut max_num = n::max_value();\n    for i in 2..max_num {\n\
    \        if n % i == 0 {\n            return i;\n        }\n    }\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `n`\n\
    \  --> /tmp/tmpwtp7fbyb.rs:10:23\n   |\n10 |     let mut max_num = n::max_value();\n\
    \   |                       ^ use of undeclared crate or module `n`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut prime_factor = 1;\n    loop {\n        if n % i == 0 {\n            prime_factor\
    \ = i;\n            i += 2;\n        } else if i == n / prime_factor {\n     \
    \       return prime_factor;\n        } else {\n            i += 1;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut j = 2;\n    while i * j <= n {\n        if n % i == 0 {\n            i +=\
    \ 1;\n        } else if n % j == 0 {\n            j += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    if i * j <= n {\n        i * j\n  \
    \  } else {\n        i\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp6_d8im9v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max = 1;\n\n    while i * i <= n {\n        if n % i == 0 {\n          \
    \  max = i;\n            i += 1;\n        }\n        i += 1;\n    }\n\n    if\
    \ max == 1 {\n        0\n    } else {\n        max\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp1ocio4eg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime: isize\
    \ = 0;\n    let mut divisor: isize = 1;\n    while n > 1 {\n        if n % divisor\
    \ == 0 {\n            divisor *= 2;\n            prime += 1;\n        } else {\n\
    \            divisor += 1;\n        }\n        n /= 2;\n    }\n    prime\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpra2bfphr.rs:16:9\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \       n /= 2;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 0usize;\n\
    \    let mut m = 0usize;\n    let mut p = 1usize;\n    let mut q = 2usize;\n \
    \   while p * p <= n {\n        if n % p == 0 {\n            n /= p;\n       \
    \     f += 1;\n        } else {\n            if p * p > n {\n                break;\n\
    \            }\n            if n % q == 0 {\n                n /= q;\n       \
    \         m += 1;\n            } else {\n                if q * q > n {\n    \
    \                break;\n                }\n                if q * q == n {\n\
    \                    q /= q;\n                    p += 1;\n                } else\
    \ {\n                    if q * q > n {\n                        break;\n    \
    \                }\n                    q /= q;\n                    m += 1;\n\
    \                }\n            }\n        }\n    }\n    f as isize * m\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8s68iw76.rs:11:20\n   |\n\
    11 |     while p * p <= n {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     while p * p <= n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8s68iw76.rs:12:16\n   |\n12 |         if n % p == 0 {\n\
    \   |                ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ mod `isize` by `usize`\n  --> /tmp/tmp8s68iw76.rs:12:14\n   |\n12 |        \
    \ if n % p == 0 {\n   |              ^ no implementation for `isize % usize`\n\
    \   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s68iw76.rs:13:18\n   |\n13 |             n\
    \ /= p;\n   |                  ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot divide-assign `isize` by `usize`\n  --> /tmp/tmp8s68iw76.rs:13:15\n \
    \  |\n13 |             n /= p;\n   |               ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8s68iw76.rs:16:24\n\
    \   |\n16 |             if p * p > n {\n   |                        ^ expected\
    \ `usize`, fo"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: find a better\
    \ way of doing this\n    if n <= 1 {\n        return 1;\n    }\n\n    let mut\
    \ prime = n - 1;\n    let mut i = 2;\n\n    while i <= sqrt(n) {\n        if n\
    \ % i == 0 {\n            prime -= 1;\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    prime\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmp_hm5jeyr.rs:15:16\n\
    \   |\n15 |     while i <= sqrt(n) {\n   |                ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2; // Starting\
    \ at 2, since 1 is not a prime number.\n    while f * f <= n {\n        if n %\
    \ f == 0 {\n            n = n / f;\n        } else {\n            f = f + 2;\n\
    \        }\n    }\n    if n > 2 {\n        largest_prime_factor(n - 1)\n    }\
    \ else {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv35kwp_u.rs:10:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n10 |  \
    \           n = n / f;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = HashSet::new();\n    let mut i = 2; // i is always greater than 1.\n    while\
    \ i <= n {\n        if prime_factors.contains(&i) {\n            i += 2;\n   \
    \     } else if n % i == 0 {\n            prime_factors.insert(i);\n         \
    \   i += 1;\n        } else {\n            i += 1;\n        }\n    }\n    prime_factors.len()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp2njujfcc.rs:7:29\n  |\n7 |     let mut prime_factors = HashSet::new();\n\
    \  |                             ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 { return 1;\
    \ }\n    if n % 2 == 0 { return 2; }\n    \n    let mut candidate = 3; // Prime\
    \ factor: 3\n    \n    // Start by testing primes\n    loop {\n        if n %\
    \ candidate == 0 { return candidate; }\n        candidate += 2;\n    }\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp8y8p9zt1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // First guess is 2,\
    \ then increment by 2 to get the next guess. We have\n    // a chance that we\
    \ can break out of that loop quickly on large numbers.\n    let mut factors =\
    \ vec![2];\n    let mut i = 0;\n    while i < n {\n        if n % i == 0 {\n \
    \           factors.push(i);\n            i += 2;\n        } else {\n        \
    \    i += 1;\n        }\n    }\n    factors.max()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp768dpn6z.rs:19:13\n    |\n19  |     factors.max()\n    |     \
    \        ^^^- supplied 0 arguments\n    |             |\n    |             expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp768dpn6z.rs:19:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n19 |     factors.max()\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i * i <= m {\n        if m % i == 0 {\n            m =\
    \ m / i;\n            i = 2;\n        }\n        else {\n            i += 1;\n\
    \        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpimbwcmb4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \    let mut m = n as isize;\n    loop {\n        m /= 2;\n        if m > 1 {\n\
    \            break;\n        }\n        // TODO: use sieve for bigger numbers\n\
    \        let c = primes::<isize>[m];\n        if Ordering::cmp(&c, &1) == Ordering::Greater\
    \ {\n            return m;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmpzar28naa.rs:15:17\n\
    \   |\n15 |         let c = primes::<isize>[m];\n   |                 ^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzar28naa.rs:16:30\n\
    \   |\n16 |         if Ordering::cmp(&c, &1) == Ordering::Greater {\n   |    \
    \                          ^^ expected enum `std::cmp::Ordering`, found integer\n\
    \   |\n   = note: expected reference `&std::cmp::Ordering`\n              found\
    \ reference `&{integer}`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    for (i, &k) in factorization(n).iter().enumerate() {\n        if *k <= n\
    \ {\n            return *k;\n        }\n        for factor in factors.iter().rev()\
    \ {\n            if factor % n == 0 {\n                return *factor;\n     \
    \       }\n        }\n        factors.push(k);\n    }\n    factors.iter().max().unwrap_or(1)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n -->\
    \ /tmp/tmpz_t_74tq.rs:8:20\n  |\n8 |     for (i, &k) in factorization(n).iter().enumerate()\
    \ {\n  |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz_t_74tq.rs:19:36\n   |\n19 |     factors.iter().max().unwrap_or(1)\n\
    \   |                                    ^\n   |                             \
    \       |\n   |                                    expected `&isize`, found integer\n\
    \   |                                    help: consider borrowing here: `&1`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz_t_74tq.rs:19:5\n   |\n6  | fn\
    \ largest_prime_factor(n: isize) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n19 |     factors.iter().max().unwrap_or(1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     *factors.iter().max().unwrap_or(1)\n\
    \   |     +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    factors::factorize(n)\n\
    \        .max()\n        .unwrap_or(n)\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factors`\n\
    \ --> /tmp/tmplh43l5ox.rs:7:5\n  |\n7 |     factors::factorize(n)\n  |     ^^^^^^^\
    \ use of undeclared crate or module `factors`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     2\n    } else if n % 3 == 0 {\n        3\n    } else {\n        // Start\
    \ at 3 and move only odd numbers up\n        let mut i = 3;\n        while i *\
    \ i <= n && n % i == 0 {\n            i += 2;\n        }\n        i\n    }\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp8bfz24_r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = n;\n\
    \    let mut i: isize = 1;\n\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest = i;\n        }\n\n        i += 1;\n    }\n\n    if largest\
    \ <= n {\n        largest\n    } else {\n        largest\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpfo06xygb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    while result <= n {\n        let mut i = result;\n        let mut j = 1;\n\
    \        while j * i <= n {\n            i += 1;\n            j *= i;\n      \
    \  }\n        result = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `5`', /tmp/tmp5qt_ba6j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut prime_factor: isize = 1;\n    while i * prime_factor <= n && n >= 2 {\n\
    \        if n % i == 0 {\n            i += 1;\n        } else {\n            prime_factor\
    \ *= i;\n        }\n        i += 1;\n    }\n    prime_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `5`', /tmp/tmpsu5m7h2o.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 { return 2 }\n\
    \n    let mut factors = vec![2..=n];\n\n    for &factor in &factors {\n      \
    \  if n % factor == 0 {\n            factors.remove(factor);\n            break;\n\
    \        }\n    }\n\n    factors.last().unwrap_or(1)\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `RangeInclusive<isize>`\n  --> /tmp/tmprtqhtunq.rs:12:14\n\
    \   |\n12 |         if n % factor == 0 {\n   |              ^ no implementation\
    \ for `isize % RangeInclusive<isize>`\n   |\n   = help: the trait `Rem<RangeInclusive<isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprtqhtunq.rs:13:28\n\
    \   |\n13 |             factors.remove(factor);\n   |                        \
    \    ^^^^^^ expected `usize`, found struct `RangeInclusive`\n   |\n   = note:\
    \ expected type `usize`\n            found struct `RangeInclusive<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprtqhtunq.rs:18:30\n   |\n18 |  \
    \   factors.last().unwrap_or(1)\n   |                              ^ expected\
    \ reference, found integer\n   |\n   = note: expected reference `&RangeInclusive<isize>`\n\
    \                   found type `{integer}`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprtqhtunq.rs:18:5\n   |\n6  | fn largest_prime_factor(n: isize)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n18 |     factors.last().unwrap_or(1)\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&RangeInclusive<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ n\n    } else {\n        let mut i = 1u64;\n        while i * i <= n {\n   \
    \         if n % i == 0 {\n                return i;\n            }\n        \
    \    i += 1;\n        }\n        n\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsgw1kwi3.rs:11:24\n   |\n\
    11 |         while i * i <= n {\n   |                        ^ expected `u64`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u64` and panic if\
    \ the converted value doesn't fit\n   |\n11 |         while i * i <= n.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsgw1kwi3.rs:12:20\n   |\n12 |             if n % i == 0\
    \ {\n   |                    ^ expected `isize`, found `u64`\n\nerror[E0277]:\
    \ cannot mod `isize` by `u64`\n  --> /tmp/tmpsgw1kwi3.rs:12:18\n   |\n12 |   \
    \          if n % i == 0 {\n   |                  ^ no implementation for `isize\
    \ % u64`\n   |\n   = help: the trait `Rem<u64>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsgw1kwi3.rs:13:24\n   |\n13 |              \
    \   return i;\n   |                        ^ expected `isize`, found `u64`\n \
    \  |\nhelp: you can convert a `u64` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n13 |                 return i.try_into().unwrap();\n   |\
    \                         ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![0;\
    \ n as usize];\n    let mut prime_divisor = 1;\n    let mut prime_factor = 0;\n\
    \    while prime_divisor <= n {\n        if n % prime_divisor == 0 {\n       \
    \     factors[prime_factor] = prime_divisor;\n            if n == prime_divisor\
    \ * prime_divisor {\n                // Odd divisor\n                if prime_divisor\
    \ == 2 {\n                    // Even divisor of a prime\n                   \
    \ factors[0] = prime_divisor;\n                } else {\n                    //\
    \ Not a prime\n                    return 0;\n                }\n            }\n\
    \        } else {\n            prime_divisor *= 2;\n        }\n    }\n    for\
    \ &factor in factors.iter() {\n        if factor > n {\n            break;\n \
    \       }\n    }\n    return factors[factors.len() - 1];\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = vec![0; n + 1];\n    let mut prime_factor = 1;\n    while n % prime_factor\
    \ == 0 {\n        prime_factors[prime_factors as usize + 1] += 1;\n        n /=\
    \ prime_factor;\n        prime_factor *= prime_factors;\n    }\n    prime_factors[prime_factors\
    \ as usize + 1]\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzjrrdm83.rs:7:37\n  |\n7 |\
    \     let mut prime_factors = vec![0; n + 1];\n  |                           \
    \          ^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n  |\n7 |\
    \     let mut prime_factors = vec![0; (n + 1).try_into().unwrap()];\n  |     \
    \                                +     +++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot multiply-assign `isize` by `Vec<{integer}>`\n  --> /tmp/tmpzjrrdm83.rs:12:22\n\
    \   |\n12 |         prime_factor *= prime_factors;\n   |                     \
    \ ^^ no implementation for `isize *= Vec<{integer}>`\n   |\n   = help: the trait\
    \ `MulAssign<Vec<{integer}>>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n\
    \             <f32 as MulAssign>\n             <f64 as MulAssign<&f64>>\n    \
    \         <f64 as MulAssign>\n             <i128 as MulAssign<&i128>>\n      \
    \       <i128 as MulAssign>\n             <i16 as MulAssign<&i16>>\n         \
    \    <i16 as MulAssign>\n           and 20 others\n\nerror[E0605]: non-primitive\
    \ cast: `Vec<isize>` as `usize`\n  --> /tmp/tmpzjrrdm83.rs:10:23\n   |\n10 | \
    \        prime_factors[prime_factors as usize + 1] += 1;\n   |               \
    \        ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror[E0605]:\
    \ non-primitive cast: `Vec<isize>` as `usize`\n  --> /tmp/tmpzjrrdm83.rs:14:19\n\
    \   |\n14 |     prime_factors[prime_factors as usize + 1]\n   |              \
    \     ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0605.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    loop {\n        if n\
    \ % 2 == 0 {\n            n /= 2;\n            continue;\n        }\n\n      \
    \  let mut i = 3;\n        while i * i <= n {\n            if n % i == 0 {\n \
    \               n /= i;\n                continue;\n            }\n          \
    \  i += 1;\n        }\n\n        if n == 1 {\n            return n;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpdqh2g5rv.rs:9:13\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \       n /= 2;\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdqh2g5rv.rs:16:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \               n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut prime = true;\n    while n != 1 {\n        if n % 2 == 1 {\n    \
    \        factors.push(n);\n            n /= 2;\n        }\n        if n % 2 ==\
    \ 0 {\n            n /= 2;\n        } else {\n            prime = false;\n   \
    \         break;\n        }\n    }\n    if prime {\n        factors.pop();\n \
    \   }\n    factors.iter().max().unwrap_or(1)\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22waiev1.rs:24:36\n   |\n\
    24 |     factors.iter().max().unwrap_or(1)\n   |                             \
    \       ^\n   |                                    |\n   |                   \
    \                 expected `&isize`, found integer\n   |                     \
    \               help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp22waiev1.rs:24:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n24 |     factors.iter().max().unwrap_or(1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     *factors.iter().max().unwrap_or(1)\n\
    \   |     +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 0;\n\n    for i in 2..n / 2 {\n        if n % i == 0 {\n            match max_factor\
    \ {\n                Some(factor) => {\n                    max_factor = factor;\n\
    \                }\n                None => {\n                    max_factor\
    \ = i;\n                }\n            }\n        }\n    }\n    max_factor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0tkeuxzp.rs:12:17\n   |\n\
    11 |             match max_factor {\n   |                   ---------- this expression\
    \ has type `{integer}`\n12 |                 Some(factor) => {\n   |         \
    \        ^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note:\
    \ expected type `{integer}`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0tkeuxzp.rs:15:17\n   |\n11 |             match\
    \ max_factor {\n   |                   ---------- this expression has type `{integer}`\n\
    ...\n15 |                 None => {\n   |                 ^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2isize;\n\
    \    let mut max_factor = 2isize;\n    while n > 1isize {\n        if n % factor\
    \ == 0 {\n            factor += 1;\n        } else {\n            max_factor =\
    \ factor;\n            factor += 1;\n        }\n        n /= factor;\n    }\n\
    \    max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpmzlepigx.rs:16:9\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \       n /= factor;\n   |         ^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut s = 1;\n    while\
    \ s * s < n {\n        if n % s == 0 {\n            s += 2;\n        } else {\n\
    \            s -= 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 { return\
    \ 2; }\n    let mut result = 1;\n    let mut max_i = 2;\n    for &i in [n - 2,\
    \ n - 1] {\n        while i * result <= n {\n            result *= i;\n      \
    \      max_i += 1;\n        }\n        if result == n {\n            return max_i;\n\
    \        }\n    }\n    return max_i;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoc060i7q.rs:10:9\n   |\n\
    10 |     for &i in [n - 2, n - 1] {\n   |         ^^    -------------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n    let mut n2: isize = 1;\n    let mut d: isize = 2;\n\n    while\
    \ n2 <= n {\n        if n % d == 0 {\n            return d;\n        }\n     \
    \   d += 1;\n        n2 += d;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpujnfzhlx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Largest prime factor\
    \ is 2\n    let mut i = 2;\n    while i * i < n {\n        i += 1;\n    }\n  \
    \  i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpo_e6nfio.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            n =\
    \ n / i;\n        }\n        else {\n            i += 1;\n        }\n    }\n \
    \   if n == 1 {\n        n\n    } else {\n        n\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1isize;\n\
    \    let mut p = 1isize;\n    while i * p <= n {\n        if n % i == 0 {\n  \
    \          i += 1;\n        } else {\n            p += 1;\n        }\n    }\n\
    \    p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `5`', /tmp/tmppriehu6c.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = 2; // assume\
    \ n > 1\n    let mut p = 1;\n    let mut q = 2;\n    while p <= n {\n        if\
    \ n % p == 0 {\n            m = p;\n        }\n        if p % q == 0 {\n     \
    \       p = q;\n        }\n        p += 1;\n        q += 1;\n    }\n    m\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp4atnc7xc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // https://oeis.org/A000074\n\
    \    fn sieve(n: isize) -> Vec<usize> {\n        let mut vec = [0; n + 1];\n \
    \       vec.push(0);\n        for i in 2..n {\n            vec[i] = vec[i / 2];\n\
    \            if i % 2 != 0 {\n                for j in 3..(i + 1) * (i + 2) /\
    \ 2 {\n                    vec[j / 2] = vec[j];\n                }\n         \
    \   }\n        }\n        vec\n    }\n\n    let mut primes = sieve(n);\n    while\
    \ primes.len() > 0 {\n        if n % primes.len() == 0 {\n            n = n /\
    \ primes.len();\n        } else {\n            primes.remove(0);\n        }\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n --> /tmp/tmpuphe_6uj.rs:9:27\n\
    \  |\n8 |     fn sieve(n: isize) -> Vec<usize> {\n  |              - this would\
    \ need to be a `const`\n9 |         let mut vec = [0; n + 1];\n  |           \
    \                ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuphe_6uj.rs:24:16\n\
    \   |\n24 |         if n % primes.len() == 0 {\n   |                ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n\
    \  --> /tmp/tmpuphe_6uj.rs:24:14\n   |\n24 |         if n % primes.len() == 0\
    \ {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuphe_6uj.rs:25:21\n   |\n25 |             n = n / primes.len();\n\
    \   |                     ^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot divide `isize` by `usize`\n  --> /tmp/tmpuphe_6uj.rs:25:19\n   |\n25\
    \ |             n = n / primes.len();\n   |                   ^ no implementation\
    \ for `isize / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0435.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_prime_factor = 1;\n\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest_prime_factor = i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 1;\n    while n % prime_factor == 0 {\n        prime_factor *= 2;\n    }\n\
    \    prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpd7ihs8pt.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return i;\n        }\n  \
    \      i += 1;\n    }\n    return n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp3bwa1_yx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ n;\n    }\n\n    let mut max_factor = isize::max_value();\n    let mut max_factor_in_sqrt\
    \ = isize::max_value();\n\n    for i in 2..n {\n        for j in 2..n / i {\n\
    \            max_factor_in_sqrt = max_factor_in_sqrt.max(j * i);\n        }\n\
    \        max_factor = max_factor.max(max_factor_in_sqrt);\n    }\n    max_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9223372036854775807`,\n right: `5`', /tmp/tmp119revcv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..).filter(|factor|\
    \ n % factor == 0).count().max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp6bk6xsng.rs:7:52\n    |\n7   |     (1..).filter(|factor| n % factor\
    \ == 0).count().max()\n    |                                                 \
    \   ^^^- supplied 0 arguments\n    |                                         \
    \           |\n    |                                                    expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp6bk6xsng.rs:7:5\n  |\n6 | fn largest_prime_factor(n: isize)\
    \ -> isize {\n  |                                      ----- expected `isize`\
    \ because of return type\n7 |     (1..).filter(|factor| n % factor == 0).count().max()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n7 |     (1..).filter(|factor| n % factor\
    \ == 0).count().max().try_into().unwrap()\n  |                               \
    \                          ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest: isize\
    \ = 1;\n    let mut i: isize = n;\n    while i != 1 {\n        let mut j: isize\
    \ = 1;\n        while j * i <= i {\n            j += 1;\n        }\n        i\
    \ += j;\n        if i > largest * 2 {\n            largest = i;\n        }\n \
    \   }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut res = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            i\
    \ += 1;\n        } else {\n            i = i + 2;\n            res = i;\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp7_1xkzgq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return 1;\n    }\n    let mut ret = 1;\n    let mut max_root = 1;\n\n    for\
    \ i in 2..(n + 1) {\n        if n % i == 0 {\n            ret = i;\n         \
    \   max_root = i;\n        }\n    }\n\n    if ret == max_root {\n        ret;\n\
    \    } else {\n        largest_prime_factor(max_root) * ret\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp32ojfvq6.rs:20:24\n   |\n\
    20 |       if ret == max_root {\n   |  ________________________^\n21 | |     \
    \    ret;\n   | |            - help: remove this semicolon\n22 | |     } else\
    \ {\n   | |_____^ expected `isize`, found `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let mut m = n.clone();\n    let mut i = 2;\n    while i <= m {\n        if m.mod(i).is_zero()\
    \ {\n            i += 1;\n        } else {\n            return i;\n        }\n\
    \    }\n    return i;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmpmi4ub_u4.rs:11:14\n\
    \   |\n11 |         if m.mod(i).is_zero() {\n   |              ^^^ expected identifier,\
    \ found keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n11\
    \ |         if m.r#mod(i).is_zero() {\n   |              ++\n\nerror[E0599]: no\
    \ method named `r#mod` found for type `isize` in the current scope\n  --> /tmp/tmpmi4ub_u4.rs:11:14\n\
    \   |\n11 |         if m.mod(i).is_zero() {\n   |              ^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    primenumber(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primenumber` in this scope\n --> /tmp/tmpobvn9odf.rs:7:5\n\
    \  |\n7 |     primenumber(n).unwrap()\n  |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     n / 2\n    } else {\n        largest_prime_factor(n - 1) * 3 + 1\n    }\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `5`', /tmp/tmpxylwm5md.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \n    let mut i = n;\n    let mut max_factor = 0;\n    while i != 1 {\n      \
    \  let factor = i / 2;\n        if ((factor * factor <= n) && (n % factor == 0))\
    \ {\n            max_factor = factor;\n        }\n        i -= 1;\n    }\n   \
    \ max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpqy9sl0fd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m: isize = 1;\n\
    \    let mut d: isize = 2;\n    while d < n {\n        while m % d == 0 {\n  \
    \          m += 1;\n        }\n        d += 1;\n    }\n    m\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpt608q0_u.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n      \
    \      if max_factor < i {\n                max_factor = i;\n            }\n \
    \       }\n        i += 1;\n    }\n    max_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp656sb7r_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn is_prime(a: isize)\
    \ -> bool {\n        a > 1\n            && (a / 2) == a\n            && (1 / (a\
    \ * a)) == a\n            && (1 / (a * a - 1)) == a\n            && (1 / (a *\
    \ a * a)) == a\n            && (a / a) == 0\n    }\n\n    let mut f = 1;\n   \
    \ while !is_prime(f) {\n        if n % f == 0 {\n            return f;\n     \
    \   }\n        f += 2;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp75t9pt5b.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f: isize = 1;\n\
    \    let mut m = n;\n    while m > 1 {\n        if m % f == 0 {\n            break;\n\
    \        }\n        f += 1;\n        m /= f;\n    }\n    m\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp5d03b8v3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as isize;\n\
    \    // Make sure n has a positive factors\n    loop {\n        if n % 2 == 0\
    \ { break; }\n        n /= 2;\n    }\n    let mut result = 1;\n    // Compute\
    \ the prime factors\n    while n > 1 {\n        if n % 2 == 0 {\n            result\
    \ *= 2;\n            n /= 2;\n        } else {\n            result *= n;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpk00zh_1_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut is_prime = false;\n\
    \    for i in 2..=n {\n        if n % i == 0 {\n            is_prime = true;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        n / 2\n    }\
    \ else {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp1w73obrm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // See https://en.wikipedia.org/wiki/Primality_test#Practical_performance\n\
    \    loop {\n        let root = big_prime::is_prime(n);\n        if root > 1 {\n\
    \            return root;\n        }\n        n = n / root * root;\n    }\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `big_prime`\n\
    \ --> /tmp/tmp8vlswy1p.rs:9:20\n  |\n9 |         let root = big_prime::is_prime(n);\n\
    \  |                    ^^^^^^^^^ use of undeclared crate or module `big_prime`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut result = 1;\n    while n > 1 {\n        let mut n = n / result;\n\
    \        result = result * result + 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6tx0dnfn.rs:13:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n13 |    \
    \ result\n   |     ^^^^^^ expected `isize`, found `u64`\n   |\nhelp: you can convert\
    \ a `u64` to an `isize` and panic if the converted value doesn't fit\n   |\n13\
    \ |     result.try_into().unwrap()\n   |           ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max_divisor = 1;\n    while i <= n {\n        if n % i == 0 {\n        \
    \    max_divisor = i;\n        }\n        i += 1;\n    }\n    max_divisor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpfz8z12x4.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f: isize = 1;\n\
    \    for p in PRIME_PS.iter() {\n        if n % p == 0 {\n            f = p;\n\
    \            break;\n        }\n    }\n    f\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `PRIME_PS` in this scope\n --> /tmp/tmpf5vz3w1n.rs:8:14\n\
    \  |\n8 |     for p in PRIME_PS.iter() {\n  |              ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2i32; while\
    \ i <= n {\n        let mut j = 2i32; while j < i {\n            if n % i == 0\
    \ {\n                return i;\n            }\n            i += 1;\n         \
    \   j += 1i32;\n        }\n        i += 1;\n    }\n    n - 1\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo7cw_6pv.rs:7:34\n  |\n7 |\
    \     let mut i = 2i32; while i <= n {\n  |                                  ^\
    \ expected `i32`, found `isize`\n  |\nhelp: you can convert an `isize` to an `i32`\
    \ and panic if the converted value doesn't fit\n  |\n7 |     let mut i = 2i32;\
    \ while i <= n.try_into().unwrap() {\n  |                                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpo7cw_6pv.rs:9:20\n  |\n9 |    \
    \         if n % i == 0 {\n  |                    ^ expected `isize`, found `i32`\n\
    \nerror[E0277]: cannot mod `isize` by `i32`\n --> /tmp/tmpo7cw_6pv.rs:9:18\n \
    \ |\n9 |             if n % i == 0 {\n  |                  ^ no implementation\
    \ for `isize % i32`\n  |\n  = help: the trait `Rem<i32>` is not implemented for\
    \ `isize`\n  = help: the following other types implement trait `Rem<Rhs>`:\n \
    \           <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n       \
    \     <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n           \
    \ <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a i8\
    \ as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo7cw_6pv.rs:10:24\n   |\n10 |\
    \                 return i;\n   |                        ^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |                 return i.try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: find out why\
    \ this algorithm is slower than the previous one.\n    let mut max_i = 2;\n  \
    \  for &i in &[2..n / 2]\n        .iter()\n        .filter(|&i| *i == 1)\n   \
    \     .skip(1)\n    {\n        if n % i == 0 {\n            max_i = i;\n     \
    \   }\n    }\n    max_i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6p34dhw.rs:11:28\n   |\n\
    11 |         .filter(|&i| *i == 1)\n   |                            ^ expected\
    \ struct `std::ops::Range`, found integer\n   |\n   = note: expected struct `std::ops::Range<isize>`\n\
    \                found type `{integer}`\n\nerror[E0277]: `&Skip<Filter<std::slice::Iter<'_,\
    \ std::ops::Range<isize>>, [closure@/tmp/tmpa6p34dhw.rs:11:17: 11:29]>>` is not\
    \ an iterator\n  --> /tmp/tmpa6p34dhw.rs:9:15\n   |\n9  |       for &i in &[2..n\
    \ / 2]\n   |                 ^ help: consider removing the leading `&`-reference\n\
    \   |  _______________|\n   | |\n10 | |         .iter()\n11 | |         .filter(|&i|\
    \ *i == 1)\n12 | |         .skip(1)\n   | |________________^ `&Skip<Filter<std::slice::Iter<'_,\
    \ std::ops::Range<isize>>, [closure@/tmp/tmpa6p34dhw.rs:11:17: 11:29]>>` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&Skip<Filter<std::slice::Iter<'_,\
    \ std::ops::Range<isize>>, [closure@/tmp/tmpa6p34dhw.rs:11:17: 11:29]>>`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&Skip<Filter<std::slice::Iter<'_, std::ops::Range<isize>>, [closure@/tmp/tmpa6p34dhw.rs:11:17:\
    \ 11:29]>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 1usize;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   m = i;\n        } else {\n            i += 1;\n        }\n    }\n    m\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz4shuf79.rs:9:20\n  |\n9 |\
    \     while i * i <= n {\n  |                    ^ expected `usize`, found `isize`\n\
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     while i * i <= n.try_into().unwrap() {\n  |\
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz4shuf79.rs:10:16\n   |\n10 |         if n % i == 0 {\n   |   \
    \             ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n  --> /tmp/tmpz4shuf79.rs:10:14\n   |\n10 |         if n % i ==\
    \ 0 {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz4shuf79.rs:11:17\n   |\n7  |     let mut m = n;\n   |\
    \                 - expected due to this value\n...\n11 |             m = i;\n\
    \   |                 ^ expected `isize`, found `usize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut f = 2;\n    while i * f < n {\n        if n % i == 0 {\n            i +=\
    \ 1;\n        } else if f != 2 {\n            f += 1;\n        } else {\n    \
    \        i += 1;\n            f += 1;\n        }\n    }\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpola2365k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n    let mut i = 2;\n    let mut f = 0;\n    let mut prime\
    \ = false;\n    while i * i < n {\n        if n % i == 0 {\n            prime\
    \ = true;\n            i += 1;\n        } else {\n            i += 2;\n      \
    \  }\n        if prime == true {\n            f += 1;\n        }\n    }\n    f\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpfxeb_n77.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)\
    \ as isize).sqrt()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SmallPrimes`\n\
    \ --> /tmp/tmp16il0pvx.rs:7:23\n  |\n7 |     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)\
    \ as isize).sqrt()\n  |                       ^^^^^^^^^^^ use of undeclared type\
    \ `SmallPrimes`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp16il0pvx.rs:7:67\n\
    \  |\n7 |     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)\
    \ as isize).sqrt()\n  |                                                      \
    \             ^^ expected `isize`, found `&{integer}`\n  |\nhelp: consider removing\
    \ the borrow\n  |\n7 -     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)\
    \ as isize).sqrt()\n7 +     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(1)\
    \ as isize).sqrt()\n  | \n\nerror[E0599]: no method named `sqrt` found for type\
    \ `isize` in the current scope\n --> /tmp/tmp16il0pvx.rs:7:81\n  |\n7 |     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)\
    \ as isize).sqrt()\n  |                                                      \
    \                           ^^^^ method not found in `isize`\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n --> /tmp/tmp16il0pvx.rs:7:5\n  |\n\
    7 |     (&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1) as isize).sqrt()\n\
    \  |     ^----------------------------------------------------------------^^^^^^^^^^\n\
    \  |     ||\n  |     |help: dereference the expression: `*&(n).checked_mul(SmallPrimes::SmallestPrimeFactor).unwrap_or(&1)`\n\
    \  |     cannot cast `&isize` as `isize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433, E0599, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    while n > 1 {\n        if n % result == 0 {\n            break;\n       \
    \ }\n        result *= 2;\n        n /= result;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp7qck6dws.rs:13:9\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \       n /= result;\n   |         ^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut res = 1;\n    while i <= n {\n        if n % i == 0 {\n            res =\
    \ i;\n            while n % res == 0 {\n                res += 1;\n          \
    \  }\n            i += 1;\n        }\n        i += 1;\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `5`', /tmp/tmprud8k78n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut r = 1;\n    let\
    \ mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n            r = i;\n\
    \            i += 2;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmptctnf__4.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n\n    fn sieve_upper_bound(n: isize) -> isize {\n        n.checked_div(8).ok()\n\
    \    }\n\n    fn next_prime(n: isize) -> Option<isize> {\n        let mut next\
    \ = n.checked_add(1).ok_or(());\n        let mut check = 3; let mut k = 3;\n \
    \       loop {\n            if k == next {\n                return Some(next);\n\
    \            }\n            if check > sieve_upper_bound(next) {\n           \
    \     return None;\n            }\n            let mut m = k.checked_mul(next).ok_or(());\n\
    \            next += m;\n            k += 2;\n        }\n    }\n\n    let mut\
    \ result = 1;\n    while result.is_positive() {\n        result = next_prime(result);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `is_positive` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmp40_6jh65.rs:32:18\n   |\n32 |     while result.is_positive()\
    \ {\n   |                  ^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n31 |     let mut result: i32 = 1;\n   |    \
    \     ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40_6jh65.rs:33:18\n\
    \   |\n31 |     let mut result = 1;\n   |                      - expected due\
    \ to this value\n32 |     while result.is_positive() {\n33 |         result =\
    \ next_prime(result);\n   |                  ^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror[E0599]: no method named `ok` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmp40_6jh65.rs:12:26\n   |\n12 |         n.checked_div(8).ok()\n\
    \   |                          ^^ help: there is an associated function with a\
    \ similar name: `or`\n\nerror[E0277]: can't compare `{integer}` with `Result<isize,\
    \ ()>`\n  --> /tmp/tmp40_6jh65.rs:19:18\n   |\n19 |             if k == next {\n\
    \   |                  ^^ no implementation for `{integer} == Result<isize, ()>`\n\
    \   |\n   = help: the trait `PartialEq<Result<isize, ()>>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40_6jh65.rs:20:29\n\
    \   |\n20 |                 return Some(next);\n   |                         \
    \    ^^^^ expected `isize`, found enum `Result`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Result<isize, ()>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp40_6jh65.rs:22:42\n   |\n22 |             if check > sieve_upper_bound(next)\
    \ {\n   |                                          ^^^^ expected `isize`, found\
    \ enum `Result`\n   |\n   = note: expected type `isize`\n              found enum"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmp5r1fcgcu.rs:7:5\n  |\n7 |     largest_prime_factors(n).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    while n % factor == 0 {\n        factor *= 2;\n    }\n    factor\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpbliab6ki.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m: isize = 2;\n\
    \    while m <= n {\n        if n % m == 0 {\n            return m;\n        }\n\
    \        m += 1;\n    }\n    return n;\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpjn6iyxzf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_iter(n).next()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_iter` in this scope\n\
    \ --> /tmp/tmp04dvr3nc.rs:7:5\n  |\n7 |     largest_prime_iter(n).next()\n  |\
    \     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    loop {\n        if n % factor == 0 {\n            factor *= 2;\n        \
    \    n /= factor;\n        }\n        else {\n            break;\n        }\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnv66uib0.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 { 2 }\n\
    \    else if n % 3 == 0 { 3 }\n    else if n % 5 == 0 { 5 }\n    else if n % 7\
    \ == 0 { 7 }\n    else if n % 11 == 0 { 11 }\n    else { n / 2 }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpuobjiv9c.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1i32;\n \
    \   let mut res = n;\n    while i * i <= res {\n        i += 1;\n    }\n    while\
    \ i < n {\n        if n % i == 0 {\n            i += 1;\n            res = n;\n\
    \        }\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj4x3h5r6.rs:9:20\n  |\n9 |\
    \     while i * i <= res {\n  |                    ^^^ expected `i32`, found `isize`\n\
    \  |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     while i * i <= res.try_into().unwrap() {\n \
    \ |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj4x3h5r6.rs:12:15\n   |\n12 |     while i < n {\n   |         \
    \      ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to an `i32` and panic if the converted value doesn't fit\n   |\n12 |     while\
    \ i < n.try_into().unwrap() {\n   |                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj4x3h5r6.rs:13:16\n   |\n13 |         if n %\
    \ i == 0 {\n   |                ^ expected `isize`, found `i32`\n\nerror[E0277]:\
    \ cannot mod `isize` by `i32`\n  --> /tmp/tmpj4x3h5r6.rs:13:14\n   |\n13 |   \
    \      if n % i == 0 {\n   |              ^ no implementation for `isize % i32`\n\
    \   |\n   = help: the trait `Rem<i32>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: optimize\n \
    \   // return n.iter().cloned().max(|a, b| {\n    //     if a.is_prime() && b.is_prime()\
    \ {\n    //         if a < b {\n    //             a\n    //         } else {\n\
    \    //             b\n    //         }\n    //     } else {\n    //         if\
    \ a < b {\n    //             b\n    //         } else {\n    //             a\n\
    \    //         }\n    //     }\n    // }).unwrap()\n    n.iter().cloned().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp26t6raao.rs:23:7\n   |\n23 |     n.iter().cloned().max().unwrap()\n\
    \   |       ^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_divisor_factor_memo(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_divisor_factor_memo`\
    \ in this scope\n --> /tmp/tmpijnr4cg6.rs:7:5\n  |\n7 |     largest_prime_divisor_factor_memo(n)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..n).fold(1, |a, b|\
    \ {\n        if n % a == 0 { a } else { b }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmprlfiayro.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..n).filter(|i|\n \
    \       n % i\n            == 0\n            && (\n                n % i == 0\n\
    \                || (\n                    i % 2 == 0 && i % 3 == 0\n        \
    \            || (i % 4 == 0 && i % 5 == 0)\n                )\n            )\n\
    \    )\n    .max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg95i2r87.rs:7:5\n   |\n6\
    \  |   fn largest_prime_factor(n: isize) -> isize {\n   |                    \
    \                    ----- expected `isize` because of return type\n7  | /   \
    \  (1..n).filter(|i|\n8  | |         n % i\n9  | |             == 0\n10 | |  \
    \           && (\n...  |\n17 | |     )\n18 | |     .max()\n   | |__________^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(1,\
    \ n)\n        .last()\n        .expect(\"No prime factors found in range [1..n]\"\
    .to_string())\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmp_tuqh41e.rs:7:5\n  |\n7 |     largest_prime_factors(1, n)\n  | \
    \    ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![BigNum::new(1);\
    \ n as usize];\n    let mut i = 2;\n    while i < factors.len() {\n        if\
    \ factors[i].is_prime() {\n            factors.swap(i, &i);\n        } else {\n\
    \            i += 1;\n        }\n    }\n    factors[n as usize]\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BigNum`\n -->\
    \ /tmp/tmps5556_v5.rs:7:28\n  |\n7 |     let mut factors = vec![BigNum::new(1);\
    \ n as usize];\n  |                            ^^^^^^ use of undeclared type `BigNum`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Special cases first.\n\
    \    if n < 2 {\n        return n;\n    }\n    if n % 2 == 0 {\n        return\
    \ 2;\n    }\n\n    let mut m = n - 1;\n    while m % 2 == 0 {\n        m /= 2;\n\
    \    }\n    m += 2;\n\n    if m <= 3 {\n        return m;\n    }\n\n    let mut\
    \ nfactor = 2;\n    while m % nfactor == 0 {\n        m /= nfactor;\n        nfactor\
    \ *= 2;\n    }\n\n    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmppzhl2i5n.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        1\n\
    \    } else if n % 2 == 0 {\n        2\n    } else if n % 3 == 0 {\n        3\n\
    \    } else {\n        largest_prime_factor(n / 3) + 1\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpewd088rv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 1;\n\
    \    let mut j: isize = 2;\n    while i * j < n {\n        if n % i == 0 {\n \
    \           j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    j\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmptuluuv1u.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut maxf = 2;\n    let mut minf = n;\n\n    while (minf % f != 0 || n == 1)\
    \ {\n        while (minf % f != 0 || f % 2 == 0) {\n            f += 1;\n    \
    \    }\n        maxf = f;\n        minf = n / f;\n    }\n    maxf\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors:\
    \ Vec<_> = Vec::new();\n    let mut i = 3; // Start at 3\n    while prime_factors.len()\
    \ < n / 2 {\n        for factor in &factors {\n            if n % i == 0 {\n \
    \               break; // n is not a prime\n            }\n            prime_factors.push(i);\n\
    \            i += 1;\n        }\n    }\n    prime_factors.pop()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `factors` in this scope\n  --> /tmp/tmpqoj6_0az.rs:10:24\n\
    \   |\n10 |         for factor in &factors {\n   |                        ^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqoj6_0az.rs:9:33\n\
    \  |\n9 |     while prime_factors.len() < n / 2 {\n  |                       \
    \          ^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n  |\n9 |\
    \     while prime_factors.len() < (n / 2).try_into().unwrap() {\n  |         \
    \                        +     +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqoj6_0az.rs:18:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n18 |     prime_factors.pop()\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return 1;\n    }\n\n    use num::Prime;\n\n    let mut s = 1;\n    let mut p\
    \ = Prime::new();\n\n    while !p.is_prime() {\n        if n % s == 0 {\n    \
    \        s = s * 2;\n        }\n\n        p.next::<isize>();\n\n        if n %\
    \ s == 0 {\n            return s;\n        }\n    }\n\n    s * 2\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `num`\n  --> /tmp/tmpaxa07o55.rs:11:9\n\
    \   |\n11 |     use num::Prime;\n   |         ^^^\n   |         |\n   |      \
    \   unresolved import\n   |         help: a similar path exists: `std::num`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert_eq!(n%2,\
    \ 0);\n    let mut n = n as isize;\n    let mut max_num = 2;\n\n    while n %\
    \ max_num == 0 {\n        max_num += 2;\n    }\n\n    while max_num * max_num\
    \ < n {\n        max_num <<= 1;\n    }\n\n    while n % max_num == 0 {\n     \
    \   n /= max_num;\n    }\n\n    if n > 1 {\n        n\n    } else {\n        0\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp8gjjju6r.rs:7:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    loop\
    \ {\n        while n % i == 0 {\n            i += 1;\n        }\n        if i\
    \ == n {\n            return i;\n        }\n        i += 2;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_divisor_cache\
    \ = [2, 2];\n    let mut prime_factor_cache = [3, 3];\n    let mut prime_cache\
    \ = [2, 2];\n    while prime_divisor_cache[1] < n {\n        if n % prime_divisor_cache[0]\
    \ == 0 {\n            prime_divisor_cache[0] = prime_divisor_cache[1];\n     \
    \       prime_factor_cache[1] = prime_factor_cache[0];\n            prime_cache[1]\
    \ = prime_cache[0];\n        }\n        let mut next_divisor = prime_divisor_cache[1];\n\
    \        prime_divisor_cache[1] = n;\n        for prime in &prime_cache {\n  \
    \          let next_prime_factor = prime % next_divisor;\n            if next_prime_factor\
    \ != 0 {\n                next_divisor = next_prime_factor;\n                break;\n\
    \            }\n        }\n        prime_factor_cache[0] = prime_factor_cache[1];\n\
    \        prime_factor_cache[1] = next_divisor;\n        prime_cache[0] = prime_cache[1];\n\
    \    }\n    prime_factor_cache[1]\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpf0_36a0m.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // skip\
    \ 2, the smallest prime factor of n\n    while i*i <= n {\n        if n % i ==\
    \ 0 {\n            i += 1;\n            continue;\n        }\n        return i;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmplkhla19z.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     return n;\n    }\n\n    let mut factor = 3;\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            factor = i;\n           \
    \ i += 1;\n            continue;\n        }\n\n        i += 2;\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmppqq_ztpt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n.checked_div(2).expect(&format!(\"\
    n must be an integer greater than 1\"))\n        .checked_mul(2).expect(&format!(\"\
    n must be an integer greater than 1\"))\n        .unwrap_or(1)\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or` found for type `isize` in the\
    \ current scope\n --> /tmp/tmp9kaxjfhg.rs:9:10\n  |\n9 |         .unwrap_or(1)\n\
    \  |          ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return n;\n    }\n\n    let mut largest_prime_factor = n as isize;\n\n    loop\
    \ {\n        largest_prime_factor /= 2; // n = 2k\n        if !is_prime(largest_prime_factor)\
    \ {\n            return largest_prime_factor;\n        }\n\n        // n is prime,\
    \ since 2k > 2.\n        largest_prime_factor *= 2; // n = 4k\n        if is_prime(largest_prime_factor)\
    \ {\n            return largest_prime_factor;\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmph_np6gl2.rs:15:13\n\
    \   |\n15 |         if !is_prime(largest_prime_factor) {\n   |             ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmph_np6gl2.rs:21:12\n   |\n21 |         if is_prime(largest_prime_factor)\
    \ {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_count =\
    \ std::collections::HashMap::new();\n    prime_count.insert(n, 1);\n\n    for\
    \ &(n, _) in prime_count.iter() {\n        let mut num_factors = 0;\n        let\
    \ mut new_factor = 1;\n        while new_factor < n {\n            if n % new_factor\
    \ == 0 {\n                num_factors += 1;\n                new_factor *= new_factor;\n\
    \            } else {\n                break;\n            }\n        }\n\n  \
    \      if num_factors > 0 {\n            prime_count.insert(n, num_factors);\n\
    \            return n;\n        }\n    }\n\n    1\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00g2h7zm.rs:10:9\n   |\n\
    10 |     for &(n, _) in prime_count.iter() {\n   |         ^^^^^^^    ------------------\
    \ this expression has type `Option<(&isize, &{integer})>`\n   |         |\n  \
    \ |         expected tuple, found reference\n   |\n   = note:  expected tuple\
    \ `(&isize, &{integer})`\n           found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_i = 21;\n\
    \    for i in 1..n {\n        if n % i == 0 {\n            max_i = i;\n      \
    \  } else {\n            break;\n        }\n    }\n    max_i\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp240fzda1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut q = n;\n    let mut i = 1;\n    while q != 1 {\n        if n % p == 0 {\n\
    \            i += 1;\n            n /= p;\n        }\n        p += 1;\n      \
    \  q /= p;\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphc1gviz_.rs:13:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \           n /= p;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes: Vec<_>\
    \ = vec![2; 3; 5; 7; 11; 13; 17; 19; 23; 29];\n    primes.push(1);\n    while\
    \ primes.len() < n {\n        let prime = primes.iter().find(|&x| n % x == 0);\n\
    \        if prime == Some(&primes.last()) {\n            primes.push(primes.last().checked_add(1).unwrap());\n\
    \        } else {\n            primes.push(prime);\n        }\n    }\n    primes.iter().find_map(|&x|\
    \ x.unwrap()).unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: no rules expected the token `;`\n --> /tmp/tmprw1j2530.rs:7:39\n\
    \  |\n7 |     let mut primes: Vec<_> = vec![2; 3; 5; 7; 11; 13; 17; 19; 23; 29];\n\
    \  |                                       ^ no rules expected this token in macro\
    \ call\n\nerror[E0308]: mismatched types\n --> /tmp/tmprw1j2530.rs:9:26\n  |\n\
    9 |     while primes.len() < n {\n  |                          ^ expected `usize`,\
    \ found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     while primes.len() < n.try_into().unwrap()\
    \ {\n  |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprw1j2530.rs:11:26\n   |\n11 |         if prime == Some(&primes.last())\
    \ {\n   |                          ^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&isize`\n              found\
    \ reference `&Option<&isize>`\n\nerror[E0599]: no method named `checked_add` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmprw1j2530.rs:12:39\n  \
    \ |\n12 |             primes.push(primes.last().checked_add(1).unwrap());\n  \
    \ |                                       ^^^^^^^^^^^ method not found in `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprw1j2530.rs:14:25\n   |\n14 |\
    \             primes.push(prime);\n   |                         ^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmprw1j2530.rs:17:35\n\
    \   |\n17 |     primes.iter().find_map(|&x| x.unwrap()).unwrap()\n   |       \
    \                            ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // start\
    \ at 2, since 2 is the first factor of n\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            i += 1;\n        } else {\n            n = n / i;\n\
    \        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp00kcj666.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n = n / i;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 1usize;\n    let mut prime_divisor: isize = 0;\n\n    for i in 2..n {\n  \
    \      prime_divisor = i;\n        while prime_divisor % prime_factor == 0 {\n\
    \            prime_divisor *= prime_factor;\n            prime_factor++;\n   \
    \     }\n    }\n\n    prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpj22lp1fj.rs:14:25\n\
    \   |\n14 |             prime_factor++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n14 |         \
    \    { let tmp = prime_factor; prime_factor += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n14 -             prime_factor++;\n14\
    \ +             prime_factor += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj22lp1fj.rs:12:31\n   |\n12 |         while prime_divisor % prime_factor\
    \ == 0 {\n   |                               ^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpj22lp1fj.rs:12:29\n\
    \   |\n12 |         while prime_divisor % prime_factor == 0 {\n   |          \
    \                   ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj22lp1fj.rs:13:30\n   |\n13 |             prime_divisor\
    \ *= prime_factor;\n   |                              ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj22lp1fj.rs:18:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n18\
    \ |     prime_factor\n   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     prime_factor.try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror[E0277]: cannot multiply-assign `isize`\
    \ by `usize`\n  --> /tmp/tmpj22lp1fj.rs:13:27\n   |\n13 | "
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering;\n\
    \n    let mut i = 1;\n    loop {\n        let mut j = n;\n        let mut p =\
    \ i;\n        while j % i == 0 {\n            j = j / i;\n            p += 1;\n\
    \        }\n        if j < i {\n            break;\n        }\n        i += 1;\n\
    \    }\n    p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `p` in this scope\n  --> /tmp/tmpy73zrbhp.rs:22:5\n\
    \   |\n22 |     p\n   |     ^ help: a local variable with a similar name exists:\
    \ `i`\n\nwarning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpy73zrbhp.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut factor = 1;\n    let mut prime_found = false;\n    while !prime_found\
    \ && factor <= n {\n        if n % factor == 0 {\n            factor *= factor;\n\
    \        } else {\n            max_factor = std::cmp::max(max_factor, factor);\n\
    \            if factor % n == 0 {\n                prime_found = true;\n     \
    \       }\n            factor *= n;\n        }\n    }\n    max_factor\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n % 2 != 0 ? n / 2 :\
    \ 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `n`\n\
    \ --> /tmp/tmp_b5kvrpo.rs:7:18\n  |\n7 |     n % 2 != 0 ? n / 2 : 1\n  |     \
    \             ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // 0!\n\
    \    let mut f = 1; // 1!\n    while i <= n {\n        if n % i == 0 {\n     \
    \       i += 1;\n            f += 1;\n        }\n        else {\n            i\
    \ += 2;\n        }\n    }\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpj4owzc_8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn isprime(i: isize)\
    \ -> bool {\n        if i < 2 {\n            return false;\n        }\n      \
    \  \n        let mut i2 = i * 2;\n        while i2 < n {\n            if n % i2\
    \ == 0 {\n                return false;\n            }\n            i2 = i2 *\
    \ 2;\n        }\n        \n        true\n    }\n    \n    let mut f = 2;\n   \
    \ while f <= n {\n        if isprime(f) {\n            return f;\n        }\n\
    \        f += 2;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpzzbd0zvk.rs:13:20\n\
    \   |\n13 |         while i2 < n {\n   |                    ^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmpzzbd0zvk.rs:14:16\n   |\n14 |      \
    \       if n % i2 == 0 {\n   |                ^\n   |\n   = help: use the `||\
    \ { ... }` closure form instead\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_iterative(n).next()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_iterative` in\
    \ this scope\n --> /tmp/tmpobzphza7.rs:7:5\n  |\n7 |     largest_prime_factor_iterative(n).next()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
