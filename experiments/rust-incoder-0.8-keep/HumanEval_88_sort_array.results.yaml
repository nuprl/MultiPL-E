name: HumanEval_88_sort_array
language: rust
results:
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.into_iter().enumerate().map(|(idx,\
    \ item)| {\n        (if idx % 2 == 0 {\n            item\n        } else {\n \
    \           -item // descending\n        }).collect()\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmpj5_2dvmo.rs:17:12\n\
    \   |\n17 |         }).collect()\n   |            ^^^^^^^ `isize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `&mut isize: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut tmp = array.clone();\n\
    \    let mut swapped = false;\n    while !tmp.is_empty() {\n        swapped =\
    \ false;\n        for v in tmp.iter_mut() {\n            if v.is_odd() {\n   \
    \             v.swap(0);\n                swapped = true;\n            }\n   \
    \     }\n        if swapped {\n            tmp.swap(0);\n        } else {\n  \
    \          break;\n        }\n    }\n    return tmp;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for mutable reference `&mut\
    \ isize` in the current scope\n  --> /tmp/tmppqb1_x0k.rs:17:18\n   |\n17 |   \
    \          if v.is_odd() {\n   |                  ^^^^^^ method not found in `&mut\
    \ isize`\n\nerror[E0599]: no method named `swap` found for mutable reference `&mut\
    \ isize` in the current scope\n  --> /tmp/tmppqb1_x0k.rs:18:19\n   |\n18 |   \
    \              v.swap(0);\n   |                   ^^^^ method not found in `&mut\
    \ isize`\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmppqb1_x0k.rs:23:17\n    |\n23  |             tmp.swap(0);\n   \
    \ |                 ^^^^ - supplied 1 argument\n    |                 |\n    |\
    \                 expected 2 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ i in array {\n        sum += i;\n    }\n    if sum % 2 != 0 {\n        for i\
    \ in array.iter().rev() {\n            sum += i;\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpqiulzpge.rs:17:18\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n12  |     let mut sum = 0;\n13  |     for i in array\
    \ {\n    |              ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |         for i in array.iter().rev() {\n    |                  ^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |     for i in &array\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut array_copy = array;\n\n    array_copy.sort_by(|&x, &y| {\n        if x >=\
    \ y {\n            sum -= x;\n            sum -= y;\n            true\n      \
    \  } else {\n            sum -= y;\n            sum -= x;\n            false\n\
    \        }\n    });\n\n    sum\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78vc2tpm.rs:19:13\n   |\n\
    19 |             true\n   |             ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78vc2tpm.rs:23:13\n\
    \   |\n23 |             false\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78vc2tpm.rs:27:5\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n27 |     sum\n   |     ^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        max_value = &value if sum > max_value {\n            max_value = value;\n\
    \        };\n    }\n\n    let mut sort_array = array;\n    if sum % 2 == 1 {\n\
    \        sort_array.sort_by_key(|value| -value);\n    } else {\n        sort_array.sort_by_key(|value|\
    \ value);\n    }\n\n    *max_value\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmphwumexds.rs:16:28\n   |\n16 |         max_value\
    \ = &value if sum > max_value {\n   |                            ^^ expected one\
    \ of 8 possible tokens\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmphwumexds.rs:28:5\n   |\n28 |     *max_value\n   |     ^^^^^^^^^^\n\
    \   |\nhelp: parentheses are required to parse this as an expression\n   |\n22\
    \ ~     (if sum % 2 == 1 {\n23 |         sort_array.sort_by_key(|value| -value);\n\
    24 |     } else {\n25 |         sort_array.sort_by_key(|value| value);\n26 ~ \
    \    })\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_vec();\n\
    \n    let mut sum: usize = 0;\n    let mut min_element = 0;\n    let mut max_element\
    \ = array.len();\n    for value in array.iter() {\n        sum += value;\n   \
    \     if sum % 2 == 0 {\n            min_element = value;\n        } else {\n\
    \            max_element = value;\n        }\n    }\n\n    if min_element > max_element\
    \ {\n        // swap min_element and max_element\n        let temp_element = min_element;\n\
    \        min_element = max_element;\n        max_element = temp_element;\n   \
    \ }\n\n    // sort array\n    let mut min_value = min_element;\n    let mut max_value\
    \ = max_element;\n\n    for value in array.iter() {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n\n    array.set_len(max_value\
    \ - min_value + 1);\n\n    // sort array\n    let mut min_element = min_value;\n\
    \    let mut max_element = max_value;\n\n    for value in array.iter() {\n   \
    \     if value < min_element {\n            min_element = value;\n        }\n\
    \        if value > max_element {\n            max_element = value;\n        }\n\
    \    }\n\n    array.set_len(max_element - min_element + 1);\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:18:16\n   |\n\
    18 |         sum += value;\n   |                ^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `&isize` to `usize`\n  --> /tmp/tmpxtbtl_jc.rs:18:13\n\
    \   |\n18 |         sum += value;\n   |             ^^ no implementation for `usize\
    \ += &isize`\n   |\n   = help: the trait `AddAssign<&isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:20:27\n\
    \   |\n15 |     let mut min_element = 0;\n   |                           - expected\
    \ due to this value\n...\n20 |             min_element = value;\n   |        \
    \                   ^^^^^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             min_element = *value;\n   |\
    \                           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:22:27\n\
    \   |\n16 |     let mut max_element = array.len();\n   |                     \
    \      ----------- expected due to this value\n...\n22 |             max_element\
    \ = value;\n   |                           ^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:38:20\n   |\n38 |\
    \         if value < min_value {\n   |                    ^^^^^^^^^ expected `&isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:39:25\n\
    \   |\n34 |     let mut min_value = min_element;\n   |                       \
    \  ----------- expected due to this value\n...\n39 |             min_value = value;\n\
    \   |                         ^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxtbtl_jc.rs:41:20\n   |\n41 |         if value\
    \ > max_value {\n   |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut sum = array[0];\n    for i in 1..array.len()\
    \ {\n        sum += array[i];\n    }\n    if sum % 2 == 0 {\n        array.sort_by_key(|x|\
    \ -x)\n    } else {\n        array.sort_by_key(|x| x)\n    }\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbsmkffoz.rs:20:9\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n20 |         array.sort_by_key(|x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbsmkffoz.rs:22:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n22 |         array.sort_by_key(|x| x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n\
    \    sorted_array.sort();\n    sorted_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpgx7jr02q.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut sum = array[0] + array[array.len()-1];\n\
    \    if sum % 2 == 1 {\n        array.iter().cloned().sort();\n        return\
    \ array;\n    }\n    array.iter().cloned().sort().rev();\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpwdvp5yxy.rs:17:31\n   |\n17 |         array.iter().cloned().sort();\n\
    \   |                               ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `sort` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpwdvp5yxy.rs:20:27\n   |\n20 |     array.iter().cloned().sort().rev();\n\
    \   |                           ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwdvp5yxy.rs:11:37\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------\
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() <= 1 {\n        result\n    } else {\n        let mut result\
    \ = array.clone();\n        let mut first: isize = array[0];\n        let mut\
    \ last: isize = array[0];\n        let mut sum: isize = 0;\n        for val in\
    \ &mut result {\n            sum += val;\n            if sum % 2 != 0 {\n    \
    \            last = val;\n            } else {\n                first = val;\n\
    \            }\n        }\n        result.replace_range(first..last, first..last);\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `&mut isize` to `isize`\n  --> /tmp/tmpx_lhtxp0.rs:21:17\n\
    \   |\n21 |             sum += val;\n   |                 ^^ no implementation\
    \ for `isize += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx_lhtxp0.rs:23:24\n\
    \   |\n18 |         let mut last: isize = array[0];\n   |                    \
    \   ----- expected due to this type\n...\n23 |                 last = val;\n \
    \  |                        ^^^ expected `isize`, found `&mut isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n23 |                 last = *val;\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx_lhtxp0.rs:25:25\n\
    \   |\n17 |         let mut first: isize = array[0];\n   |                   \
    \     ----- expected due to this type\n...\n25 |                 first = val;\n\
    \   |                         ^^^ expected `isize`, found `&mut isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n25 |                 first = *val;\n\
    \   |                         +\n\nerror[E0599]: no method named `replace_range`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx_lhtxp0.rs:28:16\n\
    \   |\n28 |         result.replace_range(first..last, first..last);\n   |    \
    \            ^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // code here\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4_9bxdpb.rs:11:37\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array: Vec<isize>\
    \ = array.clone();\n    let mut sum = 0;\n    for i in &array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 != 0 {\n        for i in &array {\n            sum\
    \ += i;\n        }\n        array.sort_by_key(|&i| i);\n    } else {\n       \
    \ for i in &array {\n            sum += i;\n        }\n        array.sort_by_key(|&i|\
    \ -i).reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpx8wiwsbc.rs:26:36\n   |\n26 |         array.sort_by_key(|&i|\
    \ -i).reverse();\n   |                                    ^^^^^^^ method not found\
    \ in `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array;\n\
    \n    if array.is_empty() {\n        return result;\n    }\n\n    let mut array_sum:\
    \ isize = 0;\n    for value in &array {\n        array_sum += value;\n    }\n\n\
    \    if array_sum % 2 == 1 {\n        result.reverse();\n    }\n\n    if array_sum\
    \ % 2 == 0 {\n        let mut temp: isize = 0;\n        let mut i = 0;\n     \
    \   while i < result.len() - 1 {\n            if result[i] > result[i + 1] {\n\
    \                result[temp] = result[i];\n                result[i] = result[i\
    \ + 1];\n                result[i + 1] = temp;\n                temp += 1;\n \
    \           } else {\n                i += 1;\n            }\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8x2vsj3w.rs:32:17\n\
    \   |\n32 |                 result[temp] = result[i];\n   |                 ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(array.len(),\
    \ 0);\n\n    let mut result = vec![];\n    for i in 0..array.len() {\n       \
    \ let mut sum: isize = array[i];\n        let mut j: usize = 0;\n        let mut\
    \ k: usize = array.len();\n        // while loop to calculate the sum of each\
    \ index\n        while sum != 0 {\n            sum += array[j];\n            j\
    \ += 1;\n            k -= 1;\n        }\n        // if the sum is odd then swap\
    \ it with first index\n        if sum % 2 == 1 {\n            result.swap(j, k);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpo2i5tbwb.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|x| {\n\
    \        if ((*x).checked_sub(1).is_odd()) {\n            x.checked_sub(1)\n \
    \       } else {\n            x.checked_sub(0)\n        }\n    });\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb2fd5yjo.rs:13:12\n\
    \   |\n13 |         if ((*x).checked_sub(1).is_odd()) {\n   |            ^   \
    \                         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n13 -         if ((*x).checked_sub(1).is_odd())\
    \ {\n13 +         if (*x).checked_sub(1).is_odd() {\n   | \n\nerror[E0599]: no\
    \ method named `is_odd` found for enum `Option` in the current scope\n  --> /tmp/tmpb2fd5yjo.rs:13:33\n\
    \   |\n13 |         if ((*x).checked_sub(1).is_odd()) {\n   |                \
    \                 ^^^^^^ method not found in `Option<isize>`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(array.len(),\
    \ 0);\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = array[0];\n   \
    \ while i < array.len() {\n        while j < array.len() && array[j] > k {\n \
    \           i += 1;\n            j += 1\n        }\n        k -= array[j];\n \
    \       i += 1;\n        j = 1\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprn877rt1.rs:15:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n\n    let mut array = array.to_owned();\n    sort_array_helper(array.len(),\
    \ &mut array, array.len());\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_helper` in this scope\n\
    \  --> /tmp/tmpzt0xluql.rs:17:5\n   |\n17 |     sort_array_helper(array.len(),\
    \ &mut array, array.len());\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = array.iter().sum();\n\
    \    if sum % 2 == 0 {\n        array.sort_by(|x, y| {\n            if *x > y\
    \ {\n                *x - y\n            } else {\n                *y - x\n  \
    \          }\n        });\n    } else {\n        array.sort_by(|x, y| {\n    \
    \        if *x < y {\n                *x - y\n            } else {\n         \
    \       *y - x\n            }\n        });\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtnugz7a.rs:15:21\n   |\n\
    15 |             if *x > y {\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \     if *x > *y {\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxtnugz7a.rs:16:17\n   |\n16 |                 *x - y\n   |    \
    \             ^^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxtnugz7a.rs:18:17\n   |\n18 |              \
    \   *y - x\n   |                 ^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtnugz7a.rs:23:21\n\
    \   |\n23 |             if *x < y {\n   |                     ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           if *x < *y {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtnugz7a.rs:24:17\n   |\n24 |                 *x - y\n\
    \   |                 ^^^^^^ expected enum `std::cmp::Ordering`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxtnugz7a.rs:26:17\n   |\n26 |\
    \                 *y - x\n   |                 ^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = array[0];\n\
    \    for &x in &array {\n        sum += x;\n    }\n    if sum % 2 == 0 {\n   \
    \     array.iter().rev().cloned().collect()\n    } else {\n        array.iter().cloned().collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpa9m6ep1e.rs:12:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut count = 0;\n\n    for i in array.iter() {\n        sum += i;\n        count\
    \ += 1;\n    }\n\n    if count % 2 == 1 {\n        array.sort();\n    } else {\n\
    \        array.reverse();\n    }\n\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpey8vhaje.rs:21:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort();\n   |         ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmpey8vhaje.rs:23:9\n   |\n11 |\
    \ fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |               ----- help:\
    \ consider changing this to be mutable: `mut array`\n...\n23 |         array.reverse();\n\
    \   |         ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = array.len();\n\n    // swap elements if array sum\
    \ is even\n    while i < k {\n        while j < k {\n            if array[j] >\
    \ array[j + 1] {\n                let temp = array[j];\n                array[j]\
    \ = array[j + 1];\n                array[j + 1] = temp;\n            }\n     \
    \       j += 1;\n        }\n        i += 1;\n        j = 0;\n    }\n\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvr2zj37d.rs:14:9\n\
    \   |\n14 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpvr2zj37d.rs:21:17\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n21 |                 array[j] = array[j\
    \ + 1];\n   |                 ^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpvr2zj37d.rs:22:17\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n22 |\
    \                 array[j + 1] = temp;\n   |                 ^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort();\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpz3z740o8.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort();\n   |     ^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n\
    \    let mut index = 0;\n    while sorted_array.is_empty() {\n        let value\
    \ = sorted_array.get_mut(index);\n        let last_index = index;\n        while\
    \ let Some(next_value) = sorted_array.get_mut(last_index + 1) {\n            if\
    \ next_value + value > value {\n                sorted_array.swap(last_index,\
    \ next_index);\n                last_index = next_index;\n            }\n    \
    \        last_index += 1\n        }\n        index += 1;\n    }\n    sorted_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `next_index` in this scope\n  --> /tmp/tmpzm9ty1wb.rs:19:47\n\
    \   |\n19 |                 sorted_array.swap(last_index, next_index);\n   | \
    \                                              ^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `last_index`\n\nerror[E0425]: cannot find value\
    \ `next_index` in this scope\n  --> /tmp/tmpzm9ty1wb.rs:20:30\n   |\n20 |    \
    \             last_index = next_index;\n   |                              ^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `last_index`\n\nerror[E0369]:\
    \ cannot add `Option<&mut isize>` to `&mut isize`\n  --> /tmp/tmpzm9ty1wb.rs:18:27\n\
    \   |\n18 |             if next_value + value > value {\n   |                ----------\
    \ ^ ----- Option<&mut isize>\n   |                |\n   |                &mut\
    \ isize\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 1 {\n\
    \        return array\n    }\n    let mut left = array.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut right = array.iter().cloned().collect::<Vec<_>>();\n    let mut new_array\
    \ = array.iter().cloned().collect::<Vec<_>>();\n    if left.len() == right.len()\
    \ {\n        return array;\n    }\n\n    let mut mid = 0;\n    while let Some(mid)\
    \ = new_array.iter().position(|&x| x <= mid) {\n        swap(left, mid, new_array);\n\
    \    }\n    new_array = left;\n    let mut last = new_array.iter().cloned().collect::<Vec<_>>();\n\
    \    last = if left.len() % 2 == 0 {\n        last + [right.last().unwrap() +\
    \ 1]\n    } else {\n        last + [left.last().unwrap() - 1]\n    };\n    last\
    \ = if right.len() % 2 == 0 {\n        last + [left.last().unwrap() + 1]\n   \
    \ } else {\n        last + [right.last().unwrap() - 1]\n    };\n\n    for &mut\
    \ x in new_array {\n        let mut left_sum = 0;\n        let mut right_sum =\
    \ 0;\n        for &v in &left {\n            left_sum += v;\n        }\n     \
    \   for &v in &right {\n            right_sum += v;\n        }\n        let left_sum\
    \ = left_sum * mid;\n        let right_sum = right_sum * mid;\n        let (left_min,\
    \ left_max) = match (left_sum, right_sum) {\n            (Some(a), Some(b)) =>\
    \ (a, b),\n            (Some(a), None) => (a, Some(b)),\n            (None, Some(b))\
    \ => (Some(a), Some(b)),\n            (None, None) => break,\n            _ =>\
    \ (panic!(\"No sum!\"), None),\n        };\n        if left_min < x {\n      \
    \      swap(left, x, new_array);\n        }\n        if right_max > x {\n    \
    \        swap(right, x, new_array);\n        }\n    }\n\n    new_array += last;\n\
    \n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmps58sfw6u.rs:24:9\n\
    \   |\n24 |         swap(left, mid, new_array);\n   |         ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `b` in this scope\n  --> /tmp/tmps58sfw6u.rs:52:41\n   |\n52 |  \
    \           (Some(a), None) => (a, Some(b)),\n   |                           \
    \              ^ help: a local variable with a similar name exists: `a`\n\nerror[E0425]:\
    \ cannot find value `a` in this scope\n  --> /tmp/tmps58sfw6u.rs:53:38\n   |\n\
    53 |             (None, Some(b)) => (Some(a), Some(b)),\n   |                \
    \                      ^ help: a local variable with a similar name exists: `b`\n\
    \nerror[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmps58sfw6u.rs:58:13\n\
    \   |\n58 |             swap(left, x, new_array);\n   |             ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `right_max` in this scope\n  --> /tmp/tmps58sfw6u.rs:60:12\n   |\n\
    60 |         if right_max > x {\n   |            ^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `right_sum`\n\nerror[E0425]: cannot find function\
    \ `swap` in this scope\n  --> /tmp/tmps58sfw6u.rs:61:13\n   |\n61 |          \
    \   swap(right, x, new_array);\n   |             ^^^^ not found in this scope\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0369]: cannot add `[isize; 1]`\
    \ to `Vec<isize>`\n  --> /tmp/tmps58sfw6u.rs:29:14\n   |\n29 |         last +\
    \ [right.last().unwrap() + 1]\n   |         ---- ^ ---------------------------\
    \ [isize; 1]\n   |         |\n   |         Vec<isize>\n\nerror[E0369]: cannot\
    \ add `[isize; 1]` to `Vec<isize>`\n  --> /tmp/tmps58sfw6u.rs:31:14\n   |\n31\
    \ |         last + [left.last().unwrap() - 1]\n   |         ---- ^ --------------------------\
    \ [isize; 1]\n   |         |\n   |         V"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut sum = array[0];\n    let mut result\
    \ = vec![0; array.len()];\n\n    for i in 0..array.len() {\n        let value\
    \ = array[i];\n        let index = i as usize;\n        // We have to check both\
    \ the odd and even conditions\n        if ((sum % 2 == 0) || (value <= sum)) {\n\
    \            result[index] = value;\n        }\n        sum += value;\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpylu9914v.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut n = array.len();\n\
    \    if n % 2 == 1 {\n        array.sort();\n    } else {\n        array.sort_by_key(|&x|\
    \ -x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9wlcd4cv.rs:12:9\n\
    \   |\n12 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp9wlcd4cv.rs:14:9\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n14 |         array.sort();\n   |     \
    \    ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp9wlcd4cv.rs:16:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n16 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array;\n\
    \    result.sort_unstable_by_key(|x| {\n        if x.0 % 2 == 0 {\n          \
    \  x.0\n        } else {\n            x.0\n        }\n    });\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpscorrvnv.rs:14:14\n\
    \   |\n14 |         if x.0 % 2 == 0 {\n   |              ^\n\nerror[E0609]: no\
    \ field `0` on type `&isize`\n  --> /tmp/tmpscorrvnv.rs:15:15\n   |\n15 |    \
    \         x.0\n   |               ^\n\nerror[E0609]: no field `0` on type `&isize`\n\
    \  --> /tmp/tmpscorrvnv.rs:17:15\n   |\n17 |             x.0\n   |           \
    \    ^\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // O(N), where N is array's\
    \ length\n    if array.len() < 2 {\n        return array;\n    }\n\n    let mut\
    \ min: usize = array[0];\n    let mut max: usize = array[0];\n    let mut sum\
    \ = 0;\n    let mut j = 0;\n    let mut i = 0;\n    while i < array.len() {\n\
    \        let value = array[i];\n        sum += value;\n\n        while j < array.len()\
    \ {\n            let value2 = array[j];\n            sum += value2;\n\n      \
    \      if sum > max {\n                max = sum;\n                j = j + 1;\n\
    \            } else if sum < min {\n                min = sum;\n             \
    \   i = i + 1;\n            } else {\n                break;\n            }\n\
    \        }\n        sum += value;\n    }\n    let mut i = 0;\n    while i < array.len()\
    \ {\n        let value = array[i];\n        let mut value = value;\n        if\
    \ i < array.len() - 1 {\n            if max > value {\n                let mut\
    \ tmp = array[i + 1];\n                array[i + 1] = array[i];\n            \
    \    array[i] = tmp;\n            }\n        }\n\n        i += 1;\n    }\n   \
    \ return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyj1bpfs8.rs:17:26\n   |\n\
    17 |     let mut min: usize = array[0];\n   |                  -----   ^^^^^^^^\
    \ expected `usize`, found `isize`\n   |                  |\n   |             \
    \     expected due to this\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut min: usize\
    \ = array[0].try_into().unwrap();\n   |                                  ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyj1bpfs8.rs:18:26\n   |\n18 |\
    \     let mut max: usize = array[0];\n   |                  -----   ^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |                  |\n   |                  expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |     let mut max: usize = array[0].try_into().unwrap();\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyj1bpfs8.rs:30:22\n   |\n30 |             if sum > max\
    \ {\n   |                      ^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n30 |             if sum > max.try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyj1bpfs8.rs:31:23\n   |\n18 |     let mut max: usize = array[0];\n \
    \  |                  ----- expected due to this type\n...\n31 |             \
    \    max = sum;\n   |                       ^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyj1bpfs8.rs:33:29\n   |\n33 |\
    \             } else if sum < min {\n   |                             ^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |             } else\
    \ if sum < min.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyj1bpfs8.rs:34:23\n   |\n17 |\
    \     let mut min: us"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut sorted_array = vec![];\n    for i in array {\n        sum += i;\n      \
    \  sorted_array.push(i);\n    }\n    if sum % 2 == 1 {\n        for i in sorted_array.rt.iter_mut().rev()\
    \ {\n            *i = - *i;\n        }\n    }\n    sorted_array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `rt` on type `Vec<isize>`\n  --> /tmp/tmpyab3ogma.rs:19:31\n\
    \   |\n19 |         for i in sorted_array.rt.iter_mut().rev() {\n   |        \
    \                       ^^ unknown field\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = [0i32;\
    \ array.len()];\n    for i in 0..array.len() {\n        new_array[i] = array[i];\n\
    \    }\n\n    let mut sum: i32;\n    for i in 0..new_array.len() {\n        sum\
    \ = sum + new_array[i];\n        if sum % 2 == 1 {\n            new_array[i] =\
    \ new_array[i] as i32;\n        } else {\n            new_array[i] = -new_array[i]\
    \ as i32;\n        }\n    }\n    for i in 0..new_array.len() {\n        new_array[i]\
    \ = new_array[i] as isize;\n    }\n\n    for i in 0..new_array.len() {\n     \
    \   new_array[i] = new_array[i] as isize;\n    }\n    new_array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpnmrp761s.rs:12:32\n   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize>\
    \ {\n   |               ----- this would need to be a `const`\n12 |     let mut\
    \ new_array = [0i32; array.len()];\n   |                                ^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0435`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array_copy = array.clone();\n    if\
    \ array_copy[0] > array_copy[array_copy.len() - 1] {\n        swap(&array_copy[0],\
    \ &array_copy[array_copy.len() - 1]);\n    }\n\n    let mut sum = 0;\n    for\
    \ i in 1..array_copy.len() {\n        sum += array_copy[i];\n    }\n    if sum\
    \ % 2 == 0 {\n        array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i).rev();\n    }\n    array_copy\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp477_pnck.rs:17:9\n\
    \   |\n17 |         swap(&array_copy[0], &array_copy[array_copy.len() - 1]);\n\
    \   |         ^^^^ not found in this scope\n   |\nhelp: consider importing one\
    \ of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp477_pnck.rs:27:36\n\
    \   |\n27 |         array.sort_by_key(|&i| -i).rev();\n   |                  \
    \                  ^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut s = array.clone();\n\
    \    let len = s.len();\n    \n    if s.len() % 2 != 0 {\n        // sort in descending\
    \ order\n        s.reverse();\n    }\n    \n    let mut sum: isize = 0;\n    for\
    \ i in 0..len - 1 {\n        sum += s[i];\n    }\n    \n    if sum % 2 != 0 {\n\
    \        // sort in ascending order\n        s.reverse();\n    }\n    \n    s\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzj6lvx39.rs:21:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut s = array.to_vec();\n\
    \    s.sort();\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_zhobefc.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // code here\n    let mut\
    \ temp: Vec<isize> = array.clone();\n    let mut count: isize = 0;\n    for i\
    \ in 0..temp.len() {\n        count += temp[i];\n        if count % 2 == 1 {\n\
    \            temp[i] = temp[temp.len() - i];\n            temp[temp.len() - i]\
    \ = i;\n        }\n    }\n    temp\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfjl8j2d7.rs:19:36\n   |\n\
    19 |             temp[temp.len() - i] = i;\n   |             --------------------\
    \   ^ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut min_idx = array.len();\n\
    \    let mut max_idx = array.len();\n\n    while min_idx < max_idx {\n       \
    \ let mut min_value = array[min_idx];\n        let mut max_value = array[max_idx];\n\
    \        if min_value < max_value {\n            // swap two elements if one is\
    \ smaller\n            if min_value < max_value {\n                array[idx::min_idx]\
    \ = array[min_idx];\n                array[idx::max_idx] = array[max_idx];\n \
    \           }\n            min_idx++;\n            max_idx--;\n        } else\
    \ {\n            // swap two elements if one is larger\n            if min_value\
    \ > max_value {\n                array[idx::min_idx] = array[max_idx];\n     \
    \           array[idx::max_idx] = array[min_idx];\n            }\n           \
    \ max_idx--;\n            min_idx++;\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpdslhkiq0.rs:24:20\n\
    \   |\n24 |             min_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |             { let tmp =\
    \ min_idx; min_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    24 -             min_idx++;\n24 +             min_idx += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmpdslhkiq0.rs:32:22\n   |\n32 |         \
    \    max_idx--;\n   |                      ^ expected expression\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `idx`\n  --> /tmp/tmpdslhkiq0.rs:21:23\n\
    \   |\n21 |                 array[idx::min_idx] = array[min_idx];\n   |      \
    \                 ^^^ use of undeclared crate or module `idx`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `idx`\n  --> /tmp/tmpdslhkiq0.rs:22:23\n\
    \   |\n22 |                 array[idx::max_idx] = array[max_idx];\n   |      \
    \                 ^^^ use of undeclared crate or module `idx`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `idx`\n  --> /tmp/tmpdslhkiq0.rs:29:23\n\
    \   |\n29 |                 array[idx::min_idx] = array[max_idx];\n   |      \
    \                 ^^^ use of undeclared crate or module `idx`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `idx`\n  --> /tmp/tmpdslhkiq0.rs:30:23\n\
    \   |\n30 |                 array[idx::max_idx] = array[min_idx];\n   |      \
    \                 ^^^ use of undeclared crate or module `idx`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut temp_vector = Vec::with_capacity(array.len()\
    \ * 2);\n    let mut sum = 0;\n    let mut temp_array: Vec<isize> = Vec::with_capacity(array.len());\n\
    \    for element in array {\n        temp_vector.push(element);\n        sum +=\
    \ element;\n    }\n    if sum % 2 == 0 {\n        for element in temp_vector {\n\
    \            temp_array.push(element);\n        }\n    } else {\n        for element\
    \ in temp_vector {\n            temp_array.push(-element);\n        }\n    }\n\
    \    temp_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5]`,\n right: `[5]`', /tmp/tmpv8hzzk57.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    debug!(\"sort_array\");\n\
    \n    let mut sum = 0;\n\n    for ele in array.iter() {\n        if ele > 0 {\n\
    \            sum += ele;\n        }\n    }\n\n    if sum % 2 == 1 {\n        array.sort();\n\
    \    } else {\n        array\n            .iter()\n            .fold(0, |sum,\
    \ ele| {\n                if ele > 0 {\n                    sum += ele;\n    \
    \            }\n                sum\n            })\n            .sorted(|a, b|\
    \ a > b)\n            .cloned()\n    }\n\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmppua4ggwn.rs:12:5\n\
    \   |\n12 |     debug!(\"sort_array\");\n   |     ^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppua4ggwn.rs:17:18\n   |\n17 |         if ele > 0 {\n  \
    \ |                  ^\n   |                  |\n   |                  expected\
    \ `&isize`, found integer\n   |                  help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppua4ggwn.rs:28:26\n  \
    \ |\n28 |                 if ele > 0 {\n   |                          ^\n   |\
    \                          |\n   |                          expected `&isize`,\
    \ found integer\n   |                          help: consider borrowing here:\
    \ `&0`\n\nerror[E0599]: no method named `sorted` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmppua4ggwn.rs:33:14\n   |\n33 |             .sorted(|a,\
    \ b| a > b)\n   |              ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    sort.sort_by(|a, b| {\n        match a < b {\n            true => -1,\n \
    \           false => 1,\n        }\n    });\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `sort` in this scope\n  --> /tmp/tmp2aa2_9gk.rs:13:5\n\
    \   |\n13 |     sort.sort_by(|a, b| {\n   |     ^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array;\n    }\n    let mut sorted_array = array.clone();\n   \
    \ let mut first_element = sorted_array[0];\n    let mut last_element = sorted_array.pop().unwrap();\n\
    \    for element in sorted_array {\n        let last_element += element;\n   \
    \     if last_element % 2 == 0 {\n            sorted_array.swap(0, sorted_array.len());\n\
    \            break;\n        }\n        last_element = element;\n    }\n    sorted_array.swap(0,\
    \ sorted_array.len());\n    return sorted_array;\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: can't reassign to an uninitialized variable\n  --> /tmp/tmpd80oub3j.rs:19:26\n\
    \   |\n19 |         let last_element += element;\n   |                       \
    \   ^^ help: initialize the variable\n   |\n   = help: if you meant to overwrite,\
    \ remove the `let` binding\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut max = 0;\n    for i in array {\n        sum += i;\n        if sum > max\
    \ {\n            max = sum;\n        }\n    }\n    let mut arr: Vec<isize> = vec![];\n\
    \    for i in array {\n        if max % 2 == 1 {\n            arr.push(i);\n \
    \       } else {\n            arr.push(-i);\n        }\n    }\n    arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `array`\n   --> /tmp/tmps297p4ro.rs:21:14\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n14  |     for i in array {\n    |         \
    \     ----- `array` moved due to this implicit call to `.into_iter()`\n...\n21\
    \  |     for i in array {\n    |              ^^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n14  |     for i in &array {\n  \
    \  |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array\n    }\n    let mut result = array.clone();\n    let mut\
    \ sum = 0;\n    for &i in &result {\n        sum += i;\n    }\n    result.sort();\n\
    \    let mut i = 0;\n    while i < result.len() {\n        let current_value =\
    \ result[i];\n        let left_value = result[i++];\n        let right_value =\
    \ result[i++];\n        let new_value = if sum % 2 == 0 {\n            if current_value\
    \ > right_value {\n                left_value\n            } else {\n        \
    \        right_value\n            }\n        } else {\n            if current_value\
    \ > left_value {\n                right_value\n            } else {\n        \
    \        left_value\n            }\n        };\n        result[i] = new_value;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfjzh24pp.rs:24:34\n\
    \   |\n24 |         let left_value = result[i++];\n   |                      \
    \            ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n24 |         let left_value = result[{ let tmp = i; i += 1; tmp }];\n \
    \  |                                 +++++++++++  ~~~~~~~~~~~~~~~\n24 -      \
    \   let left_value = result[i++];\n24 +         let left_value = result[i += 1];\n\
    \   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    sort_array(&array, SortType::Ascending,\
    \ SortType::Ascending, SortType::Ascending)\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SortType`\n  -->\
    \ /tmp/tmpodaybxg5.rs:12:24\n   |\n12 |     sort_array(&array, SortType::Ascending,\
    \ SortType::Ascending, SortType::Ascending)\n   |                        ^^^^^^^^\
    \ use of undeclared type `SortType`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `SortType`\n  --> /tmp/tmpodaybxg5.rs:12:45\n   |\n12 |    \
    \ sort_array(&array, SortType::Ascending, SortType::Ascending, SortType::Ascending)\n\
    \   |                                             ^^^^^^^^ use of undeclared type\
    \ `SortType`\n\nerror[E0433]: failed to resolve: use of undeclared type `SortType`\n\
    \  --> /tmp/tmpodaybxg5.rs:12:66\n   |\n12 |     sort_array(&array, SortType::Ascending,\
    \ SortType::Ascending, SortType::Ascending)\n   |                            \
    \                                      ^^^^^^^^ use of undeclared type `SortType`\n\
    \nerror[E0061]: this function takes 1 argument but 4 arguments were supplied\n\
    \  --> /tmp/tmpodaybxg5.rs:12:5\n   |\n12 |     sort_array(&array, SortType::Ascending,\
    \ SortType::Ascending, SortType::Ascending)\n   |     ^^^^^^^^^^ ------  -------------------\
    \  -------------------  ------------------- supplied 4 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpodaybxg5.rs:11:4\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ^^^^^^^^^^\
    \ -----------------\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    trace!(\"sort_array >>>\
    \ array: {:?}\", array);\n\n    let mut new_array: Vec<isize> = vec![];\n    let\
    \ mut sum: isize = 0;\n\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \        new_array.push(sum);\n    }\n\n    trace!(\"sort_array <<< new_array:\
    \ {:?}\", new_array);\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `trace` in this scope\n  --> /tmp/tmp2cqzwlv8.rs:12:5\n\
    \   |\n12 |     trace!(\"sort_array >>> array: {:?}\", array);\n   |     ^^^^^\n\
    \nerror: cannot find macro `trace` in this scope\n  --> /tmp/tmp2cqzwlv8.rs:22:5\n\
    \   |\n22 |     trace!(\"sort_array <<< new_array: {:?}\", new_array);\n   | \
    \    ^^^^^\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    debug_assert!(array.is_sorted());\n\
    \    let mut result = array.to_vec();\n    result.sort_by_key(|&i| i as isize);\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmp8i7dodrv.rs:12:25\n   |\n12 |     debug_assert!(array.is_sorted());\n\
    \   |                         ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut even = true;\n    let mut odd = true;\n\
    \    let mut sum = 0;\n    for element in &array {\n        sum += element;\n\
    \        if even {\n            if sum % 2 != 0 {\n                even = false;\n\
    \            }\n        } else {\n            if sum % 2 != 0 {\n            \
    \    odd = false;\n            }\n        }\n    }\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut last = array.len() - 1;\n    let mut current = array.len()\
    \ - 1;\n    let mut current = array.len() - 1;\n    let mut current = array.len()\
    \ - 1;\n    let mut current = array.len() - 1;\n    while i < (array.len() - 1)\
    \ && (j + 1) < (array.len() - 1) {\n        if array[j] > array[j + 1] {\n   \
    \         array[j + 1] = array[j];\n            current -= 1;\n            j +=\
    \ 1;\n        }\n        i += 1;\n        last -= 1;\n    }\n    array[j + 1]\
    \ = array[j];\n    current -= 1;\n    even ^= true;\n    odd ^= false;\n    if\
    \ array.len() > 2 {\n        sort_array(&array[last..]);\n    }\n    if array.len()\
    \ > 0 {\n        if even {\n            if array[0] % 2 == 1 {\n             \
    \   array[0] = array[0] % 2;\n                array[1] += 1;\n            }\n\
    \        } else {\n            if array[0] % 2 == 0 {\n                array[0]\
    \ = array[0] % 2;\n                array[1] -= 1;\n            }\n        }\n\
    \        if array[0] > array[1] {\n            let temp = array[0];\n        \
    \    array[0] = array[1];\n            array[1] = temp;\n        }\n    }\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_rp3zj8.rs:51:20\n   |\n\
    51 |         sort_array(&array[last..]);\n   |                    ^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&[isize]`\nhelp: try using a conversion method\n\
    \   |\n51 |         sort_array((&array[last..]).to_vec());\n   |             \
    \       +              ++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut max_sum = array[0];\n\
    \    let mut min_sum = array[0];\n    let mut temp_sum = 0;\n    let mut array_copy\
    \ = array.clone();\n    for &v in array_copy {\n        if v > max_sum {\n   \
    \         max_sum = v;\n        }\n        if v < min_sum {\n            min_sum\
    \ = v;\n        }\n        temp_sum += v;\n    }\n    if temp_sum & 1 == 1 {\n\
    \        array_copy.sort_unstable();\n    }\n    else {\n        array_copy.sort_descending();\n\
    \    }\n    array_copy\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpypn74b4q.rs:16:9\n   |\n\
    16 |     for &v in array_copy {\n   |         ^^    ---------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `v`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: no method named `sort_descending` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpypn74b4q.rs:29:20\n   |\n29 |         array_copy.sort_descending();\n\
    \   |                    ^^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    let mut sum = 0;\n    for i in array {\n        sum += i;\n    }\n    debug_assert!(sum\
    \ & 1 == 1);\n    for j in array {\n        sum += j;\n        debug_assert!(sum\
    \ & 1 == 0);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbdp3qpee.rs:12:9\n\
    \   |\n12 |     let mut array = array.to_owned();\n   |         ----^^^^^\n  \
    \ |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `array`\n   --> /tmp/tmpbdp3qpee.rs:18:14\n\
    \    |\n12  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n13  |     let mut sum = 0;\n14  |     for i in array {\n    |       \
    \       ----- `array` moved due to this implicit call to `.into_iter()`\n...\n\
    18  |     for j in array {\n    |              ^^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n14  |     for i in &array {\n  \
    \  |              +\n\nerror[E0382]: use of moved value: `array`\n  --> /tmp/tmpbdp3qpee.rs:22:5\n\
    \   |\n12 |     let mut array = array.to_owned();\n   |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n18 |     for j in array {\n   |              ----- `array` moved\
    \ due to this implicit call to `.into_iter()`\n...\n22 |     array\n   |     ^^^^^\
    \ value used here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n18 |     for\
    \ j in &array {\n   |              +\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \n    result.sort_unstable_by(|a, b| {\n        if a + b == 2 {\n            a\
    \ < b\n        } else {\n            a < b\n        }\n    });\n\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps6fpo4ij.rs:16:13\n   |\n\
    16 |             a < b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps6fpo4ij.rs:18:13\n\
    \   |\n18 |             a < b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut a = array.iter().cloned().collect();\n\
    \    a.sort();\n    a\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplai21per.rs:13:5\n\
    \   |\n12 |     let mut a = array.iter().cloned().collect();\n   |         -----\
    \ consider giving `a` a type\n13 |     a.sort();\n   |     ^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut first_index = 0;\n    let mut last_index\
    \ = array.len() - 1;\n    let mut sum_of_first_and_last_elements = 0;\n\n    loop\
    \ {\n        if first_index == last_index {\n            break;\n        }\n\n\
    \        let element = &array[first_index];\n\n        let next_element = &array[last_index];\n\
    \n        sum_of_first_and_last_elements += element;\n        last_index--;\n\n\
    \        sum_of_first_and_last_elements += next_element;\n\n        match sum_of_first_and_last_elements.checked_sub(1)?\
    \ {\n            Some(odd) => {\n                if odd {\n                  \
    \  first_index++;\n                } else {\n                    last_index--;\n\
    \                }\n            }\n            None => break,\n        }\n   \
    \ }\n\n    let mut temp_vector = Vec::new();\n\n    for i in 0..first_index {\n\
    \        temp_vector.push(array[i]);\n    }\n\n    for i in last_index..array.len()\
    \ {\n        temp_vector.push(array[i]);\n    }\n\n    temp_vector\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpe010tcma.rs:30:21\n\
    \   |\n30 |         last_index--;\n   |                     ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut n = array.len();\n    loop {\n        result .push(array[0]);\n \
    \       let left = n - 1;\n        let mut sum = 0;\n        let mut temp = 0;\n\
    \        while left >= 0 {\n            sum = sum + array[left];\n           \
    \ temp = array[left];\n            if sum % 2 == 1 {\n                array[left]\
    \ = temp;\n                left--;\n            } else {\n                array[left]\
    \ = array[left - 1];\n                left--;\n            }\n        }\n    \
    \    if sum > n {\n            break;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp0qct71cd.rs:24:23\n\
    \   |\n24 |                 left--;\n   |                       ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmp0qct71cd.rs:27:23\n   |\n\
    27 |                 left--;\n   |                       ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0qct71cd.rs:30:18\n   |\n30 |\
    \         if sum > n {\n   |                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if sum > n.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut sum = 0;\n    for value in array.iter() {\n     \
    \   sum += *value;\n        result.push(value);\n    }\n    if sum % 2 == 1 {\n\
    \        result.sort();\n    } else {\n        result.sort_by_key(|&x| -x);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplsyhehjw.rs:16:21\n   |\n\
    16 |         result.push(value);\n   |                     ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \       result.push(*value);\n   |                     +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|&a| if\
    \ a % 2 == 1 {\n        -1\n    } else {\n        a\n    })\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03dqg56b.rs:12:5\n   |\n\
    11 |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    12 | /     array.sort_by_key(|&a| if a % 2 == 1 {\n13 | |         -1\n14 | | \
    \    } else {\n15 | |         a\n16 | |     })\n   | |______^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut res = vec![];\n    let mut s = array[0];\n\
    \    let mut e = array[0];\n    for (i, v) in array.iter().enumerate() {\n   \
    \     if i > 0 {\n            s = v;\n        }\n        if i % 2 == 0 {\n   \
    \         e = v;\n        }\n        res.push(v);\n    }\n    sort_array_helper(res,\
    \ s, e);\n    return res;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_helper` in this scope\n\
    \  --> /tmp/tmppqjwvsvc.rs:27:5\n   |\n27 |     sort_array_helper(res, s, e);\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppqjwvsvc.rs:20:17\n   |\n16 |     let mut s = array[0];\n\
    \   |                 -------- expected due to this value\n...\n20 |         \
    \    s = v;\n   |                 ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |             s = *v;\n   |    \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqjwvsvc.rs:23:17\n\
    \   |\n17 |     let mut e = array[0];\n   |                 -------- expected\
    \ due to this value\n...\n23 |             e = v;\n   |                 ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |             e = *v;\n   |                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppqjwvsvc.rs:28:12\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n...\n28 |     return res;\n   |       \
    \     ^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_vec();\n\
    \    let size = array.len();\n    array.sort();\n    let mut ret: Vec<isize> =\
    \ Vec::new();\n    for i in 0..size {\n        if i % 2 == 0 {\n            ret.push(*(array[i].unwrap()\
    \ + array[size - 1 - i].unwrap()));\n        } else {\n            ret.push(*(array[i].unwrap()\
    \ - array[size - 1 - i].unwrap()));\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpl2wyv2mb.rs:18:33\n   |\n18 |             ret.push(*(array[i].unwrap()\
    \ + array[size - 1 - i].unwrap()));\n   |                                 ^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpl2wyv2mb.rs:18:64\n   |\n\
    18 |             ret.push(*(array[i].unwrap() + array[size - 1 - i].unwrap()));\n\
    \   |                                                                ^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpl2wyv2mb.rs:20:33\n   |\n20 |  \
    \           ret.push(*(array[i].unwrap() - array[size - 1 - i].unwrap()));\n \
    \  |                                 ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpl2wyv2mb.rs:20:64\n   |\n20 |             ret.push(*(array[i].unwrap()\
    \ - array[size - 1 - i].unwrap()));\n   |                                    \
    \                            ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.to_vec();\n\
    \    new_array.sort();\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmps8b8gr3q.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_vec();\n\
    \    let n = array.len();\n    let mut sum = 0;\n    for i in 0..n {\n       \
    \ sum += array[i];\n    }\n    if n % 2 == 0 {\n        for j in 0..(n-1) / 2\
    \ {\n            swap(&mut array, j, n-1-j);\n        }\n    } else {\n      \
    \  for j in 0..(n-1) / 2 {\n            swap(&mut array, n-j-1, n-j);\n      \
    \  }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpzdh0w6uc.rs:20:13\n\
    \   |\n20 |             swap(&mut array, j, n-1-j);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find function `swap` in this scope\n  --> /tmp/tmpzdh0w6uc.rs:24:13\n\
    \   |\n24 |             swap(&mut array, n-j-1, n-j);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // sort ascending\n    if\
    \ array.len() % 2 == 1 {\n        array.iter().rev().sort().rev()\n    } else\
    \ {\n        array.iter().sort().rev()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmp62ksmta4.rs:14:28\n   |\n14 |         array.iter().rev().sort().rev()\n\
    \   |                            ^^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `sort` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp62ksmta4.rs:16:22\n   |\n16 |         array.iter().sort().rev()\n\
    \   |                      ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array;\n\
    \    if array.is_empty() {\n        return result;\n    }\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    let mut curr_sum = 0;\n\
    \    for element in &array {\n        curr_sum += element;\n        min_value\
    \ = element;\n        if curr_sum < min_value {\n            min_value = curr_sum;\n\
    \        }\n        max_value = element;\n        if curr_sum > max_value {\n\
    \            max_value = curr_sum;\n        }\n    }\n    if max_value - min_value\
    \ > 0 {\n        result.sort_by_key(|e| e - min_value);\n    } else {\n      \
    \  result.sort_by_key(|e| e - max_value);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp50xyughh.rs:21:21\n   |\n\
    16 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n21 |         min_value = element;\n   |   \
    \                  ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |         min_value = *element;\n   |   \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50xyughh.rs:25:21\n\
    \   |\n17 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |         max_value = element;\n   |   \
    \                  ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |         max_value = *element;\n   |   \
    \                  +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.clone();\n\
    \    sort_array(&mut array);\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe1og3y3b.rs:13:16\n   |\n\
    13 |     sort_array(&mut array);\n   |                ^^^^^^^^^^ expected struct\
    \ `Vec`, found `&mut Vec<isize>`\n   |\n   = note:         expected struct `Vec<isize>`\n\
    \           found mutable reference `&mut Vec<isize>`\nhelp: consider removing\
    \ the borrow\n   |\n13 -     sort_array(&mut array);\n13 +     sort_array(array);\n\
    \   | \n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpwk06k1aw.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    sort_array_internal(array, 0, array.len());\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_internal` in this scope\n\
    \  --> /tmp/tmprivf88_t.rs:13:5\n   |\n13 |     sort_array_internal(array, 0,\
    \ array.len());\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|i| {\n\
    \        if i < 0 {\n            -1\n        } else {\n            i + 1\n   \
    \     }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6z5c847.rs:13:16\n   |\n\
    13 |         if i < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // write your code here\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpth03oi41.rs:11:37\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(*array.len(),\
    \ 0);\n    let mut max_value: Option<isize> = None;\n    let mut min_value: Option<isize>\
    \ = None;\n    let mut sum: Option<isize> = None;\n    for el in array.iter()\
    \ {\n        let (min, max) = (el as isize).min(|a, b| a.partial_cmp(b));\n  \
    \      if let Some(value) = min {\n            if max_value.is_none() {\n    \
    \            max_value = Some(value);\n            } else {\n                max_value\
    \ = Some(max_value.unwrap() + value);\n            }\n        }\n        if let\
    \ Some(value) = max {\n            if min_value.is_none() {\n                min_value\
    \ = Some(value);\n            } else {\n                min_value = Some(min_value.unwrap()\
    \ + value);\n            }\n        }\n        sum = Some(el + sum.unwrap());\n\
    \    }\n    sort_array(min_value, max_value, sum)\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp1n6zojaj.rs:12:16\n\
    \   |\n12 |     assert_eq!(*array.len(), 0);\n   |                ^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1n6zojaj.rs:17:13\n   |\n17 |\
    \         let (min, max) = (el as isize).min(|a, b| a.partial_cmp(b));\n   | \
    \            ^^^^^^^^^^   ------------------------------------------ this expression\
    \ has type `isize`\n   |             |\n   |             expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `(_,\
    \ _)`\n\nerror[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmp1n6zojaj.rs:34:5\n   |\n34 |     sort_array(min_value, max_value,\
    \ sum)\n   |     ^^^^^^^^^^ ---------  ---------  --- supplied 3 arguments\n \
    \  |     |\n   |     expected 1 argument\n   |\nnote: function defined here\n\
    \  --> /tmp/tmp1n6zojaj.rs:11:4\n   |\n11 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |    ^^^^^^^^^^ -----------------\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmp1n6zojaj.rs:17:26\n   |\n17 |\
    \         let (min, max) = (el as isize).min(|a, b| a.partial_cmp(b));\n   | \
    \                         ^--^^^^^^^^^^\n   |                          ||\n  \
    \ |                          |help: dereference the expression: `*el`\n   |  \
    \                        cannot cast `&isize` as `isize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0606, E0614.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = array[0];\n\
    \    for &i in &array[1..] {\n        sum += i;\n    }\n    if sum % 2 != 0 {\n\
    \        array.sort();\n    }\n    else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpbikoszvl.rs:17:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n17 |         array.sort();\n   |         ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmpbikoszvl.rs:20:9\n   |\n11 |\
    \ fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |               ----- help:\
    \ consider changing this to be mutable: `mut array`\n...\n20 |         array.sort();\n\
    \   |         ^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpbikoszvl.rs:21:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n21 |\
    \         array.reverse();\n   |         ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut tmp = array;\n \
    \   tmp.sort();\n    return tmp;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp7onq0mhy.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array: [usize;\
    \ MAX_ARRAY_LENGTH] = [];\n\n    let mut last_sum = 0;\n    for i in array.iter()\
    \ {\n        sorted_array[last_sum] += i;\n        last_sum += i;\n    }\n\n \
    \   let mut last_sum1 = 0;\n    for i in sorted_array.iter() {\n        if last_sum1\
    \ % 2 == 1 {\n            *i = *i.saturating_add((*i).saturating_add(1));\n  \
    \      } else {\n            *i = *i.saturating_sub((*i).saturating_sub(1));\n\
    \        }\n        last_sum1 += *i;\n    }\n    return sorted_array[0..(last_sum)].to_vec();\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_ARRAY_LENGTH` in this scope\n  -->\
    \ /tmp/tmpoa8ujvcl.rs:12:35\n   |\n12 |     let mut sorted_array: [usize; MAX_ARRAY_LENGTH]\
    \ = [];\n   |                                   ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpoa8ujvcl.rs:23:18\n\
    \   |\n23 |             *i = *i.saturating_add((*i).saturating_add(1));\n   |\
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpoa8ujvcl.rs:25:18\n   |\n\
    25 |             *i = *i.saturating_sub((*i).saturating_sub(1));\n   |       \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoa8ujvcl.rs:29:12\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n...\n29 |     return sorted_array[0..(last_sum)].to_vec();\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(!array.is_empty(),\
    \ \"cannot sort an empty array\");\n    assert_eq!(0, array.len());\n\n    let\
    \ mut sum = array[0];\n    for i in 1..array.len() {\n        let current_sum\
    \ = array[i];\n        assert_eq!(sum + current_sum, sum);\n        sum += current_sum;\n\
    \    }\n    let mut array = array.clone();\n    array.sort_by_key(|x| x + sum);\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'cannot sort an empty array', /tmp/tmpwecbd0tm.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|&x| x.to_owned());\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpypdize_z.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort_by_key(|&x| x.to_owned());\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // write your code in rust\
    \ here\n    let mut temp: Vec<isize> = array.clone();\n    for i in 1..array.len()\
    \ {\n        if temp.iter().skip(i - 1).sum::<usize>() % 2 == 1 {\n          \
    \  temp.reverse();\n        }\n    }\n    temp\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Sum<&isize>` is not satisfied\n \
    \   --> /tmp/tmpfsipkopu.rs:15:36\n     |\n15   |         if temp.iter().skip(i\
    \ - 1).sum::<usize>() % 2 == 1 {\n     |                                    ^^^\
    \ the trait `Sum<&isize>` is not implemented for `usize`\n     |\n     = help:\
    \ the following other types implement trait `Sum<A>`:\n               <f32 as\
    \ Sum<&'a f32>>\n               <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n\
    \               <f64 as Sum>\n               <i128 as Sum<&'a i128>>\n       \
    \        <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n               <i16\
    \ as Sum>\n             and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array: Vec<isize>\
    \ = vec![];\n    for i in 0..array.len() {\n        let mut sum: isize = 0;\n\
    \        for j in 0..i {\n            sum += array[j];\n        }\n        if\
    \ sum % 2 == 0 {\n            sorted_array.push(array[i]);\n        } else {\n\
    \            sorted_array.push(array[i]);\n            sorted_array.pop_back();\n\
    \        }\n    }\n    return sorted_array;\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop_back` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkoqm1k5r.rs:22:26\n   |\n22 |          \
    \   sorted_array.pop_back();\n   |                          ^^^^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut counter = array[0];\n\
    \    for i in 1..array.len() {\n        if counter > array[i] {\n            counter\
    \ += array[i];\n            array[i] = counter;\n        }\n    }\n    return\
    \ array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpz5iy__du.rs:16:13\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n16 |             array[i] = counter;\n   |      \
    \       ^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ v in array {\n        sum += v;\n    }\n\n    if sum % 2 == 1 {\n        //\
    \ odd sum\n        array.iter().sort_by_key(|v| *v).collect()\n    } else {\n\
    \        // even sum\n        array.iter().rev().sort_by_key(|v| *v).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp2mckv84m.rs:19:22\n   |\n19 |         array.iter().sort_by_key(|v|\
    \ *v).collect()\n   |                      ^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: no method named `sort_by_key` found for struct `Rev`\
    \ in the current scope\n  --> /tmp/tmp2mckv84m.rs:22:28\n   |\n22 |         array.iter().rev().sort_by_key(|v|\
    \ *v).collect()\n   |                            ^^^^^^^^^^^ method not found\
    \ in `Rev<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.is_sorted());\n\
    \    if array.len() % 2 == 1 {\n        sort_array_reverse(array)\n    } else\
    \ {\n        sort_array(sort_array_reverse(array))\n    }\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_reverse` in this scope\n\
    \  --> /tmp/tmpmev6h93m.rs:14:9\n   |\n14 |         sort_array_reverse(array)\n\
    \   |         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_array_reverse` in this scope\n  --> /tmp/tmpmev6h93m.rs:16:20\n\
    \   |\n16 |         sort_array(sort_array_reverse(array))\n   |              \
    \      ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0658]: use of unstable\
    \ library feature 'is_sorted': new API\n  --> /tmp/tmpmev6h93m.rs:12:19\n   |\n\
    12 |     assert!(array.is_sorted());\n   |                   ^^^^^^^^^\n   |\n\
    \   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.clone();\n\
    \    array.sort();\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp2ihqf6yr.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n\n    let mut left = array[0];\n    let mut right\
    \ = array[0];\n\n    for &value in &array[1..] {\n        if *value < *left {\n\
    \            left = *value;\n        }\n\n        if *value > *right {\n     \
    \       right = *value;\n        }\n    }\n\n    if left + 1 == right {\n    \
    \    return array;\n    }\n\n    let mut middle = (left + right) / 2;\n    let\
    \ mut result = vec![left];\n\n    for i in 1..middle+1 {\n        let mut j =\
    \ 0;\n\n        while j < result.len() {\n            if array[j] > middle {\n\
    \                result[j+1] = array[j];\n                break;\n           \
    \ }\n\n            j +=1;\n        }\n\n        result[j+1] = middle;\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:20:12\n\
    \   |\n20 |         if *value < *left {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:20:21\n   |\n\
    20 |         if *value < *left {\n   |                     ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:21:20\n   |\n\
    21 |             left = *value;\n   |                    ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:24:12\n   |\n\
    24 |         if *value > *right {\n   |            ^^^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:24:21\n   |\n24 |\
    \         if *value > *right {\n   |                     ^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpq8ddgjrj.rs:25:21\n   |\n\
    25 |             right = *value;\n   |                     ^^^^^^\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array2 = array;\n\
    \    let mut index1 = 0;\n    let mut index2 = 0;\n\n    while index1 < array2.len()\
    \ && index2 < array2.len() {\n        let sum = array2[index1] + array2[index2];\n\
    \        if sum % 2 == 1 {\n            array2[index2] = array2[index1];\n   \
    \         array2[index1] = 0;\n            index2 += 1;\n        } else {\n  \
    \          array2[index2] = array2[index2];\n            array2[index1] = array2[index1];\n\
    \            index1 += 1;\n        }\n    }\n    if index1 < array2.len() {\n\
    \        array2.reverse();\n    }\n    if index2 < array2.len() {\n        array2.reverse();\n\
    \    }\n    array2\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 5, 1, 3]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpq58pltmz.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.len() > 0);\n\
    \    let mut array: Vec<isize> = array;\n    let mut min_value: isize = 0;\n \
    \   let mut max_value: isize = 0;\n    for index in array.iter_mut() {\n     \
    \   if *index >= max_value {\n            max_value = *index;\n        }\n   \
    \     if *index <= min_value {\n            min_value = *index;\n        }\n \
    \   }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    while array.len() > 1 {\n        let mut i = 0;\n        let mut j = 0;\n\
    \        let mut found = false;\n        while i < array.len() && j < array.len()\
    \ {\n            if min_value + array[j] >= max_value {\n                i +=\
    \ 1;\n                found = true;\n            } else {\n                j +=\
    \ 1;\n            }\n        }\n        if found {\n            if min_value >=\
    \ max_value {\n                array[j..] = &mut array[j..];\n               \
    \ array[j..].sort();\n            } else {\n                array[i..] = &mut\
    \ array[i..];\n                array[i..].sort();\n            }\n        } else\
    \ {\n            array[j..] = &mut array[j..];\n        }\n        min_value =\
    \ array[0];\n        max_value = array[j];\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv5j23tbm.rs:40:30\n   |\n\
    40 |                 array[j..] = &mut array[j..];\n   |                 ----------\
    \   ^^^^^^^^^^^^^^^ expected slice `[isize]`, found `&mut [isize]`\n   |     \
    \            |\n   |                 expected due to the type of this binding\n\
    \   |\nhelp: consider removing the borrow\n   |\n40 -                 array[j..]\
    \ = &mut array[j..];\n40 +                 array[j..] = array[j..];\n   | \n\n\
    error[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpv5j23tbm.rs:40:17\n   |\n40 |                 array[j..]\
    \ = &mut array[j..];\n   |                 ^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n\
    \   = note: the left-hand-side of an assignment must have a statically known size\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv5j23tbm.rs:43:30\n   |\n43 |\
    \                 array[i..] = &mut array[i..];\n   |                 ----------\
    \   ^^^^^^^^^^^^^^^ expected slice `[isize]`, found `&mut [isize]`\n   |     \
    \            |\n   |                 expected due to the type of this binding\n\
    \   |\nhelp: consider removing the borrow\n   |\n43 -                 array[i..]\
    \ = &mut array[i..];\n43 +                 array[i..] = array[i..];\n   | \n\n\
    error[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpv5j23tbm.rs:43:17\n   |\n43 |                 array[i..]\
    \ = &mut array[i..];\n   |                 ^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n\
    \   = note: the left-hand-side of an assignment must have a statically known size\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv5j23tbm.rs:47:26\n   |\n47 |\
    \             array[j..] = &mut array[j..];\n   |             ----------   ^^^^^^^^^^^^^^^\
    \ expected slice `[isize]`, found `&mut [isize]`\n   |             |\n   |   \
    \          expected due to the type of this binding\n   |\nhelp: consider removing\
    \ the borrow\n   |\n47 -             arr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    // Compute the sum of the two values in the\
    \ array\n    let mut sum: isize = 0;\n    for i in 0..array.len() {\n        sum\
    \ += array[i];\n    }\n    // If the sum of the two values in the array is odd,\
    \ we reverse the array\n    if sum % 2 == 1 {\n        array.reverse();\n    }\n\
    \    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpurs3jf9z.rs:22:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n22 |         array.reverse();\n   |         ^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    if array.len() <= 2 {\n        new_array\n    } else {\n        let mut sum\
    \ = 0;\n        let mut index = 0;\n        for &x in new_array {\n          \
    \  sum += x;\n            if sum % 2 == 1 {\n                index += 1;\n   \
    \         }\n        }\n        let mut tmp = new_array[index - 1];\n        for\
    \ &x in new_array {\n            new_array[index - 1] = x;\n            if index\
    \ > 0 {\n                new_array[index] = tmp;\n                index -= 1;\n\
    \                sum += new_array[index];\n                if sum % 2 == 1 {\n\
    \                    new_array[index] = tmp;\n                    index -= 1;\n\
    \                }\n            } else {\n                break;\n           \
    \ }\n        }\n    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgkd1n35v.rs:14:9\n   |\n\
    13 | /     if array.len() <= 2 {\n14 | |         new_array\n   | |         ^^^^^^^^^\
    \ expected `()`, found struct `Vec`\n15 | |     } else {\n16 | |         let mut\
    \ sum = 0;\n...  |\n38 | |         }\n39 | |     }\n   | |_____- expected this\
    \ to be `()`\n   |\n   = note: expected unit type `()`\n                 found\
    \ struct `Vec<isize>`\nhelp: you might have meant to return this value\n   |\n\
    14 |         return new_array;\n   |         ++++++          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgkd1n35v.rs:18:13\n   |\n18 |         for &x\
    \ in new_array {\n   |             ^^    --------- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgkd1n35v.rs:25:13\n   |\n25 |         for &x\
    \ in new_array {\n   |             ^^    --------- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|&x| x);\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpg4mr6uxc.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort_by_key(|&x| x);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut a = array.to_owned();\n    a.sort_unstable();\n\
    \    a\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp57stjw2e.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.clone();\n\
    \    array.sort_unstable_by_key(|&i| i);\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpx2_6cvy_.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.iter().cloned().sorted().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp4hloj8yv.rs:12:27\n   |\n12 |     array.iter().cloned().sorted().collect()\n\
    \   |                           ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array: Vec<isize>\
    \ = array.clone();\n    let mut sum: isize = 0;\n    for element in new_array.iter()\
    \ {\n        sum += element;\n    }\n    if sum % 2 == 1 {\n        new_array.sort();\n\
    \    }\n    else {\n        new_array.reverse();\n    }\n    new_array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpzsew_hb7.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n\n    let mut array = array.to_vec();\n    let mut\
    \ sum = 0;\n    let mut first_value = array[0];\n    let mut last_value = array[0];\n\
    \n    for &value in array.iter() {\n        sum += value;\n        last_value\
    \ = value;\n    }\n\n    if sum % 2 == 1 {\n        array.sort();\n    } else\
    \ {\n        array.sort();\n        array.reverse();\n    }\n\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp8jaxgiy6.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    debug_assert_eq!(array.is_empty(),\
    \ true);\n    if array.len() == 0 {\n        return array;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut first = array.iter().next();\n    for element in array\
    \ {\n        sum += element;\n        if sum % 2 == 0 {\n            first = element;\n\
    \        }\n    }\n\n    let mut last = array\n        .iter()\n        .rev()\n\
    \        .fold(0, |x, y| x + y);\n    let mut result = Vec::new();\n    result.push(first);\n\
    \    result.push(last);\n    for i in 2..array.len() {\n        let mut new_first\
    \ = 0;\n        let mut new_last = 0;\n        for j in 1..i {\n            let\
    \ element = array[j - 1];\n            let next_element = array[j];\n        \
    \    let new_sum = sum + element + next_element;\n            if new_sum % 2 ==\
    \ 0 {\n                new_first += element;\n                new_last += next_element;\n\
    \            } else {\n                new_first += next_element;\n          \
    \      new_last += element;\n            }\n        }\n\n        result.push(new_first);\n\
    \        result.push(new_last);\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpss01hg8j.rs:22:21\n   |\n\
    18 |     let mut first = array.iter().next();\n   |                     -------------------\
    \ expected due to this value\n...\n22 |             first = element;\n   |   \
    \                  ^^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note:\
    \ expected enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpss01hg8j.rs:32:17\n   |\n32 |     result.push(last);\n\
    \   |                 ^^^^ expected enum `Option`, found `isize`\n   |\n   = note:\
    \ expected enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpss01hg8j.rs:49:21\n   |\n49 |         result.push(new_first);\n\
    \   |                     ^^^^^^^^^ expected enum `Option`, found `isize`\n  \
    \ |\n   = note: expected enum `Option<&isize>`\n              found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpss01hg8j.rs:50:21\n   |\n50 |\
    \         result.push(new_last);\n   |                     ^^^^^^^^ expected enum\
    \ `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n \
    \             found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpss01hg8j.rs:53:5\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n53 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<&isize>>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut a = array.to_vec();\n    let mut\
    \ sorted_array = array.to_vec();\n\n    let mut sum = 0;\n    for x in a.iter()\
    \ {\n        sum += x;\n    }\n\n    if sum % 2 != 0 {\n        sorted_array.is_sort_descending(|&a|\
    \ a < 0);\n    } else {\n        sorted_array.is_sort_ascending(|&a| a < 0);\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_sort_descending` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmparraud2v.rs:25:22\n   |\n25 |         sorted_array.is_sort_descending(|&a|\
    \ a < 0);\n   |                      ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_sorted`\n\nerror[E0599]: no method named `is_sort_ascending`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmparraud2v.rs:27:22\n\
    \   |\n27 |         sorted_array.is_sort_ascending(|&a| a < 0);\n   |        \
    \              ^^^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_sorted`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        array\n    } else {\n        let mut res = array.clone();\n        res.sort();\n\
    \        if res.sum::<isize>() % 2 != 0 {\n            res\n        } else {\n\
    \            res\n                .iter()\n                .cloned()\n       \
    \         .cloned()\n                .sort_by_key(|x| -x)\n                .collect()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmplsbky5mg.rs:17:16\n\
    \    |\n17  |           if res.sum::<isize>() % 2 != 0 {\n    |              \
    \    ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror[E0271]: type\
    \ mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item == &&_`\n\
    \    --> /tmp/tmplsbky5mg.rs:23:18\n     |\n23   |                 .cloned()\n\
    \     |                  ^^^^^^ expected reference, found `isize`\n     |\n  \
    \   = note: expected reference `&&_`\n                found reference `&isize`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmplsbky5mg.rs:24:18\n   |\n24 |                 .sort_by_key(|x|\
    \ -x)\n   |                  ^^^^^^^^^^^ method not found in `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array\n    }\n    let mut sum: isize = 0;\n    for n in array\
    \ {\n        sum += n;\n    }\n    array.sort();\n    if sum % 2 == 1 {\n    \
    \    array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpfxkta2j4.rs:19:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n19 |     array.sort();\n   |     ^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpfxkta2j4.rs:19:5\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n16  |     for n in array {\n    |         \
    \     ----- `array` moved due to this implicit call to `.into_iter()`\n...\n19\
    \  |     array.sort();\n    |     ^^^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n16  |     for n in &array {\n  \
    \  |              +\n\nerror[E0596]: cannot borrow `array` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmpfxkta2j4.rs:21:9\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n21 |         array.reverse();\n   |  \
    \       ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    let mut sum = 0;\n\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n\n    // 1. Sort if sum is odd\n    if sum % 2 == 1 {\n        for i in\
    \ 0..array.len() {\n            if array[i] > array[i - 1] {\n               \
    \ array[i] = array[i - 1];\n            }\n        }\n    }\n\n    // 2. Sort\
    \ if sum is even\n    else {\n        for i in 0..array.len() {\n            if\
    \ array[i] < array[i - 1] {\n                array[i] = array[i - 1];\n      \
    \      }\n        }\n    }\n\n    return array;\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_2f_k_bw.rs:22:33\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_cloned = array.clone();\n\
    \    array_cloned.sort_unstable_by_key(|&i| i);\n    return array_cloned;\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpf0qaide5.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum % 2 != 0\
    \ {\n        for i in 0..array.len() {\n            let mut s = array[i];\n  \
    \          array[i] = array[array.len() - 1 - i];\n            array[array.len()\
    \ - 1 - i] = s;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_96a53f1.rs:18:17\n\
    \   |\n18 |             let mut s = array[i];\n   |                 ----^\n  \
    \ |                 |\n   |                 help: remove this `mut`\n   |\n  \
    \ = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp_96a53f1.rs:19:13\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n19 |\
    \             array[i] = array[array.len() - 1 - i];\n   |             ^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `array` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmp_96a53f1.rs:20:13\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n20 |             array[array.len() - 1\
    \ - i] = s;\n   |             ^^^^^ cannot borrow as mutable\n\nerror[E0502]:\
    \ cannot borrow `array` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmp_96a53f1.rs:20:19\n   |\n20 |             array[array.len() - 1\
    \ - i] = s;\n   |             ------^^^^^^^^^^^---------\n   |             | \
    \    |\n   |             |     immutable borrow occurs here\n   |            \
    \ mutable borrow occurs here\n   |             mutable borrow later used here\n\
    \   |\nhelp: try adding a local storing this...\n  --> /tmp/tmp_96a53f1.rs:20:19\n\
    \   |\n20 |             array[array.len() - 1 - i] = s;\n   |                \
    \   ^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> /tmp/tmp_96a53f1.rs:20:13\n\
    \   |\n20 |             array[array.len() - 1 - i] = s;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0502, E0596.\nFor more information about an error, try\
    \ `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Your code here\n    let\
    \ mut counter: usize = 0;\n    let mut sum: usize = 0;\n    for val in array {\n\
    \        sum = sum + val;\n        if sum % 2 == 0 {\n            counter = counter\
    \ + 1;\n        } else {\n            counter = counter - 1;\n        }\n    }\n\
    \    let mut result = vec![0; counter];\n    for val in array {\n        sum =\
    \ sum + val;\n        if sum % 2 == 0 {\n            for i in 0..counter {\n \
    \               if array[i] == val {\n                    result[i] = val;\n \
    \                   break;\n                }\n            }\n        } else {\n\
    \            for i in 0..counter {\n                if array[i] == val {\n   \
    \                 result[i] = val;\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1nw0oon1.rs:16:21\n   |\n\
    16 |         sum = sum + val;\n   |                     ^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp1nw0oon1.rs:16:19\n\
    \   |\n16 |         sum = sum + val;\n   |                   ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nw0oon1.rs:25:21\n\
    \   |\n25 |         sum = sum + val;\n   |                     ^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp1nw0oon1.rs:25:19\n\
    \   |\n25 |         sum = sum + val;\n   |                   ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array\n    }\n\n    let mut array = array.clone();\n    let mut\
    \ sum_of_first_and_last_element = array\n        .iter()\n        .fold(0, |sum,\
    \ elt| sum + elt)\n        .wrapping_add(array\n            .iter_mut()\n    \
    \        .rev()\n            .fold(0, |sum, elt| sum + elt))\n        .unwrap();\n\
    \n    if sum_of_first_and_last_element % 2 != 0 {\n        array.sort_by(|a, b|\
    \ {\n            if a < b {\n                true\n            } else {\n    \
    \            false\n            }\n        });\n    } else {\n        array.sort_by(|a,\
    \ b| {\n            if a > b {\n                true\n            } else {\n \
    \               false\n            }\n        });\n    }\n\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `&mut isize` to `isize`\n  --> /tmp/tmpbhdeh8xk.rs:23:37\n\
    \   |\n23 |             .fold(0, |sum, elt| sum + elt))\n   |                \
    \                     ^ no implementation for `isize + &mut isize`\n   |\n   =\
    \ help: the trait `Add<&mut isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpbhdeh8xk.rs:24:10\n\
    \   |\n24 |         .unwrap();\n   |          ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbhdeh8xk.rs:29:17\n   |\n29 |\
    \                 true\n   |                 ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhdeh8xk.rs:31:17\n\
    \   |\n31 |                 false\n   |                 ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhdeh8xk.rs:37:17\n\
    \   |\n37 |                 true\n   |                 ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhdeh8xk.rs:39:17\n\
    \   |\n39 |                 false\n   |                 ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    let mut result = Vec::new();\n    while\
    \ i < array.len() {\n        if j < array.len() {\n            if array[j] > array[j\
    \ + 1] {\n                let tmp = array[j];\n                array[j] = array[j\
    \ + 1];\n                array[j + 1] = tmp;\n            }\n        }\n     \
    \   while j < array.len() {\n            if array[j] > array[j + 1] {\n      \
    \          result.push(array[j]);\n                j += 1;\n            }\n  \
    \          else {\n                j += 1;\n            }\n        }\n       \
    \ while k < result.len() {\n            if result[k] > array[k + 1] {\n      \
    \          let tmp = result[k];\n                result[k] = array[k + 1];\n \
    \               array[k + 1] = tmp;\n            }\n            k += 1;\n    \
    \    }\n        while k < result.len() {\n            if result[k] > array[k +\
    \ 1] {\n                result.push(result[k]);\n                k += 1;\n   \
    \         }\n            else {\n                k += 1;\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvnichh3u.rs:12:9\n\
    \   |\n12 |     let mut i = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpvnichh3u.rs:20:17\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n20 |                 array[j] = array[j + 1];\n \
    \  |                 ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpvnichh3u.rs:21:17\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n21 |\
    \                 array[j + 1] = tmp;\n   |                 ^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpvnichh3u.rs:37:17\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n37 |                 array[k + 1] = tmp;\n\
    \   |                 ^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ 3 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort();\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpvafld5as.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort();\n   |     ^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum_of_array = array.iter().sum();\n\
    \    if sum_of_array % 2 == 0 {\n        array.sort_by(|a, b| a.cmp(b));\n   \
    \ } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdxt_8ff9.rs:12:9\n\
    \   |\n12 |     let mut sum_of_array = array.iter().sum();\n   |         ^^^^^^^^^^^^^^^^\
    \ consider giving `sum_of_array` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.to_vec();\n\
    \    sorted_array.sort_unstable();\n    sorted_array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpupuh_x5h.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    sort_array(&array[0..array.len()])\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphc60jyei.rs:12:16\n   |\n\
    12 |     sort_array(&array[0..array.len()])\n   |                ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&[isize]`\nhelp: try using a conversion method\n\
    \   |\n12 |     sort_array((&array[0..array.len()]).to_vec())\n   |          \
    \      +                      ++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_copy = array.clone();\n\
    \    array_copy.sort();\n    array_copy\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpy4iuaw_s.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array: [isize; 6]\
    \ = [0; 6];\n    let mut num: isize = 0;\n    let mut sum: isize = 0;\n    for\
    \ &i in array {\n        sum += i;\n        array[n] = sum;\n        n += 1;\n\
    \    }\n    if sum % 2 != 0 {\n        array.reverse();\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `n` in this scope\n  --> /tmp/tmpdgllloog.rs:17:15\n\
    \   |\n17 |         array[n] = sum;\n   |               ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror[E0425]: cannot find value `n` in this\
    \ scope\n  --> /tmp/tmpdgllloog.rs:18:9\n   |\n18 |         n += 1;\n   |    \
    \     ^ help: a local variable with a similar name exists: `i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdgllloog.rs:15:9\n   |\n15 |     for &i in array\
    \ {\n   |         ^^    ----- this expression has type `Option<isize>`\n   | \
    \        |\n   |         expected `isize`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdgllloog.rs:23:5\n   |\n11 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                     ---------- expected `Vec<isize>`\
    \ because of return type\n...\n23 |     array\n   |     ^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |     |\n   |     expected struct `Vec`,\
    \ found array `[isize; 6]`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \             found array `[isize; 6]`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n\
    \    if array.len() <= 2 {\n        result.push(array.len());\n        return\
    \ result;\n    }\n    let mut sum = 0;\n    for i in 0..array.len() {\n      \
    \  sum += array[i];\n        result.push(i);\n        if sum % 2 == 1 {\n    \
    \        result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpskeamo2x.rs:14:21\n   |\n\
    14 |         result.push(array.len());\n   |                     ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         result.push(array.len().try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpskeamo2x.rs:20:21\n   |\n20 |         result.push(i);\n\
    \   |                     ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |         result.push(i.try_into().unwrap());\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpskeamo2x.rs:22:25\n\
    \   |\n22 |             result.push(i);\n   |                         ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |             result.push(i.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut last_sum = array[0];\n    let mut first_sum = array[0];\n    for\
    \ x in array {\n        let current_sum = x + first_sum;\n        if current_sum\
    \ > last_sum {\n            result.push(first_sum);\n            last_sum = current_sum;\n\
    \            first_sum = x;\n        } else if current_sum < last_sum {\n    \
    \        result.push(x - first_sum);\n            last_sum = current_sum;\n  \
    \          first_sum = x;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpa1be3gav.rs:13:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.to_vec();\n\
    \    new_array.sort();\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpfunn4tk2.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ num in array {\n        sum += num;\n    }\n\n    let mut buffer = Vec::new();\n\
    \    buffer.push(0);\n    buffer.push(array[0]);\n\n    let mut index = 1;\n \
    \   for num in array {\n        buffer.push(num);\n        sum += num;\n\n   \
    \     if sum % 2 == 0 {\n            buffer.swap(0, index);\n        }\n\n   \
    \     index += 1;\n    }\n\n    buffer\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpmpqvt8pb.rs:19:17\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n12  |     let mut sum = 0;\n13  |     for num in\
    \ array {\n    |                ----- `array` moved due to this implicit call\
    \ to `.into_iter()`\n...\n19  |     buffer.push(array[0]);\n    |            \
    \     ^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `array`\nhelp: consider iterating over a\
    \ slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n  \
    \  |\n13  |     for num in &array {\n    |                +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array;\n \
    \   let mut i = 0;\n    while i < res.len() - 1 {\n        let mut min = i;\n\
    \        for i in i + 1 .. res.len() {\n            if res[i] + res[min] > res[min]\
    \ + res[i] {\n                min = i;\n            }\n        }\n        let\
    \ temp = res[i];\n        let temp = res[min];\n        res[i] = temp;\n     \
    \   res[min] = temp;\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5_aycw2z.rs:14:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    debug_assert!(array.is_sorted());\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmppqrfwnfn.rs:12:25\n   |\n12 |     debug_assert!(array.is_sorted());\n\
    \   |                         ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array\n        .into_iter()\n\
    \        .map(|x| if x.is_even() {\n            x + 1\n        } else {\n    \
    \        x - 1\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp23qfd3h9.rs:14:23\n   |\n14 |         .map(|x| if x.is_even()\
    \ {\n   |                       ^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ &n in array {\n        sum += n;\n    }\n    if sum % 2 == 1 {\n        array.sort();\n\
    \    } else {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnj5tq4_2.rs:13:9\n   |\n\
    13 |     for &n in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(array.len(),\
    \ 6);\n    if array.is_empty() {\n        return array;\n    }\n\n    let mut\
    \ sum = 0;\n    let mut max_val = array[0];\n    let mut min_val = array[0];\n\
    \n    for i in 1..array.len() {\n        sum += array[i];\n        if sum % 2\
    \ == 1 {\n            max_val = array[i];\n        } else {\n            min_val\
    \ = array[i];\n        }\n    }\n\n    // O(n^2)\n    for i in array.rev() {\n\
    \        if i > max_val {\n            array[i] = min_val;\n        } else {\n\
    \            array[i] = max_val;\n        }\n    }\n\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp3jnz2jmm.rs:31:20\n\
    \    |\n31  |       for i in array.rev() {\n    |                      ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut temp_array = array;\n\
    \    let mut min_value: isize = 0;\n    let mut max_value: isize = 0;\n    let\
    \ mut min_sum: isize = 0;\n    for num in temp_array.iter() {\n        min_value\
    \ = num;\n        max_value = num;\n        min_sum = num;\n        for num in\
    \ temp_array.iter().rev() {\n            min_sum += num;\n            if min_sum\
    \ < min_value {\n                min_value = num;\n            }\n           \
    \ if min_sum > max_value {\n                max_value = num;\n            }\n\
    \        }\n        let temp: Vec<isize> = vec![min_value, max_value];\n     \
    \   temp_array = temp_array.remove(0);\n        temp_array.extend(temp);\n   \
    \ }\n    temp_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo7t6y42b.rs:17:21\n   |\n\
    13 |     let mut min_value: isize = 0;\n   |                        ----- expected\
    \ due to this type\n...\n17 |         min_value = num;\n   |                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |         min_value = *num;\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo7t6y42b.rs:18:21\n   |\n14 |\
    \     let mut max_value: isize = 0;\n   |                        ----- expected\
    \ due to this type\n...\n18 |         max_value = num;\n   |                 \
    \    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |         max_value = *num;\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo7t6y42b.rs:19:19\n   |\n15 |\
    \     let mut min_sum: isize = 0;\n   |                      ----- expected due\
    \ to this type\n...\n19 |         min_sum = num;\n   |                   ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         min_sum = *num;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo7t6y42b.rs:23:29\n   |\n13 |     let mut min_value: isize\
    \ = 0;\n   |                        ----- expected due to this type\n...\n23 |\
    \                 min_value = num;\n   |                             ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |                 min_value = *num;\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpo7t6y42b.rs:26:29\n   |\n14 |  \
    \   let mut max_value: isize = 0;\n   |                        ----- expected\
    \ due to this type\n...\n26 |                 max_value = num;\n   |         \
    \                    ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n26 |                 max_value = *num;\n   |\
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo7t6y42b.rs:30:22\n\
    \   |\n12 |     let mut temp_array = array;\n   |                          -"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut i = 1;\n    let mut j = 1;\n    let mut result: Vec<isize> = array.to_vec();\n\
    \    while i <= array.len() {\n        while j <= array.len() && sum < array[j]\
    \ {\n            sum += array[j];\n            j +=1;\n        }\n        result[i\
    \ - 1] = j;\n        if sum % 2 != 0 {\n            result.swap(i - 1, i);\n \
    \       } else {\n            result.swap(i - 1, i);\n            i = j;\n   \
    \     }\n        sum = 0;\n        i += 1;\n        j = 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptp4l9047.rs:21:25\n   |\n\
    21 |         result[i - 1] = j;\n   |         -------------   ^ expected `isize`,\
    \ found `usize`\n   |         |\n   |         expected due to the type of this\
    \ binding\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_ = array.to_vec();\n\
    \    sort_array_helper(array_, 0, array.len(), 0, 0);\n    array_\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_helper` in this scope\n\
    \  --> /tmp/tmpmthxvaz1.rs:13:5\n   |\n13 |     sort_array_helper(array_, 0, array.len(),\
    \ 0, 0);\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut len = array.len();\n\
    \    let mut min = array[0];\n    let mut max = array[0];\n    for i in 1..array.len()\
    \ {\n        let current = array[i];\n        if current < min {\n           \
    \ min = current;\n        }\n        if current > max {\n            max = current;\n\
    \        }\n    }\n    if min <= max {\n        array.sort();\n    } else {\n\
    \        array.sort();\n        array.sort_by_key(|x| -x.into());\n    }\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp1ta_c3k_.rs:28:34\n\
    \   |\n28 |         array.sort_by_key(|x| -x.into());\n   |                  \
    \              --^^^^--\n   |                                | |\n   |       \
    \                         | cannot infer type for type parameter `T` declared\
    \ on the trait `Into`\n   |                                this method call resolves\
    \ to `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for value in array.iter() {\n        match value {\n            0 | 1 | 2\
    \ => result.push(value),\n            _ => unreachable!(),\n        }\n    }\n\
    \    result.sort_by_key(|x| x.into());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoozbl70i.rs:20:5\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n20 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.len() >= 2,\
    \ \"the array length must be bigger than 2\");\n    let mut sum = 0;\n    for\
    \ value in &array[2..] {\n        sum += *value;\n    }\n    if sum % 2 == 1 {\n\
    \        array.sort_by(|x, y| x.partial_cmp(y).unwrap());\n    } else {\n    \
    \    array.sort_by(|x, y| y.partial_cmp(x).unwrap());\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpa8ldwy1z.rs:18:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n18 |         array.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as\
    \ mutable\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpa8ldwy1z.rs:20:9\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n20 |         array.sort_by(|x, y| y.partial_cmp(x).unwrap());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as\
    \ mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array\n    }\n    let mut array = array.clone();\n    let mut\
    \ index = 0;\n    let mut last_index = 0;\n    while index != array.len() - 1\
    \ {\n        let sum = array[index] + array[index + 1];\n        if sum % 2 ==\
    \ 1 {\n            array.swap(index, index + 1);\n            array.swap(index\
    \ + 1, index + 2);\n        }\n        index += 2;\n        last_index += 2;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 6 but the index\
    \ is 6', /tmp/tmpx8f_kzas.rs:19:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array;\n    }\n\n    let mut sorted_array = array;\n    if array.len()\
    \ % 2 == 1 {\n        sorted_array.sort();\n    } else {\n        sorted_array.sort();\n\
    \        sorted_array.reverse();\n    }\n    sorted_array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `array`\n  --> /tmp/tmp59wf7oni.rs:17:8\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16 |     let mut sorted_array = array;\n   |        \
    \                    ----- value moved here\n17 |     if array.len() % 2 == 1\
    \ {\n   |        ^^^^^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n\
    \    let mut evensum = 0;\n    let mut oddsum = 0;\n    let mut newarray: Vec<isize>\
    \ = vec![];\n    for number in array {\n        if number % 2 == 0 {\n       \
    \     evensum += number;\n        } else {\n            oddsum += number;\n  \
    \      }\n    }\n    if evensum > oddsum {\n        newarray = array;\n    } else\
    \ {\n        newarray = array;\n        for number in array {\n            if\
    \ number % 2 == 0 {\n                newarray.push(number + 1);\n            }\n\
    \        }\n    }\n    return newarray;\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `newarray` is never read\n  --> /tmp/tmplrw5aog5.rs:15:13\n\
    \   |\n15 |     let mut newarray: Vec<isize> = vec![];\n   |             ^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nerror[E0382]: use of moved value: `array`\n\
    \   --> /tmp/tmplrw5aog5.rs:24:20\n    |\n11  | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    |               ----- move occurs because `array` has type\
    \ `Vec<isize>`, which does not implement the `Copy` trait\n...\n16  |     for\
    \ number in array {\n    |                   ----- `array` moved due to this implicit\
    \ call to `.into_iter()`\n...\n24  |         newarray = array;\n    |        \
    \            ^^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `array`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n16  |     for number in &array {\n    |                   +\n\nerror[E0382]:\
    \ use of moved value: `array`\n  --> /tmp/tmplrw5aog5.rs:27:23\n   |\n11 | fn\
    \ sort_array(array: Vec<isize>) -> Vec<isize> {\n   |               ----- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n26 |         newarray = array;\n   |                    ----- value\
    \ moved here\n27 |         for number in array {\n   |                       ^^^^^\
    \ value used here after move\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_copy = array.to_vec();\n\
    \    array_copy.sort_by(|a, b| a <=> b);\n    array_copy\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: invalid comparison operator `<=>`\n  --> /tmp/tmpilpijs04.rs:13:33\n\
    \   |\n13 |     array_copy.sort_by(|a, b| a <=> b);\n   |                    \
    \             ^^^ `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpilpijs04.rs:13:31\n   |\n13 |\
    \     array_copy.sort_by(|a, b| a <=> b);\n   |                              \
    \ ^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut array = array;\n    array.sort();\n\
    \    if array[0] + array[array.len() - 1] % 2 == 0 {\n        array.iter().rev().cloned().collect()\n\
    \    } else {\n        array.iter().cloned().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 14, 21, 23]`,\n right: `[23, 21, 14, 11]`', /tmp/tmpw48xd6cn.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_with_sum =\
    \ 0;\n    let mut array_with_odd_sum = 0;\n    let mut array_with_reverse_odd_sum\
    \ = 0;\n\n    for i in 0..array.len() {\n        array_with_sum += array[i];\n\
    \        if array_with_sum & 1 != 0 {\n            array_with_odd_sum += array[i];\n\
    \        } else {\n            array_with_reverse_odd_sum += array[i];\n     \
    \   }\n    }\n\n    if array_with_odd_sum > array_with_reverse_odd_sum {\n   \
    \     for i in 0..array.len() {\n            array[i] = array_with_odd_sum - array[i];\n\
    \        }\n    } else {\n        for i in 0..array.len() {\n            array[i]\
    \ = array_with_reverse_odd_sum - array[i];\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpax9jufcg.rs:27:13\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n27 |             array[i] = array_with_odd_sum -\
    \ array[i];\n   |             ^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpax9jufcg.rs:31:13\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \             array[i] = array_with_reverse_odd_sum - array[i];\n   |        \
    \     ^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut s = array[0];\n\
    \    for i in 1..array.len() {\n        s += array[i];\n        if !s.is_odd()\
    \ {\n            s.swap(0, i);\n        }\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7da9catp.rs:15:15\n   |\n15 |         if !s.is_odd() {\n\
    \   |               ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `swap` found for type `isize` in the current scope\n  --> /tmp/tmp7da9catp.rs:16:15\n\
    \   |\n16 |             s.swap(0, i);\n   |               ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // 1. get the sum of all\
    \ elements\n    let mut s: isize = 0;\n    for i in 0..array.len() {\n       \
    \ s += array[i];\n    }\n    // 2. sort if odd\n    if s % 2 != 0 {\n        array.sort();\n\
    \    }\n    // 3. sort if even\n    else if s == 0 {\n        array.sort();\n\
    \        array.iter().reverse();\n    }\n    // 4. sort if even\n    else {\n\
    \        array.sort();\n    }\n    // 5. return a copy of the given array\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp5mf940fb.rs:24:22\n   |\n24 |         array.iter().reverse();\n\
    \   |                      ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut sum_of_array = array.iter().sum::<isize>();\n\n    while sum_of_array\
    \ % 2 == 1 {\n        for element in array.iter() {\n            result.push(*element);\n\
    \            sum_of_array -= *element;\n        }\n    }\n\n    while sum_of_array\
    \ % 2 == 0 {\n        for element in array.iter().rev() {\n            result.push(*element);\n\
    \            sum_of_array -= *element;\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array\n    }\n\n    let mut sum = array[0] + array[1];\n    let\
    \ mut i = 0;\n    let mut j = 0;\n\n    while i < array.len() {\n        while\
    \ j < array.len() && array[j] >= array[i] {\n            sum += array[j];\n  \
    \          j += 1;\n        }\n\n        swap(&mut array[i .. j], &mut array[j\
    \ .. i]);\n        i += 1;\n        j += 1;\n    }\n\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpqs8rgg5l.rs:26:9\n\
    \   |\n26 |         swap(&mut array[i .. j], &mut array[j .. i]);\n   |      \
    \   ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut sum = array[0];\n    for &x in array.iter().skip(1)\
    \ {\n        sum = sum.wrapping_add(x);\n    }\n    if sum.wrapping_sub(0).is_odd()\
    \ {\n        array.iter().rev().chain(array).cloned().collect()\n    } else {\n\
    \        array.iter().cloned().chain(array).rev().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp376l0gv4.rs:19:28\n   |\n19 |     if sum.wrapping_sub(0).is_odd()\
    \ {\n   |                            ^^^^^^ method not found in `isize`\n\nerror[E0271]:\
    \ type mismatch resolving `<Vec<isize> as IntoIterator>::Item == &isize`\n   -->\
    \ /tmp/tmp376l0gv4.rs:20:28\n    |\n20  |         array.iter().rev().chain(array).cloned().collect()\n\
    \    |                            ^^^^^ expected `&isize`, found `isize`\n   \
    \ |\nnote: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]:\
    \ the method `cloned` exists for struct `std::iter::Chain<Rev<std::slice::Iter<'_,\
    \ isize>>, std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp376l0gv4.rs:20:41\n   |\n20 |            array.iter().rev().chain(array).cloned().collect()\n\
    \   |                                            ^^^^^^ method cannot be called\
    \ on `std::iter::Chain<Rev<std::slice::Iter<'_, isize>>, std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &isize`\n           which is required by `std::iter::Chain<Rev<std::slice::Iter<'_,\
    \ isize>>, std::vec::IntoIter<isize>>: Iterator`\n           `std::iter::Chain<Rev<std::slice::Iter<'_,\
    \ isize>>, std::vec::IntoIter<isize>>: Iterator`\n           which is required\
    \ by `&mut std::iter::Chain<Rev<std::slice::Iter<'_, isize>>, std::vec::IntoIter<isize>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|x| if\
    \ x <= array[0] { x } else { array[0] - x });\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq3plq0_z.rs:12:35\n   |\n\
    12 |     array.sort_by_key(|x| if x <= array[0] { x } else { array[0] - x });\n\
    \   |                                   ^^^^^^^^\n   |                       \
    \            |\n   |                                   expected `&isize`, found\
    \ `isize`\n   |                                   help: consider borrowing here:\
    \ `&array[0]`\n\nerror[E0308]: `if` and `else` have incompatible types\n  -->\
    \ /tmp/tmpq3plq0_z.rs:12:57\n   |\n12 |     array.sort_by_key(|x| if x <= array[0]\
    \ { x } else { array[0] - x });\n   |                                        \
    \      -          ^^^^^^^^^^^^ expected `&isize`, found `isize`\n   |        \
    \                                      |\n   |                               \
    \               expected because of this\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut min = array[0];\n\
    \    let mut max = array[0];\n    for i in array.iter().rev() {\n        if min\
    \ > i {\n            min = i;\n        }\n        if max < i {\n            max\
    \ = i;\n        }\n    }\n    if sum((min, max)) % 2 == 0 {\n        array.rev().sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.rev().sort_by(|a, b| a.cmp(b));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n  --> /tmp/tmph165jgr3.rs:22:8\n\
    \   |\n22 |     if sum((min, max)) % 2 == 0 {\n   |        ^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph165jgr3.rs:15:18\n \
    \  |\n15 |         if min > i {\n   |                  ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \ if min > *i {\n   |                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmph165jgr3.rs:16:19\n   |\n12 |     let mut min = array[0];\n   |\
    \                   -------- expected due to this value\n...\n16 |           \
    \  min = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n16 |             min = *i;\n  \
    \ |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph165jgr3.rs:18:18\n\
    \   |\n18 |         if max < i {\n   |                  ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |        \
    \ if max < *i {\n   |                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmph165jgr3.rs:19:19\n   |\n13 |     let mut max = array[0];\n   |\
    \                   -------- expected due to this value\n...\n19 |           \
    \  max = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n19 |             max = *i;\n  \
    \ |                   +\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   -->\
    \ /tmp/tmph165jgr3.rs:23:15\n    |\n23  |           array.rev().sort_by(|a, b|\
    \ b.cmp(a));\n    |                 ^^^ `Vec<isize>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmph165jgr3.rs:25:15\n\
    \    |\n25  |           array.rev().sort_by(|a, b| a.cmp(b));\n    |         \
    \        ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the f"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let\
    \ mut sorted_array = vec![];\n    let mut array_copy = array.clone();\n    let\
    \ mut last_index = array_copy.len();\n\n    loop {\n        if i != array_copy.len()\
    \ {\n            sorted_array.push(array_copy[i]);\n            i += 1;\n    \
    \    }\n\n        let mut sum = 0;\n        let mut first_value = array_copy[i\
    \ - 1];\n\n        if first_value > 0 {\n            sum += first_value;\n   \
    \     }\n        last_index = i;\n\n        loop {\n            if i == array_copy.len()\
    \ {\n                break;\n            }\n\n            let mut next_value =\
    \ array_copy[i];\n            if next_value > 0 {\n                sum += next_value;\n\
    \            } else {\n                break;\n            }\n            i +=\
    \ 1;\n        }\n\n        if sum % 2 == 1 {\n            sorted_array.push(last_index);\n\
    \        } else {\n            sorted_array.push(i);\n        }\n    }\n\n   \
    \ sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpizs3ste_.rs:46:31\n   |\n\
    46 |             sorted_array.push(last_index);\n   |                        \
    \       ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    46 |             sorted_array.push(last_index.try_into().unwrap());\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpizs3ste_.rs:48:31\n   |\n48 |             sorted_array.push(i);\n\
    \   |                               ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n48 |             sorted_array.push(i.try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nwarning: unreachable\
    \ expression\n  --> /tmp/tmpizs3ste_.rs:52:5\n   |\n17 | /     loop {\n18 | |\
    \         if i != array_copy.len() {\n19 | |             sorted_array.push(array_copy[i]);\n\
    20 | |             i += 1;\n...  |\n49 | |         }\n50 | |     }\n   | |_____-\
    \ any code following this expression is unreachable\n51 | \n52 |       sorted_array\n\
    \   |       ^^^^^^^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.is_sorted());\n\
    \n    let mut sum = 0;\n    for x in array {\n        sum += x;\n    }\n\n   \
    \ if sum % 2 == 1 {\n        array.iter().cloned().reverse().collect()\n    }\
    \ else {\n        array.iter().cloned().collect()\n    }\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmpe4llc_r8.rs:12:19\n   |\n12 |     assert!(array.is_sorted());\n   |\
    \                   ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `Cloned` in the current scope\n  --> /tmp/tmpe4llc_r8.rs:20:31\n   |\n20 | \
    \        array.iter().cloned().reverse().collect()\n   |                     \
    \          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0658.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum%2 == 1 {\n\
    \        array.sort_by(|a, b| a.cmp(b));\n    } else {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp6b5h97jq.rs:17:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n17 |         array.sort_by(|a, b| a.cmp(b));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp6b5h97jq.rs:19:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n19 |\
    \         array.sort_by(|a, b| b.cmp(a));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![0;\
    \ array.len()];\n\n    array.iter().for_each(|element| {\n        if element <\
    \ 0 {\n            sorted.push(element);\n        } else {\n            let first_element_index\
    \ = sorted.iter().position(|x| x == element);\n            let last_element_index\
    \ = sorted.iter().rposition(|x| x == element);\n\n            if first_element_index\
    \ == last_element_index {\n                sorted.push(element);\n           \
    \ } else {\n                if ((*first_element_index as usize) %2 != 0) {\n \
    \                   sorted.insert(first_element_index, element);\n           \
    \     } else {\n                    sorted.insert(last_element_index, element);\n\
    \                }\n            }\n        }\n    });\n\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnqw4yl5u.rs:24:20\n\
    \   |\n24 |                 if ((*first_element_index as usize) %2 != 0) {\n \
    \  |                    ^                                       ^\n   |\n   =\
    \ note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n24 -                 if ((*first_element_index as usize) %2 != 0) {\n24\
    \ +                 if (*first_element_index as usize) %2 != 0 {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnqw4yl5u.rs:15:22\n   |\n15 |         if element\
    \ < 0 {\n   |                      ^\n   |                      |\n   |      \
    \                expected `&isize`, found integer\n   |                      help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnqw4yl5u.rs:16:25\n\
    \   |\n16 |             sorted.push(element);\n   |                         ^^^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             sorted.push(*element);\n   |                         +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnqw4yl5u.rs:22:29\n   |\n22 |\
    \                 sorted.push(element);\n   |                             ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |                 sorted.push(*element);\n   |                     \
    \        +\n\nerror[E0614]: type `Option<usize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpnqw4yl5u.rs:24:22\n   |\n24 |                 if ((*first_element_index\
    \ as usize) %2 != 0) {\n   |                      ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnqw4yl5u.rs:25:35\n   |\n25 |              \
    \       sorted.insert(first_element_index, element);\n   |                   \
    \                ^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n \
    \  |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnqw4yl5u.rs:25:56\n   |\n25 |\
    \                     sorted.insert(first_element_index, element);\n   |     \
    \                           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|x| x);\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmpezux1bge.rs:12:27\n\
    \   |\n12 |     array.sort_by_key(|x| x);\n   |                        -- ^ returning\
    \ this value requires that `'1` must outlive `'2`\n   |                      \
    \  ||\n   |                        |return type of closure is &'2 isize\n   |\
    \                        has type `&'1 isize`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpezux1bge.rs:12:5\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n12 |     array.sort_by_key(|x|\
    \ x);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ i in array.iter() {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n     \
    \   array.sort_by_key(|i| {\n            *i as isize\n        })\n    } else {\n\
    \        array.sort_by_key(|i| {\n            *i as isize\n        }).reverse()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmperlnbgrq.rs:17:9\n   |\n\
    11 |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n17 | /         array.sort_by_key(|i| {\n18 | |             *i as isize\n\
    19 | |         })\n   | |__________^ expected struct `Vec`, found `()`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error[E0599]: no method named `reverse` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmperlnbgrq.rs:23:12\n   |\n23 |         }).reverse()\n  \
    \ |            ^^^^^^^ method not found in `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array: Vec<isize>\
    \ = vec![];\n    let mut sum = 0;\n    for element in array.iter() {\n       \
    \ sum += element;\n        sorted_array.push(element);\n    }\n    if sum % 2\
    \ == 1 {\n        sorted_array.sort();\n    } else {\n        sorted_array.reverse();\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfsna084t.rs:16:27\n   |\n\
    16 |         sorted_array.push(element);\n   |                           ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |         sorted_array.push(*element);\n   |                       \
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ i in array.iter().cloned() {\n        sum += i;\n    }\n    if sum % 2 == 1\
    \ {\n        array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmppy086sy8.rs:17:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n17 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmppy086sy8.rs:19:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n19 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(array.len(),\
    \ 4);\n    let mut result = array;\n    result.sort();\n    if result.sum::<usize>()\
    \ > result.len() % 2 {\n        result.sort_by_key(|&x| x.reverse());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpoyfimyln.rs:15:15\n\
    \    |\n15  |       if result.sum::<usize>() > result.len() % 2 {\n    |     \
    \            ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ no method named `reverse` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpoyfimyln.rs:16:35\n   |\n16 |         result.sort_by_key(|&x| x.reverse());\n\
    \   |                                   ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reverse_bits`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut n = array.len();\n\
    \    if n % 2 == 1 {\n        let mut min_len = n * (n - 1) / 2;\n        let\
    \ mut min_element = array[0];\n        let mut max_element = array[0];\n     \
    \   let mut min_index = min_element;\n        let mut max_index = min_element;\n\
    \        for i in 0..n {\n            let element = array[i];\n            if\
    \ element < min_element {\n                min_element = element;\n          \
    \      min_index = i;\n            }\n            if element > max_element {\n\
    \                max_element = element;\n                max_index = i;\n    \
    \        }\n        }\n        if min_element + max_element < min_len {\n    \
    \        min_len = min_element + max_element;\n        }\n        sort_array(array.iter().cloned().filter(|&element|\
    \ element < min_element || element > max_element).cloned().collect())\n      \
    \      .sort_by(|a, b| {\n                if a + b < min_len {\n             \
    \       if a + b > 0 {\n                        a - b\n                    } else\
    \ {\n                        0\n                    }\n                } else\
    \ {\n                    b - a\n                }\n            });\n    } else\
    \ {\n        array.iter().cloned().sorted().collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpviiz_wll.rs:23:29\n   |\n\
    17 |         let mut min_index = min_element;\n   |                          \
    \   ----------- expected due to this value\n...\n23 |                 min_index\
    \ = i;\n   |                             ^ expected `isize`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpviiz_wll.rs:27:29\n   |\n18 |  \
    \       let mut max_index = min_element;\n   |                             -----------\
    \ expected due to this value\n...\n27 |                 max_index = i;\n   | \
    \                            ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpviiz_wll.rs:30:40\n   |\n30 |         if min_element\
    \ + max_element < min_len {\n   |                                        ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n30 |         if\
    \ min_element + max_element < min_len.try_into().unwrap() {\n   |            \
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpviiz_wll.rs:31:23\n   |\n14 |         let mut min_len =\
    \ n * (n - 1) / 2;\n   |                           --------------- expected due\
    \ to this value\n...\n31 |             min_len = min_element + max_element;\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize>\
    \ as Iterator>::Item == &&_`\n  --> /tmp/tmpviiz_wll.rs:33:108\n   |\n33 |   \
    \      sort_array(array.iter().cloned().filter(|&element| element < min_element\
    \ || element > max_element).cloned().collect())\n   |                        \
    \                                                                            \
    \        ^^^^^^ expected reference, found `isize`\n   |\n   = note: expected reference\
    \ `&&_`\n              found reference `&isize`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n   = note: 1 redundant requirement hidden\n   = note: requi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort();\n\n    let\
    \ mut ret = vec![];\n\n    for i in 1..array.len() {\n        if array[-i-1] >\
    \ array[-i] {\n            ret.push(array[-i-1]);\n        } else {\n        \
    \    ret.push(array[-i]);\n        }\n    }\n\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpe3wegh6i.rs:17:18\n\
    \   |\n17 |         if array[-i-1] > array[-i] {\n   |                  ^^ cannot\
    \ apply unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpe3wegh6i.rs:17:32\n\
    \   |\n17 |         if array[-i-1] > array[-i] {\n   |                       \
    \         ^^ cannot apply unary operator `-`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpe3wegh6i.rs:18:28\n   |\n18 |             ret.push(array[-i-1]);\n\
    \   |                            ^^ cannot apply unary operator `-`\n   |\n  \
    \ = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpe3wegh6i.rs:20:28\n   |\n20 |  \
    \           ret.push(array[-i]);\n   |                            ^^ cannot apply\
    \ unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0600`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.len() > 0);\n\
    \n    // initialize sum variable\n    let mut sum = 0;\n    for &n in &array {\n\
    \        // compute sum\n        sum += n;\n    }\n\n    // initialize min variable\n\
    \    let mut min = array[0];\n    for &n in &array {\n        // if the current\
    \ element is smaller than min\n        // then it means the min is going to be\
    \ updated\n        // and min variable will be updated\n        if n < min {\n\
    \            min = n;\n        }\n    }\n\n    // initialize max variable\n  \
    \  let mut max = array[0];\n    for &n in &array {\n        // if the current\
    \ element is greater than max\n        // then it means the max is going to be\
    \ updated\n        // and max variable will be updated\n        if n > max {\n\
    \            max = n;\n        }\n    }\n\n    // initialize middle variable\n\
    \    let mut middle = array[0];\n    for &n in &array {\n        // if the current\
    \ element is equal to the middle element\n        // then it means the middle\
    \ is going to be updated\n        // and middle variable will be updated\n   \
    \     if n == middle {\n            middle = n;\n        }\n    }\n\n    // initialize\
    \ min_index variable\n    let mut min_index = 0;\n    for &n in &array {\n   \
    \     // if the current element is smaller than min\n        // then it means\
    \ the min is going to be updated\n        // and min variable will be updated\n\
    \        if n < min {\n            min = n;\n        }\n    }\n\n    // initialize\
    \ max_index variable\n    let mut max_index = 0;\n    for &n in &array {\n   \
    \     // if the current element is greater than max\n        // then it means\
    \ the max is going to be updated\n        // and max variable will be updated\n\
    \        if n > max {\n            max = n;\n        }\n    }\n\n    // initialize\
    \ middle_position variable\n    let mut middle_position = 0;\n    for &n in &array\
    \ {\n        // if the current element is equal to the middle element\n      \
    \  // then it means the middle is going to be updated\n        // and middle variable\
    \ will be updated\n        if n == middle {\n            middle_position += 1;\n\
    \        }\n    }\n\n    // initialize min_index variable\n    let mut min_index\
    \ = 0;\n    for &n in &array {\n        // if the current element is smaller than\
    \ min\n        // then it means the min is going to be updated\n        // and\
    \ min variable will be updated\n        if n < min {\n            min = n;\n \
    \       }\n    }\n\n    // initialize max_index variable\n    let mut max_index\
    \ = 0;\n    for &n in &array {\n        // if the current element is greater than\
    \ max\n        // then it means the max is going to be updated\n        // and\
    \ max variable will be updated\n        if n > max {\n            max = n;\n \
    \       }\n    }\n\n    // initialize middle_index variable\n    let mut middle_index\
    \ = 0;\n    for &\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n   --> /tmp/tmp3jlahsd0.rs:112:1\n\
    \    |\n112 | }\n    | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Write your code here.\n\
    \    let mut temp_array: Vec<isize> = Vec::new();\n    let mut sum = 0;\n    for\
    \ ele in &array {\n        sum += ele;\n        temp_array.push(ele);\n    }\n\
    \    temp_array.sort();\n    for i in 0..temp_array.len() {\n        if sum %\
    \ 2 == 1 {\n            temp_array.reverse();\n        }\n        sum += temp_array[i];\n\
    \    }\n    temp_array\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt8z5cgyw.rs:17:25\n   |\n\
    17 |         temp_array.push(ele);\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |         temp_array.push(*ele);\n   |                         +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.clone();\n\
    \    if array.len() == 0 {\n        return array;\n    }\n    let n = array.len()\
    \ - 1;\n    array[n] = array[n].unwrap();\n    if n & 1 != 0 {\n        array.swap(n,\
    \ n + 1);\n    }\n    sort_array(array)\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxx_f0ysg.rs:17:25\n   |\n17 |     array[n] = array[n].unwrap();\n\
    \   |                         ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 1 {\n \
    \       return array;\n    }\n\n    // use bubble sort algorithm\n    let mut\
    \ sorted_array = [0; array.len()];\n    let mut swap_count = 0;\n    let mut last_index_value\
    \ = array.last();\n    let mut first_index_value = array.first();\n    while swap_count\
    \ < array.len() - 1 {\n        if swap_count % 2 == 1 {\n            sorted_array[first_index_value]\
    \ =\n                sorted_array[first_index_value] + sorted_array[last_index_value];\n\
    \            sorted_array[last_index_value] = array[first_index_value];\n    \
    \    } else {\n            sorted_array[first_index_value] =\n               \
    \ sorted_array[last_index_value] + sorted_array[first_index_value];\n        \
    \    sorted_array[last_index_value] = array[last_index_value];\n        }\n  \
    \      last_index_value = last_index_value - 1;\n        first_index_value = first_index_value\
    \ + 1;\n        swap_count = swap_count + 1;\n    }\n\n    sorted_array.sort_unstable();\n\
    \    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpo3s4zte6.rs:17:32\n   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize>\
    \ {\n   |               ----- this would need to be a `const`\n...\n17 |     let\
    \ mut sorted_array = [0; array.len()];\n   |                                ^^^^^\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n  -->\
    \ /tmp/tmpo3s4zte6.rs:25:46\n   |\n25 |             sorted_array[last_index_value]\
    \ = array[first_index_value];\n   |                                          \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `Option<&isize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<&isize>>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpo3s4zte6.rs:29:46\n   |\n29 |             sorted_array[last_index_value]\
    \ = array[last_index_value];\n   |                                           \
    \   ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `Option<&isize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<&isize>>`\
    \ for `Vec<isize>`\n\nerror[E0369]: cannot subtract `{integer}` from `Option<&isize>`\n\
    \  --> /tmp/tmpo3s4zte6.rs:31:45\n   |\n31 |         last_index_value = last_index_value\
    \ - 1;\n   |                            ---------------- ^ - {integer}\n   | \
    \                           |\n   |                            Option<&isize>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&isize>`\n  --> /tmp/tmpo3s4zte6.rs:32:47\n\
    \   |\n32 |         first_index_value = first_index_value + 1;\n   |         \
    \                    ----------------- ^ - {integer}\n   |                   \
    \          |\n   |                             Option<&isize>\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0369,\
    \ E0435.\nFor more information abou"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_vec();\n\
    \    array.sort();\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpwh92xcfu.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    sort.sort_with::<isize>(|l, r| l < r ? l : r);\n    let mut result = array.to_vec();\n\
    \    sort.sort_with::<isize>(|l, r| l < r ? l : r);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `l`\n\
    \  --> /tmp/tmp66f3mytc.rs:13:44\n   |\n13 |     sort.sort_with::<isize>(|l, r|\
    \ l < r ? l : r);\n   |                                           -^ expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n   |                            \
    \               |\n   |                                           help: missing\
    \ `,`\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `l`\n\
    \  --> /tmp/tmp66f3mytc.rs:15:44\n   |\n15 |     sort.sort_with::<isize>(|l, r|\
    \ l < r ? l : r);\n   |                                           -^ expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n   |                            \
    \               |\n   |                                           help: missing\
    \ `,`\n\nerror[E0425]: cannot find value `sort` in this scope\n  --> /tmp/tmp66f3mytc.rs:13:5\n\
    \   |\n13 |     sort.sort_with::<isize>(|l, r| l < r ? l : r);\n   |     ^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `l` in this scope\n\
    \  --> /tmp/tmp66f3mytc.rs:13:44\n   |\n13 |     sort.sort_with::<isize>(|l, r|\
    \ l < r ? l : r);\n   |                                            ^ expecting\
    \ a type here because of type ascription\n\nerror[E0412]: cannot find type `r`\
    \ in this scope\n  --> /tmp/tmp66f3mytc.rs:13:48\n   |\n13 |     sort.sort_with::<isize>(|l,\
    \ r| l < r ? l : r);\n   |                                                ^ expecting\
    \ a type here because of type ascription\n\nerror[E0425]: cannot find value `sort`\
    \ in this scope\n  --> /tmp/tmp66f3mytc.rs:15:5\n   |\n15 |     sort.sort_with::<isize>(|l,\
    \ r| l < r ? l : r);\n   |     ^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmp66f3mytc.rs:15:44\n   |\n15 |  \
    \   sort.sort_with::<isize>(|l, r| l < r ? l : r);\n   |                     \
    \                       ^ expecting a type here because of type ascription\n\n\
    error[E0412]: cannot find type `r` in this scope\n  --> /tmp/tmp66f3mytc.rs:15:48\n\
    \   |\n15 |     sort.sort_with::<isize>(|l, r| l < r ? l : r);\n   |         \
    \                                     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    let mut sum = 0;\n\n    for i in 0..new_array.len() {\n        sum = sum\
    \ + new_array[i];\n        if sum % 2 == 1 {\n            new_array.swap(i, new_array.len()\
    \ - 1 - i);\n        }\n    }\n\n    new_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `new_array` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmp99tauol4.rs:18:31\n   |\n18 |           \
    \  new_array.swap(i, new_array.len() - 1 - i);\n   |             ------------------^^^^^^^^^^^^^^^---------\n\
    \   |             |         |       |\n   |             |         |       immutable\
    \ borrow occurs here\n   |             |         mutable borrow later used by\
    \ call\n   |             mutable borrow occurs here\n   |\nhelp: try adding a\
    \ local storing this argument...\n  --> /tmp/tmp99tauol4.rs:18:31\n   |\n18 |\
    \             new_array.swap(i, new_array.len() - 1 - i);\n   |              \
    \                 ^^^^^^^^^^^^^^^\nhelp: ...and then using that local as the argument\
    \ to this call\n  --> /tmp/tmp99tauol4.rs:18:13\n   |\n18 |             new_array.swap(i,\
    \ new_array.len() - 1 - i);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    if len == 0 {\n        return array;\n    }\n    let mut new_array = array.to_vec();\n\
    \    let mut last_sum = 0;\n    let mut cur = 0;\n    let mut min_pos = 0;\n \
    \   let mut max_pos = 0;\n\n    while cur < len {\n        let cur = &new_array[cur];\n\
    \        if cur > max_pos {\n            max_pos = cur;\n        }\n        if\
    \ cur < min_pos {\n            min_pos = cur;\n        }\n        last_sum +=\
    \ cur;\n        cur += 1;\n    }\n\n    if last_sum % 2 == 1 {\n        let mut\
    \ min = min_pos;\n        let mut max = max_pos;\n        for pos in new_array.iter().rev()\
    \ {\n            let tmp = *pos;\n            *pos = max;\n            max = *pos;\n\
    \            *pos = tmp;\n        }\n        new_array.swap(min, max);\n    }\n\
    \    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdvcpfx3k.rs:24:18\n   |\n\
    24 |         if cur > max_pos {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&isize`, found integer\n   |    \
    \              help: consider borrowing here: `&max_pos`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdvcpfx3k.rs:25:23\n   |\n20 |     let mut max_pos = 0;\n\
    \   |                       - expected due to this value\n...\n25 |          \
    \   max_pos = cur;\n   |                       ^^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n25 |             max_pos\
    \ = *cur;\n   |                       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdvcpfx3k.rs:27:18\n   |\n27 |         if cur < min_pos {\n   |     \
    \             ^^^^^^^\n   |                  |\n   |                  expected\
    \ `&isize`, found integer\n   |                  help: consider borrowing here:\
    \ `&min_pos`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdvcpfx3k.rs:28:23\n\
    \   |\n19 |     let mut min_pos = 0;\n   |                       - expected due\
    \ to this value\n...\n28 |             min_pos = cur;\n   |                  \
    \     ^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n28 |             min_pos = *cur;\n   |                   \
    \    +\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to\
    \ type `&isize`\n  --> /tmp/tmpdvcpfx3k.rs:31:9\n   |\n31 |         cur += 1;\n\
    \   |         ---^^^^^\n   |         |\n   |         cannot use `+=` on type `&isize`\n\
    \   |\nhelp: `+=` can be used on `isize`, you can dereference `cur`\n   |\n31\
    \ |         *cur += 1;\n   |         +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdvcpfx3k.rs:43:29\n   |\n43 |         new_array.swap(min, max);\n  \
    \ |                             ^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n43 |         new_array.swap(min, max.try_into().unwrap());\n   |\
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ 6 previous err"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by_key(|&i| i);\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpekvgazwf.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort_by_key(|&i| i);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_sorted = vec![];\n\
    \    let mut sum_of_array = array[0];\n    for value in &array {\n        if value\
    \ > sum_of_array {\n            array_sorted.push(sum_of_array);\n           \
    \ sum_of_array = value;\n        } else {\n            sum_of_array += value;\n\
    \        }\n    }\n    array_sorted.push(sum_of_array);\n    array_sorted\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyynt35du.rs:15:20\n   |\n\
    15 |         if value > sum_of_array {\n   |                    ^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&sum_of_array`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyynt35du.rs:17:28\n   |\n13 |     let mut sum_of_array\
    \ = array[0];\n   |                            -------- expected due to this value\n\
    ...\n17 |             sum_of_array = value;\n   |                            ^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |             sum_of_array = *value;\n   |                         \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut first_sum = 0;\n    let mut last_sum\
    \ = 0;\n    for i in 0..array.len() - 1 {\n        first_sum += array[i];\n  \
    \      last_sum += array[i + 1];\n    }\n    if first_sum % 2 == 1 {\n       \
    \ array.sort_by_key(|i| -i);\n    } else {\n        array.sort_by_key(|i| i);\n\
    \    }\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable `last_sum` is assigned to, but never used\n  --> /tmp/tmpbg61xuxb.rs:16:13\n\
    \   |\n16 |     let mut last_sum = 0;\n   |             ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n   = note: consider using `_last_sum`\
    \ instead\n\nerror: lifetime may not live long enough\n  --> /tmp/tmpbg61xuxb.rs:24:31\n\
    \   |\n24 |         array.sort_by_key(|i| i);\n   |                          \
    \  -- ^ returning this value requires that `'1` must outlive `'2`\n   |      \
    \                      ||\n   |                            |return type of closure\
    \ is &'2 isize\n   |                            has type `&'1 isize`\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpbg61xuxb.rs:22:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n22 |\
    \         array.sort_by_key(|i| -i);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `array` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmpbg61xuxb.rs:24:9\n   |\n11 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n24 |         array.sort_by_key(|i| i);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array;\n    }\n    let mut sum_of_array = array[0];\n    for i\
    \ in array.iter().skip(1) {\n        sum_of_array += i;\n    }\n    let is_odd\
    \ = (sum_of_array % 2) == 1;\n    if is_odd {\n        array.iter().rev().sort_by(|a,\
    \ b| b - a);\n    } else {\n        array.iter().rev().sort_by(|a, b| a - b);\n\
    \    }\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmp2eaixdd6.rs:21:28\n   |\n21 |         array.iter().rev().sort_by(|a,\
    \ b| b - a);\n   |                            ^^^^^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `sort_by` found for struct `Rev` in\
    \ the current scope\n  --> /tmp/tmp2eaixdd6.rs:23:28\n   |\n23 |         array.iter().rev().sort_by(|a,\
    \ b| a - b);\n   |                            ^^^^^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.to_vec();\n\
    \    let mut current_sum = 0;\n    for value in &mut sorted_array {\n        current_sum\
    \ += value;\n    }\n    if current_sum % 2 == 1 {\n        sorted_array.sort_by(|a,\
    \ b| a.partial_cmp(&b));\n    } else {\n        sorted_array.sort_by(|a, b| b.partial_cmp(&a));\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `&mut isize` to `{integer}`\n  --> /tmp/tmpb90iiovz.rs:15:21\n\
    \   |\n15 |         current_sum += value;\n   |                     ^^ no implementation\
    \ for `{integer} += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb90iiovz.rs:18:37\n\
    \   |\n18 |         sorted_array.sort_by(|a, b| a.partial_cmp(&b));\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<std::cmp::Ordering>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb90iiovz.rs:20:37\n   |\n20 |         sorted_array.sort_by(|a,\
    \ b| b.partial_cmp(&a));\n   |                                     ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array: Vec<isize>\
    \ = vec![];\n    let mut left_sum = 0;\n\n    for &x in array {\n        if left_sum\
    \ % 2 == 1 {\n            sorted_array.push(x);\n        } else {\n          \
    \  sorted_array.push(x - sorted_array.len());\n        }\n\n        left_sum +=\
    \ x;\n    }\n\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplztn9xpn.rs:15:9\n   |\n\
    15 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplztn9xpn.rs:19:35\n   |\n19 |             sorted_array.push(x\
    \ - sorted_array.len());\n   |                                   ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from\
    \ `isize`\n  --> /tmp/tmplztn9xpn.rs:19:33\n   |\n19 |             sorted_array.push(x\
    \ - sorted_array.len());\n   |                                 ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for value in array {\n        if value < 0 {\n            result.push(-value);\n\
    \        } else {\n            result.push(value);\n        }\n    }\n    if result.len()\
    \ > 1 {\n        result.sort();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpa2c6y_8r.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.to_vec();\n\
    \    let mut sum = 0;\n    let mut odd_or_even = true;\n\n    for i in 0..array.len()\
    \ {\n        sum += sorted_array[i];\n\n        if sum % 2 == 0 {\n          \
    \  odd_or_even = !odd_or_even;\n        }\n\n        if odd_or_even {\n      \
    \      sorted_array.swap(i, i + 1);\n        }\n    }\n\n    sorted_array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpajbctnjl.rs:24:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array\n    }\n    let mut sum = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = array.len();\n    while i < k {\n        sum +=\
    \ array[i];\n        if sum % 2 == 1 {\n            array[i] = array[j];\n   \
    \         array[j] = array[i];\n        }\n        i += 1;\n        j += 1;\n\
    \        k -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp1r9op2e4.rs:22:13\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n22 |             array[i] = array[j];\n   |     \
    \        ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp1r9op2e4.rs:23:13\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \             array[j] = array[i];\n   |             ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array_copy = array.to_vec();\n\
    \    array_copy.sort();\n    array_copy\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpzcmsbksi.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    // sum\n    let mut sum = 0;\n    for ele\
    \ in array {\n        sum += ele;\n    }\n    let mut array = array.clone();\n\
    \    // if sum is odd\n    if sum & 1 != 0 {\n        array.sort_unstable();\n\
    \        // if sum is even\n    } else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpiwcrsq8l.rs:20:21\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n17  |     for ele in array {\n    |       \
    \         ----- `array` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for ele in &array {\n    |                +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut buffer = array;\n\
    \    buffer.sort();\n    buffer\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp8ejl17wj.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut max_so_far = array[0];\n\
    \    let mut min_so_far = array[0];\n    let mut min_so_far_so_far = 0;\n    let\
    \ mut max_so_far_so_far = 0;\n    for &x in array {\n        min_so_far = min_so_far_so_far\
    \ + (x - min_so_far);\n        max_so_far = max_so_far_so_far + (x - max_so_far);\n\
    \        min_so_far_so_far = min_so_far_so_far;\n        max_so_far_so_far = max_so_far_so_far;\n\
    \    }\n    if max_so_far == min_so_far {\n        return array;\n    }\n    if\
    \ max_so_far + min_so_far % 2 == 0 {\n        sort_array(array.iter().rev().cloned())\n\
    \    } else {\n        sort_array(array.iter().cloned())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvg1utdzv.rs:16:9\n   |\n\
    16 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvg1utdzv.rs:26:20\n   |\n26 |         sort_array(array.iter().rev().cloned())\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n           \
    \   found struct `Cloned<Rev<std::slice::Iter<'_, isize>>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvg1utdzv.rs:28:20\n   |\n28 |         sort_array(array.iter().cloned())\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array;\n    }\n\n    let mut first = array[0];\n    let mut last\
    \ = array[0];\n    let mut mid = 0;\n    while let Some(item) = array.iter().next_back()\
    \ {\n        if item > first {\n            mid = first;\n            first =\
    \ item;\n        } else {\n            first = item;\n        }\n        if item\
    \ > last {\n            last = mid;\n        }\n    }\n\n    array.sort();\n \
    \   let mut tmp = array.clone();\n    tmp.sort();\n\n    // reverse if odd and\
    \ reverse tmp if even\n    let odd = array.iter().fold(false, |odd, item| {\n\
    \        odd = odd and (item == last);\n        odd\n    });\n    let even = tmp.iter().fold(false,\
    \ |even, item| {\n        even = even and (item == first);\n        even\n   \
    \ });\n    if even {\n        tmp.reverse();\n    }\n\n    if odd {\n        tmp.reverse();\n\
    \    }\n\n    tmp.into_iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: `and` is not a logical operator\n  --> /tmp/tmpf51c46o0.rs:37:19\n\
    \   |\n37 |         odd = odd and (item == last);\n   |                   ^^^\
    \ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g.,\
    \ python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and`\
    \ is not a logical operator\n  --> /tmp/tmpf51c46o0.rs:41:21\n   |\n41 |     \
    \    even = even and (item == first);\n   |                     ^^^ help: use\
    \ `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python\
    \ and PHP, `&&` and `||` are used for logical operators\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf51c46o0.rs:20:19\n   |\n20 |         if item > first {\n\
    \   |                   ^^^^^\n   |                   |\n   |                \
    \   expected `&isize`, found `isize`\n   |                   help: consider borrowing\
    \ here: `&first`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf51c46o0.rs:22:21\n\
    \   |\n16 |     let mut first = array[0];\n   |                     -------- expected\
    \ due to this value\n...\n22 |             first = item;\n   |               \
    \      ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n22 |             first = *item;\n   |                    \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf51c46o0.rs:24:21\n   |\n\
    16 |     let mut first = array[0];\n   |                     -------- expected\
    \ due to this value\n...\n24 |             first = item;\n   |               \
    \      ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |             first = *item;\n   |                    \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf51c46o0.rs:26:19\n   |\n\
    26 |         if item > last {\n   |                   ^^^^\n   |             \
    \      |\n   |                   expected `&isize`, found `isize`\n   |      \
    \             help: consider borrowing here: `&last`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpf51c46o0.rs:37:29\n   |\n37 |         odd\
    \ = odd and (item == last);\n   |                             ^^ no implementation "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Write your code here\n\
    \    let mut sum = array[0];\n    let mut result = vec![];\n    for i in 1..array.len()\
    \ {\n        sum += array[i];\n        if sum % 2 == 0 {\n            result.push(array[i]);\n\
    \        } else {\n            result.push(array[i] - array[i - 1]);\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp7u1elzpq.rs:13:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Write your code here\n\
    \    let n = array.len();\n    for i in 0..n - 1 {\n        let x = array[i];\n\
    \        let y = n - i;\n        if y > 0 {\n            if array[i] - array[y-1]\
    \ > 0 {\n                array[i], array[y-1] = array[y-1], array[i];\n      \
    \      } else {\n                array[i], array[y] = array[y], array[i];\n  \
    \          }\n        } else {\n            if array[i] < array[i-1] {\n     \
    \           array[i], array[i-1] = array[i-1], array[i];\n            }\n    \
    \    }\n    }\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpkxt0zjsn.rs:19:25\n   |\n19 |                 array[i], array[y-1]\
    \ = array[y-1], array[i];\n   |                         ^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `,`\n  --> /tmp/tmpkxt0zjsn.rs:21:25\n   |\n21 |     \
    \            array[i], array[y] = array[y], array[i];\n   |                  \
    \       ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `,`\n  --> /tmp/tmpkxt0zjsn.rs:25:25\n\
    \   |\n25 |                 array[i], array[i-1] = array[i-1], array[i];\n   |\
    \                         ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.clone();\n\
    \    let mut temp: isize = 0;\n    let mut sum: isize = 0;\n    let mut odd: bool\
    \ = false;\n    let mut even: bool = false;\n\n    for value in array {\n    \
    \    if value == temp {\n            sum += value;\n        } else {\n       \
    \     odd = !odd;\n            even = !even;\n            if !even {\n       \
    \         let mut last = array.get_mut(array.len() - 1);\n                temp.swap(last);\n\
    \                sum += last;\n            } else if !odd {\n                let\
    \ mut first = array.get_mut(0);\n                temp.swap(first);\n         \
    \       sum += first;\n            }\n            temp = value;\n            sum\
    \ = 0;\n        }\n    }\n    if even {\n        array.swap(array.get_mut(0));\n\
    \        sum += array.get_mut(0);\n    } else if !odd {\n        array.swap(array.get_mut(array.len()\
    \ - 1));\n        sum += array.get_mut(array.len() - 1);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxeisjjz3.rs:26:22\n   |\n26 |                 temp.swap(last);\n\
    \   |                      ^^^^ method not found in `isize`\n\nerror[E0277]: cannot\
    \ add-assign `Option<&mut isize>` to `isize`\n  --> /tmp/tmpxeisjjz3.rs:27:21\n\
    \   |\n27 |                 sum += last;\n   |                     ^^ no implementation\
    \ for `isize += Option<&mut isize>`\n   |\n   = help: the trait `AddAssign<Option<&mut\
    \ isize>>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n \
    \            <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n     \
    \        <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n       \
    \      <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n          \
    \   <i16 as AddAssign>\n           and 20 others\n\nerror[E0599]: no method named\
    \ `swap` found for type `isize` in the current scope\n  --> /tmp/tmpxeisjjz3.rs:30:22\n\
    \   |\n30 |                 temp.swap(first);\n   |                      ^^^^\
    \ method not found in `isize`\n\nerror[E0277]: cannot add-assign `Option<&mut\
    \ isize>` to `isize`\n  --> /tmp/tmpxeisjjz3.rs:31:21\n   |\n31 |            \
    \     sum += first;\n   |                     ^^ no implementation for `isize\
    \ += Option<&mut isize>`\n   |\n   = help: the trait `AddAssign<Option<&mut isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0061]: this function takes 2 arguments but\
    \ 1 argument was supplied\n   --> /tmp/tmpxeisjjz3.rs:38:15\n    |\n38  |    \
    \     array.swap(array.get_mut(0));\n    |               ^^^^ ----------------\
    \ supplied 1 argument\n    |               |\n    |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n\
    \    array.sort_by(|a, b| if a.partial_sum::<usize>().unwrap() % 2 == 1 {\n  \
    \          Ordering::Less => b.partial_sum::<usize>().unwrap(),\n            Ordering::Greater\
    \ => a.partial_sum::<usize>().unwrap(),\n        } else {\n            Ordering::Greater\
    \ => a.partial_sum::<usize>().unwrap(),\n            Ordering::Less => b.partial_sum::<usize>().unwrap(),\n\
    \        });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpdi3b_i6t.rs:14:28\n   |\n14 |             Ordering::Less\
    \ => b.partial_sum::<usize>().unwrap(),\n   |                            ^^ expected\
    \ one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`,\
    \ `{`, `}`, or an operator, found `=>`\n  --> /tmp/tmpdi3b_i6t.rs:17:31\n   |\n\
    17 |             Ordering::Greater => a.partial_sum::<usize>().unwrap(),\n   |\
    \                               ^^ expected one of 8 possible tokens\n\nwarning:\
    \ unused import: `std::cmp::Ordering`\n  --> /tmp/tmpdi3b_i6t.rs:12:9\n   |\n\
    12 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method named\
    \ `partial_sum` found for reference `&isize` in the current scope\n  --> /tmp/tmpdi3b_i6t.rs:13:31\n\
    \   |\n13 |     array.sort_by(|a, b| if a.partial_sum::<usize>().unwrap() % 2\
    \ == 1 {\n   |                               ^^^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n\n    let mut index = 0;\n\n    loop {\n      \
    \  if index + 1 < array.len() {\n            if index == 0 {\n               \
    \ let sum = array[0] + array[index + 1];\n                if sum % 2 != 0 {\n\
    \                    index += 1;\n                } else {\n                 \
    \   index += 1;\n                }\n                continue;\n            }\n\
    \n            let sum = array[index] + array[index + 1];\n            if sum %\
    \ 2 != 0 {\n                index += 1;\n            } else {\n              \
    \  index += 1;\n            }\n        } else {\n            break;\n        }\n\
    \    }\n\n    array.drain(..index);\n\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpb3od0kwm.rs:41:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n41 |     array.drain(..index);\n   |     ^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    let mut sum = array[0];\n\n    for i in 1..array.len() {\n        let v =\
    \ array[i];\n        sum = sum + v;\n        array.swap(i, 0);\n    }\n\n    if\
    \ sum % 2 != 0 {\n        array.sort_by_key(|x| -x);\n    } else {\n        array.sort_by_key(|x|\
    \ x);\n    }\n\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmpx7gnavwl.rs:24:31\n\
    \   |\n24 |         array.sort_by_key(|x| x);\n   |                          \
    \  -- ^ returning this value requires that `'1` must outlive `'2`\n   |      \
    \                      ||\n   |                            |return type of closure\
    \ is &'2 isize\n   |                            has type `&'1 isize`\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = array.iter().sum();\n\
    \    let mut n = array.len();\n    \n    if sum % 2 == 0 {\n        array.sort_by(|a,\
    \ b| a.partial_cmp(&b).reverse());\n    } else {\n        array.sort_by(|a, b|\
    \ a.partial_cmp(&b));\n    }\n    \n    return array;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp59thqu6k.rs:16:48\n   |\n16 |         array.sort_by(|a,\
    \ b| a.partial_cmp(&b).reverse());\n   |                                     \
    \           ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp59thqu6k.rs:18:30\n   |\n18 |         array.sort_by(|a,\
    \ b| a.partial_cmp(&b));\n   |                              ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // init return array\n \
    \   let mut ret = vec![];\n    // init sum\n    let mut sum_array = 0;\n    //\
    \ init array\n    let mut array = array.clone();\n    // init max number\n   \
    \ let mut max_num = array[0];\n\n    // init loop counter\n    let mut counter\
    \ = 0;\n\n    // loop through array\n    while counter < array.len() {\n     \
    \   // sum\n        sum_array += array.pop().unwrap();\n        // check sum\n\
    \        if sum_array % 2 == 1 {\n            ret = ret.push(array.pop().unwrap());\n\
    \        } else {\n            ret = ret.push(array.pop().unwrap());\n       \
    \ }\n        // get max number\n        if array.pop().unwrap() > max_num {\n\
    \            max_num = array.pop().unwrap();\n        }\n        counter += 1;\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp86ingn6f.rs:30:19\n   |\n\
    13 |     let mut ret = vec![];\n   |                   ------ expected due to\
    \ this value\n...\n30 |             ret = ret.push(array.pop().unwrap());\n  \
    \ |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp86ingn6f.rs:32:19\n  \
    \ |\n13 |     let mut ret = vec![];\n   |                   ------ expected due\
    \ to this value\n...\n32 |             ret = ret.push(array.pop().unwrap());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp86ingn6f.rs:32:23\n\
    \   |\n32 |             ret = ret.push(array.pop().unwrap());\n   |          \
    \         --- ^^^^ this call modifies `ret` in-place\n   |                   |\n\
    \   |                   you probably want to use this value after calling the\
    \ method...\n   = note: ...instead of the `()` output of method `push`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert_eq!(array.len(),\
    \ 0);\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp3svk4yo2.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.is_sorted());\n\
    \    let mut new_array = array.clone();\n    let mut last = new_array.len() -\
    \ 1;\n    let mut current_sum = 0;\n    while last >= 0 {\n        current_sum\
    \ += new_array[last];\n        // If sum is odd, then add it\n        if current_sum\
    \ % 2 != 0 {\n            new_array.push(new_array[last]);\n        }\n      \
    \  // If sum is even, then add it and remove it\n        else {\n            new_array.remove(&last);\n\
    \        }\n        last--;\n    }\n    return new_array;\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmptbj_os1y.rs:26:15\n\
    \   |\n26 |         last--;\n   |               ^ expected expression\n\nerror[E0658]:\
    \ use of unstable library feature 'is_sorted': new API\n  --> /tmp/tmptbj_os1y.rs:12:19\n\
    \   |\n12 |     assert!(array.is_sorted());\n   |                   ^^^^^^^^^\n\
    \   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbj_os1y.rs:24:30\n\
    \   |\n24 |             new_array.remove(&last);\n   |                       \
    \       ^^^^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n24 -             new_array.remove(&last);\n24 +          \
    \   new_array.remove(last);\n   | \n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0658.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    let\
    \ mut max: isize = 0;\n    for ele in array.iter() {\n        sum += ele;\n  \
    \      if sum > max {\n            max = sum;\n        }\n    }\n    if max %\
    \ 2 == 1 {\n        array.sort_by(|a, b| a.partial_cmp(&b));\n    } else {\n \
    \       array.sort_by(|a, b| b.partial_cmp(&a));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ff1pxtd.rs:21:30\n   |\n\
    21 |         array.sort_by(|a, b| a.partial_cmp(&b));\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found enum\
    \ `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n            \
    \  found enum `Option<std::cmp::Ordering>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6ff1pxtd.rs:23:30\n   |\n23 |         array.sort_by(|a, b| b.partial_cmp(&a));\n\
    \   |                              ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<std::cmp::Ordering>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array\n    }\n    let mut sum = array.iter().sum();\n    if sum\
    \ % 2 == 0 {\n        array.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n \
    \   } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n \
    \       array.iter().rev();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp6lz0v95u.rs:17:50\n   |\n17 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n   |                                        \
    \          ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp6lz0v95u.rs:19:50\n   |\n19 |         array.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \   |                                                  ^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    assert!(array.is_sorted());\n\
    \    let mut sum = array[0];\n    let mut min_value = array[0];\n    for value\
    \ in array.iter().rev() {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            min_value = value;\n        }\n    }\n    array.set_len(0);\n   \
    \ array.push(*min_value);\n    array.push(*array);\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmpo3v8_pdt.rs:12:19\n   |\n12 |     assert!(array.is_sorted());\n   |\
    \                   ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo3v8_pdt.rs:18:25\n\
    \   |\n14 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n18 |             min_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |             min_value = *value;\n   | \
    \                        +\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpo3v8_pdt.rs:22:16\n   |\n22 |     array.push(*min_value);\n   |\
    \                ^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo3v8_pdt.rs:23:16\n\
    \   |\n23 |     array.push(*array);\n   |                ^^^^^^ expected `isize`,\
    \ found slice `[isize]`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614, E0658.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = 0;\n    for\
    \ ele in array.iter() {\n        sum += ele;\n    }\n    if sum % 2 != 0 {\n \
    \       array.sort();\n    } else {\n        array.sort_reverse();\n    }\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_reverse` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkqzk36qd.rs:19:15\n   |\n19 |         array.sort_reverse();\n\
    \   |               ^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `reverse`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array: Vec<isize>\
    \ = array;\n    new_array.sort();\n    new_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpwfp14cyv.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0;\
    \ array.len()];\n    let mut flag = true;\n    for value in array.iter() {\n \
    \       if flag & !((value % 2) == 0) {\n            result.swap(0, result.len());\n\
    \            flag = false;\n        }\n        result[result.len()-1] = value;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi9nuski.rs:19:34\n   |\n\
    19 |         result[result.len()-1] = value;\n   |         ----------------------\
    \   ^^^^^ expected integer, found `&isize`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |         result[result.len()-1] = *value;\n   |                   \
    \               +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut max = array[0];\n    let mut min = array[0];\n\
    \    for value in array.iter().rev() {\n        if value > max {\n           \
    \ max = value;\n        }\n        if value < min {\n            min = value;\n\
    \        }\n    }\n    if max - min == 0 {\n        return array;\n    }\n   \
    \ if max % 2 == 1 {\n        array.sort_by_key(|&x| x.reverse());\n    } else\
    \ {\n        array.sort_by_key(|&x| x.rev());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsp9ubhf1.rs:18:20\n   |\n\
    18 |         if value > max {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected `&isize`, found `isize`\n   |    \
    \                help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsp9ubhf1.rs:19:19\n   |\n15 |     let mut max = array[0];\n\
    \   |                   -------- expected due to this value\n...\n19 |       \
    \      max = value;\n   |                   ^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |             max = *value;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsp9ubhf1.rs:21:20\n\
    \   |\n21 |         if value < min {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected `&isize`, found `isize`\n \
    \  |                    help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsp9ubhf1.rs:22:19\n   |\n16 |     let mut min\
    \ = array[0];\n   |                   -------- expected due to this value\n...\n\
    22 |             min = value;\n   |                   ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \           min = *value;\n   |                   +\n\nerror[E0599]: no method\
    \ named `reverse` found for type `isize` in the current scope\n  --> /tmp/tmpsp9ubhf1.rs:29:34\n\
    \   |\n29 |         array.sort_by_key(|&x| x.reverse());\n   |               \
    \                   ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reverse_bits`\n\nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmpsp9ubhf1.rs:31:34\n\
    \   |\n31 |         array.sort_by_key(|&x| x.rev());\n   |                   \
    \               ^^^ `isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `&mut isize: Iterator`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc -"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() > 1 {\n \
    \       let mut swapped = false;\n        let mut sum: isize = array[0];\n   \
    \     for value in &array[1:] {\n            if value > sum {\n              \
    \  swap(&mut array, &mut swapped, &mut sum);\n                sum += value;\n\
    \            } else {\n                sum += value;\n            }\n        }\n\
    \        if swapped {\n            sort_array(array)\n        } else {\n     \
    \       array\n        }\n    } else {\n        array\n    }\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `]`\n  --> /tmp/tmpm30awaqm.rs:15:31\n   |\n\
    15 |         for value in &array[1:] {\n   |                              -^ expected\
    \ type\n   |                              |\n   |                            \
    \  help: maybe write a path separator here: `::`\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // get max and min values\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        if value < min_value {\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_value = value;\n \
    \       }\n    }\n\n    // get sum of all values\n    let mut sum = 0;\n    for\
    \ value in array {\n        sum += value;\n    }\n\n    // return sorted array\n\
    \    if sum % 2 != 0 {\n        array.sort_by_key(|v| v).reverse();\n    } else\
    \ {\n        array.sort_by_key(|v| v);\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpn8argbpd.rs:32:34\n   |\n32 |         array.sort_by_key(|v|\
    \ v).reverse();\n   |                                  ^^^^^^^ method not found\
    \ in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8argbpd.rs:31:21\n\
    \   |\n31 |       if sum % 2 != 0 {\n   |  _____________________^\n32 | |    \
    \     array.sort_by_key(|v| v).reverse();\n33 | |     } else {\n   | |_____^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8argbpd.rs:33:12\n\
    \   |\n33 |       } else {\n   |  ____________^\n34 | |         array.sort_by_key(|v|\
    \ v);\n35 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    if len <= 1 {\n        return array;\n    }\n    let mut result = vec![0;\
    \ len];\n    let mut last_element = 0;\n    let mut last_index = 0;\n\n    //\
    \ If sum modulo 2, then sort descending\n    while last_element + array[0] + array[len-1]\
    \ + 1 != last_element {\n        // Sum modulo 2\n        last_element = last_element\
    \ + array[len-1] + array[0];\n        let mut sum = 0;\n        for index in range(0,\
    \ len) {\n            sum += array[index];\n            result[index] = sum %\
    \ 2;\n        }\n        // If odd sum, sort descending\n        if last_element\
    \ % 2 == 1 {\n            let len = result.len();\n            for index in range(0,\
    \ len) {\n                result[index] = result[len-1];\n            }\n    \
    \    }\n        // If even sum, sort ascending\n        else {\n            let\
    \ len = result.len();\n            for index in range(0, len) {\n            \
    \    result[index] = result[0];\n            }\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp4mmofq0x.rs:25:22\n\
    \   |\n25 |         for index in range(0, len) {\n   |                      ^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range`\
    \ in this scope\n  --> /tmp/tmp4mmofq0x.rs:32:26\n   |\n32 |             for index\
    \ in range(0, len) {\n   |                          ^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n\
    \   |\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp4mmofq0x.rs:39:26\n\
    \   |\n39 |             for index in range(0, len) {\n   |                   \
    \       ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Your code here\n    let\
    \ mut sum = array.iter().sum();\n    if sum % 2 == 1 {\n        array.iter().sort().collect()\n\
    \    } else {\n        array.iter().rev().sort().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpftlfbtzc.rs:15:22\n   |\n15 |         array.iter().sort().collect()\n\
    \   |                      ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror[E0599]: no method named `sort` found for struct `Rev` in the current scope\n\
    \  --> /tmp/tmpftlfbtzc.rs:17:28\n   |\n17 |         array.iter().rev().sort().collect()\n\
    \   |                            ^^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array\n    }\n    let mut min = array[0];\n    let mut max = array[0];\n\
    \    for &item in &array {\n        if item < min {\n            min = item;\n\
    \        }\n        if item > max {\n            max = item;\n        }\n    }\n\
    \    let mut min_sum = array[0];\n    let mut max_sum = array[0];\n    for &item\
    \ in &array {\n        if item < min {\n            item -= 1;\n        }\n  \
    \      min_sum += item;\n        if item > max {\n            item += 1;\n   \
    \     }\n        max_sum += item;\n    }\n    let mut min_sum2 = min;\n    let\
    \ mut max_sum2 = max;\n    if min_sum2 % 2 == 1 && max_sum2 % 2 == 1 {\n     \
    \   array.sort();\n    } else {\n        array.sort_by_key(|&item| item < min);\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable `min_sum` is assigned to, but never used\n  --> /tmp/tmpcwmltnil.rs:25:13\n\
    \   |\n25 |     let mut min_sum = array[0];\n   |             ^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_min_sum` instead\n\nwarning: variable `max_sum` is assigned to, but never\
    \ used\n  --> /tmp/tmpcwmltnil.rs:26:13\n   |\n26 |     let mut max_sum = array[0];\n\
    \   |             ^^^^^^^\n   |\n   = note: consider using `_max_sum` instead\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpcwmltnil.rs:37:9\n\
    \   |\n37 |     let mut min_sum2 = min;\n   |         ----^^^^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpcwmltnil.rs:38:9\n\
    \   |\n38 |     let mut max_sum2 = max;\n   |         ----^^^^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `item`\n  --> /tmp/tmpcwmltnil.rs:29:13\n   |\n27 |  \
    \   for &item in &array {\n   |          ----\n   |          |\n   |         \
    \ first assignment to `item`\n   |          help: consider making this binding\
    \ mutable: `mut item`\n28 |         if item < min {\n29 |             item -=\
    \ 1;\n   |             ^^^^^^^^^ cannot assign twice to immutable variable\n\n\
    error[E0384]: cannot assign twice to immutable variable `item`\n  --> /tmp/tmpcwmltnil.rs:33:13\n\
    \   |\n27 |     for &item in &array {\n   |          ----\n   |          |\n \
    \  |          first assignment to `item`\n   |          help: consider making\
    \ this binding mutable: `mut item`\n...\n33 |             item += 1;\n   |   \
    \          ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpcwmltnil.rs:40:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n40 |\
    \         array.sort();\n   |         ^^^^^^^^^^^^ cannot borrow as mutable\n\n\
    error[E0596]: cannot "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    array.sort_unstable();\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpsv2nh6ca.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort();\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpfepvghfz.rs:12:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n12 |     array.sort();\n   |     ^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut s = vec![];\n    let mut a = array;\n\
    \    let mut sum_of_first = vec![];\n    let mut sum_of_last = vec![];\n    for\
    \ i in 0..a.len() {\n        s.push(i);\n        let first = &a[i - 1];\n    \
    \    let last = &a[i];\n        sum_of_first.push(first);\n        sum_of_last.push(last);\n\
    \    }\n    if sum_of_first.len() == sum_of_last.len() {\n        for i in s.iter()\
    \ {\n            a.push(i);\n        }\n        return a;\n    }\n    if sum_of_first.len()\
    \ > sum_of_last.len() {\n        for i in 0..sum_of_last.len() {\n           \
    \ a.push(sum_of_last[i]);\n        }\n        return a;\n    }\n    for i in 0..sum_of_first.len()\
    \ {\n        a.push(sum_of_first[i]);\n    }\n    return a;\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzgoygco.rs:28:20\n   |\n\
    28 |             a.push(i);\n   |                    ^ expected `isize`, found\
    \ `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzgoygco.rs:34:20\n\
    \   |\n34 |             a.push(sum_of_last[i]);\n   |                    ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n34 |             a.push(*sum_of_last[i]);\n   |                    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgzgoygco.rs:39:16\n   |\n39 |  \
    \       a.push(sum_of_first[i]);\n   |                ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    39 |         a.push(*sum_of_first[i]);\n   |                +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array.to_owned();\n\
    \    array.sort_by_key(|x| -x.0);\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpbfqrsww5.rs:13:30\n\
    \   |\n13 |     array.sort_by_key(|x| -x.0);\n   |                           \
    \   ^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0609`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n\
    \    if sorted_array.len() % 2 == 0 {\n        sorted_array.pop();\n    }\n  \
    \  sorted_array.sort();\n    sorted_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmptliixj_y.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        return array;\n    }\n    let mut sum = array[0];\n    for index in 1..array.len()\
    \ {\n        sum += array[index];\n    }\n    if sum % 2 == 1 {\n        array.sort_unstable();\n\
    \    } else {\n        array.sort_reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_reverse` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpl9kqp5h9.rs:22:15\n   |\n22 |         array.sort_reverse();\n\
    \   |               ^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `reverse`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n\
    \        array\n    } else {\n        let mut counter = 0;\n        let mut temp_sum\
    \ = array[0];\n        let mut temp_array = array;\n        let mut result_array\
    \ = vec![];\n\n        for val in temp_array {\n            if val > temp_sum\
    \ {\n                temp_sum += val;\n            } else {\n                temp_sum\
    \ = temp_sum - val;\n            }\n\n            if temp_sum == 0 {\n       \
    \         result_array.push(val);\n            } else {\n                while\
    \ temp_sum != 0 {\n                    if temp_sum % 2 == 0 {\n              \
    \          temp_sum += val;\n                    } else {\n                  \
    \      temp_sum += val * -1;\n                    }\n                }\n     \
    \       }\n        }\n        result_array\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array\n    }\n\n    let mut sum = array.iter().fold(0, |mut a,\
    \ &b| {\n        let mut c = a + b;\n        if c & 1 != 0 {\n            c =\
    \ c - 1;\n        }\n        c\n    });\n\n    if sum % 2 != 0 {\n        array.iter().reverse().sort().collect()\n\
    \    } else {\n        array.iter().sort().collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpcojrfwmj.rs:25:22\n   |\n25 |         array.iter().reverse().sort().collect()\n\
    \   |                      ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror[E0599]: no method named `sort` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmpcojrfwmj.rs:27:22\n   |\n27 |         array.iter().sort().collect()\n\
    \   |                      ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array\n    }\n\n    let mut array = array.clone();\n    let mut\
    \ first_value = array[0];\n    let mut last_value = array[0];\n\n    for i in\
    \ array.iter_mut().rev() {\n        *i += 1;\n        if *i > *array.len() {\n\
    \            *i -= 1;\n        }\n\n        if *i % 2 == 0 {\n            last_value\
    \ = *i;\n        } else {\n            first_value = *i;\n        }\n    }\n \
    \   array.sort_by_key(|&i| i.cmp(&first_value).unwrap());\n    array.sort_by_key(|&i|\
    \ i.cmp(&last_value).unwrap());\n    return array;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp7bgy317g.rs:22:17\n\
    \   |\n22 |         if *i > *array.len() {\n   |                 ^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmp7bgy317g.rs:32:48\n   |\n32 |     array.sort_by_key(|&i|\
    \ i.cmp(&first_value).unwrap());\n   |                                       \
    \         ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0599]: no\
    \ method named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n\
    \  --> /tmp/tmp7bgy317g.rs:33:47\n   |\n33 |     array.sort_by_key(|&i| i.cmp(&last_value).unwrap());\n\
    \   |                                               ^^^^^^ method not found in\
    \ `std::cmp::Ordering`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpab_l51nh.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut sum = 0;\n\n    while i < array.len() && j < array.len() {\n        sum\
    \ += array[i];\n        i += 1;\n        j += 1;\n\n        if sum % 2 == 1 {\n\
    \            std::swap(&array[i], &array[j]);\n        }\n    }\n\n    if sum\
    \ % 2 == 0 {\n        std::swap(&array[0], &array[j]);\n    }\n\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in crate `std`\n  --> /tmp/tmpbh3uvx0h.rs:26:18\n\
    \   |\n26 |             std::swap(&array[i], &array[j]);\n   |               \
    \   ^^^^ not found in `std`\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\nhelp: if\
    \ you import `swap`, refer to it directly\n   |\n26 -             std::swap(&array[i],\
    \ &array[j]);\n26 +             swap(&array[i], &array[j]);\n   | \n\nerror[E0425]:\
    \ cannot find function `swap` in crate `std`\n  --> /tmp/tmpbh3uvx0h.rs:31:14\n\
    \   |\n31 |         std::swap(&array[0], &array[j]);\n   |              ^^^^ not\
    \ found in `std`\n   |\nhelp: consider importing one of these items\n   |\n1 \
    \ | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\nhelp: if you import\
    \ `swap`, refer to it directly\n   |\n31 -         std::swap(&array[0], &array[j]);\n\
    31 +         swap(&array[0], &array[j]);\n   | \n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n\
    \    let mut min_sum = array[0];\n    let mut max_sum = array[0];\n    for i in\
    \ &array[0..] {\n        min_sum = min_sum.min(&i);\n        max_sum = max_sum.max(&i);\n\
    \    }\n    for i in &array {\n        if min_sum + i < max_sum {\n          \
    \  res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcuuphpue.rs:16:31\n   |\n\
    16 |         min_sum = min_sum.min(&i);\n   |                               ^^\
    \ expected `isize`, found `&&isize`\n   |\nhelp: consider removing the `&` and\
    \ dereferencing the borrow instead\n   |\n16 |         min_sum = min_sum.min(*i);\n\
    \   |                               ~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcuuphpue.rs:17:31\n   |\n17 |         max_sum = max_sum.max(&i);\n \
    \  |                               ^^ expected `isize`, found `&&isize`\n   |\n\
    help: consider removing the `&` and dereferencing the borrow instead\n   |\n17\
    \ |         max_sum = max_sum.max(*i);\n   |                               ~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcuuphpue.rs:24:5\n   |\n11 | fn\
    \ sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                        \
    \             ---------- expected `Vec<isize>` because of return type\n...\n24\
    \ |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // get the sum first.\n\
    \    let mut sum_of_array = array.iter().sum();\n    // if sum is even, then sort\
    \ in descending order\n    if sum_of_array % 2 == 0 {\n        array.sort_by_key(|x|\
    \ x.partial_cmp(&x[..]).reverse());\n    } else {\n        // otherwise, sort\
    \ in ascending order\n        array.sort_by_key(|x| x.partial_cmp(&x[..]));\n\
    \    }\n    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp545pz2zr.rs:16:46\n\
    \   |\n16 |         array.sort_by_key(|x| x.partial_cmp(&x[..]).reverse());\n\
    \   |                                              ^^^^^\n\nerror[E0599]: no method\
    \ named `reverse` found for enum `Option` in the current scope\n  --> /tmp/tmp545pz2zr.rs:16:53\n\
    \   |\n16 |         array.sort_by_key(|x| x.partial_cmp(&x[..]).reverse());\n\
    \   |                                                     ^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror[E0608]: cannot index into a value of\
    \ type `&isize`\n  --> /tmp/tmp545pz2zr.rs:19:46\n   |\n19 |         array.sort_by_key(|x|\
    \ x.partial_cmp(&x[..]));\n   |                                              ^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut tmp = array.clone();\n\
    \    if tmp.len() < 2 {\n        return tmp;\n    }\n\n    let mut i = 0;\n  \
    \  while i < tmp.len() {\n        while i + 1 < tmp.len() {\n            if tmp.as_slice()[i]\
    \ + tmp.as_slice()[i + 1] == 2 * tmp.as_slice()[i + 1] {\n                tmp\
    \ = tmp.clone();\n                tmp.swap(i, i + 1);\n                i += 1;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    i += 1;\n    }\n\n    tmp\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpxr2m1m6c.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
