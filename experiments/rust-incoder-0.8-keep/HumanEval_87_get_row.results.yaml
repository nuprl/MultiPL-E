name: HumanEval_87_get_row
language: rust
results:
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::new();\n    for (i, v) in lst.iter().enumerate() {\n\
    \        if i == 0 {\n            for n in v.iter().rev() {\n                row.push((i,\
    \ n));\n            }\n            continue;\n        }\n        let mut curr\
    \ = row.iter_mut().rev().collect::<Vec<_>>();\n        let last = curr.last().unwrap();\n\
    \        if last.0 == i {\n            for n in v.iter().rev() {\n           \
    \     curr.pop();\n                curr.push((i, n));\n            }\n       \
    \     continue;\n        }\n        if last.1 == i {\n            for n in v.iter().rev()\
    \ {\n                curr.push((i, n));\n            }\n            continue;\n\
    \        }\n        for n in v.iter().rev() {\n            curr.pop();\n     \
    \       curr.pop();\n            curr.pop();\n            curr.push((i, n));\n\
    \        }\n    }\n    row.sort();\n    row.reverse();\n    row\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4e07z4d.rs:31:27\n   |\n\
    31 |                 curr.push((i, n));\n   |                           ^^^^^^\n\
    \   |                           |\n   |                           expected mutable\
    \ reference, found tuple\n   |                           help: consider mutably\
    \ borrowing here: `&mut (i, n)`\n   |\n   = note: expected mutable reference `&mut\
    \ (usize, &isize)`\n                          found tuple `(usize, &isize)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr4e07z4d.rs:35:22\n   |\n35 |  \
    \       if last.1 == i {\n   |                      ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n  --> /tmp/tmpr4e07z4d.rs:35:19\n\
    \   |\n35 |         if last.1 == i {\n   |                   ^^ no implementation\
    \ for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr4e07z4d.rs:37:27\n   |\n37 |                 curr.push((i, n));\n \
    \  |                           ^^^^^^\n   |                           |\n   |\
    \                           expected mutable reference, found tuple\n   |    \
    \                       help: consider mutably borrowing here: `&mut (i, n)`\n\
    \   |\n   = note: expected mutable reference `&mut (usize, &isize)`\n        \
    \                  found tuple `(usize, &isize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr4e07z4d.rs:45:23\n   |\n45 |             curr.push((i, n));\n\
    \   |                       ^^^^^^\n   |                       |\n   |       \
    \                expected mutable reference, found tuple\n   |               \
    \        help: consider mutably borrowing here: `&mut (i, n)`\n   |\n   = note:\
    \ expected mutable reference `&mut (usize, &isize)`\n                        \
    \  found tuple `(usize, &isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.sort_by(|a, b| {\n        let mut l = a.len();\n        let mut r\
    \ = b.len();\n        if l > r {\n            l, r = r, l;\n        }\n      \
    \  b.iter().zip(a.iter()).copied().filter_map(|x| x.1).map(|x| x.0).min(l).max(r);\n\
    \    });\n\n    let mut res = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        let mut row = row.to_vec();\n        row.sort_by(|a, b| {\n     \
    \       let mut l = a.len();\n            let mut r = b.len();\n            if\
    \ l > r {\n                l, r = r, l;\n            }\n            b.iter().zip(a.iter()).copied().filter_map(|x|\
    \ x.1).map(|x| x.0).min(l).max(r);\n        });\n        row.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n\
    \        res.push((i, row));\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp4pzu31k4.rs:22:18\n   |\n\
    22 |             l, r = r, l;\n   |                 -^\n   |                 |\n\
    \   |                 help: replace equals symbol with a colon: `:`\n\nerror:\
    \ expected one of `,` or `}`, found `;`\n  --> /tmp/tmp4pzu31k4.rs:22:24\n   |\n\
    21 |         if l > r {\n   |                - while parsing this struct\n22 |\
    \             l, r = r, l;\n   |                        ^ expected one of `,`\
    \ or `}`\n\nerror: struct literals are not allowed here\n  --> /tmp/tmp4pzu31k4.rs:21:16\n\
    \   |\n21 |           if l > r {\n   |  ________________^\n22 | |            \
    \ l, r = r, l;\n23 | |         }\n   | |_________^\n   |\nhelp: surround the struct\
    \ literal with parentheses\n   |\n21 ~         if l > (r {\n22 |             l,\
    \ r = r, l;\n23 ~         })\n   |\n\nerror: expected `{`, found `b`\n  --> /tmp/tmp4pzu31k4.rs:24:9\n\
    \   |\n21 |         if l > r {\n   |         -- this `if` expression has a condition,\
    \ but no block\n...\n24 |         b.iter().zip(a.iter()).copied().filter_map(|x|\
    \ x.1).map(|x| x.0).min(l).max(r);\n   |         ^ expected `{`\n   |\nhelp: try\
    \ placing this code inside a block\n   |\n24 |         { b.iter().zip(a.iter()).copied().filter_map(|x|\
    \ x.1).map(|x| x.0).min(l).max(r); }\n   |         +                         \
    \                                                        +\n\nerror: expected\
    \ `:`, found `=`\n  --> /tmp/tmp4pzu31k4.rs:34:22\n   |\n34 |                \
    \ l, r = r, l;\n   |                     -^\n   |                     |\n   |\
    \                     help: replace equals symbol with a colon: `:`\n\nerror:\
    \ expected one of `,` or `}`, found `;`\n  --> /tmp/tmp4pzu31k4.rs:34:28\n   |\n\
    33 |             if l > r {\n   |                    - while parsing this struct\n\
    34 |                 l, r = r, l;\n   |                            ^ expected\
    \ one of `,` or `}`\n\nerror: struct literals are not allowed here\n  --> /tmp/tmp4pzu31k4.rs:33:20\n\
    \   |\n33 |               if l > r {\n   |  ____________________^\n34 | |    \
    \             l, r = r, l;\n35 | |             }\n   | |_____________^\n   |\n\
    help: surround the"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    let mut cols = vec![];\n    let mut row_iter\
    \ = lst.into_iter();\n    while let Some(row) = row_iter.next() {\n        cols.clear();\n\
    \        let mut col_iter = row.into_iter();\n        while let Some(col) = col_iter.next()\
    \ {\n            if col == x {\n                row.push(col);\n             \
    \   cols.push(col);\n                break;\n            }\n            cols.push(col);\n\
    \        }\n        if cols.len() == row.len() {\n            row.push(0);\n \
    \           row.push(cols.len());\n        }\n        row.sort_by_key(|i| i);\n\
    \        row.sort_by_key(|i| i, |j| j);\n        row.push(0);\n        row.push(cols.len());\n\
    \        row.sort_by_key(|i| i);\n        row.sort_by_key(|i| i, |j| j);\n   \
    \     row.push(-2);\n        row.push(-2);\n        row.push(0);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n       \
    \ row.push(-2);\n        row.push(-2);\n        row.push(-2);\n        row.push(-2);\n\
    \        row.push(-2);\n        row.push(-2);\n        row.\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpavn2r4ex.rs:108:3\n\
    \    |\n17  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n21  |     while let Some(row) = row_iter.next() {\n\
    \    |                                           - this delimiter might not be\
    \ properly closed...\n...\n98  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n108 | }\n    |   ^\n\nerror: unexpected token: `}`\n  -->\
    \ /tmp/tmpavn2r4ex.rs:98:1\n   |\n98 | }\n   | ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpavn2r4ex.rs:34:22\n   |\n34 |             row.push(cols.len());\n\
    \   |                      ^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n34 |             row.push(cols.len().try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpavn2r4ex.rs:37:13\n\
    \    |\n37  |         row.sort_by_key(|i| i, |j| j);\n    |             ^^^^^^^^^^^\
    \ -----  ----- supplied 2 arguments\n    |             |\n    |             expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpavn2r4ex.rs:39:18\n   |\n39 |         row.push(cols.len());\n\
    \   |                  ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |         row.push(cols.len().try_into().unwrap());\n   |    \
    \                        ++++++++++++++++++++\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n   --> /tmp/tmpavn2r4ex.rs:41:13\n\
    \    |\n41  |         row.sort_by_key(|i| i, |j| j);\n    |             ^^^^^^^^^^^\
    \ -----  ----- supplied 2 arguments\n    |             |\n    |             expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = vec![];\n    for row in lst {\n        for col\
    \ in row.iter().rev() {\n            if col == x {\n                coordinates.push((*row.iter().rev().next().unwrap(),\
    \ *col));\n            }\n        }\n    }\n    coordinates.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    coordinates.sort_by(|a, b| a.0.cmp(&b.0));\n    coordinates\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp4iy39abs.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans = vec![];\n    for r in lst {\n        if r.len() == x {\n\
    \            ans.push((r.len(), 0));\n        }\n    }\n    if ans.len() == 0\
    \ {\n        return vec![];\n    }\n    ans.sort_by(|a, b| a.1.cmp(&b.1));\n \
    \   for a in ans.iter() {\n        let mut b = a.1;\n        for r in lst {\n\
    \            match r[b] {\n                i if i == x => ans.insert(0, (i + r.len(),\
    \ 0)),\n                _ => (),\n            }\n        }\n    }\n    ans.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    ans.iter()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixoq5zp1.rs:20:23\n   |\n\
    20 |         if r.len() == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if r.len() == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpixoq5zp1.rs:32:51\n   |\n32 |                 i if i ==\
    \ x => ans.insert(0, (i + r.len(), 0)),\n   |                                \
    \                   ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpixoq5zp1.rs:32:47\n   |\n32 |                 i if i ==\
    \ x => ans.insert(0, (i + r.len(), 0)),\n   |                                \
    \               ^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n32 |                 i if i == x => ans.insert(0, ((i + r.len()).try_into().unwrap(),\
    \ 0)),\n   |                                               +           +++++++++++++++++++++\n\
    \nerror[E0277]: cannot add `usize` to `isize`\n  --> /tmp/tmpixoq5zp1.rs:32:49\n\
    \   |\n32 |                 i if i == x => ans.insert(0, (i + r.len(), 0)),\n\
    \   |                                                 ^ no implementation for\
    \ `isize + usize`\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixoq5zp1.rs:38:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of re"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    \n    let mut rows: Vec<(isize, isize)> = vec![(0, 0)];\n    \n    for\
    \ row in lst.iter() {\n        let mut row: Vec<(isize, isize)> = row;\n     \
    \   let mut cnt = 0;\n        let mut idx = 0;\n        \n        loop {\n   \
    \         if row[idx] == x {\n                rows.push(row);\n              \
    \  break;\n            }\n            \n            idx += 1;\n            cnt\
    \ += 1;\n        }\n        \n        cnt = cnt + (lst.len() - 1) * x;\n     \
    \   \n        rows.push((cnt, -x));\n    }\n    \n    rows.sort_by_key(|r| r[0]);\n\
    \    rows.sort_by_key(|r| -r[1]);\n    \n    rows\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0qyy19f.rs:22:44\n   |\n\
    22 |         let mut row: Vec<(isize, isize)> = row;\n   |                   \
    \   -------------------   ^^^ expected struct `Vec`, found `&Vec<isize>`\n   |\
    \                      |\n   |                      expected due to this\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n           found reference\
    \ `&Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk0qyy19f.rs:27:28\n\
    \   |\n27 |             if row[idx] == x {\n   |                            ^\
    \ expected tuple, found `isize`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \               found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk0qyy19f.rs:28:27\n\
    \   |\n28 |                 rows.push(row);\n   |                           ^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk0qyy19f.rs:36:39\n   |\n36 |         cnt = cnt + (lst.len()\
    \ - 1) * x;\n   |                                       ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmpk0qyy19f.rs:36:37\n\
    \   |\n36 |         cnt = cnt + (lst.len() - 1) * x;\n   |                   \
    \                  ^ no implementation for `usize * isize`\n   |\n   = help: the\
    \ trait `Mul<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk0qyy19f.rs:38:20\n   |\n38 |         rows.push((cnt, -x));\n\
    \   |                    ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n38 |         rows.push(("
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = vec![];\n    let mut rows_sorted = vec![];\n    let mut\
    \ cols_sorted = vec![];\n    for row in lst {\n        rows_sorted.push(row.iter().enumerate().map(|(v,\
    \ k)| (k, v.clone())));\n        let mut col_sorted = vec![];\n        for (col,\
    \ item) in row.iter().enumerate().map(|(v, k)| (k, v.clone())) {\n           \
    \ if item == x {\n                cols_sorted.push(col.clone());\n           \
    \ }\n        }\n        res.push(row_to_pair(rows_sorted.clone(), cols_sorted.clone()));\n\
    \    }\n    sort_pair(res);\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `row_to_pair` in this scope\n  --> /tmp/tmpz2lhejg6.rs:29:18\n\
    \   |\n29 |         res.push(row_to_pair(rows_sorted.clone(), cols_sorted.clone()));\n\
    \   |                  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_pair` in this scope\n  --> /tmp/tmpz2lhejg6.rs:31:5\n  \
    \ |\n31 |     sort_pair(res);\n   |     ^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz2lhejg6.rs:25:24\n   |\n25 |  \
    \           if item == x {\n   |                        ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |             if item == x.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let rows = lst.len();\n\
    \    let cols = lst[0].len();\n    let mut rows_sorted = vec![];\n    let mut\
    \ columns_sorted = vec![];\n    for j in 0..cols {\n        for r in 0..rows {\n\
    \            let (a, b) = ((r, j), (j, r));\n            if lst[r][j] == x {\n\
    \                result.push(a);\n                rows_sorted.push(r);\n     \
    \           columns_sorted.push(j);\n            }\n        }\n    }\n    if rows_sorted.len()\
    \ == 0 {\n        vec![]\n    } else if columns_sorted.len() == 0 {\n        vec![]\n\
    \    } else {\n        result.sort_unstable_by_key(|&(row, _)| rows_sorted.iter().position(|&i|\
    \ i == row).unwrap());\n        result.sort_unstable_by_key(|&(column, _)| columns_sorted.iter().position(|&i|\
    \ i == column).unwrap());\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpptjd9u27.rs:27:29\n   |\n\
    27 |                 result.push(a);\n   |                             ^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected tuple `(isize, isize)`\n \
    \             found tuple `(usize, usize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpptjd9u27.rs:38:87\n   |\n38 |         result.sort_unstable_by_key(|&(row,\
    \ _)| rows_sorted.iter().position(|&i| i == row).unwrap());\n   |            \
    \                                                                           ^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n38 |         result.sort_unstable_by_key(|&(row,\
    \ _)| rows_sorted.iter().position(|&i| i == row.try_into().unwrap()).unwrap());\n\
    \   |                                                                        \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpptjd9u27.rs:39:93\n   |\n39 |         result.sort_unstable_by_key(|&(column,\
    \ _)| columns_sorted.iter().position(|&i| i == column).unwrap());\n   |      \
    \                                                                            \
    \           ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    39 |         result.sort_unstable_by_key(|&(column, _)| columns_sorted.iter().position(|&i|\
    \ i == column.try_into().unwrap()).unwrap());\n   |                          \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter().enumerate().filter(|(i, x)| x == x).collect::<Vec<(isize,\
    \ isize)>>()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `(usize, &Vec<isize>)`\n    --> /tmp/tmp4hq235sv.rs:18:52\n\
    \     |\n18   |     lst.iter().enumerate().filter(|(i, x)| x == x).collect::<Vec<(isize,\
    \ isize)>>()\n     |                                                    ^^^^^^^\
    \ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ &Vec<isize>)>`\n     |\n     = help: the trait `FromIterator<(usize, &Vec<isize>)>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .map(|row| {\n            let mut row = row.to_vec();\n\
    \            row.sort();\n            row.sort_by_key(|i| -i);\n            row\n\
    \        })\n        .filter(|row| row[x] != 0)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4bppyztv.rs:25:23\n\
    \   |\n25 |         .filter(|row| row[x] != 0)\n   |                       ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `Vec<isize>`\n    --> /tmp/tmp4bppyztv.rs:26:10\n     |\n26\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<(isize, isize)>`\
    \ cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n     |\n     =\
    \ help: the trait `FromIterator<Vec<isize>>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coor = vec![];\n    let mut rows = vec![];\n    let mut cols\
    \ = vec![];\n    for row in lst {\n        let mut temp_cols = vec![];\n     \
    \   let mut temp_rows = vec![];\n        for col in row {\n            if col\
    \ == x {\n                temp_cols.push((col, row.len()));\n            }\n \
    \       }\n        temp_rows.sort_by(|a, b| a.cmp(b));\n        rows.push((temp_rows.len(),\
    \ temp_cols));\n        temp_cols.sort_by(|a, b| a.cmp(b));\n        cols.push((temp_cols,\
    \ temp_rows.len()));\n    }\n    rows.sort_by(|a, b| a.cmp(b));\n    cols.sort_by(|a,\
    \ b| b.cmp(a));\n    coor.push((rows, cols));\n    coor\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp6pohet6r.rs:29:28\n\
    \   |\n29 |         temp_rows.sort_by(|a, b| a.cmp(b));\n   |                \
    \            ^ consider giving this closure parameter the explicit type `&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    let mut col = 0;\n    for v in lst {\n   \
    \     row.push((v, col));\n        if col == x {\n            break;\n       \
    \ }\n        col += 1;\n    }\n    row.sort_by(|a, b| b.1.cmp_to(b.0));\n    row.iter().map(|&(_,\
    \ y)| (y, b.1.clone()).rev()).collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpuvjhnakq.rs:28:34\n\
    \   |\n28 |     row.iter().map(|&(_, y)| (y, b.1.clone()).rev()).collect()\n \
    \  |                                  ^ help: a local variable with a similar\
    \ name exists: `x`\n\nerror[E0599]: no method named `cmp_to` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpuvjhnakq.rs:27:28\n   |\n27 |     row.sort_by(|a,\
    \ b| b.1.cmp_to(b.0));\n   |                            ^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut new_lst = Vec::new();\n    for row in lst {\n        let mut\
    \ temp_row = row.clone();\n        let mut j = x;\n        temp_row.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n        temp_row.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\
    \        for (i, elem) in temp_row.iter().enumerate() {\n            if i == j\
    \ {\n                new_lst.push((i, j));\n            }\n        }\n    }\n\
    \    new_lst.sort_by(|a, b| b.0.partial_cmp(b.1).unwrap());\n    new_lst.sort_by(|a,\
    \ b| a.0.partial_cmp(a.1).unwrap());\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxhskz5pm.rs:25:21\n   |\n\
    25 |             if i == j {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |             if i == j.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxhskz5pm.rs:30:44\n   |\n30 |     new_lst.sort_by(|a, b|\
    \ b.0.partial_cmp(b.1).unwrap());\n   |                                      \
    \      ^^^ expected `&usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxhskz5pm.rs:31:44\n   |\n31 |     new_lst.sort_by(|a, b| a.0.partial_cmp(a.1).unwrap());\n\
    \   |                                            ^^^ expected `&usize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhskz5pm.rs:32:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n32 |     new_lst\n   |  \
    \   ^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<(isize, _)>`\n              found struct `Vec<(usize, _)>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = Vec::new();\n    let mut ix: Vec<isize> = Vec::new();\n\
    \    let mut iy: Vec<isize> = Vec::new();\n\n    for row in lst.iter() {\n   \
    \     ix = row.iter().enumerate().filter(|&(idx, _)| idx != x).collect();\n  \
    \      iy = row.iter().enumerate().filter(|&(_, idx)| idx != x).collect();\n \
    \       ret.push((ix.len(), iy.len()));\n    }\n\n    ret.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \n    for (_, i) in ret.into_iter().rev() {\n        let (cix, cjy) = i;\n   \
    \     let idx = cix.iter().enumerate().filter(|&(_, idx)| idx != x).count();\n\
    \        let cjx = cjy.iter().enumerate().filter(|&(_, idx)| idx != x).count();\n\
    \        ret.push((cjx.collect(), ciy.collect()));\n    }\n\n    ret\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ciy` in this scope\n  --> /tmp/tmpxdzw0mwm.rs:34:34\n\
    \   |\n34 |         ret.push((cjx.collect(), ciy.collect()));\n   |          \
    \                        ^^^ help: a local variable with a similar name exists:\
    \ `cix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxdzw0mwm.rs:23:63\n \
    \  |\n23 |         ix = row.iter().enumerate().filter(|&(idx, _)| idx != x).collect();\n\
    \   |                                                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |         ix = row.iter().enumerate().filter(|&(idx,\
    \ _)| idx != x.try_into().unwrap()).collect();\n   |                         \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `(usize, &isize)`\n    --> /tmp/tmpxdzw0mwm.rs:23:66\n     |\n23   |\
    \         ix = row.iter().enumerate().filter(|&(idx, _)| idx != x).collect();\n\
    \     |                                                                  ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(usize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpxdzw0mwm.rs:24:60\n   |\n\
    24 |         iy = row.iter().enumerate().filter(|&(_, idx)| idx != x).collect();\n\
    \   |                                                            ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be buil"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.iter().map(|x| x.clone());\n    rows = rows[..]\n\
    \        .iter()\n        .map(|row| row.iter().cloned().skip(x).collect::<Vec<_>>())\n\
    \        .collect::<Vec<_>>();\n    let mut cols = lst.iter().map(|x| x.clone());\n\
    \    cols = cols[..]\n        .iter()\n        .map(|col| col.iter().cloned().skip(x).collect::<Vec<_>>())\n\
    \        .collect::<Vec<_>>();\n    if rows.len() == 1 && cols.len() == 1 {\n\
    \        rows[0].sort_by_key(|r| r.0);\n        cols[0].sort_by_key(|c| c.0);\n\
    \    }\n    let mut res: Vec<(isize, isize)> = vec![];\n    for i in 0..rows.len()\
    \ {\n        let mut cols_sorted = cols.clone();\n        cols_sorted.sort_by_key(|c|\
    \ c.0);\n        for j in 0..cols_sorted.len() {\n            let row = rows[i];\n\
    \            let col = cols_sorted[j];\n            if col == x {\n          \
    \      res.push((i, j));\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_,\
    \ Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:18:35: 18:48]>`\n  --> /tmp/tmp6husl3x2.rs:19:12\n\
    \   |\n19 |     rows = rows[..]\n   |            ^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<std::slice::Iter<'_, Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:23:35:\
    \ 23:48]>`\n  --> /tmp/tmp6husl3x2.rs:24:12\n   |\n24 |     cols = cols[..]\n\
    \   |            ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_,\
    \ Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:18:35: 18:48]>`\n  --> /tmp/tmp6husl3x2.rs:29:9\n\
    \   |\n29 |         rows[0].sort_by_key(|r| r.0);\n   |         ^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Map<std::slice::Iter<'_, Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:23:35:\
    \ 23:48]>`\n  --> /tmp/tmp6husl3x2.rs:30:9\n   |\n30 |         cols[0].sort_by_key(|c|\
    \ c.0);\n   |         ^^^^^^^\n\nerror[E0599]: no method named `sort_by_key` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmp6husl3x2.rs:35:21\n   |\n\
    35 |         cols_sorted.sort_by_key(|c| c.0);\n   |                     ^^^^^^^^^^^\
    \ method not found in `Map<std::slice::Iter<'_, Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:23:35:\
    \ 23:48]>`\n\nerror[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_,\
    \ Vec<isize>>, [closure@/tmp/tmp6husl3x2.rs:18:35: 18:48]>`\n  --> /tmp/tmp6husl3x2.rs:37:23\n\
    \   |\n37 |             let row = rows[i];\n   |                       ^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Map<std::slice::Iter<'_, Vec<isize>>,\
    \ [closure@/tmp/tmp6husl3x2.rs:23:35: 23:48]>`\n  --> /tmp/tmp6husl3x2.rs:38:23\n\
    \   |\n38 |             let col = cols_sorted[j];\n   |                      \
    \ ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6husl3x2.rs:40:27\n\
    \   |\n40 |                 res.push((i, j));\n   |                          \
    \ ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n40 |        \
    \         res.push((i.try_into().unwrap(), j));\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = 0;\n    let mut col = 0;\n    let mut res = vec![];\n \
    \   let mut row_index = 1;\n    let mut col_index = 0;\n    while row != row_index\
    \ {\n        res.push(row_index, (col_index));\n        let mut row_index += 1;\n\
    \        let mut col_index += 1;\n        if col_index == lst.len() {\n      \
    \      col_index = 0;\n            row += 1;\n        }\n    }\n    res\n    \
    \    .iter()\n        .enumerate()\n        .sort((a, b) => (a[1].cmp(&b[1]) as\
    \ u32))\n        .sort((a, b) => (b[0].cmp(&a[0]) as u32))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: can't reassign to an uninitialized variable\n  --> /tmp/tmp5u67w4k_.rs:25:27\n\
    \   |\n25 |         let mut row_index += 1;\n   |                           ^^\
    \ help: initialize the variable\n   |\n   = help: if you meant to overwrite, remove\
    \ the `let` binding\n\nerror: can't reassign to an uninitialized variable\n  -->\
    \ /tmp/tmp5u67w4k_.rs:26:27\n   |\n26 |         let mut col_index += 1;\n   |\
    \                           ^^ help: initialize the variable\n   |\n   = help:\
    \ if you meant to overwrite, remove the `let` binding\n\nerror: expected one of\
    \ `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmp5u67w4k_.rs:35:22\n\
    \   |\n35 |         .sort((a, b) => (a[1].cmp(&b[1]) as u32))\n   |          \
    \            ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if !lst.is_empty() {\n        let mut coords = vec![];\n        coords.resize(lst.len(),\
    \ (x, 0));\n        for coord in &mut coords {\n            if let Some((i, col))\
    \ = find_index(&lst, coord) {\n                coord = coord.clone();\n      \
    \          coords[i] = coord.clone();\n                coord.set_y(coord.y() -\
    \ 1);\n            }\n        }\n        coords.sort_by_key(|&(x, y)| x.0);\n\
    \        coords.sort_by_key(|&(x, y)| -y.1);\n        let mut coord = vec![];\n\
    \        for coord in coords.into_iter().rev() {\n            coord.push((coord.0,\
    \ coord.1));\n        }\n        coord\n    } else {\n        vec![]\n    }\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_index` in this scope\n  --> /tmp/tmpz_dk18qr.rs:22:37\n\
    \   |\n22 |             if let Some((i, col)) = find_index(&lst, coord) {\n  \
    \ |                                     ^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz_dk18qr.rs:23:25\n   |\n21 |  \
    \       for coord in &mut coords {\n   |             ----- expected due to the\
    \ type of this binding\n22 |             if let Some((i, col)) = find_index(&lst,\
    \ coord) {\n23 |                 coord = coord.clone();\n   |                \
    \         ^^^^^^^^^^^^^ expected mutable reference, found tuple\n   |\n   = note:\
    \ expected mutable reference `&mut (isize, {integer})`\n                     \
    \     found tuple `(isize, {integer})`\nhelp: consider dereferencing here to assign\
    \ to the mutable borrowed piece of memory\n   |\n23 |                 *coord =\
    \ coord.clone();\n   |                 +\n\nerror[E0599]: no method named `set_y`\
    \ found for mutable reference `&mut (isize, {integer})` in the current scope\n\
    \  --> /tmp/tmpz_dk18qr.rs:25:23\n   |\n25 |                 coord.set_y(coord.y()\
    \ - 1);\n   |                       ^^^^^ method not found in `&mut (isize, {integer})`\n\
    \nerror[E0599]: no method named `y` found for mutable reference `&mut (isize,\
    \ {integer})` in the current scope\n  --> /tmp/tmpz_dk18qr.rs:25:35\n   |\n25\
    \ |                 coord.set_y(coord.y() - 1);\n   |                        \
    \           ^ method not found in `&mut (isize, {integer})`\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpz_dk18qr.rs:28:40\n\
    \   |\n28 |         coords.sort_by_key(|&(x, y)| x.0);\n   |                 \
    \                       ^\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpz_dk18qr.rs:29:41\n   |\n29 | \
    \        coords.sort_by_key(|&(x, y)| -y.1);\n   |                           \
    \              ^\n\nerror[E0599]: no method named `push` found for tuple `(isize,\
    \ {integer})` in the current scope\n  --> /tmp/tmpz_dk18qr.rs:32:19\n   |\n32\
    \ |             coord.push((coord.0,"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row_list = Vec::new();\n  \
    \  for row in lst {\n        if row.len() == x {\n            row_list.push(row);\n\
    \        }\n    }\n    row_list\n        .iter()\n        .filter(|&row| row.len()\
    \ == x)\n        .for_each(|row| {\n            let mut row_list = Vec::new();\n\
    \            for col in row.iter() {\n                let mut row_list = Vec::new();\n\
    \                if col == x {\n                    row_list.push((row, col));\n\
    \                }\n            }\n            result.push(row_list);\n      \
    \  });\n    sort_rows(result);\n    sort_columns(result);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmpbzfvpg6s.rs:38:5\n\
    \   |\n38 |     sort_rows(result);\n   |     ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sort_columns` in this scope\n  --> /tmp/tmpbzfvpg6s.rs:39:5\n\
    \   |\n39 |     sort_columns(result);\n   |     ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzfvpg6s.rs:21:25\n \
    \  |\n21 |         if row.len() == x {\n   |                         ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         if row.len()\
    \ == x.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbzfvpg6s.rs:27:37\n   |\n27 |\
    \         .filter(|&row| row.len() == x)\n   |                               \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n27 |      \
    \   .filter(|&row| row.len() == x.try_into().unwrap())\n   |                 \
    \                     ++++++++++++++++++++\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpbzfvpg6s.rs:32:24\n   |\n32 |                 if\
    \ col == x {\n   |                        ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzfvpg6s.rs:40:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n40 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found s"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = 0;\n    let mut idx = 0;\n    let mut coords: Vec<(isize,\
    \ isize)> = Vec::new();\n    let mut reversed_row: Vec<(isize, isize)> = Vec::new();\n\
    \n    for (i, item) in lst.iter().enumerate() {\n        if item == x {\n    \
    \        coords.push(i as (isize, isize));\n            idx += 1;\n        } else\
    \ {\n            if idx == row.len() {\n                idx -= 1;\n          \
    \      row += 1;\n            }\n            reversed_row.push((row, item as isize));\n\
    \        }\n    }\n    row.reverse();\n    reversed_row.reverse();\n    coords.sort_by(|a,\
    \ b| a.0 < b.0);\n    reversed_row.sort_by(|a, b| a.1 < b.1);\n    reversed_row\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&Vec<isize>` with `isize`\n  --> /tmp/tmpf5yc43ue.rs:24:17\n\
    \   |\n24 |         if item == x {\n   |                 ^^ no implementation\
    \ for `&Vec<isize> == isize`\n   |\n   = help: the trait `PartialEq<isize>` is\
    \ not implemented for `&Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpf5yc43ue.rs:28:27\n\
    \   |\n28 |             if idx == row.len() {\n   |                          \
    \ ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n\
    18 |     let mut row: i32 = 0;\n   |         ~~~~~~~~~~~~\n\nerror[E0599]: no\
    \ method named `reverse` found for type `isize` in the current scope\n  --> /tmp/tmpf5yc43ue.rs:35:9\n\
    \   |\n35 |     row.reverse();\n   |         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf5yc43ue.rs:37:27\n   |\n37 |     coords.sort_by(|a, b| a.0 < b.0);\n\
    \   |                           ^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5yc43ue.rs:38:33\n\
    \   |\n38 |     reversed_row.sort_by(|a, b| a.1 < b.1);\n   |                \
    \                 ^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0605]: non-primitive cast: `usize` as `(isize, isize)`\n  --> /tmp/tmpf5yc43ue.rs:25:25\n\
    \   |\n25 |             coords.push(i as (isize, isize));\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror[E0606]:\
    \ casting `&Vec<isize>` as `isize` is invalid\n  --> /tmp/tmpf5yc43ue.rs:32:37\n\
    \   |\n32 |             reversed_row.push((row, item as i"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = Vec::new();\n    for row in lst {\n        for\
    \ (i, e) in row.iter().enumerate().rev() {\n            if e == x {\n        \
    \        coordinates.push((i, 0));\n                break\n            }\n   \
    \     }\n    }\n    coordinates.sort_by_key(|(_, y)| *y);\n    coordinates.sort_by_key(|(_,\
    \ y)| *y, |(&i, _)| i).reverse();\n    coordinates\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpa4earp27.rs:21:18\n\
    \   |\n21 |             if e == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0061]: this function takes 1\
    \ argument but 2 arguments were supplied\n   --> /tmp/tmpa4earp27.rs:28:17\n \
    \   |\n28  |     coordinates.sort_by_key(|(_, y)| *y, |(&i, _)| i).reverse();\n\
    \    |                 ^^^^^^^^^^^ -----------  ----------- supplied 2 arguments\n\
    \    |                 |\n    |                 expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0599]: no method named `reverse`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpa4earp27.rs:28:55\n\
    \   |\n28 |     coordinates.sort_by_key(|(_, y)| *y, |(&i, _)| i).reverse();\n\
    \   |                                                       ^^^^^^^ method not\
    \ found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4earp27.rs:29:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     coordinates\n  \
    \ |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<(isize, isize)>`\n              found struct `Vec<(usize, {integer})>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = Vec::new();\n    let mut last_row:\
    \ Vec<isize> = Vec::new();\n    let mut last_col: Vec<isize> = Vec::new();\n \
    \   for col in lst.iter().rev() {\n        if col.len() == x {\n            if\
    \ last_row.len() == 0 {\n                last_row.push(0);\n                last_col.push(0);\n\
    \                ret.push((last_row, last_col));\n            } else {\n     \
    \           let (mut cur_row, mut cur_col) = last_row.clone();\n             \
    \   while cur_row < last_row.len() {\n                    cur_row[cur_row] = cur_row[cur_row]\
    \ + 1;\n                    cur_col[cur_col] = cur_col[cur_col] + 1;\n       \
    \             if cur_row[cur_row] == x {\n                        ret.push((cur_row,\
    \ cur_col));\n                        break;\n                    }\n        \
    \            cur_row[cur_row] = cur_row[cur_row] + 1;\n                    cur_col[cur_col]\
    \ = cur_col[cur_col] + 1;\n                }\n            }\n        }\n     \
    \   last_row.push(col.len());\n        last_col.push(0);\n    }\n    ret.sort_by_key(|&(k1,\
    \ v1)| {\n        k1.iter().rev().skip(v1).collect()\n    });\n    ret.sort_by_key(|&(k1,\
    \ v1)| {\n        k1.iter().rev().rev().skip(v1).collect()\n    });\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp827bmysv.rs:22:25\n   |\n\
    22 |         if col.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |         if col.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp827bmysv.rs:26:27\n   |\n26 |                 ret.push((last_row,\
    \ last_col));\n   |                           ^^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp827bmysv.rs:26:37\n\
    \   |\n26 |                 ret.push((last_row, last_col));\n   |            \
    \                         ^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp827bmysv.rs:28:21\n   |\n28 |              \
    \   let (mut cur_row, mut cur_col) = last_row.clone();\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---------------- this expression has type `Vec<isize>`\n\
    \   |                     |\n   |                     expected struct `Vec`, found\
    \ tuple\n   |\n   = note: expected struct `Vec<isize>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp827bmysv.rs:41:23\n\
    \   |\n41 |         last_row.push(col.len());\n   |                       ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n41 |         last_row.push(col.len().try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp827bmysv.rs:45:12\n\
    \   |\n45 |         k1.iter().rev().skip(v1).collect()\n   |            ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `iter` found for type\
    \ `isize` in the current scope\n  --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n\n    // sort coordinates initially by\
    \ rows in ascending order.\n    let mut rows = lst.into_iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n\
    \    let mut row_by_col: Vec<(isize, isize)> = rows.iter().enumerate().map(|(i,\
    \ row)| {\n        (i, row.iter().cloned()).collect::<Vec<_>>()\n    }).collect();\n\
    \    row_by_col.sort_by_key(|(_, row)| row.iter().cloned());\n\n    let mut cols\
    \ = row_by_col.iter().map(|(_, row)| row.iter().cloned()).collect::<Vec<_>>();\n\
    \    cols.sort_by_key(|(_, row)| row.iter().cloned());\n    cols.reverse();\n\n\
    \    let mut current_row = 0;\n    let mut current_col = 0;\n    let mut last_row_col:\
    \ (isize, isize) = (0, 0);\n\n    while current_row < row_by_col.len() {\n   \
    \     let row_len = row_by_col[current_row].len();\n        let next_row_len =\
    \ cols.len();\n        let (row_start, row_end) = row_by_col[current_row].split_at_mut(row_len);\n\
    \        let next_row_start = last_row_col;\n        if row_len > next_row_len\
    \ {\n            for (row_col, next_row_col) in next_row_end.zip(last_row_col.unchecked_add(next_row_len))\
    \ {\n                result.push((row_start.clone() + row_col, cols.clone() +\
    \ next_row_col));\n            }\n            current_row += 1;\n            last_row_col\
    \ = (0, 0);\n            next_row_end = cols.iter().cloned().skip(next_row_len).collect::<Vec<_>>();\n\
    \            cols.clear();\n        } else {\n            for (row_col, next_row_col)\
    \ in last_row_col.zip(next_row_start) {\n                result.push((row_start.clone()\
    \ + row_col, cols.clone() + next_row_col));\n            }\n            current_row\
    \ += 1;\n            last_row_col = row_start.clone() + row_len;\n           \
    \ next_row_start = last_row_col;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `next_row_end` in this scope\n  --> /tmp/tmp_v_hkqbh.rs:41:44\n\
    \   |\n41 |             for (row_col, next_row_col) in next_row_end.zip(last_row_col.unchecked_add(next_row_len))\
    \ {\n   |                                            ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `next_row_len`\n\nerror[E0425]: cannot\
    \ find value `next_row_end` in this scope\n  --> /tmp/tmp_v_hkqbh.rs:46:13\n \
    \  |\n46 |             next_row_end = cols.iter().cloned().skip(next_row_len).collect::<Vec<_>>();\n\
    \   |             ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `next_row_len`\n\nerror[E0599]: no method named `iter` found for reference `&Cloned<std::slice::Iter<'_,\
    \ isize>>` in the current scope\n  --> /tmp/tmp_v_hkqbh.rs:23:17\n   |\n23 | \
    \        (i, row.iter().cloned()).collect::<Vec<_>>()\n   |                 ^^^^\
    \ method not found in `&Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&isize` in the current scope\n \
    \ --> /tmp/tmp_v_hkqbh.rs:25:43\n   |\n25 |     row_by_col.sort_by_key(|(_, row)|\
    \ row.iter().cloned());\n   |                                           ^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `iter` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp_v_hkqbh.rs:27:57\n   |\n27 | \
    \    let mut cols = row_by_col.iter().map(|(_, row)| row.iter().cloned()).collect::<Vec<_>>();\n\
    \   |                                                         ^^^^ method not\
    \ found in `&isize`\n\nerror[E0599]: no method named `len` found for tuple `(isize,\
    \ isize)` in the current scope\n  --> /tmp/tmp_v_hkqbh.rs:36:47\n   |\n36 |  \
    \       let row_len = row_by_col[current_row].len();\n   |                   \
    \                            ^^^ method not found in `(isize, isize)`\n\nerror[E0599]:\
    \ no method named `split_at_mut` found for tuple `(isize, isize)` in the current\
    \ scope\n  --> /tmp/tmp_v_hkqbh.rs:38:60\n   |\n38 |         let (row_start, row_end)\
    \ = row_by_col[current_row].split_at_mut(row_len);\n   |                     \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n\n    for (row_no, row) in lst.iter().enumerate()\
    \ {\n        if row_no != 0 {\n            let mut row_sorted = vec![];\n\n  \
    \          for (col_no, col) in row.iter().enumerate() {\n                if col_no\
    \ != x {\n                    row_sorted.push((col_no, col));\n              \
    \  }\n            }\n            result.push(row_sorted.reverse());\n        }\n\
    \    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph73dukzq.rs:25:30\n   |\n\
    25 |                 if col_no != x {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |                 if\
    \ col_no != x.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph73dukzq.rs:33:5\n   |\n17 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n33 |     result\n   |     ^^^^^^ expected\
    \ tuple, found `()`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<()>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n    let mut row_index:\
    \ usize = lst.len() - 1;\n    let mut column_index: usize = lst[0].len() - 1;\n\
    \n    while row_index >= 0 && column_index >= 0 {\n        let row_slice = &lst[row_index][column_index..];\n\
    \n        if row_slice.contains(&x) {\n            return vec![((row_index, column_index),\
    \ (x, 0))];\n        }\n\n        if row_index < 0 {\n            row_index =\
    \ lst.len() - 1;\n        }\n\n        column -= 1;\n    }\n\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `column`\n  --> /tmp/tmpg72ecgmm.rs:36:9\n\
    \   |\n36 |         column -= 1;\n   |         ^^^^^^ not a value\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg72ecgmm.rs:29:26\n   |\n29 |             return\
    \ vec![((row_index, column_index), (x, 0))];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, usize)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg72ecgmm.rs:29:53\n   |\n29 |             return vec![((row_index, column_index),\
    \ (x, 0))];\n   |                                                     ^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(isize, {integer})`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0423.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans = Vec::new();\n    let mut row_map = HashMap::new();\n  \
    \  let mut col_map = HashMap::new();\n    let mut row = 0;\n    let mut col =\
    \ 0;\n    let mut idx = 0;\n    for elm in lst {\n        if elm.len() == 0 {\n\
    \            continue;\n        }\n        let mut cur_row: Vec<_> = elm.iter().cloned().collect();\n\
    \        cur_row.sort_by_key(|elm| elm.to_owned());\n        let mut cur_col:\
    \ Vec<_> = cur_row.iter().cloned().collect();\n        cur_col.sort_by_key(|elm|\
    \ elm.to_owned());\n        if cur_row[x].is_none() {\n            cur_row[x]\
    \ = Some(idx);\n            row_map.insert(cur_row[x], elm.clone());\n       \
    \     idx += 1;\n        } else {\n            if cur_col[x].is_none() {\n   \
    \             cur_col[x] = Some(idx);\n                col_map.insert(cur_col[x],\
    \ elm.clone());\n                idx += 1;\n            }\n        }\n    }\n\n\
    \    for (elm, idx) in row_map.iter().cloned().sort_by(|elm| elm.key()) {\n  \
    \      let mut col_num = idx;\n        while col_num >= 0 {\n            ans.push(\
    \ (idx, col_num) );\n            col_num -= 1;\n        }\n    }\n    for (elm,\
    \ idx) in col_map.iter().cloned().sort_by(|elm| elm.key()) {\n        let mut\
    \ row_num = idx;\n        while row_num >= 0 {\n            ans.push( (idx, row_num)\
    \ );\n            row_num -= 1;\n        }\n    }\n    ans.sort_by_key(|elm| elm.0);\n\
    \    ans\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9j9khheg.rs:19:23\n   |\n19 |     let mut row_map = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp9j9khheg.rs:20:23\n\
    \   |\n20 |     let mut col_map = HashMap::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9j9khheg.rs:32:12\n   |\n32 |  \
    \       if cur_row[x].is_none() {\n   |            ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9j9khheg.rs:33:13\n   |\n33 |            \
    \ cur_row[x] = Some(idx);\n   |             ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9j9khheg.rs:34:28\n   |\n34 |            \
    \ row_map.insert(cur_row[x], elm.clone());\n   |                            ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![(0, 0)].into_iter().collect();\n    let rows =\
    \ lst.len();\n    let columns = lst[0].len();\n    if rows == 0 || columns ==\
    \ 0 {\n        result.into_iter().map(|(_, row)| row).collect();\n    } else {\n\
    \        let mut cols = columns.iter().cloned().collect::<Vec<_>>();\n       \
    \ let mut rows = rows.iter().cloned().collect::<Vec<_>>();\n        let mut i\
    \ = rows;\n        while i >= 1 {\n            if cols[0] > x {\n            \
    \    rows[0] -= 1;\n                i -= 1;\n                cols[0] -= 1;\n \
    \           } else {\n                result.push((i, cols[0]));\n           \
    \     cols[0] -= 1;\n                i -= 1;\n            }\n        }\n    }\n\
    \    result.into_iter().map(|(i, j)| {\n        (i, j + 1)\n    }).collect();\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp686sy1d1.rs:22:9\n\
    \   |\n18 |     let mut result = vec![(0, 0)].into_iter().collect();\n   |   \
    \      ---------- consider giving `result` a type\n...\n22 |         result.into_iter().map(|(_,\
    \ row)| row).collect();\n   |         ^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0599]: no method named `iter` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmp686sy1d1.rs:24:32\n   |\n\
    24 |         let mut cols = columns.iter().cloned().collect::<Vec<_>>();\n   |\
    \                                ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `usize` in the current scope\n  --> /tmp/tmp686sy1d1.rs:25:29\n\
    \   |\n25 |         let mut rows = rows.iter().cloned().collect::<Vec<_>>();\n\
    \   |                             ^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp686sy1d1.rs:17:47\n   |\n17 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len();\n    let cols = lst[0].len();\n    let mut rows\
    \ = Vec::with_capacity(rows);\n    let mut cols = Vec::with_capacity(cols);\n\
    \    for i in 0..rows {\n        let mut row = vec![];\n        for j in 0..cols\
    \ {\n            if lst[i][j] == x {\n                row.push((i, j));\n    \
    \        }\n        }\n        rows.push(row);\n    }\n\n    rows\n        .iter()\n\
    \        .map(|row| row.iter().rev().collect::<Vec<(isize, isize)>>())\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp19c3mmpp.rs:22:17\n   |\n\
    22 |     for i in 0..rows {\n   |                 ^^^^ expected integer, found\
    \ struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found\
    \ struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp19c3mmpp.rs:24:21\n\
    \   |\n24 |         for j in 0..cols {\n   |                     ^^^^ expected\
    \ integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n  \
    \          found struct `Vec<_>`\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ isize)>` cannot be built from an iterator over elements of type `&(usize, usize)`\n\
    \    --> /tmp/tmp19c3mmpp.rs:34:37\n     |\n34   |         .map(|row| row.iter().rev().collect::<Vec<(isize,\
    \ isize)>>())\n     |                                     ^^^^^^^ value of type\
    \ `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=&(usize,\
    \ usize)>`\n     |\n     = help: the trait `FromIterator<&(usize, usize)>` is\
    \ not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `Vec<(isize, isize)>`\n    --> /tmp/tmp19c3mmpp.rs:35:10\n\
    \     |\n35   |         .collect()\n     |          ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=Vec<(isize, isize)>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<(isize, isize)>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len() - 1;\n    let cols = lst[0].len() - 1;\n    let\
    \ mut res: Vec<(isize, isize)> = vec![];\n\n    for row in 0..rows {\n       \
    \ let mut col = 0;\n        let mut tmp = 0;\n        let mut tmp_x = 0;\n\n \
    \       for el in &lst[row][col] {\n            if tmp != el {\n             \
    \   col = 0;\n            }\n\n            tmp = el;\n\n            tmp_x = tmp_x;\n\
    \            tmp_x += 1;\n        }\n\n        res.push((row + 1, col + tmp_x\
    \ - (col - tmp_x - 1)))\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmpn6olh2oz.rs:27:19\n\
    \   |\n27 |         for el in &lst[row][col] {\n   |                   ^^^^^^^^^^^^^^\
    \ `&isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6olh2oz.rs:38:19\n\
    \   |\n38 |         res.push((row + 1, col + tmp_x - (col - tmp_x - 1)))\n   |\
    \                   ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n38 |         res.push(((row + 1).try_into().unwrap(), col + tmp_x - (col\
    \ - tmp_x - 1)))\n   |                   +       +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn6olh2oz.rs:38:28\n   |\n38 |         res.push((row\
    \ + 1, col + tmp_x - (col - tmp_x - 1)))\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n38 |         res.push((row\
    \ + 1, (col + tmp_x - (col - tmp_x - 1)).try_into().unwrap()))\n   |         \
    \                   +                               +++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 || x == 0 || x&0x1 != 0 {\n        return Vec::new();\n\
    \    }\n\n    let mut row = vec![];\n    let mut row_len = lst.len();\n    let\
    \ mut row_len_by_column = lst.len();\n    let mut row_len_by_column_in_row = 0;\n\
    \    let mut row_len_by_column_in_row_by_column = 0;\n    let mut row_len_by_row_by_column\
    \ = 0;\n    let mut row_len_by_row_by_column_in_column = 0;\n\n    for i in 0..row_len\
    \ {\n        row_len_by_row_by_column += lst[i].len();\n        if row_len_by_row_by_column_in_column\
    \ == row_len_by_column {\n            row_len_by_row_by_column += 1;\n       \
    \     row_len_by_column_in_row += 1;\n            row_len_by_column_in_row_by_column\
    \ += 1;\n        } else {\n            row_len_by_column_in_row_by_column += 1;\n\
    \            row_len_by_row_by_column += 1;\n        }\n        row_len_by_row_by_column_in_column\
    \ += lst[i].len();\n        if row_len_by_column_in_row_by_column == row_len_by_row_by_column\
    \ {\n            row.push((i, row_len_by_column_in_row - 1));\n        }\n   \
    \ }\n\n    let mut column = vec![];\n    let mut column_len = lst.len();\n   \
    \ let mut column_len_by_row = lst.len();\n    let mut column_len_by_row_in_row\
    \ = 0;\n    let mut column_len_by_row_in_row_by_row = 0;\n    let mut column_len_by_row_by_column\
    \ = 0;\n    let mut column_len_by_row_by_column_in_row = 0;\n\n    for i in 0..row_len_by_column\
    \ {\n        column_len_by_row_by_column += lst[i].len();\n        if column_len_by_row_by_column_in_row\
    \ == column_len_by_row {\n            column_len_by_row_by_column += 1;\n    \
    \        column_len_by_row_in_row += 1;\n            column_len_by_row_in_row_by_column\
    \ += 1;\n        } else {\n            column_len_by_row_in_row_by_column += 1;\n\
    \            column_len_by_row_by_column += 1;\n        }\n        column_len_by_row_by_column_in_row\
    \ += lst[i].len();\n        if column_len_by_row_in_row_by_column == column_len_by_row_by_row\
    \ {\n            column.push((i, column_len_by_row_in_row - 1));\n        }\n\
    \    }\n\n    row.sort_by(|a, b| a.1.cmp(&b.1));\n    column.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    return row\n        .into_iter()\n        .chain(column)\n\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `column_len_by_row_in_row_by_column` in\
    \ this scope\n  --> /tmp/tmp854bt5n6.rs:59:13\n   |\n59 |             column_len_by_row_in_row_by_column\
    \ += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `column_len_by_row_in_row_by_row`\n\nerror[E0425]:\
    \ cannot find value `column_len_by_row_in_row_by_column` in this scope\n  -->\
    \ /tmp/tmp854bt5n6.rs:61:13\n   |\n61 |             column_len_by_row_in_row_by_column\
    \ += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `column_len_by_row_in_row_by_row`\n\nerror[E0425]:\
    \ cannot find value `column_len_by_row_in_row_by_column` in this scope\n  -->\
    \ /tmp/tmp854bt5n6.rs:65:12\n   |\n65 |         if column_len_by_row_in_row_by_column\
    \ == column_len_by_row_by_row {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `column_len_by_row_in_row_by_row`\n\
    \nerror[E0425]: cannot find value `column_len_by_row_by_row` in this scope\n \
    \ --> /tmp/tmp854bt5n6.rs:65:50\n   |\n65 |         if column_len_by_row_in_row_by_column\
    \ == column_len_by_row_by_row {\n   |                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `column_len_by_row_in_row`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp854bt5n6.rs:72:12\n   |\n17 |   fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \           ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n72 |       return row\n   |  ____________^\n73 | |         .into_iter()\n\
    74 | |         .chain(column)\n   | |______________________^ expected struct `Vec`,\
    \ found struct `std::iter::Chain`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `std::iter::Chain<std::vec::IntoIter<(usize,\
    \ {integer})>, std::vec::IntoIter<(usize, {integer})>>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Create a map to store the coordinates of all cells\n    // of the\
    \ form (row, column).\n    let mut map: HashMap<(isize, isize), usize> = HashMap::new();\n\
    \n    // For each element in the given list, iterate through it\n    // to find\
    \ the corresponding coordinates. Each element in the\n    // list is converted\
    \ to string so that we can compare them\n    // with x and check if they are equal.\n\
    \    for ele in lst {\n        map.insert(\n            (\n                ele.iter().map(|x|\
    \ x.to_string()).collect::<Vec<String>>(),\n                ele.iter().map(|y|\
    \ y.to_string()).collect::<Vec<String>>(),\n            ),\n            ele.iter().count(),\n\
    \        );\n    }\n\n    let mut counter: HashMap<isize, usize> = HashMap::new();\n\
    \    let mut max_counter: usize = 0;\n    // Get row with maximum number of cells\
    \ and record the\n    // coordinates of that cell.\n    for elem in map.keys()\
    \ {\n        if elem.1.unwrap() > max_counter {\n            max_counter = elem.1.unwrap();\n\
    \        }\n    }\n    let mut row: Vec<(isize, isize)> = vec![];\n    // Get\
    \ row with maximum number of cells and record the\n    // coordinates of that\
    \ cell.\n    for elem in map.keys() {\n        if elem.1.unwrap() == max_counter\
    \ {\n            // Get the coordinate corresponding to maximum\n            //\
    \ number of cells\n            let mut row = elem.0;\n            let mut counter\
    \ = elem.1;\n\n            // Check if there is any cell which contains x\n  \
    \          for (k, v) in map.iter() {\n                if counter.contains(&x.to_string())\
    \ {\n                    row = k;\n                    counter = v;\n        \
    \        }\n            }\n            // Update row and counter\n           \
    \ row.push((x, 0));\n            counter.unwrap() = counter.unwrap() + 1;\n  \
    \          // Check if row and counter are equal\n            for (k, v) in map.iter()\
    \ {\n                if row == k {\n                    counter = v;\n       \
    \         }\n            }\n            row.push((x, 0));\n            counter.unwrap()\
    \ = counter.unwrap() - 1;\n            row.sort();\n            row.sort();\n\
    \            row.push((x, 0));\n            counter.unwrap() = counter.unwrap()\
    \ - 1;\n            row.sort();\n            row.sort();\n            // Add the\
    \ row and its counter to the list\n            row.iter().for_each(|x| *x += 1);\n\
    \            row.iter().for_each(|x| *x += 1);\n            row.iter().for_each(|x|\
    \ *x += 1);\n            row.iter().for_each(|x| *x += 1);\n            row.iter().for_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph2i4g824.rs:95:3\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n48 |     for elem in map.keys() {\n   |           \
    \                 - unclosed delimiter\n49 |         if elem.1.unwrap() == max_counter\
    \ {\n   |                                           - this delimiter might not\
    \ be properly closed...\n...\n85 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n95 | }\n   |   ^\n\nerror[E0412]: cannot find type\
    \ `HashMap` in this scope\n  --> /tmp/tmph2i4g824.rs:20:18\n   |\n20 |     let\
    \ mut map: HashMap<(isize, isize), usize> = HashMap::new();\n   |            \
    \      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmph2i4g824.rs:20:51\n   |\n20\
    \ |     let mut map: HashMap<(isize, isize), usize> = HashMap::new();\n   |  \
    \                                                 ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmph2i4g824.rs:36:22\n\
    \   |\n36 |     let mut counter: HashMap<isize, usize> = HashMap::new();\n   |\
    \                      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmph2i4g824.rs:36:46\n\
    \   |\n36 |     let mut counter: HashMap<isize, usize> = HashMap::new();\n   |\
    \                                              ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmph2i4g824.rs:64:30\n\
    \   |\n64 |             counter.unwrap() = counter.unwrap() + 1;\n   |       \
    \      -----"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    for list in lst.iter().rev()\
    \ {\n        row.push(list.iter().enumerate().filter(|&(index, element)| element\
    \ == x).collect());\n    }\n    row.sort_by_key(|&(row, _)| row);\n    row.sort_by_key(|&(_,\
    \ column)| -column);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpku4a_zuu.rs:20:77\n\
    \   |\n20 |         row.push(list.iter().enumerate().filter(|&(index, element)|\
    \ element == x).collect());\n   |                                            \
    \                                 ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: a value of type `(isize, isize)` cannot be built\
    \ from an iterator over elements of type `(usize, &isize)`\n    --> /tmp/tmpku4a_zuu.rs:20:83\n\
    \     |\n20   |         row.push(list.iter().enumerate().filter(|&(index, element)|\
    \ element == x).collect());\n     |                                          \
    \                                         ^^^^^^^ value of type `(isize, isize)`\
    \ cannot be built from `std::iter::Iterator<Item=(usize, &isize)>`\n     |\n \
    \    = help: the trait `FromIterator<(usize, &isize)>` is not implemented for\
    \ `(isize, isize)`\n     = help: the trait `FromIterator<()>` is implemented for\
    \ `()`\nnote: required by a bound in `collect`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut ret: Vec<(isize, isize)> = Vec::new();\n\
    \n    let mut row_sorted = lst.clone();\n    row_sorted.sort();\n\n    for (i,\
    \ r) in row_sorted.iter().enumerate() {\n        let mut col_sorted = r.clone();\n\
    \        col_sorted.sort();\n\n        for (j, c) in col_sorted.iter().enumerate()\
    \ {\n            if c == x {\n                ret.push((i, j));\n            \
    \    break;\n            }\n        }\n    }\n\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6d25q_f5.rs:30:27\n   |\n\
    30 |                 ret.push((i, j));\n   |                           ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |                 ret.push((i.try_into().unwrap(),\
    \ j));\n   |                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6d25q_f5.rs:30:30\n   |\n30 |              \
    \   ret.push((i, j));\n   |                              ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n30 |                 ret.push((i, j.try_into().unwrap()));\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp6d25q_f5.rs:29:18\n   |\n29 | \
    \            if c == x {\n   |                  ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![(0, 0)];\n    let mut col = vec![(0, 0, 0)];\n   \
    \ for ((x, y), mut v) in lst.iter().zip2(&mut row) {\n        v.push((x, y));\n\
    \        if *v == x {\n            col.push((*v - x, *v + 1));\n        }\n  \
    \  }\n    col.sort_by(|a, b| b.0);\n    row.sort_by(|a, b| b.0);\n    row.iter().map(|x|\
    \ (*x, col.iter().filter(|&(_, c1)| c1 < x).map(|&(_, c2)| c2).sum()))\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpey3jao8j.rs:20:39\n   |\n20 |     for ((x,\
    \ y), mut v) in lst.iter().zip2(&mut row) {\n   |                            \
    \           ^^^^ method not found in `std::slice::Iter<'_, Vec<isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpey3jao8j.rs:23:22\n   |\n23 |             col.push((*v\
    \ - x, *v + 1));\n   |                      ^^^^^^^^^^^^^^^^ expected a tuple\
    \ with 3 elements, found one with 2 elements\n   |\n   = note: expected tuple\
    \ `({integer}, {integer}, {integer})`\n              found tuple `({integer},\
    \ {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpey3jao8j.rs:26:24\n\
    \   |\n26 |     col.sort_by(|a, b| b.0);\n   |                        ^^^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpey3jao8j.rs:27:24\n   |\n27 |     row.sort_by(|a, b| b.0);\n  \
    \ |                        ^^^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpey3jao8j.rs:28:49\n   |\n28 |\
    \     row.iter().map(|x| (*x, col.iter().filter(|&(_, c1)| c1 < x).map(|&(_, c2)|\
    \ c2).sum()))\n   |                                                 ^^^^^^-\n\
    \   |                                                 |     |\n   |          \
    \                                       |     expected due to this\n   |     \
    \                                            expected a tuple with 3 elements,\
    \ found one with 2 elements\n   |\n   = note: expected tuple `({integer}, {integer},\
    \ {integer})`\n              found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpey3jao8j.rs:28:72\n   |\n28 |     row.iter().map(|x| (*x,\
    \ col.iter().filter(|&(_, c1)| c1 < x).map(|&(_, c2)| c2).sum()))\n   |      \
    \                                                                  ^^^^^^-\n \
    \  |                                                                        |\
    \     |\n   |                                                                \
    \        |     expected due to this\n   |                         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    lst.sort_by(|a,\
    \ b| {\n        a.iter().cmp(&b.iter()).reverse().rev()\n    });\n    \n    let\
    \ mut rows: Vec<(isize, isize)> = vec![];\n    for row in lst {\n        let mut\
    \ cols: Vec<isize> = vec![];\n        for el in row {\n            if el == x\
    \ {\n                cols.push(x);\n            } else {\n                cols.push(el);\n\
    \            }\n        }\n        rows.push((row[0], row[1], cols));\n    }\n\
    \    \n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n    -->\
    \ /tmp/tmpb8ucbm3o.rs:18:37\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \     |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(*&b.iter()).reverse());\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-reference\n     |\n18   -     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    18   +     lst.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n     | \nhelp:\
    \ consider changing this borrow's mutability\n     |\n18   |     lst.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n     |                         \
    \            ~~~~\n\nerror[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n\
    \    --> /tmp/tmpb8ucbm3o.rs:20:22\n     |\n20   |         a.iter().cmp(&b.iter()).reverse().rev()\n\
    \     |                  --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>` is not an\
    \ iterator\n     |                  |\n     |                  required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, isize>`\nnote: required\
    \ by a bound in `std::iter::Iterator::cmp`\nhelp: consider dereferencing here\n\
    \     |\n20   |         a.iter().cmp(*&b.iter()).reverse().rev()\n     |     \
    \                 +\nhelp: consider removing the leading `&`-reference\n     |\n\
    20   -         a.iter().cmp(&b.iter()).reverse().rev()\n20   +       "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    debug_assert!(lst.len() >= 1);\n    debug_assert!(lst.len() <= 2);\n\
    \    let mut coords = vec![(x.0, 0)];\n    let mut row = vec![];\n    let mut\
    \ i = 0;\n    for row in lst {\n        let mut col_count = 1;\n        let mut\
    \ col_coord = 0;\n        let mut row_count = 0;\n        let mut row_coord =\
    \ 0;\n        let mut row_row_coord = 0;\n        let mut row_col_coord = 0;\n\
    \        for col in row {\n            if col == x {\n                row_count++;\n\
    \                row_coord = row_row_coord + col_coord;\n                row_col_coord\
    \ = row_col_coord + col_count;\n            }\n            if row_count == col_count\
    \ {\n                row_row_coord = row_row_coord + col_coord;\n            \
    \    row_col_coord = row_col_coord + col_count;\n            }\n            if\
    \ row_count == row_count + col_count {\n                row_row_coord = row_row_coord\
    \ + col_coord;\n                row_col_coord = row_col_coord + col_count;\n \
    \           }\n            col_count++;\n        }\n        coords.push((row_coord,\
    \ row_col_coord));\n    }\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1)).reverse();\n    coords\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpiz8d9pms.rs:32:26\n\
    \   |\n32 |                 row_count++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |       \
    \          { let tmp = row_count; row_count += 1; tmp };\n   |               \
    \  +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n32 -                 row_count++;\n\
    32 +                 row_count += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpiz8d9pms.rs:44:22\n   |\n44 |             col_count++;\n\
    \   |                      ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n44 |             { let tmp = col_count; col_count += 1; tmp\
    \ };\n   |             +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n44 -    \
    \         col_count++;\n44 +             col_count += 1;\n   | \n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpiz8d9pms.rs:20:30\n\
    \   |\n20 |     let mut coords = vec![(x.0, 0)];\n   |                       \
    \       ^\n\nerror[E0599]: no method named `reverse` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmpiz8d9pms.rs:49:42\n   |\n49 |     coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1)).reverse();\n   |                                         \
    \ ^^^^^^^ method not found in `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for row in lst {\n\
    \        if row.len() == x {\n            result.push((row.len() - 1, row.len()\
    \ - 1));\n        }\n    }\n    let mut sorted_rows = result.iter().cloned().collect::<Vec<(isize,\
    \ isize)>>();\n    sorted_rows.sort();\n    sorted_rows.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    sorted_rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5zwo80s.rs:20:25\n   |\n\
    20 |         if row.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if row.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf5zwo80s.rs:21:26\n   |\n21 |             result.push((row.len()\
    \ - 1, row.len() - 1));\n   |                          ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |             result.push(((row.len()\
    \ - 1).try_into().unwrap(), row.len() - 1));\n   |                          +\
    \             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5zwo80s.rs:21:41\n\
    \   |\n21 |             result.push((row.len() - 1, row.len() - 1));\n   |   \
    \                                      ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |             result.push((row.len() - 1, (row.len()\
    \ - 1).try_into().unwrap()));\n   |                                         +\
    \             +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len();\n    let cols = lst[0].len();\n\n    if rows <\
    \ x {\n        return vec![];\n    }\n\n    let mut row = (0, 0);\n    let mut\
    \ row_max = rows;\n\n    for _ in 0..rows {\n        let mut col = (0, 0);\n \
    \       let mut col_max = cols;\n\n        for row in 0..rows {\n            for\
    \ col in 0..cols {\n                if row == row && col == col {\n          \
    \          continue;\n                }\n\n                if row > row || col\
    \ > col {\n                    break;\n                }\n\n                if\
    \ row > row_max || col > col_max {\n                    row_max = row;\n     \
    \               col_max = col;\n                }\n\n                if row ==\
    \ row && col == col {\n                    col += 1;\n                    continue;\n\
    \                }\n\n                if row != row || col != col {\n        \
    \            break;\n                }\n\n                if row == row {\n  \
    \                  col += 1;\n                    continue;\n                }\n\
    \n                if col == col {\n                    row += 1;\n           \
    \         continue;\n                }\n\n                if row == row_max &&\
    \ col == col_max {\n                    break;\n                }\n          \
    \  }\n        }\n\n        if col > col_max {\n            break;\n        }\n\
    \n        if row == row_max && col == col_max {\n            break;\n        }\n\
    \n        row += 1;\n    }\n\n    return vec![((*row), (*col))].into_iter().map(|&(x,\
    \ y)| x).collect();\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmpbg4ae4he.rs:83:28\n\
    \   |\n83 |     return vec![((*row), (*col))].into_iter().map(|&(x, y)| x).collect();\n\
    \   |                            ^^^ help: a local variable with a similar name\
    \ exists: `cols`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg4ae4he.rs:21:15\n\
    \   |\n21 |     if rows < x {\n   |               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     if rows < x.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg4ae4he.rs:72:18\n\
    \   |\n72 |         if col > col_max {\n   |                  ^^^^^^^ expected\
    \ tuple, found `usize`\n   |\n   = note: expected tuple `({integer}, {integer})`\n\
    \               found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg4ae4he.rs:76:19\n\
    \   |\n76 |         if row == row_max && col == col_max {\n   |              \
    \     ^^^^^^^ expected tuple, found `usize`\n   |\n   = note: expected tuple `({integer},\
    \ {integer})`\n               found type `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbg4ae4he.rs:76:37\n   |\n76 |         if row == row_max && col\
    \ == col_max {\n   |                                     ^^^^^^^ expected tuple,\
    \ found `usize`\n   |\n   = note: expected tuple `({integer}, {integer})`\n  \
    \             found type `usize`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `({integer}, {integer})`\n  --> /tmp/tmpbg4ae4he.rs:80:9\n\
    \   |\n80 |         row += 1;\n   |         ---^^^^^\n   |         |\n   |   \
    \      cannot use `+=` on type `({integer}, {integer})`\n\nerror[E0614]: type\
    \ `({integer}, {integer})` cannot be dereferenced\n  --> /tmp/tmpbg4ae4he.rs:83:18\n\
    \   |\n83 |     return vec![((*row), (*col))].into_iter().map(|&(x, y)| x).collect();\n\
    \   |                  ^^^^^^\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0425, E0614.\nFor more\
    \ information about an error, try `rustc --explain E0308`"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter().flat_map(|row| {\n        row.iter().enumerate().sort_by_key(|(i,\
    \ _)| (row.len() - i, -i)).take(x).collect()\n    })\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Enumerate`\
    \ in the current scope\n  --> /tmp/tmpe0oyet5t.rs:19:32\n   |\n19 |         row.iter().enumerate().sort_by_key(|(i,\
    \ _)| (row.len() - i, -i)).take(x).collect()\n   |                           \
    \     ^^^^^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut ret:\
    \ Vec<(isize, isize)> = vec![];\n    let mut row_sort = vec![];\n    for i in\
    \ 0..(lst.len() - 1) {\n        if i == x {\n            let mut ret: Vec<(isize,\
    \ isize)> = vec![];\n            for i in 0..(lst[x].len() - 1) {\n          \
    \      let i = (*lst.clone()).get(i);\n                let j = (*lst.clone()).get(x\
    \ + 1);\n                let i1 = i;\n                let j1 = j;\n          \
    \      let i2 = i + 1;\n                let j2 = j + 1;\n                let i3\
    \ = i + 2;\n                let j3 = j + 2;\n                let i4 = i + 3;\n\
    \                let j4 = j + 3;\n                let i5 = i + 4;\n          \
    \      let j5 = j + 4;\n                let i6 = i + 5;\n                let j6\
    \ = j + 5;\n                let i7 = i + 6;\n                let j7 = j + 6;\n\
    \                let i8 = i + 7;\n                let j8 = j + 7;\n          \
    \      let i9 = i + 8;\n                let j9 = j + 8;\n                let i10\
    \ = i + 9;\n                let j10 = j + 9;\n                let i11 = i + 10;\n\
    \                let j11 = j + 10;\n                let i12 = i + 11;\n      \
    \          let j12 = j + 11;\n                let i13 = i + 12;\n            \
    \    let j13 = j + 12;\n                let i14 = i + 13;\n                let\
    \ j14 = j + 13;\n                let i15 = i + 14;\n                let j15 =\
    \ j + 14;\n                let i16 = i + 15;\n                let j16 = j + 15;\n\
    \                let i17 = i + 16;\n                let j17 = j + 16;\n      \
    \          let i18 = i + 17;\n                let i18 = j + 17;\n            \
    \    let i19 = i + 18;\n                let j19 = j + 18;\n                let\
    \ i20 = i + 19;\n                let j20 = j + 19;\n                let i21 =\
    \ i + 20;\n                let j21 = j + 20;\n                let i22 = i + 21;\n\
    \                let j22 = j + 21;\n                let i23 = i + 22;\n      \
    \          let j23 = j + 22;\n                let i24 = i + 23;\n            \
    \    let j24 = j + 23;\n                let i25 = i + 24;\n                let\
    \ j25 = \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpi8cjk09x.rs:89:3\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n23 |     for i in 0..(lst.len() - 1) {\n   |      \
    \                           - unclosed delimiter\n24 |         if i == x {\n \
    \  |                   - unclosed delimiter\n25 |             let mut ret: Vec<(isize,\
    \ isize)> = vec![];\n26 |             for i in 0..(lst[x].len() - 1) {\n   | \
    \                                           - this delimiter might not be properly\
    \ closed...\n...\n79 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpi8cjk09x.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi8cjk09x.rs:24:17\n   |\n24 |         if i == x {\n   |       \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n24 |      \
    \   if i == x.try_into().unwrap() {\n   |                  ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmpi8cjk09x.rs:26:26\n\
    \   |\n26 |             for i in 0..(lst[x].len() - 1) {\n   |               \
    \           ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\
    \nerror[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n   --> /tmp/tmpi8cjk09x.rs:28:44\n\
    \    |\n28  |                 let j = (*lst.clone()).get(x + 1);\n    |      \
    \                                  --- ^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n    |                                        |\n    |\
    \                                        required by a bound"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.iter().map(|e| e.iter().cloned()).collect::<Vec<_>>();\n\
    \    let mut res = vec![];\n    for row in lst {\n        for element in row.iter()\
    \ {\n            if element == x {\n                res.push((row.iter().cloned().collect::<Vec<_>>().len(),\
    \ element));\n            }\n        }\n    }\n    res.sort_by(|a, b| b[0] - a[0]);\n\
    \    res.sort_by(|a, b| b[1] - a[1]);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmp8pk9xwxu.rs:21:28\n   |\n21 |         for element in row.iter()\
    \ {\n   |                            ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmp8pk9xwxu.rs:23:31\n   |\n23 |             \
    \    res.push((row.iter().cloned().collect::<Vec<_>>().len(), element));\n   |\
    \                               ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // TODO: this can be done by sorting each row\n    let mut sorted_rows:\
    \ Vec<(isize, isize)> = Vec::new();\n    for row in lst {\n        let mut sorted_cols:\
    \ Vec<isize> = Vec::new();\n        for col in row.iter().rev() {\n          \
    \  sorted_cols.push(col);\n        }\n        sorted_rows.push((sorted_cols.iter().min(),\
    \ sorted_cols.iter().max()));\n    }\n\n    let mut ret: Vec<(isize, isize)> =\
    \ Vec::new();\n    for row in sorted_rows.iter().rev() {\n        let mut ret:\
    \ Vec<(isize, isize)> = Vec::new();\n        for row in sorted_rows.iter().rev()\
    \ {\n            if row[0] >= x && row[1] < x {\n                ret.push(row);\n\
    \            }\n        }\n        ret.sort();\n        ret.sort_by_key(|r| -r[0]);\n\
    \        if ret.is_empty() {\n            continue;\n        }\n        for x\
    \ in ret[0] {\n            if x >= x {\n                break;\n            }\n\
    \        }\n        let mut last_x: isize = x;\n        for x in ret[0] {\n  \
    \          if x > last_x {\n                last_x = x;\n            }\n     \
    \   }\n        for i in 0 .. ret.len() - 1 {\n            if ret[i][1] > last_x\
    \ {\n                ret[i] = (0, ret[i][1]);\n            }\n        }\n    \
    \    for i in 0 .. ret.len() - 1 {\n            if ret[i][1] < last_x {\n    \
    \            ret[i] = (ret[i][0], last_x);\n            }\n        }\n       \
    \ if ret.is_empty() {\n            continue;\n        }\n        for x in ret[0]\
    \ {\n            if x >= x {\n                break;\n            }\n        }\n\
    \        let mut last_x: isize = x;\n        for x in ret[0] {\n            if\
    \ x > last_x {\n                last_x = x;\n            }\n        }\n      \
    \  for i in 0 .. ret.len() - 1 {\n            if ret[i][1] > last_x {\n      \
    \          ret[i] = (0, ret[i][1]);\n            }\n        }\n        for i in\
    \ 0 .. ret.len() - 1 {\n            if ret[i][1] < last_x {\n                ret[i]\
    \ = (ret[i][0], last_x);\n            }\n        }\n        if ret.is_empty()\
    \ {\n            continue;\n        }\n        for x in ret[0] {\n           \
    \ if x >= x {\n                break;\n            }\n        }\n        let mut\
    \ last_x: isize = x;\n        for x in ret[0] {\n            if x > last_x {\n\
    \                last_x = x;\n            }\n        }\n        for i in 0 ..\
    \ ret.len() - 1 {\n            if ret[i][1] > last_x {\n                ret[i]\
    \ = (0, ret[i][1]);\n            }\n        }\n        for i in 0 .. ret.len()\
    \ - 1 {\n            if ret[i][1] < \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo98zxiia.rs:117:3\n\
    \    |\n17  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n29  |     for row in sorted_rows.iter().rev() {\n \
    \   |                                         - unclosed delimiter\n...\n105 |\
    \         for i in 0 .. ret.len() - 1 {\n    |                               \
    \      - this delimiter might not be properly closed...\n106 |             if\
    \ ret[i][1] < \n107 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n117 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpo98zxiia.rs:107:1\n\
    \    |\n107 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo98zxiia.rs:23:30\n   |\n23 |             sorted_cols.push(col);\n\
    \   |                              ^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |             sorted_cols.push(*col);\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo98zxiia.rs:25:27\n   |\n25 |         sorted_rows.push((sorted_cols.iter().min(),\
    \ sorted_cols.iter().max()));\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo98zxiia.rs:25:53\n   |\n25 |         sorted_rows.push((sorted_cols.iter().min(),\
    \ sorted_cols.iter().max()));\n   |                                          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n \
    \  |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0608]: cannot index into a value of type `&(isize, isize)`\n  --> /tmp/tmpo98zxiia.rs:32:16\n\
    \   |\n32 |             if row[0] >= x && row[1] < x {\n   |                ^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `&(isize, isize)`\n  --> /tmp/tmpo98zxiia.rs:32:31\n\
    \   |\n32 |             if row"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = vec![];\n    for (i, row_lst) in\
    \ lst.iter().enumerate() {\n        let mut row: Vec<isize> = vec![];\n      \
    \  for (j, val) in row_lst.iter().enumerate().rev() {\n            if val == x\
    \ {\n                row.push((i, j));\n            }\n        }\n        if row.len()\
    \ > 0 {\n            rows.push(row);\n        }\n    }\n    sort_by_row(rows);\n\
    \    rows.iter().map(|vec| vec.clone().reverse()).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_row` in this scope\n  --> /tmp/tmpakof4m1w.rs:30:5\n\
    \   |\n30 |     sort_by_row(rows);\n   |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpakof4m1w.rs:23:26\n   |\n23 |\
    \                 row.push((i, j));\n   |                          ^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(usize, usize)`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpakof4m1w.rs:22:20\n   |\n22 |             if val == x {\n   | \
    \                   ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpakof4m1w.rs:27:23\n   |\n27 |\
    \             rows.push(row);\n   |                       ^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n     \
    \        found struct `Vec<isize>`\n\nerror[E0599]: no method named `reverse`\
    \ found for tuple `(isize, isize)` in the current scope\n  --> /tmp/tmpakof4m1w.rs:31:39\n\
    \   |\n31 |     rows.iter().map(|vec| vec.clone().reverse()).collect()\n   | \
    \                                      ^^^^^^^ method not found in `(isize, isize)`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut r = vec![];\n    for v in lst {\n        if v.len() > x {\n \
    \           continue;\n        }\n        r.push((v.len() - x, 0));\n    }\n \
    \   r.sort_by(|a, b| b.1.cmp(&a.1));\n    r.sort_by(|a, b| b.1.cmp(&a.1));\n \
    \   r\n        .iter()\n        .map(|(_, c)| c)\n        .collect::<Vec<(isize,\
    \ isize)>>()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9112oya1.rs:20:22\n   |\n\
    20 |         if v.len() > x {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |         if v.len() > x.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9112oya1.rs:23:27\n   |\n23 |         r.push((v.len() -\
    \ x, 0));\n   |                           ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp9112oya1.rs:23:25\n\
    \   |\n23 |         r.push((v.len() - x, 0));\n   |                         ^\
    \ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: a value of type `Vec<(isize, isize)>`\
    \ cannot be built from an iterator over elements of type `&{integer}`\n    -->\
    \ /tmp/tmp9112oya1.rs:30:10\n     |\n30   |         .collect::<Vec<(isize, isize)>>()\n\
    \     |          ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from\
    \ `std::iter::Iterator<Item=&{integer}>`\n     |\n     = help: the trait `FromIterator<&{integer}>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n    let mut\
    \ row = Vec::new();\n    for row in lst {\n        if row.is_empty() {\n     \
    \       continue;\n        }\n        let mut col = Vec::new();\n        for element\
    \ in row {\n            if element == x {\n                col.push((row, element));\n\
    \            }\n        }\n        row.sort_by(|a, b| a.partial_cmp(b).reverse());\n\
    \        row.sort_by(|a, b| b.partial_cmp(a).reverse());\n        row.sort_by(|a,\
    \ b| a.partial_cmp(b).reverse());\n        row.push((row, col));\n    }\n    row\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpo7p7l0nt.rs:33:45\n   |\n33 |         row.sort_by(|a,\
    \ b| a.partial_cmp(b).reverse());\n   |                                      \
    \       ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpo7p7l0nt.rs:34:45\n   |\n34 |         row.sort_by(|a, b| b.partial_cmp(a).reverse());\n\
    \   |                                             ^^^^^^^ method not found in\
    \ `Option<std::cmp::Ordering>`\n\nerror[E0599]: no method named `reverse` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpo7p7l0nt.rs:35:45\n  \
    \ |\n35 |         row.sort_by(|a, b| a.partial_cmp(b).reverse());\n   |      \
    \                                       ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo7p7l0nt.rs:36:18\n   |\n36 |\
    \         row.push((row, col));\n   |                  ^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(Vec<isize>, Vec<(Vec<isize>, isize)>)`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Get list of indices\n    let mut indices = vec![];\n    loop {\n \
    \       if indices.is_empty() {\n            break Some(vec![]);\n        }\n\
    \        let row_index = indices[0];\n        indices.remove(0);\n        let\
    \ col_index = indices[0];\n        indices.remove(0);\n        if row_index ==\
    \ row_index + 1 && col_index == col_index + 1 {\n            break Some(vec![(row_index,\
    \ col_index)]);\n        }\n    }\n    // Get row\n    let mut row = vec![];\n\
    \    for row in lst {\n        if row.len() == col {\n            break;\n   \
    \     }\n    }\n    // Check if x is in this row\n    for (_, col) in row.iter().enumerate()\
    \ {\n        if col == x {\n            return vec![];\n        }\n    }\n   \
    \ return vec![];\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmps5zgvtdq.rs:35:25\n\
    \   |\n35 |         if row.len() == col {\n   |                         ^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5zgvtdq.rs:22:19\n\
    \   |\n22 |             break Some(vec![]);\n   |                   ^^^^^^^^^^^^\
    \ expected `()`, found enum `Option`\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<Vec<_>>`\n\nerror[E0277]: can't compare\
    \ `&_` with `isize`\n  --> /tmp/tmps5zgvtdq.rs:41:16\n   |\n41 |         if col\
    \ == x {\n   |                ^^ no implementation for `&_ == isize`\n   |\n \
    \  = help: the trait `PartialEq<isize>` is not implemented for `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    for row in lst {\n        let coord\
    \ = row.iter().enumerate().filter(|(a, b)| a.1 == x).collect::<Vec<_>>();\n  \
    \      for coord in coord {\n            coords.push(coord);\n        }\n    }\n\
    \    coords.sort_by(|a, b| a.0.cmp(&b.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `1` on type `&usize`\n  --> /tmp/tmpb2xqx8u8.rs:20:62\n\
    \   |\n20 |         let coord = row.iter().enumerate().filter(|(a, b)| a.1 ==\
    \ x).collect::<Vec<_>>();\n   |                                              \
    \                ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2xqx8u8.rs:27:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n27 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, &isize)>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    for row in lst.iter()\
    \ {\n        for elm in row {\n            if elm == x {\n                rows.push((row.iter().position(|x|\
    \ x == x).unwrap_or(0), row.iter().position(|x| x == x).unwrap_or(0)));\n    \
    \        }\n        }\n    }\n    let mut reversed_rows = rows.iter().cloned().rev();\n\
    \    reversed_rows.sort_by(|a, b| a.1.cmp(b.1));\n    reversed_rows.sort_by(|a,\
    \ b| b.1.cmp(b.2));\n    reversed_rows\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpv1fi436u.rs:21:20\n\
    \   |\n21 |             if elm == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv1fi436u.rs:22:28\n   |\n22 |                 rows.push((row.iter().position(|x|\
    \ x == x).unwrap_or(0), row.iter().position(|x| x == x).unwrap_or(0)));\n   |\
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |                 rows.push((row.iter().position(|x|\
    \ x == x).unwrap_or(0).try_into().unwrap(), row.iter().position(|x| x == x).unwrap_or(0)));\n\
    \   |                                                                        ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv1fi436u.rs:22:74\n   |\n22 |\
    \                 rows.push((row.iter().position(|x| x == x).unwrap_or(0), row.iter().position(|x|\
    \ x == x).unwrap_or(0)));\n   |                                              \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |                 rows.push((row.iter().position(|x|\
    \ x == x).unwrap_or(0), row.iter().position(|x| x == x).unwrap_or(0).try_into().unwrap()));\n\
    \   |                                                                        \
    \                                              ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Rev` in the current scope\n  -->\
    \ /tmp/tmpv1fi436u.rs:27:19\n   |\n27 |     reversed_rows.sort_by(|a, b| a.1.c"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = vec![];\n    let mut row_x = vec![0; lst.len()];\n    let\
    \ mut row_y = vec![0; lst.len()];\n    let mut counter = 0;\n    for row in lst\
    \ {\n        row_x[counter] = counter;\n        row_y[counter] = row.len() - x;\n\
    \        counter += 1;\n    }\n    res\n        .push(row_x.iter().map(|i| i as\
    \ (isize, isize)).collect::<Vec<_>>())\n        .push(row_y.iter().map(|i| i as\
    \ (isize, isize)).collect::<Vec<_>>());\n    res\n        .iter()\n        .cloned()\n\
    \        .sort_by(|a, b| a.1.cmp(&b.1))\n        .map(|(a0, b0)| a0.iter().zip(&b0).collect::<Vec<_>>())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcuniwo80.rs:24:38\n   |\n\
    24 |         row_y[counter] = row.len() - x;\n   |                           \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `isize` from `usize`\n  --> /tmp/tmpcuniwo80.rs:24:36\n   |\n24 |         row_y[counter]\
    \ = row.len() - x;\n   |                                    ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0599]: no method named `push` found for unit type `()` in\
    \ the current scope\n  --> /tmp/tmpcuniwo80.rs:29:10\n   |\n29 |         .push(row_y.iter().map(|i|\
    \ i as (isize, isize)).collect::<Vec<_>>());\n   |          ^^^^ method not found\
    \ in `()`\n\nerror[E0599]: no method named `sort_by` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpcuniwo80.rs:33:10\n   |\n33 |         .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ Vec<(isize, isize)>>>`\n\nerror[E0605]: non-primitive cast: `&usize` as `(isize,\
    \ isize)`\n  --> /tmp/tmpcuniwo80.rs:28:36\n   |\n28 |         .push(row_x.iter().map(|i|\
    \ i as (isize, isize)).collect::<Vec<_>>())\n   |                            \
    \        ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive\
    \ cast: `&usize` as `(isize, isize)`\n  --> /tmp/tmpcuniwo80.rs:29:36\n   |\n\
    29 |         .push(row_y.iter().map(|i| i as (isize, isize)).collect::<Vec<_>>());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a spe"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = Vec::new();\n    let mut row = Vec::new();\n  \
    \  for column in lst {\n        if !row.contains(column[x]) {\n            row.push(column[x]);\n\
    \            coordinates.push((row.len(), column[x]));\n        }\n    }\n   \
    \ coordinates.sort_by(|a, b| a.0 as isize - b.0 as isize);\n    coordinates.sort_by(|a,\
    \ b| a.1 as isize - b.1 as isize).reverse();\n    coordinates\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyx_ip_9a.rs:21:26\n\
    \   |\n21 |         if !row.contains(column[x]) {\n   |                      \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyx_ip_9a.rs:22:22\n\
    \   |\n22 |             row.push(column[x]);\n   |                      ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyx_ip_9a.rs:23:42\n\
    \   |\n23 |             coordinates.push((row.len(), column[x]));\n   |      \
    \                                    ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx_ip_9a.rs:26:32\n\
    \   |\n26 |     coordinates.sort_by(|a, b| a.0 as isize - b.0 as isize);\n   |\
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx_ip_9a.rs:27:32\n\
    \   |\n27 |     coordinates.sort_by(|a, b| a.1 as isize - b.1 as isize).reverse();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found `isize`\n\nerror[E0599]: no method named `reverse`\
    \ found for unit type `()` in the current sco"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    for row in lst {\n        let mut ret2 = vec![];\n\
    \        let mut ret3 = vec![];\n        let mut row_len = row.len();\n      \
    \  let mut row_col = row.len();\n        for _ in 0..row_len {\n            ret2.push((row_col,\
    \ row_len));\n            ret3.push((row_len, row_col));\n            row_col\
    \ -= 1;\n        }\n        ret.push((row.to_vec(), ret2.to_vec()));\n       \
    \ ret.push((row.to_vec(), ret3.to_vec()));\n    }\n    let mut ret2 = vec![];\n\
    \    let mut ret3 = vec![];\n    let mut row_len = ret.len();\n    let mut row_col\
    \ = ret.len();\n    for _ in 0..row_len {\n        ret2.push((row_col, row_len));\n\
    \        ret3.push((row_len, row_col));\n        row_col -= 1;\n    }\n    ret.push((lst.to_vec(),\
    \ ret2.to_vec()));\n    ret.push((lst.to_vec(), ret3.to_vec()));\n    let mut\
    \ ret4 = vec![];\n    for _ in 0..row_len {\n        ret4.push((row_col, row_len));\n\
    \    }\n    ret.push((vec![], ret4.to_vec()));\n    for i in ret.iter() {\n  \
    \      if i[0].find(x) != i[0].end() {\n            return i;\n        }\n   \
    \ }\n    return ret;\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppo5xefht.rs:41:15\n   |\n\
    41 |     ret.push((lst.to_vec(), ret2.to_vec()));\n   |               ^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<isize>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppo5xefht.rs:42:15\n   |\n42 |     ret.push((lst.to_vec(), ret3.to_vec()));\n\
    \   |               ^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\
    \nerror[E0608]: cannot index into a value of type `&(Vec<isize>, Vec<(usize, usize)>)`\n\
    \  --> /tmp/tmppo5xefht.rs:49:12\n   |\n49 |         if i[0].find(x) != i[0].end()\
    \ {\n   |            ^^^^\n\nerror[E0608]: cannot index into a value of type `&(Vec<isize>,\
    \ Vec<(usize, usize)>)`\n  --> /tmp/tmppo5xefht.rs:49:28\n   |\n49 |         if\
    \ i[0].find(x) != i[0].end() {\n   |                            ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppo5xefht.rs:50:20\n   |\n50 |             return\
    \ i;\n   |                    ^ expected struct `Vec`, found reference\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n           found reference\
    \ `&(Vec<isize>, Vec<(usize, usize)>)`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = [(0, 0); (0, 0); (0, 0)];\n    for ele in lst {\n     \
    \   let (row1, col1) = row;\n        let (row2, col2) = ele;\n        if col1\
    \ <= x && x <= col2 {\n            row = ((row1, col1), (row2, col2));\n     \
    \   } else {\n            row = (row1, row2);\n        }\n    }\n    row.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `;`\n  -->\
    \ /tmp/tmpljrnwsxi.rs:18:34\n   |\n18 |     let mut row = [(0, 0); (0, 0); (0,\
    \ 0)];\n   |                                  ^ expected one of `.`, `?`, `]`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::with_capacity(lst.len());\n    let mut row_cols: Vec<isize>\
    \ = Vec::new();\n    row.push(row_cols);\n    for row in lst {\n        if !row.contains(&x)\
    \ && row.len() != 0 {\n            row_cols.push(x);\n            row.push(x)\n\
    \        }\n    }\n    row.sort();\n    row.sort();\n    row.sort_by_key(|&(x,\
    \ y)| x.cmp(y));\n    row.into_iter().map(|row| row.clone()).collect()\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdy93panx.rs:29:23\n   |\n\
    29 |     row.sort_by_key(|&(x, y)| x.cmp(y));\n   |                       ^^^^^-\n\
    \   |                       |    |\n   |                       |    expected due\
    \ to this\n   |                       expected struct `Vec`, found tuple\n   |\n\
    \   = note: expected struct `Vec<isize>`\n               found tuple `(_, _)`\n\
    \nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from an\
    \ iterator over elements of type `Vec<isize>`\n    --> /tmp/tmpdy93panx.rs:30:44\n\
    \     |\n30   |     row.into_iter().map(|row| row.clone()).collect()\n     | \
    \                                           ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n     |\n\
    \     = help: the trait `FromIterator<Vec<isize>>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter().zip(0..lst[0].len()).filter(|&((_, y), x)| x == x).cloned().collect::<Vec<_>>()\n\
    \        .sort_by(|&((_, y), _), &((_, _), z)| -y).reverse().sort_by(|&((_, y),\
    \ _), &((_, _), z)| -z)\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5gb8_y1a.rs:18:47\n   |\n\
    18 |     lst.iter().zip(0..lst[0].len()).filter(|&((_, y), x)| x == x).cloned().collect::<Vec<_>>()\n\
    \   |                                               ^^^^^^   - expected due to\
    \ this\n   |                                               |\n   |           \
    \                                    expected struct `Vec`, found tuple\n   |\n\
    \   = note: expected struct `Vec<isize>`\n               found tuple `(_, _)`\n\
    \nerror[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_, Vec<isize>>,\
    \ std::ops::Range<usize>>, [closure@/tmp/tmp5gb8_y1a.rs:18:44: 18:65]> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp5gb8_y1a.rs:18:67\n     |\n18   |     lst.iter().zip(0..lst[0].len()).filter(|&((_,\
    \ y), x)| x == x).cloned().collect::<Vec<_>>()\n     |                       \
    \                                            ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(&Vec<isize>, usize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ Vec<isize>>, std::ops::Range<usize>>, [closure@/tmp/tmp5gb8_y1a.rs:18:44: 18:65]>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp5gb8_y1a.rs:18:76\n \
    \  |\n18 |        lst.iter().zip(0..lst[0].len()).filter(|&((_, y), x)| x == x).cloned().collect::<Vec<_>>()\n\
    \   |                                                                        \
    \       ^^^^^^^ method cannot be called on `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ Vec<isize>>, std::ops::Range<usize>>, [closure@/tmp/tmp5gb8_y1a.rs:18:44: 18:65]>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Filter<Zip<std::slice::Iter<'_, Vec<isize>>,\
    \ std::ops::Range<usize>>, [closure@/tmp/tmp5gb8_y1a.rs:18:44: 18:65]> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ Vec<isize>>, std::ops::Range<usize>>, [closure@/tmp/tmp5gb8_y1a.rs:18:44: 18:65]>>: "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst\n        .iter()\n        .enumerate()\n        .filter_map(|(row,\
    \ i)| {\n            Vec::from(row)\n                .iter()\n               \
    \ .enumerate()\n                .filter_map(|(column, j)| {\n                \
    \    if i == j {\n                        Some((i + x, j + x))\n             \
    \       } else {\n                        None\n                    }\n      \
    \          })\n                .collect::<Vec<_>>()\n        })\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Vec<_, _>: From<usize>` is not satisfied\n\
    \  --> /tmp/tmpbyapxnuu.rs:22:13\n   |\n22 |             Vec::from(row)\n   |\
    \             ^^^^^^^^^ the trait `From<usize>` is not implemented for `Vec<_,\
    \ _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T,\
    \ A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut\
    \ [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as\
    \ From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8>\
    \ as From<&str>>\n           and 2 others\n\nerror[E0369]: cannot add `isize`\
    \ to `&Vec<isize>`\n  --> /tmp/tmpbyapxnuu.rs:27:33\n   |\n27 |              \
    \           Some((i + x, j + x))\n   |                               - ^ - isize\n\
    \   |                               |\n   |                               &Vec<isize>\n\
    \nerror[E0277]: can't compare `Vec<isize>` with `isize`\n  --> /tmp/tmpbyapxnuu.rs:26:26\n\
    \   |\n26 |                     if i == j {\n   |                          ^^\
    \ no implementation for `Vec<isize> == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&isize>` for `&Vec<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbyapxnuu.rs:22:13\n   |\n22 | /\
    \             Vec::from(row)\n23 | |                 .iter()\n24 | |         \
    \        .enumerate()\n25 | |                 .filter_map(|(column, j)| {\n...\
    \  |\n31 | |                 })\n32 | |                 .collect::<Vec<_>>()\n\
    \   | |____________________________________^ expected enum `Option`, found struct\
    \ `Vec`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    for i in 0..lst.len() {\n        let mut\
    \ row: Vec<(isize, isize)> = vec![];\n        for (j, elem) in &lst[i].iter()\
    \ {\n            if elem == x {\n                row.push((i, j));\n         \
    \   }\n        }\n        coords.extend_from_slice(row);\n    }\n    coords.sort_by(|x,\
    \ y| x.0.cmp(y.0));\n    coords.sort_by(|x, y| y.0.cmp(x.0));\n    coords.reverse();\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n  -->\
    \ /tmp/tmp1wetwfz_.rs:21:26\n   |\n21 |         for (j, elem) in &lst[i].iter()\
    \ {\n   |                          -^^^^^^^^^^^^^\n   |                      \
    \    |\n   |                          `&std::slice::Iter<'_, isize>` is not an\
    \ iterator\n   |                          help: consider removing the leading\
    \ `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&std::slice::Iter<'_, isize>`\n   = note: `Iterator` is implemented for `&mut\
    \ std::slice::Iter<'_, isize>`, but not for `&std::slice::Iter<'_, isize>`\n \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1wetwfz_.rs:23:27\n   |\n23 |                 row.push((i, j));\n  \
    \ |                           ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |                 row.push((i.try_into().unwrap(), j));\n   |\
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1wetwfz_.rs:26:34\n   |\n26 |         coords.extend_from_slice(row);\n\
    \   |                                  ^^^\n   |                             \
    \     |\n   |                                  expected `&[_]`, found struct `Vec`\n\
    \   |                                  help: consider borrowing here: `&row`\n\
    \   |\n   = note: expected reference `&[_]`\n                 found struct `Vec<(isize,\
    \ isize)>`\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmp1wetwfz_.rs:28:29\n\
    \   |\n28 |     coords.sort_by(|x, y| x.0.cmp(y.0));\n   |                   \
    \          ^\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n    let mut row:\
    \ Vec<(isize, isize)> = vec![];\n    let mut column_idx = 0;\n    let mut row_idx\
    \ = 0;\n\n    while row_idx < lst.len() {\n        let curr_row = lst[row_idx];\n\
    \n        if curr_row.len() < column_idx {\n            break;\n        }\n\n\
    \        let curr_row = curr_row[column_idx..];\n\n        if curr_row.iter().all(|x|\
    \ *x == x) {\n            row.push((row_idx, column_idx));\n        }\n\n    \
    \    column_idx += 1;\n        row_idx += 1;\n    }\n\n    row.sort();\n\n   \
    \ let mut sorted = vec![];\n\n    for row in row.iter().cloned() {\n        let\
    \ row_idx = row.0; // row index\n        let column_idx = row.1; // column index\n\
    \n        let mut col_coord = column_idx;\n        let mut row_coord = row_idx;\n\
    \        while col_coord > 0 && col_coord < lst.len() {\n            let row =\
    \ lst[row_coord];\n            let cell = row[col_coord];\n            if cell\
    \ == x {\n                sorted.push((row_coord, column_coord));\n          \
    \  }\n            row_coord += 1;\n            col_coord += 1;\n        }\n  \
    \  }\n\n    sorted.reverse();\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `column_coord` in this scope\n  --> /tmp/tmpn46ykrav.rs:57:41\n\
    \   |\n57 |                 sorted.push((row_coord, column_coord));\n   |    \
    \                                     ^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `col_coord`\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n  --> /tmp/tmpn46ykrav.rs:33:13\n\
    \   |\n33 |         let curr_row = curr_row[column_idx..];\n   |             ^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `[isize]`\n   = note: all local variables must have a\
    \ statically known size\n   = help: unsized locals are gated as an unstable feature\n\
    help: consider borrowing here\n   |\n33 |         let curr_row = &curr_row[column_idx..];\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn46ykrav.rs:35:42\n\
    \   |\n35 |         if curr_row.iter().all(|x| *x == x) {\n   |              \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |         if curr_row.iter().all(|x| *x ==\
    \ *x) {\n   |                                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn46ykrav.rs:36:23\n   |\n36 |             row.push((row_idx,\
    \ column_idx));\n   |                       ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n36 |             row.push((row_idx.try_into().unwrap(),\
    \ column_idx));\n   |                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn46ykrav.rs:36:32\n   |\n36 |             row.push((row_idx,\
    \ column_idx));\n   |                                ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n36 |             row.push((row_idx,\
    \ column_idx.try_into().unwrap()));\n   |                                    \
    \      ++++++++++++++++++++\n\nerror[E0308]:"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = Vec::new();\n\n    for row in lst {\n        let mut cur_row\
    \ = row.clone();\n        let mut j = 0;\n        while j < cur_row.len() {\n\
    \            if cur_row[j] == x {\n                let row2 = cur_row.clone();\n\
    \                row2.remove(j);\n                let col2 = j;\n            \
    \    res.push((row2.len(), col2));\n            }\n            j += 1\n      \
    \  }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqk2jnlf.rs:34:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n34 |     res\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    let mut rows\
    \ = vec![];\n    for i in 0..lst.len() {\n        if lst[i].len() == 0 {\n   \
    \         continue;\n        }\n        let mut cols = vec![];\n        let mut\
    \ row_iter = lst[i].iter().rev();\n        let mut col_iter = row_iter.peekable().peek();\n\
    \        for j in 0..x {\n            col_iter.next();\n            cols.push((col_iter.value(),\
    \ j));\n        }\n        rows.push((i, cols.len()));\n    }\n    rows.sort();\n\
    \    rows.sort_by(|a, b| b.1.cmp(b.0));\n    rows.into_iter().map(|(i, cols)|\
    \ {\n        (i, cols.iter().map(|c| c.0).collect::<Vec<_>>().reverse())\n   \
    \ })\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpm30ni_gk.rs:30:22\n   |\n30 |             col_iter.next();\n\
    \   |                      ^^^^ method not found in `Option<&&isize>`\n\nerror[E0599]:\
    \ no method named `value` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpm30ni_gk.rs:31:33\n   |\n31 |             cols.push((col_iter.value(),\
    \ j));\n   |                                 ^^^^^ method not found in `Option<&&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm30ni_gk.rs:36:33\n   |\n36 |\
    \     rows.sort_by(|a, b| b.1.cmp(b.0));\n   |                               \
    \  ^^^\n   |                                 |\n   |                         \
    \        expected `&usize`, found `usize`\n   |                              \
    \   help: consider borrowing here: `&b.0`\n\nerror[E0599]: no method named `iter`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpm30ni_gk.rs:38:18\n\
    \   |\n38 |         (i, cols.iter().map(|c| c.0).collect::<Vec<_>>().reverse())\n\
    \   |                  ^^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm30ni_gk.rs:37:5\n   |\n17 |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \              ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n37 | /     rows.into_iter().map(|(i, cols)| {\n38 | |         (i,\
    \ cols.iter().map(|c| c.0).collect::<Vec<_>>().reverse())\n39 | |     })\n   |\
    \ |______^ expected struct `Vec`, found struct `Map`\n   |\n   = note: expected\
    \ struct `Vec<(isize, isize)>`\n              found struct `Map<std::vec::IntoIter<(usize,\
    \ usize)>, _>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut counter = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \    let mut counter_reverse = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \    let mut counter_reverse1 = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \    find_coords(lst, 0, counter, counter_reverse, counter_reverse1, x);\n   \
    \ sort_rows(counter_reverse, counter_reverse1);\n    let mut row_counter = vec![vec![0;\
    \ x].into_iter().cloned().collect::<Vec<_>>()];\n    let mut row_counter_reverse\
    \ = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n    let mut row_counter_reverse1\
    \ = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n    find_coords(counter_reverse,\
    \ 0, row_counter, row_counter_reverse, row_counter_reverse1, x);\n    sort_columns(row_counter_reverse,\
    \ row_counter_reverse1);\n    let mut coords = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \    let mut coords1 = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \    find_coords(row_counter_reverse1, 0, coords, coords1, coords, x);\n    sort_coordinates(coords1);\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_coords` in this scope\n  --> /tmp/tmp8hvekhy5.rs:21:5\n\
    \   |\n21 |     find_coords(lst, 0, counter, counter_reverse, counter_reverse1,\
    \ x);\n   |     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `sort_rows` in this scope\n  --> /tmp/tmp8hvekhy5.rs:22:5\n   |\n22\
    \ |     sort_rows(counter_reverse, counter_reverse1);\n   |     ^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `find_coords` in this\
    \ scope\n  --> /tmp/tmp8hvekhy5.rs:26:5\n   |\n26 |     find_coords(counter_reverse,\
    \ 0, row_counter, row_counter_reverse, row_counter_reverse1, x);\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `sort_columns`\
    \ in this scope\n  --> /tmp/tmp8hvekhy5.rs:27:5\n   |\n27 |     sort_columns(row_counter_reverse,\
    \ row_counter_reverse1);\n   |     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `find_coords` in this scope\n  --> /tmp/tmp8hvekhy5.rs:30:5\n\
    \   |\n30 |     find_coords(row_counter_reverse1, 0, coords, coords1, coords,\
    \ x);\n   |     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `sort_coordinates` in this scope\n  --> /tmp/tmp8hvekhy5.rs:31:5\n\
    \   |\n31 |     sort_coordinates(coords1);\n   |     ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8hvekhy5.rs:18:36\n\
    \   |\n18 |     let mut counter = vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n\
    \   |                                    ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     let mut counter = vec![vec![0; x.try_into().unwrap()].into_iter().cloned().collect::<Vec<_>>()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<{integer}> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp8hvekhy5.rs:18:51\n     |\n18   |     let mut counter =\
    \ vec![vec![0; x].into_iter().cloned().collect::<Vec<_>>()];\n     |         \
    \                      "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() || lst.len() == 0 {\n        return vec![];\n    }\n\
    \n    let mut result = vec![];\n    for row in lst {\n        for (i, e) in row.iter().enumerate().skip(x\
    \ as usize) {\n            result.push((i as isize, e as isize));\n        }\n\
    \    }\n    result.sort_by_key(|&(i, _)| i).reverse();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpgdih1iyp.rs:28:37\n   |\n28 |     result.sort_by_key(|&(i,\
    \ _)| i).reverse();\n   |                                     ^^^^^^^ method not\
    \ found in `()`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  -->\
    \ /tmp/tmpgdih1iyp.rs:25:38\n   |\n25 |             result.push((i as isize, e\
    \ as isize));\n   |                                      -^^^^^^^^^\n   |    \
    \                                  |\n   |                                   \
    \   cannot cast `&isize` as `isize`\n   |                                    \
    \  help: dereference the expression: `*e`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    let mut sorted_rows\
    \ = vec![];\n    let mut sorted_cols = vec![];\n    let mut row_idx = 0;\n   \
    \ let mut col_idx = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n \
    \   for row in lst {\n        row_len += 1;\n        if row.is_empty() {\n   \
    \         continue;\n        }\n        for element in row {\n            sorted_rows.push(row_idx);\n\
    \            sorted_cols.push(col_idx);\n            row_idx += 1;\n         \
    \   if element == x {\n                return vec![(row_idx, col_idx)];\n    \
    \        }\n            col_len += 1;\n        }\n        col_idx = 0;\n    }\n\
    \    sorted_rows.sort();\n    sorted_cols.sort();\n    return sorted_rows\n  \
    \      .iter()\n        .map(|row| vec![(row, sorted_cols[row as usize - 1])])\n\
    \        .collect();\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `Vec<(&isize, isize)>`\n    --> /tmp/tmp_ro3fo2j.rs:48:10\n\
    \     |\n48   |         .collect();\n     |          ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=Vec<(&isize, isize)>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<(&isize, isize)>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0606]: casting\
    \ `&isize` as `usize` is invalid\n  --> /tmp/tmp_ro3fo2j.rs:47:43\n   |\n47 |\
    \         .map(|row| vec![(row, sorted_cols[row as usize - 1])])\n   |       \
    \                                    ---^^^^^^^^^\n   |                      \
    \                     |\n   |                                           cannot\
    \ cast `&isize` as `usize`\n   |                                           help:\
    \ dereference the expression: `*row`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    for row in lst {\n        coords.clear();\n\
    \        let mut sorted_row = row.iter().cloned().collect::<Vec<_>>();\n     \
    \   sorted_row.sort_by_key(|e| -e).reverse();\n        for row in sorted_row.iter().cloned()\
    \ {\n            coords.extend((*row, x.clone()));\n        }\n    }\n    coords.sort_by_key(|(_,\
    \ y)| y);\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpapac7ck6.rs:22:40\n   |\n22 |         sorted_row.sort_by_key(|e|\
    \ -e).reverse();\n   |                                        ^^^^^^^ method not\
    \ found in `()`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpapac7ck6.rs:24:28\n\
    \   |\n24 |             coords.extend((*row, x.clone()));\n   |              \
    \              ^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = Vec::new();\n    for row in lst {\n        for col in\
    \ row.iter().rev() {\n            if col == x {\n                rows.push((row,\
    \ col));\n                break;\n            }\n        }\n    }\n    let mut\
    \ cols = Vec::new();\n    for row in lst {\n        cols.sort_by_key(|(_, col)|\
    \ col.cmp(&x));\n        cols.sort_by_key(|(_, col)| -col.cmp(&x));\n    }\n \
    \   rows.sort_by_key(|(_, col)| -col.cmp(&x));\n    rows\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpqk9hk6kh.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqk9hk6kh.rs:32:42\n   |\n32 |     rows.sort_by_key(|(_, col)| -col.cmp(&x));\n\
    \   |                                          ^^ expected `&isize`, found `isize`\n\
    \   |\n   = note: expected reference `&&isize`\n              found reference\
    \ `&isize`\n\nerror[E0600]: cannot apply unary operator `-` to type `std::cmp::Ordering`\n\
    \  --> /tmp/tmpqk9hk6kh.rs:32:33\n   |\n32 |     rows.sort_by_key(|(_, col)| -col.cmp(&x));\n\
    \   |                                 ^^^^^^^^^^^^ cannot apply unary operator\
    \ `-`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqk9hk6kh.rs:33:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n33 |     rows\n   |     ^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(Vec<isize>, &isize)>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst\n        .iter()\n        .filter(|row| row.len() == x)\n       \
    \ .flat_map(|row| row.iter().enumerate().cloned().collect())\n        .sort_by(|row|\
    \ row.0)\n        .sort_by(|row| -row.1)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3bgmfzn.rs:20:36\n   |\n\
    20 |         .filter(|row| row.len() == x)\n   |                             \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n20 |      \
    \   .filter(|row| row.len() == x.try_into().unwrap())\n   |                  \
    \                   ++++++++++++++++++++\n\nerror[E0271]: type mismatch resolving\
    \ `<Enumerate<std::slice::Iter<'_, isize>> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmph3bgmfzn.rs:21:48\n     |\n21   |         .flat_map(|row| row.iter().enumerate().cloned().collect())\n\
    \     |                                                ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(usize, &isize)`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmph3bgmfzn.rs:21:57\n\
    \   |\n21 |            .flat_map(|row| row.iter().enumerate().cloned().collect())\n\
    \   |                                                            ^^^^^^^ method\
    \ cannot be called on `Cloned<Enumerate<std::slice::Iter<'_, isize>>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Enumerate<std::slice::Iter<'_, isize>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Enumerate<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    sort_by_row_desc(lst);\n    let mut row_lst : Vec<(isize, isize)> = vec![];\n\
    \    let mut row_lst2 = vec![];\n    let mut col_lst : Vec<isize> = vec![];\n\
    \    let mut col_lst2 = vec![];\n    for row in lst {\n        let mut col_lst\
    \ = vec![];\n        for col in row {\n            if col == x {\n           \
    \     row_lst.push((col, row));\n                col_lst.push(col);\n        \
    \    }\n        }\n        row_lst2.push(row_lst);\n        col_lst2.push(col_lst);\n\
    \    }\n    sort_by_row_asc(row_lst2);\n    sort_by_col_asc(col_lst2);\n    col_lst2.iter().map(|x|x).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_row_desc` in this scope\n \
    \ --> /tmp/tmp5p8u_09z.rs:18:5\n   |\n18 |     sort_by_row_desc(lst);\n   |  \
    \   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `sort_by_row_asc` in this scope\n  --> /tmp/tmp5p8u_09z.rs:34:5\n   |\n34 |\
    \     sort_by_row_asc(row_lst2);\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sort_by_col_asc` in this scope\n  --> /tmp/tmp5p8u_09z.rs:35:5\n\
    \   |\n35 |     sort_by_col_asc(col_lst2);\n   |     ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5p8u_09z.rs:27:36\n\
    \   |\n27 |                 row_lst.push((col, row));\n   |                  \
    \                  ^^^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `&Vec<isize>`\n    --> /tmp/tmp5p8u_09z.rs:36:31\n     |\n\
    36   |     col_lst2.iter().map(|x|x).collect()\n     |                       \
    \        ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=&Vec<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<&Vec<isize>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut row =\
    \ vec![];\n    let mut row_vecs = Vec::with_capacity(lst.len());\n    for row\
    \ in lst {\n        row_vecs.push((*row, 0));\n    }\n    row_vecs.sort_by_key(|(_,\
    \ y)| -y);\n    let mut row_sorted: Vec<(isize, isize)> = vec![];\n    for (mut\
    \ row_vec, row_y) in row_vecs {\n        let mut row_sorted_vec: Vec<(isize, isize)>\
    \ = vec![];\n        for (mut col_vec, col_x) in row_vec {\n            col_vec\
    \ = (col_x, row_y - col_x);\n            row_sorted_vec.push(col_vec);\n     \
    \   }\n        row_sorted.push((row_vec.len(), row_sorted_vec.len()));\n    }\n\
    \    row_sorted.sort_by_key(|(_, y)| -y);\n    for (row_len, col_len) in row_sorted.iter().zip(0..row_len)\
    \ {\n        let mut new_row = vec![];\n        for (i, row) in row_sorted.iter().enumerate()\
    \ {\n            if i == row_len {\n                new_row.push(row.clone());\n\
    \                continue;\n            }\n            let mut col: Vec<(isize,\
    \ isize)> = vec![];\n            for (col_i, col) in row {\n                col\
    \ = (col, col_len - col_i);\n            }\n            new_row.push(col);\n \
    \       }\n        row.clear();\n        for (i, col) in new_row.iter().enumerate()\
    \ {\n            if i == col_len {\n                row.push(col);\n         \
    \       continue;\n            }\n            let mut new_col: Vec<(isize, isize)>\
    \ = vec![];\n            for (col_i, col) in col {\n                new_col.push((col,\
    \ col_i - col_len));\n            }\n            row.push(new_col);\n        }\n\
    \        row_vecs = vec![new_row];\n    }\n    row\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `row_len` in this scope\n  --> /tmp/tmp79ow5ob8.rs:37:56\n\
    \   |\n37 |     for (row_len, col_len) in row_sorted.iter().zip(0..row_len) {\n\
    \   |                                                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: the size for values of type `[isize]` cannot\
    \ be known at compilation time\n  --> /tmp/tmp79ow5ob8.rs:24:9\n   |\n24 |   \
    \      row_vecs.push((*row, 0));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[isize]`\n   = note: only the last element of a tuple may have\
    \ a dynamically sized type\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmp79ow5ob8.rs:22:24\n   |\n\
    22 |     let mut row_vecs = Vec::with_capacity(lst.len());\n   |             \
    \           ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[isize]`\n   = note: only\
    \ the last element of a tuple may have a dynamically sized type\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \  --> /tmp/tmp79ow5ob8.rs:26:14\n   |\n26 |     row_vecs.sort_by_key(|(_, y)|\
    \ -y);\n   |              ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ only the last element of a tuple may have a dynamically sized type\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \  --> /tmp/tmp79ow5ob8.rs:26:5\n   |\n26 |     row_vecs.sort_by_key(|(_, y)|\
    \ -y);\n   |     ^^^^^^^^ doesn't have a size known at compile-time\n   |\n  \
    \ = help: the trait `Sized` is not implemented for `[isize]`\n   = note: only\
    \ the last element of a tuple may have a dynamically sized type\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \  --> /tmp/tmp79ow5ob8.rs:28:33\n   |\n28 |     for (mut row_vec, row_y) in row_vecs\
    \ {\n   |                                 ^^^^^^^^ doe"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst\n        .iter()\n        .map(|row| {\n            row\n       \
    \         .iter()\n                .filter(|elem| elem == x)\n               \
    \ .map(|elem| {\n                    (elem - 1, elem + 1)\n                })\n\
    \                .collect()\n        })\n        .fold(Vec::new(), |mut acc, x|\
    \ {\n            acc.push(x.clone());\n            acc\n        })\n        .sort_by(|a,\
    \ b| b.cmp(a)).iter()\n        .cloned()\n        .map(|x| x.clone())\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&isize` with `isize`\n  --> /tmp/tmpno8ws07a.rs:23:37\n\
    \   |\n23 |                 .filter(|elem| elem == x)\n   |                  \
    \                   ^^ no implementation for `&&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpno8ws07a.rs:33:35\n   |\n33 |         .sort_by(|a, b| b.cmp(a)).iter()\n\
    \   |                                   ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_lengths = vec![];\n    for ele in lst {\n        let mut\
    \ row_length = 0;\n        for ele2 in ele {\n            if ele2 != x {\n   \
    \             row_length += 1;\n            }\n        }\n        row_lengths.push(row_length);\n\
    \    }\n    let mut res = vec![];\n    for ele in lst.iter().rev() {\n       \
    \ if row_lengths[ele.len() - 1] == 0 {\n            continue;\n        }\n   \
    \     let mut min_row_length = row_lengths[ele.len() - 1];\n        let mut row\
    \ = vec![];\n        for i in ele.iter().rev() {\n            if row_lengths[i]\
    \ == min_row_length {\n                row.push(i);\n            }\n        }\n\
    \        res.push(vec![(row.len(), ele.len())]);\n        for (i, ele2) in row.iter().enumerate()\
    \ {\n            let mut cur = ele2.clone();\n            cur.swap(0, cur.len()\
    \ - 1);\n            row_lengths[ele.len() - 1] -= 1;\n            row_lengths[i]\
    \ -= 1;\n            row.swap(i, cur.len() - 1);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpa8wk41z8.rs:36:16\n   |\n36 |             if row_lengths[i] == min_row_length\
    \ {\n   |                ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0599]: no method named `swap` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpa8wk41z8.rs:43:17\n   |\n43 | \
    \            cur.swap(0, cur.len() - 1);\n   |                 ^^^^ method not\
    \ found in `&isize`\n\nerror[E0599]: no method named `len` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpa8wk41z8.rs:43:29\n   |\n43 | \
    \            cur.swap(0, cur.len() - 1);\n   |                             ^^^\
    \ method not found in `&isize`\n\nerror[E0599]: no method named `len` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmpa8wk41z8.rs:46:29\n \
    \  |\n46 |             row.swap(i, cur.len() - 1);\n   |                     \
    \        ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa8wk41z8.rs:49:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n49 |     res\n   |     ^^^ expected tuple, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // sort the row and column of the given data using bubble sort\n    let\
    \ mut n = lst.len();\n    let mut row = 1;\n    let mut col = 1;\n    let mut\
    \ row_idx = 1;\n    let mut col_idx = 0;\n    let mut rows_to_sort = Vec::new();\n\
    \    let mut cols_to_sort = Vec::new();\n    while row_idx < n {\n        let\
    \ mut found = false;\n        let mut row_end = row.clone();\n        while !found\
    \ && row_end < n {\n            if rows_to_sort.len() == 0 {\n               \
    \ if cols_to_sort.len() == 0 {\n                    // sort the row and column\
    \ of the given data using bubble sort\n                    while row_idx < n &&\
    \ col_idx < n {\n                        if rows_to_sort.len() < n {\n       \
    \                     if cols_to_sort.len() < n {\n                          \
    \      if cols[col_idx] < rows[row_idx][col_idx] {\n                         \
    \           row_end = row_idx;\n                                    cols_to_sort.push(cols[col_idx]);\n\
    \                                    rows_to_sort.push(rows[row_idx]);\n     \
    \                           } else {\n                                    found\
    \ = true;\n                                }\n                            } else\
    \ {\n                                rows_to_sort.push(rows[row_idx]);\n     \
    \                           row_end = row_idx;\n                            }\n\
    \                            col_idx += 1;\n                        } else {\n\
    \                            cols_to_sort.push(cols[col_idx]);\n             \
    \               row_end = row_idx;\n                            col_idx += 1;\n\
    \                        }\n                        row_idx += 1;\n          \
    \          }\n                    rows_to_sort.sort_by_key(|x| x.0);\n       \
    \             cols_to_sort.sort_by_key(|x| -x.1);\n                } else {\n\
    \                    rows_to_sort.sort_by_key(|x| x.0);\n                    cols_to_sort.sort_by_key(|x|\
    \ -x.1);\n                }\n                if rows_to_sort.len() == n {\n  \
    \                  rows_to_sort.reverse();\n                    rows_to_sort.push(rows[row]);\n\
    \                    row += 1;\n                } else {\n                   \
    \ rows_to_sort.push(rows[row]);\n                    row += 1;\n             \
    \   }\n                cols_to_sort.reverse();\n                cols_to_sort.push(cols);\n\
    \            } else {\n                if cols_to_sort.len() == n {\n        \
    \            rows_to_sort.reverse();\n                    rows_to_sort.push(rows[row]);\n\
    \                    row += 1;\n                } else {\n                   \
    \ rows_to_sort.push(rows[row]);\n                    row += 1;\n             \
    \   }\n                cols_to_sort.reverse();\n                cols_to_sort.push(cols);\n\
    \            }\n            found = true;\n        }\n        if rows_to_\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvym4lrji.rs:96:3\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n26 |     while row_idx < n {\n   |                \
    \       - this delimiter might not be properly closed...\n...\n86 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n96 | }\n   |  \
    \ ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpvym4lrji.rs:86:1\n   |\n\
    85 |         if rows_to_\n   |         -- this `if` expression has a condition,\
    \ but no block\n86 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `cols` in this scope\n  --> /tmp/tmpvym4lrji.rs:36:36\n   |\n36 | ...      \
    \             if cols[col_idx] < rows[row_idx][col_idx] {\n   |              \
    \            ^^^^ help: a local variable with a similar name exists: `col`\n\n\
    error[E0425]: cannot find value `rows` in this scope\n  --> /tmp/tmpvym4lrji.rs:36:52\n\
    \   |\n36 | ...                   if cols[col_idx] < rows[row_idx][col_idx] {\n\
    \   |                                          ^^^^ help: a local variable with\
    \ a similar name exists: `row`\n\nerror[E0425]: cannot find value `cols` in this\
    \ scope\n  --> /tmp/tmpvym4lrji.rs:38:55\n   |\n38 | ...                   cols_to_sort.push(cols[col_idx]);\n\
    \   |                                         ^^^^ help: a local variable with\
    \ a similar name exists: `col`\n\nerror[E0425]: cannot find value `rows` in this\
    \ scope\n  --> /tmp/tmpvym4lrji.rs:39:55\n   |\n39 | ...                   rows_to_sort.push(rows[row_idx]);\n\
    \   |                                         ^^^^ help: a local variable with\
    \ a similar name exists: `row`\n\nerror[E0425]: cannot find value `rows` in this\
    \ scope\n  --> /tmp/tmpvym4lrji.rs:44:51\n   |\n44 | ...                   rows_to_sort.push(rows[row_idx]);\n\
    \   |                                         ^^^^ help: a local variable with\
    \ a similar name exists: `row`\n\nerror[E0425]: cannot find value `cols` in this\
    \ scope\n  --> /tmp/tmpvym4lrji.rs:49:47\n   |\n49 | ...          "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_vec: Vec<(isize, isize)> = vec![];\n    let mut col_vec:\
    \ Vec<(isize, isize)> = vec![];\n    let mut temp_vec: Vec<(isize, isize)> = vec![];\n\
    \    for row in lst {\n        let mut temp_row = vec![];\n        for col in\
    \ row.iter().cloned() {\n            if col == x {\n                temp_row.push((row,\
    \ col));\n            }\n        }\n        row_vec.push((row, temp_row));\n \
    \   }\n    for i in row_vec.iter().cloned() {\n        temp_vec.push(*i);\n  \
    \  }\n    for j in col_vec.iter().cloned() {\n        temp_vec.push((*j, temp_vec[temp_vec.len()\
    \ - 1]));\n    }\n    temp_vec\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph2w1tsj6.rs:28:23\n   |\n\
    28 |         row_vec.push((row, temp_row));\n   |                       ^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph2w1tsj6.rs:28:28\n\
    \   |\n28 |         row_vec.push((row, temp_row));\n   |                     \
    \       ^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<(Vec<isize>, isize)>`\n\nerror[E0614]:\
    \ type `(isize, isize)` cannot be dereferenced\n  --> /tmp/tmph2w1tsj6.rs:31:23\n\
    \   |\n31 |         temp_vec.push(*i);\n   |                       ^^\n\nerror[E0614]:\
    \ type `(isize, isize)` cannot be dereferenced\n  --> /tmp/tmph2w1tsj6.rs:34:24\n\
    \   |\n34 |         temp_vec.push((*j, temp_vec[temp_vec.len() - 1]));\n   | \
    \                       ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph2w1tsj6.rs:34:28\n\
    \   |\n34 |         temp_vec.push((*j, temp_vec[temp_vec.len() - 1]));\n   | \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `(isize,\
    \ isize)`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = [(0, 0)];\n    let mut col = vec![(0, 0)];\n    let mut\
    \ i = 0;\n    let mut k = 0;\n    while i < lst.len() {\n        // first sort\n\
    \        if lst[i].len() < x {\n            i += 1;\n            continue;\n \
    \       }\n        // sort the rows\n        for (j, v) in row.iter().enumerate()\
    \ {\n            if lst[i][j] >= x {\n                k = j;\n               \
    \ break;\n            }\n        }\n        // sort the columns\n        for (i,\
    \ v) in col.iter().enumerate() {\n            if lst[i][k] < x {\n           \
    \     k = i;\n                break;\n            }\n        }\n        let row\
    \ = row;\n        let col = vec![col, k];\n        i += 1;\n    }\n    row\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r7o2mqn.rs:24:27\n   |\n\
    24 |         if lst[i].len() < x {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |         if lst[i].len()\
    \ < x.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_r7o2mqn.rs:43:29\n   |\n43 |\
    \         let col = vec![col, k];\n   |                             ^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<({integer},\
    \ {integer})>`\n                found type `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_r7o2mqn.rs:46:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n46 |     row\n   |     ^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |     |\n   |     expected struct `Vec`, found array of 1 element\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n               found\
    \ array `[({integer}, {integer}); 1]`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    coords.sort();\n    let mut coord =\
    \ coords.iter().cloned().collect::<Vec<_>>();\n    let mut coord_by = coords.iter().cloned().enumerate().collect::<Vec<_>>();\n\
    \    coor_y.reverse();\n    coor_by.iter_mut().cloned().for_each(|(i, j)| {\n\
    \        if i as isize == x {\n            coord.push((i, coords.iter().filter(|&i|\
    \ i as isize == i).map(|&i| i as isize).max()));\n        }\n    });\n    coor_by.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n        if j as isize == x - 1 {\n            coor_by.swap(i, j);\n \
    \       }\n    });\n    coor_by.iter_mut().cloned().for_each(|(i, j)| {\n    \
    \    if j as isize == j - 1 {\n            coor_by.swap(i, j);\n        }\n  \
    \  });\n    coor_by.iter_mut().cloned().for_each(|(i, j)| {\n        if i as isize\
    \ == j + 1 {\n            coor_by.swap(i, j);\n        }\n    });\n    coor_by.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n        if i as isize == j {\n            coor_by.swap(i, j);\n     \
    \   }\n    });\n    let mut coor_by_cols = coor_by.iter().cloned().enumerate().collect::<Vec<_>>();\n\
    \    coor_by_cols.reverse();\n    coor_by_cols.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n        if j as isize == x {\n            coor_by_cols.push((i, coor_by.iter().filter(|&i|\
    \ i as isize == i).map(|&i| i as isize).max()));\n        }\n    });\n    coor_by_cols.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n        if j as isize == x - 1 {\n            coor_by_cols.swap(i, j);\n\
    \        }\n    });\n    coor_by_cols.iter_mut().cloned().for_each(|(i, j)| {\n\
    \        if j as isize == j - 1 {\n            coor_by_cols.swap(i, j);\n    \
    \    }\n    });\n    coor_by_cols.iter_mut().cloned().for_each(|(i, j)| {\n  \
    \      if i as isize == j + 1 {\n            coor_by_cols.swap(i, j);\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmnpi2bbb.rs:78:3\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n65 |     coor_by_cols.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n   |                                              -         - unclosed\
    \ delimiter\n   |                                              |\n   |       \
    \                                       unclosed delimiter\n66 |         if i\
    \ as isize == j + 1 {\n   |                                - this delimiter might\
    \ not be properly closed...\n67 |             coor_by_cols.swap(i, j);\n68 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n78 | }\n\
    \   |   ^\n\nerror[E0425]: cannot find value `coor_y` in this scope\n  --> /tmp/tmpmnpi2bbb.rs:22:5\n\
    \   |\n22 |     coor_y.reverse();\n   |     ^^^^^^ help: a local variable with\
    \ a similar name exists: `coord`\n\nerror[E0425]: cannot find value `coor_by`\
    \ in this scope\n  --> /tmp/tmpmnpi2bbb.rs:23:5\n   |\n23 |     coor_by.iter_mut().cloned().for_each(|(i,\
    \ j)| {\n   |     ^^^^^^^ help: a local variable with a similar name exists: `coord_by`\n\
    \nerror[E0425]: cannot find value `coor_by` in this scope\n  --> /tmp/tmpmnpi2bbb.rs:28:5\n\
    \   |\n28 |     coor_by.iter_mut().cloned().for_each(|(i, j)| {\n   |     ^^^^^^^\
    \ help: a local variable with a similar name exists: `coord_by`\n\nerror[E0425]:\
    \ cannot find value `coor_by` in this scope\n  --> /tmp/tmpmnpi2bbb.rs:30:13\n\
    \   |\n30 |             coor_by.swap(i, j);\n   |             ^^^^^^^ help: a\
    \ local variable with a similar name exists: `coord_by`\n\nerror[E0425]: cannot\
    \ find value `coor_by` in this scope\n  --> /tmp/tmpmnpi2bbb.rs:33:5\n   |\n33\
    \ |     coor_by.iter_mut().cloned().for_each(|(i, j)| {\n   |     ^^^^^^^ help:\
    \ a local variable with a similar name exists: `coord_by`\n\nerror[E0425]: cannot\
    \ find value `coor_by` in this scope\n  --> /tmp/tmpmnpi2bbb.rs:35:13\n   |\n\
    35 |             coor_by.swap(i, j);\n   |             ^^^^^^^ help: a local variable"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = 0;\n    let mut coords = Vec::new();\n    for vec in lst\
    \ {\n        if vec.len() == x {\n            coords.push((row, vec[x - 1].clone()));\n\
    \            row++;\n        }\n    }\n    coords.sort_by_key(|(_, c)| c.0);\n\
    \    coords.sort_by_key(|(_, c)| -c.1);\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpg57q45hc.rs:23:16\n\
    \   |\n23 |             row++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n23 |             { let tmp = row; row +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n23 -         \
    \    row++;\n23 +             row += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg57q45hc.rs:21:25\n   |\n21 |         if vec.len() == x {\n   |\
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n21 |         if vec.len() == x.try_into().unwrap() {\n   |            \
    \              ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg57q45hc.rs:22:31\n   |\n22 |         \
    \    coords.push((row, vec[x - 1].clone()));\n   |                           \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpg57q45hc.rs:26:35\n \
    \  |\n26 |     coords.sort_by_key(|(_, c)| c.0);\n   |                       \
    \            ^\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Using std::slice::from_mut_ref to avoid ownership issues\n    let\
    \ mut tuples = Vec::new();\n\n    let mut y = x;\n    let mut row = Vec::new();\n\
    \n    while y > 0 {\n        if y % 2 == 1 {\n            row.push((y, 0));\n\
    \        }\n        y /= 2;\n    }\n\n    while row.len() != 0 {\n        let\
    \ y = row.last().unwrap().0;\n\n        for x in 0..lst.len() {\n            let\
    \ value = &lst[x][0];\n            if value == y {\n                let new_row\
    \ = row.clone();\n                tuples.push((new_row, new_row.len() - 1));\n\
    \                row.truncate(0);\n                row = new_row.clone();\n  \
    \              row.push((y, 0));\n                break;\n            }\n    \
    \    }\n    }\n\n    // sorting the coordinates by rows in ascending order\n \
    \   // tuples.sort_by_key(|&(_, y)| *y);\n\n    // sorting the coordinates by\
    \ columns in descending order\n    // tuples.sort_by_key(|&(_, y2)| *y2).reverse();\n\
    \n    tuples\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpxx0p_gse.rs:36:22\n\
    \   |\n36 |             if value == y {\n   |                      ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxx0p_gse.rs:53:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n53 |     tuples\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(Vec<(isize, {integer})>, usize)>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n    let mut rows:\
    \ Vec<(isize, isize)> = vec![];\n    let mut cols: Vec<isize> = vec![];\n\n  \
    \  for i in 0..lst.len() {\n        for j in 0..lst[i].len() {\n            if\
    \ j == x {\n                rows.push((i, j));\n            }\n        }\n   \
    \ }\n\n    for i in rows.iter().rev() {\n        cols.push(rows.iter().filter(|&(i1,\
    \ j1)| i1 != i).last().unwrap().1);\n    }\n\n    cols.sort_by_key(|&i| i);\n\
    \    cols.sort_by_key(|&i| -i).reverse();\n\n    rows\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1tsckkt.rs:27:21\n   |\n\
    27 |             if j == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |             if j == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd1tsckkt.rs:28:28\n   |\n28 |                 rows.push((i,\
    \ j));\n   |                            ^ expected `isize`, found `usize`\n  \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |                 rows.push((i.try_into().unwrap(),\
    \ j));\n   |                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd1tsckkt.rs:28:31\n   |\n28 |              \
    \   rows.push((i, j));\n   |                               ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n28 |                 rows.push((i,\
    \ j.try_into().unwrap()));\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `isize` with `(isize, isize)`\n  --> /tmp/tmpd1tsckkt.rs:34:53\n\
    \   |\n34 |         cols.push(rows.iter().filter(|&(i1, j1)| i1 != i).last().unwrap().1);\n\
    \   |                                                     ^^ no implementation\
    \ for `isize == (isize, isize)`\n   |\n   = help: the trait `PartialEq<(isize,\
    \ isize)>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n    \
    \         i128\n             i16\n             i32\n             i64\n       \
    \      i8\n             isize\n           and 6 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&(isize, isize)>` for `&isize`\n\
    \nerror[E0599]: no method named `reverse` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpd1tsckkt.rs:38:31\n   |\n38 |     cols.sort_by_key(|&i|\
    \ -i).reverse();\n   |                         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.iter().cloned().collect::<Vec<_>>();\n    rows = sort_rows(rows);\n\
    \    rows = sort_columns(rows, &[(-x, -1)]);\n    rows.iter().map(|row| {\n  \
    \      let mut cols = row.iter().cloned().collect::<Vec<_>>();\n        cols =\
    \ sort_columns(cols, &[(+1, -1)]);\n        (row.iter().enumerate().take(2).map(|(_,\
    \ col)| (col, cols.iter().enumerate().take(2).map(|(_, c)| c.unwrap()))).collect::<Vec<_>>(),\
    \ row.iter().enumerate().take(2).map(|(i, _)| i).collect::<Vec<_>>())\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: leading `+` is not supported\n  --> /tmp/tmpprqdexpb.rs:23:38\n\
    \   |\n23 |         cols = sort_columns(cols, &[(+1, -1)]);\n   |            \
    \                          ^ unexpected `+`\n   |\nhelp: try removing the `+`\n\
    \   |\n23 -         cols = sort_columns(cols, &[(+1, -1)]);\n23 +         cols\
    \ = sort_columns(cols, &[(1, -1)]);\n   | \n\nerror[E0425]: cannot find function\
    \ `sort_rows` in this scope\n  --> /tmp/tmpprqdexpb.rs:19:12\n   |\n19 |     rows\
    \ = sort_rows(rows);\n   |            ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `sort_columns` in this scope\n  --> /tmp/tmpprqdexpb.rs:20:12\n\
    \   |\n20 |     rows = sort_columns(rows, &[(-x, -1)]);\n   |            ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `sort_columns`\
    \ in this scope\n  --> /tmp/tmpprqdexpb.rs:23:16\n   |\n23 |         cols = sort_columns(cols,\
    \ &[(+1, -1)]);\n   |                ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `unwrap` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpprqdexpb.rs:24:109\n   |\n24 | ..., cols.iter().enumerate().take(2).map(|(_,\
    \ c)| c.unwrap()))).collect::<Vec<_>>(), row.iter().enumerate().take(2).map(|(i,\
    \ _)| i).colle...\n   |                                                     ^^^^^^\
    \ method not found in `&isize`\n\nerror[E0277]: a value of type `Vec<(isize, isize)>`\
    \ cannot be built from an iterator over elements of type `(Vec<(&isize, Map<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>, _>)>, Vec<usize>)`\n    --> /tmp/tmpprqdexpb.rs:25:8\n     |\n25 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<(isize, isize)>`\
    \ cannot be built from `std::iter::Iterator<Item=(Vec<(&isize, Map<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>, _>)>, Vec<usize>)>`\n     |\n     = help: the trait `FromIterator<(Vec<(&isize,\
    \ Map<std::iter::Take<Enumerate<std::slice::Iter<'_, isize>>>, _>)>, Vec<usize>)>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut out = vec![];\n    let mut i = x;\n    let mut j = x;\n\n   \
    \ while i != 0 {\n        let mut row_out = vec![];\n        while j != 0 {\n\
    \            if lst[i - 1].len() == j {\n                row_out.push((i - 1,\
    \ j - 1));\n                j -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        i += 1;\n        for r in row_out.drain(..)\
    \ {\n            out.push(r);\n        }\n    }\n\n    out.sort_by_key(|&(x, y)|\
    \ x.0);\n    out.sort_by_key(|&(x, y)| y.0);\n    out\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpfg7c9f0m.rs:25:16\n   |\n25 |             if lst[i - 1].len() == j {\n\
    \   |                ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<isize>>`\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpfg7c9f0m.rs:38:33\n   |\n38 |     out.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpfg7c9f0m.rs:39:33\n\
    \   |\n39 |     out.sort_by_key(|&(x, y)| y.0);\n   |                        \
    \         ^\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut new_lst = lst\n        .iter()\n        .map(|row| row.iter().cloned())\n\
    \        .collect::<Vec<Vec<isize>>>();\n    new_lst.sort_by_key(|row| row[x]);\n\
    \    new_lst.sort_by_key(|row| {\n        let mut sorted = row.iter().cloned();\n\
    \        sorted.sort_by_key(|el| {\n            sorted.iter().position(|c| c !=\
    \ el)\n        });\n        sorted\n    });\n    new_lst.into_iter()\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<Vec<isize>>` cannot be built from an\
    \ iterator over elements of type `Cloned<std::slice::Iter<'_, isize>>`\n    -->\
    \ /tmp/tmprl_8t_hh.rs:21:10\n     |\n21   |         .collect::<Vec<Vec<isize>>>();\n\
    \     |          ^^^^^^^ value of type `Vec<Vec<isize>>` cannot be built from\
    \ `std::iter::Iterator<Item=Cloned<std::slice::Iter<'_, isize>>>`\n     |\n  \
    \   = help: the trait `FromIterator<Cloned<std::slice::Iter<'_, isize>>>` is not\
    \ implemented for `Vec<Vec<isize>>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprl_8t_hh.rs:22:31\n\
    \   |\n22 |     new_lst.sort_by_key(|row| row[x]);\n   |                     \
    \          ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmprl_8t_hh.rs:25:16\n   |\n25 |         sorted.sort_by_key(|el|\
    \ {\n   |                ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `iter` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmprl_8t_hh.rs:26:20\n   |\n26 |             sorted.iter().position(|c|\
    \ c != el)\n   |                    ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0277]: the trait bound `Cloned<std::slice::Iter<'_, isize>>:\
    \ Ord` is not satisfied\n   --> /tmp/tmprl_8t_hh.rs:23:25\n    |\n23  |      \
    \ new_lst.sort_by_key(|row| {\n    |  _____________-----------_^\n    | |    \
    \         |\n    | |             required by a bound introduced by this call\n\
    24  | |         let mut sorted = row.iter().cloned();\n25  | |         sorted.sort_by_key(|el|\
    \ {\n26  | |             sorted.iter().position(|c| c != el)\n27  |"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut x = x;\n    let mut lst = lst.clone();\n    loop {\n        lst\
    \ = lst.iter().skip(x).collect();\n        if lst.is_empty() {\n            return\
    \ vec![];\n        }\n        let mut y = lst.len() - 1;\n        loop {\n   \
    \         let xs = lst.iter().rev().skip(y).collect::<Vec<_>>();\n           \
    \ if xs.len() == 0 {\n                lst = lst.iter().skip(y).collect();\n  \
    \              break;\n            }\n            y = xs.len() - 1;\n        \
    \    let ys = lst.iter().rev().skip(y).collect::<Vec<_>>();\n            let row\
    \ = (lst.iter().rev().skip(y).collect(), ys);\n            if row == ys.iter().rev().skip(y).collect::<Vec<_>>()\n\
    \                || row == ys.iter().rev().skip(y - 1).collect::<Vec<_>>() {\n\
    \                break;\n            }\n            lst = lst.iter().skip(y +\
    \ 1).collect();\n        }\n        x = x + 1;\n    }\n    vec![]\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf95set9a.rs:21:31\n   |\n\
    21 |         lst = lst.iter().skip(x).collect();\n   |                       \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \   lst = lst.iter().skip(x.try_into().unwrap()).collect();\n   |            \
    \                    ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<Vec<isize>>`\
    \ cannot be built from an iterator over elements of type `&Vec<isize>`\n    -->\
    \ /tmp/tmpf95set9a.rs:21:34\n     |\n21   |         lst = lst.iter().skip(x).collect();\n\
    \     |                                  ^^^^^^^ value of type `Vec<Vec<isize>>`\
    \ cannot be built from `std::iter::Iterator<Item=&Vec<isize>>`\n     |\n     =\
    \ help: the trait `FromIterator<&Vec<isize>>` is not implemented for `Vec<Vec<isize>>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<Vec<isize>>` cannot\
    \ be built from an iterator over elements of type `&Vec<isize>`\n    --> /tmp/tmpf95set9a.rs:29:42\n\
    \     |\n29   |                 lst = lst.iter().skip(y).collect();\n     |  \
    \                                        ^^^^^^^ value of type `Vec<Vec<isize>>`\
    \ cannot be built from `std::iter::Iterator<Item=&Vec<isize>>`\n     |\n     =\
    \ help: the trait `FromIterator<&Vec<isize>>` is not implemented for `Vec<Vec<isize>>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf95set9a.rs:35:23\n\
    \   |\n35 |             if row == ys.iter().rev().skip(y).collect::<Vec<_>>()\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(_, Vec<&Vec<isize>>)`\n\
    \             found struct `Vec<&&Vec<isize>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf95set9a.rs:36:27\n   |\n36 |                 || row == ys.iter().rev().skip(y\
    \ - 1).collect::<Vec<_>>() {\n   |  "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::with_capacity(lst.len() * 2);\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        row.push((i, *v));\n    }\n    let mut result = vec![];\n    let\
    \ mut sort_row = row.into_iter().cloned().sorted();\n    let mut sort_col = row.into_iter().cloned().rev().sorted();\n\
    \    for i in 0..row.len() {\n        let row_i = sort_row.nth(i);\n        let\
    \ col_i = sort_col.nth(i);\n        result.push((row_i, col_i));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<(usize, Vec<isize>)>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp27uxlg3t.rs:23:40\n     |\n23   |\
    \     let mut sort_row = row.into_iter().cloned().sorted();\n     |          \
    \                              ^^^^^^ expected reference, found tuple\n     |\n\
    \     = note: expected reference `&_`\n                    found tuple `(usize,\
    \ Vec<isize>)`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method\
    \ named `sorted` found for struct `Cloned` in the current scope\n  --> /tmp/tmp27uxlg3t.rs:23:49\n\
    \   |\n23 |     let mut sort_row = row.into_iter().cloned().sorted();\n   |  \
    \                                               ^^^^^^ method not found in `Cloned<std::vec::IntoIter<(usize,\
    \ Vec<isize>)>>`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<(usize,\
    \ Vec<isize>)> as Iterator>::Item == &_`\n    --> /tmp/tmp27uxlg3t.rs:24:40\n\
    \     |\n24   |     let mut sort_col = row.into_iter().cloned().rev().sorted();\n\
    \     |                                        ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(usize, Vec<isize>)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `rev` exists for struct `Cloned<std::vec::IntoIter<(usize, Vec<isize>)>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp27uxlg3t.rs:24:49\n \
    \  |\n24 |       let mut sort_col = row.into_iter().cloned().rev().sorted();\n\
    \   |                                                   ^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<(usize, Vec<isize>)>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<std::vec::IntoIter<(usize, Vec<isize>)> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<std::vec::IntoIter<(usize, Vec<isize>)>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<(usize, Vec<isize>)>>: Iterator`\n\
    \           which is required by `&mut Cloned<std::vec::IntoIter<(usize, Vec<isize>)>>:\
    \ Iterator`\n\nerror: aborting due to 4 previous error"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Initialize empty set\n    let mut set = Set::new();\n    // Initialize\
    \ current coordinates and its row and column\n    let mut coordinates = vec![];\n\
    \    let mut row = 0;\n    let mut col = 0;\n    for coord in lst {\n        if\
    \ coord > x {\n            break;\n        }\n        set.insert(coord);\n   \
    \     coordinates.push((row, col));\n        row += 1;\n        col += 1;\n  \
    \  }\n    // Sort coordinates initially by rows in ascending order\n    // TODO:\
    \ Sort coordinates initially by columns in descending order\n    coordinates.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    // Get coordinate from coordinates set\n    let mut\
    \ current_coordinate = Coordinate::new(\n        Coordinate::new(row, col),\n\
    \        coordinates.remove(coordinates.end()).1,\n    );\n    // Get coordinate\
    \ by row\n    for coord in coordinates.iter().skip(1).flat_map(|a| a.1) {\n  \
    \      if coord == current_coordinate.row {\n            current_coordinate =\
    \ Coordinate::new(coord, current_coordinate.col);\n            break;\n      \
    \  }\n    }\n    // Return coordinates set\n    coordinates\n        .iter()\n\
    \        .map(|a| a.0 as (isize, isize))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Set`\n  --> /tmp/tmpeg_bv8pn.rs:19:19\n\
    \   |\n19 |     let mut set = Set::new();\n   |                   ^^^ use of undeclared\
    \ type `Set`\n\nerror[E0433]: failed to resolve: use of undeclared type `Coordinate`\n\
    \  --> /tmp/tmpeg_bv8pn.rs:37:34\n   |\n37 |     let mut current_coordinate =\
    \ Coordinate::new(\n   |                                  ^^^^^^^^^^ use of undeclared\
    \ type `Coordinate`\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `Coordinate`\n  --> /tmp/tmpeg_bv8pn.rs:38:9\n   |\n38 |         Coordinate::new(row,\
    \ col),\n   |         ^^^^^^^^^^ use of undeclared type `Coordinate`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Coordinate`\n  --> /tmp/tmpeg_bv8pn.rs:44:34\n\
    \   |\n44 |             current_coordinate = Coordinate::new(coord, current_coordinate.col);\n\
    \   |                                  ^^^^^^^^^^ use of undeclared type `Coordinate`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpeg_bv8pn.rs:25:20\n   |\n25 |\
    \         if coord > x {\n   |                    ^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror[E0599]: no method named `end` found for struct `Vec<({integer},\
    \ {integer})>` in the current scope\n  --> /tmp/tmpeg_bv8pn.rs:39:40\n   |\n39\
    \ |         coordinates.remove(coordinates.end()).1,\n   |                   \
    \                     ^^^ help: there is an associated function with a similar\
    \ name: `append`\n\nerror[E0277]: `{integer}` is not an iterator\n    --> /tmp/tmpeg_bv8pn.rs:42:54\n\
    \     |\n42   |     for coord in coordinates.iter().skip(1).flat_map(|a| a.1)\
    \ {\n     |                                             -------- ^^^^^^^ `{integer}`\
    \ is not an iterator\n     |                                             |\n \
    \    |                                             required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Iterator` is not implemented for\
    \ `{integer}`\n     = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive ran"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_x: Vec<(isize, isize)> = Vec::new();\n    for y in 0..lst.len()\
    \ {\n        if lst[y].len() == x {\n            row_x.push((y, lst[y][x]));\n\
    \        }\n    }\n    row_x.sort_by(|x, y| x.1)\n        .sort_by(|x, y| -x.0);\n\
    \    row_x\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0djm3pq.rs:20:28\n   |\n\
    20 |         if lst[y].len() == x {\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         if lst[y].len()\
    \ == x.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk0djm3pq.rs:21:25\n   |\n21 |\
    \             row_x.push((y, lst[y][x]));\n   |                         ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |             row_x.push((y.try_into().unwrap(),\
    \ lst[y][x]));\n   |                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk0djm3pq.rs:21:28\n\
    \   |\n21 |             row_x.push((y, lst[y][x]));\n   |                    \
    \        ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk0djm3pq.rs:24:26\n   |\n24 |\
    \     row_x.sort_by(|x, y| x.1)\n   |                          ^^^ expected enum\
    \ `std::cmp::Ordering`, found `isize`\n\nerror[E0599]: no method named `sort_by`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpk0djm3pq.rs:25:10\n\
    \   |\n25 |         .sort_by(|x, y| -x.0);\n   |          ^^^^^^^ method not found\
    \ in `()`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut i = 1;\n    let mut j = 1;\n    let mut row = 0;\n    let mut\
    \ col = 0;\n    let mut result: Vec<(isize, isize)> = vec![];\n    while i <=\
    \ lst.len() {\n        if lst[i - 1][x] as isize < x as isize {\n            i\
    \ += 1;\n        } else {\n            result.push((row, col));\n            col\
    \ += 1;\n            i = 0;\n        }\n        if j >= lst[i - 1].len() {\n \
    \           j = 0;\n            row += 1;\n        }\n    }\n    result.push((row,\
    \ col));\n    result.sort_by_key(|v| v[0]);\n    result.sort_by_key(|v| -v[1]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,` or `}`, found `+=`\n  --> /tmp/tmpo8w24arq.rs:25:15\n\
    \   |\n24 |         if lst[i - 1][x] as isize < x as isize {\n   |           \
    \                               ----- while parsing this struct\n25 |        \
    \     i += 1;\n   |               ^^ expected one of `,` or `}`\n\nerror: `<`\
    \ is interpreted as a start of generic arguments for `isize`, not a comparison\n\
    \  --> /tmp/tmpo8w24arq.rs:24:35\n   |\n24 |         if lst[i - 1][x] as isize\
    \ < x as isize {\n   |                                   ^ ---- interpreted as\
    \ generic arguments\n   |                                   |\n   |          \
    \                         not interpreted as comparison\n   |\nhelp: try comparing\
    \ the cast value\n   |\n24 |         if (lst[i - 1][x] as isize) < x as isize\
    \ {\n   |            +                      +\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo8w24arq.rs:24:12\n   |\n24 |  \
    \       if lst[i - 1][x] as isize < x as isize {\n   |            ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0608]:\
    \ cannot index into a value of type `&(isize, isize)`\n  --> /tmp/tmpo8w24arq.rs:37:28\n\
    \   |\n37 |     result.sort_by_key(|v| v[0]);\n   |                          \
    \  ^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize, isize)`\n\
    \  --> /tmp/tmpo8w24arq.rs:38:29\n   |\n38 |     result.sort_by_key(|v| -v[1]);\n\
    \   |                             ^^^^\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        ans.push(get_row_inner(row, x));\n    }\n    ans.sort_by(|l, r| l.0);\n\
    \    ans.reverse();\n    ans.dedup();\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_row_inner` in this scope\n  -->\
    \ /tmp/tmpuxdp651j.rs:20:18\n   |\n20 |         ans.push(get_row_inner(row, x));\n\
    \   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]:\
    \ no field `0` on type `&_`\n  --> /tmp/tmpuxdp651j.rs:22:26\n   |\n22 |     ans.sort_by(|l,\
    \ r| l.0);\n   |                          ^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len() as isize;\n    let mut cols = lst[0].len() as\
    \ isize;\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    rows.compare_to(&rows,\
    \ |x, _| {\n        -1\n    })\n    .unwrap();\n    cols.compare_to(&cols, |x,\
    \ _| {\n        -1\n    })\n    .unwrap();\n    while rows > 0 {\n        if cols\
    \ == x {\n            res.push((rows - 1, cols));\n            break;\n      \
    \  }\n        rows.compare_to(&rows, |x, _| {\n            -1\n        })\n  \
    \      .unwrap();\n        cols.compare_to(&cols, |x, _| {\n            1\n  \
    \      })\n        .unwrap();\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `compare_to` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp1rs4lsxn.rs:21:10\n   |\n21 |     rows.compare_to(&rows,\
    \ |x, _| {\n   |          ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `compare_to` found for type `isize` in the current scope\n \
    \ --> /tmp/tmp1rs4lsxn.rs:25:10\n   |\n25 |     cols.compare_to(&cols, |x, _|\
    \ {\n   |          ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `compare_to` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp1rs4lsxn.rs:34:14\n   |\n34 |         rows.compare_to(&rows, |x, _|\
    \ {\n   |              ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `compare_to` found for type `isize` in the current scope\n \
    \ --> /tmp/tmp1rs4lsxn.rs:38:14\n   |\n38 |         cols.compare_to(&cols, |x,\
    \ _| {\n   |              ^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut y = x; // initialize variable y\n    let mut row = Vec::new();\
    \ // initialize variable row\n    let mut lst = lst.to_owned(); // create owned\
    \ copy of lst\n\n    // initialize loop\n    while y != 0 {\n        // add a\
    \ new row\n        row.push((y&1, lst[y/2].iter().filter(|&x| x == y).count()));\n\
    \        // reset y for the new row\n        y = y / 2;\n    }\n    // sort row\
    \ by column in descending order\n    row.sort_by_key(|&(_, c)| {\n        (c,\
    \ true)\n    });\n    // sort row by row in ascending order\n    row.sort_by_key(|&(_,\
    \ c)| {\n        (c, false)\n    });\n    // return row\n    row\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpi43njqyw.rs:25:24\n   |\n25 |         row.push((y&1, lst[y/2].iter().filter(|&x|\
    \ x == y).count()));\n   |                        ^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<isize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut new_lst\
    \ = vec![];\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_end\
    \ = lst.len();\n    let mut col_end = lst[0].len();\n    let mut first_row = vec![];\n\
    \    let mut first_col = vec![];\n    while row_idx < row_end {\n        let mut\
    \ new_row = vec![];\n        while col_idx < col_end {\n            if row_idx\
    \ == row_end || col_idx == col_end {\n                break;\n            }\n\
    \            if lst[row_idx][col_idx] == x {\n                new_row.push((row_idx,\
    \ col_idx));\n                row_idx += 1;\n                col_idx += 1;\n \
    \           } else if lst[row_idx][col_idx] < x {\n                row_idx +=\
    \ 1;\n            } else {\n                col_idx += 1;\n            }\n   \
    \     }\n        first_row = first_row.push(new_row);\n    }\n    sort_by_row(&first_row);\n\
    \    sort_by_col(&first_row);\n    new_lst.push(first_row);\n    new_lst.extend(first_row);\n\
    \    return new_lst;\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_row` in this scope\n  --> /tmp/tmptilau34k.rs:46:5\n\
    \   |\n46 |     sort_by_row(&first_row);\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `sort_by_col` in this scope\n  -->\
    \ /tmp/tmptilau34k.rs:47:5\n   |\n47 |     sort_by_col(&first_row);\n   |    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptilau34k.rs:44:21\n   |\n26 |     let mut first_row = vec![];\n   |\
    \                         ------ expected due to this value\n...\n44 |       \
    \  first_row = first_row.push(new_row);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<Vec<(usize,\
    \ usize)>>`\n           found unit type `()`\n\nerror[E0271]: type mismatch resolving\
    \ `<Vec<Vec<(usize, usize)>> as IntoIterator>::Item == Vec<Vec<(usize, usize)>>`\n\
    \   --> /tmp/tmptilau34k.rs:49:13\n    |\n49  |     new_lst.extend(first_row);\n\
    \    |             ^^^^^^ expected struct `Vec`, found tuple\n    |\n    = note:\
    \ expected struct `Vec<Vec<(usize, usize)>>`\n               found struct `Vec<(usize,\
    \ usize)>`\nnote: required by a bound in `extend`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptilau34k.rs:50:12\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n50 |     return new_lst;\n   |            ^^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<Vec<(usize, usize)>>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut rows\
    \ = lst.len();\n        let mut columns = lst[0].len();\n        rows.sort_unstable_by(|a,\
    \ b| a.iter().cmp(&b.iter()).reverse());\n        columns.sort_unstable_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n\n        rows\n            .into_iter()\n\
    \            .map(|y| {\n                let mut columns = columns.clone();\n\
    \                let mut row = vec![];\n                while columns.len() !=\
    \ 0 {\n                    let column = columns.pop().unwrap();\n            \
    \        row.push((y, column));\n                }\n                row\n    \
    \        })\n            .collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_unstable_by` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpmf99dudq.rs:23:14\n   |\n23 |         rows.sort_unstable_by(|a,\
    \ b| a.iter().cmp(&b.iter()).reverse());\n   |              ^^^^^^^^^^^^^^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `sort_unstable_by` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpmf99dudq.rs:24:17\n   |\n\
    24 |         columns.sort_unstable_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \   |                 ^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ `usize` is not an iterator\n  --> /tmp/tmpmf99dudq.rs:27:14\n   |\n27 |    \
    \         .into_iter()\n   |              ^^^^^^^^^ `usize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `usize: IntoIterator`\n         \
    \  `&usize: Iterator`\n           which is required by `&usize: IntoIterator`\n\
    \           `&mut usize: Iterator`\n           which is required by `&mut usize:\
    \ IntoIterator`\n\nerror[E0599]: no method named `len` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpmf99dudq.rs:31:31\n   |\n31 |          \
    \       while columns.len() != 0 {\n   |                               ^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `pop` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpmf99dudq.rs:32:42\n   |\n32 |          \
    \           let column = columns.pop().unwrap();\n   |                       \
    \                   ^^^ help: there is an associated function with a similar name:\
    \ `pow`\n\nerror: aborting due to 5 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    let mut row_index = 0;\n    let mut row_len\
    \ = lst.len();\n\n    for row in lst {\n        let row_len = row.len();\n   \
    \     if row_index == row_len {\n            break;\n        }\n        let found\
    \ = false;\n        for col in row.iter() {\n            if col == x {\n     \
    \           found = true;\n                break;\n            }\n        }\n\
    \        if found {\n            for (i, j) in row.iter().zip(0..row_len).rev()\
    \ {\n                ret = ret.push((i, j));\n            }\n        } else {\n\
    \            break;\n        }\n        row_index += 1;\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpasdeur8y.rs:29:20\n\
    \   |\n29 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpasdeur8y.rs:36:23\n   |\n18 |     let mut ret = vec![];\n   |      \
    \             ------ expected due to this value\n...\n36 |                 ret\
    \ = ret.push((i, j));\n   |                       ^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(&isize, usize)>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpasdeur8y.rs:43:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n43 |     ret\n   |     ^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(&isize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut row = 0;\n    let mut col = 0;\n\
    \n    while lst.len() > row {\n        let col = lst.len() - 1 - row;\n\n    \
    \    while col >= 0 {\n            result.push((row, col));\n            col -=\
    \ 1;\n        }\n\n        row += 1;\n    }\n\n    if row < x {\n        result.push((row,\
    \ x));\n    }\n\n    result.sort_by(|a, b| a.1.cmp(&b.1));\n    result.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpadv0vywp.rs:33:14\n   |\n\
    33 |     if row < x {\n   |              ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |     if row < x.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadv0vywp.rs:34:27\n\
    \   |\n34 |         result.push((row, x));\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |         result.push((row,\
    \ x.try_into().unwrap()));\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpadv0vywp.rs:40:5\n   |\n17 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n40 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n    if lst.len()\
    \ == 1 {\n        return vec![(0, lst.len())];\n    }\n\n    let mut r = vec![];\n\
    \n    for x in lst {\n        for y in x {\n            if y <= x {\n        \
    \        continue;\n            }\n            if y < x {\n                r.push((y,\
    \ x.iter().cloned().nth(y).unwrap()));\n            }\n        }\n    }\n    r.sort_by(|a,\
    \ b| a.1.cmp(b.1));\n    r.sort_by_key(|a, b| b.1.cmp(a.1));\n    r.into_iter().filter_map(|(a,\
    \ b)| {\n        let mut row: Vec<(isize, isize)> = vec![(0, a.1)];\n        for\
    \ &(y, c) in &b {\n            row.push((y, c));\n        }\n        row\n   \
    \ }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_p7uud2j.rs:22:25\n   |\n\
    22 |         return vec![(0, lst.len())];\n   |                         ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |         return\
    \ vec![(0, lst.len().try_into().unwrap())];\n   |                            \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_p7uud2j.rs:29:21\n\
    \   |\n29 |             if y <= x {\n   |                     ^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_p7uud2j.rs:32:20\n\
    \   |\n32 |             if y < x {\n   |                    ^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_p7uud2j.rs:33:50\n\
    \   |\n33 |                 r.push((y, x.iter().cloned().nth(y).unwrap()));\n\
    \   |                                                  ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n33 |                 r.push((y, x.iter().cloned().nth(y.try_into().unwrap()).unwrap()));\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_p7uud2j.rs:37:30\n   |\n37 |\
    \     r.sort_by(|a, b| a.1.cmp(b.1));\n   |                              ^^^\n\
    \   |                              |\n   |                              expected\
    \ `&isize`, found `isize`\n   |                              help: consider borrowing\
    \ here: `&b.1`\n\nerror[E0593]: closure is expected to take 1 argument, but it\
    \ takes 2 arguments\n  --> /tmp/tmp_p7uud2j.rs:38:7\n   |\n38 |     r.sort_by_key(|a,\
    \ b| b.1.cmp(a.1));\n   |       ^^^^^^^^^^^ ------ takes 2 arguments\n   |   \
    \    |\n   |       expected closure that takes 1 argument\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    for row in lst.iter() {\n        let row_coords\
    \ = coords_by_row(&row);\n        let mut sorted_row_coords = row_coords.clone();\n\
    \        sorted_row_coords.sort_by_key(|&(k, _)| -k.0);\n        if let Some(mut\
    \ cur) = sorted_row_coords.iter_mut().find(|&(_, v)| v == x) {\n            cur.0\
    \ = cur.0 - 1;\n            coords.extend_from_slice(&cur.0);\n            cur.0\
    \ = cur.0 - 1;\n            coords.extend_from_slice(&cur.1);\n        }\n   \
    \ }\n    coords.sort_by_key(|&(_, v)| -v);\n    coords\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `coords_by_row` in this scope\n  -->\
    \ /tmp/tmpiyhu0kco.rs:20:26\n   |\n20 |         let row_coords = coords_by_row(&row);\n\
    \   |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = vec![];\n    for i in lst.iter().cloned() {\n        if\
    \ !i.contains(&x) {\n            continue;\n        }\n\n        let mut j = i.iter().cloned().cloned().collect::<Vec<_>>();\n\
    \        j.sort_by(|a, b| a.cmp(&b).reverse());\n        let mut z = j.clone().into_iter().filter(|&(_,\
    \ y)| y == x).collect::<Vec<_>>();\n        z.sort_by(|a, b| b.cmp(&a).reverse());\n\
    \n        for (_, y) in &z {\n            z.push(y);\n        }\n        z.sort();\n\
    \        for (_, y) in z {\n            z.push(y);\n        }\n        for i in\
    \ z {\n            res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpz3nkx8g3.rs:24:39\n     |\n24   | \
    \        let mut j = i.iter().cloned().cloned().collect::<Vec<_>>();\n     | \
    \                                      ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpz3nkx8g3.rs:24:48\n\
    \   |\n24 |           let mut j = i.iter().cloned().cloned().collect::<Vec<_>>();\n\
    \   |                                                  ^^^^^^^ method cannot be\
    \ called on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Cloned<std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n   \
    \        which is required by `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \           `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n        \
    \   which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if !lst.is_empty() {\n        let rows = lst.len() - 1;\n        let\
    \ mut row = vec![(rows, 0)];\n        for (row_i, row_row_vec) in row.iter_mut().zip::<(Vec<isize>,\
    \ isize)>(&lst) {\n            let row_row_i = row_row_vec.iter().enumerate().filter(|(n,\
    \ _)| n == row_i).map(|(n, v)| v).max().unwrap() as isize;\n            for col_i\
    \ in 0..row_row_i {\n                let col_row_i = row_row_i - (col_i + 1);\n\
    \                if col_row_i >= 0 {\n                    row_row_vec[col_i] =\
    \ col_i;\n                }\n            }\n        }\n        row.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row.sort_by(|a, b| b.1.cmp(&a.1));\n        row.iter().map(|x|\
    \ x.1).collect()\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `(Vec<isize>, isize)` is not an iterator\n  --> /tmp/tmpanyyvzyu.rs:21:52\n\
    \   |\n21 |         for (row_i, row_row_vec) in row.iter_mut().zip::<(Vec<isize>,\
    \ isize)>(&lst) {\n   |                                                    ^^^\
    \ `(Vec<isize>, isize)` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `(Vec<isize>, isize)`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `(Vec<isize>, isize)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpanyyvzyu.rs:21:79\n   |\n21 |  \
    \       for (row_i, row_row_vec) in row.iter_mut().zip::<(Vec<isize>, isize)>(&lst)\
    \ {\n   |                                                                    \
    \           ^^^^ expected tuple, found `&Vec<Vec<isize>>`\n   |\n   = note:  expected\
    \ tuple `(Vec<isize>, isize)`\n           found reference `&Vec<Vec<isize>>`\n\
    \nerror[E0277]: `(Vec<isize>, isize)` is not an iterator\n  --> /tmp/tmpanyyvzyu.rs:21:37\n\
    \   |\n21 |         for (row_i, row_row_vec) in row.iter_mut().zip::<(Vec<isize>,\
    \ isize)>(&lst) {\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `(Vec<isize>, isize)` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `(Vec<isize>, isize)`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `Zip<std::slice::IterMut<'_,\
    \ (usize, {integer})>, (Vec<isize>, isize)>`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `Zip<std::slice::IterMut<'_,\
    \ (usize, {integer})>, (Vec<isize>, isize)>`\n\nerror[E0277]: a value of type\
    \ `Vec<(isize, isize)>` cannot be built from an iterator over elements of type\
    \ `{integer}`\n    --> /tmp/tmpanyyvzyu.rs:32:33\n     |\n32   |         row.iter().map(|x|\
    \ x.1).collect()\n     |                                 ^^^^^^^ value of type\
    \ `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item={integer}>`\n\
    \     |\n     = help: the trait `FromIterator<{integer}>` is not implemented for\
    \ `Vec<(isize, isize)>`\n     = help: the trait `FromIterator"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    if lst.len() == 0 || lst.len() == 1 {\n\
    \        result.push((0, 0));\n        return result;\n    }\n    let mut row_sorted\
    \ = vec![(0, 0)];\n    for row in lst {\n        let mut col_sorted = vec![];\n\
    \        for row in row {\n            if row.is_subset(&[x]) {\n            \
    \    col_sorted.push((row.iter().min().unwrap(), row.iter().max().unwrap()));\n\
    \            }\n        }\n        row_sorted.extend(col_sorted.iter().cloned());\n\
    \    }\n    row_sorted.sort_by_key(|x| *x.1).sort_by_key(|x| *x.0);\n    for row\
    \ in row_sorted {\n        result.push((row.0, row.1));\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_subset` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp9z1l73t9.rs:27:20\n   |\n27 |             if row.is_subset(&[x])\
    \ {\n   |                    ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp9z1l73t9.rs:28:38\n\
    \   |\n28 |                 col_sorted.push((row.iter().min().unwrap(), row.iter().max().unwrap()));\n\
    \   |                                      ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp9z1l73t9.rs:28:65\n   |\n28 |                 col_sorted.push((row.iter().min().unwrap(),\
    \ row.iter().max().unwrap()));\n   |                                         \
    \                        ^^^^ method not found in `isize`\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmp9z1l73t9.rs:33:32\n   |\n\
    33 |     row_sorted.sort_by_key(|x| *x.1).sort_by_key(|x| *x.0);\n   |       \
    \                         ^^^^\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmp9z1l73t9.rs:33:38\n\
    \   |\n33 |     row_sorted.sort_by_key(|x| *x.1).sort_by_key(|x| *x.0);\n   |\
    \                                      ^^^^^^^^^^^ method not found in `()`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = vec![(0, 0)];\n    let mut rows = vec![];\n   \
    \ let mut cols = vec![];\n    let mut row = 0;\n    let mut col = 0;\n    let\
    \ mut row_len = lst.len();\n\n    while row < row_len {\n        let row_lst =\
    \ &lst[row as usize];\n        let row_x = row_lst[x as usize];\n        rows.push(row);\n\
    \        cols.push(col);\n        if row_x == x {\n            let row_y = row;\n\
    \            coordinates.push((row_y, col));\n            break;\n        }\n\
    \        row += 1;\n        col += 1;\n    }\n\n    let mut result = vec![];\n\
    \    coordinates.sort_by_key(|(_, x)| *x);\n    coordinates.sort_by_key(|(_, y)|\
    \ *y, |(_, x)| x);\n    for (row, col) in coordinates {\n        let row_lst =\
    \ &lst[row as usize];\n        let row_x = row_lst[x as usize];\n        let row_y\
    \ = row;\n        let col_x = col;\n        let col_y = col;\n        result.push((row_y,\
    \ col_x));\n        result.push((row_x, col_y));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `(_, _)`\n  --> /tmp/tmp1d80dckr.rs:41:30\n\
    \   |\n41 |     coordinates.sort_by_key(|(_, y)| *y, |(_, x)| x);\n   |      \
    \                        ^^^^^^ consider giving this closure parameter the explicit\
    \ type `(_, _)`, with the type parameters specified\n   |\n   = note: type must\
    \ be known at this point\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n   --> /tmp/tmp1d80dckr.rs:41:17\n    |\n41  |    \
    \ coordinates.sort_by_key(|(_, y)| *y, |(_, x)| x);\n    |                 ^^^^^^^^^^^\
    \ -----------  ---------- supplied 2 arguments\n    |                 |\n    |\
    \                 expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1d80dckr.rs:49:22\n  \
    \ |\n49 |         result.push((row_x, col_y));\n   |                      ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n49 |         result.push((row_x.try_into().unwrap(),\
    \ col_y));\n   |                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1d80dckr.rs:51:5\n   |\n17 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n51 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, {integer})>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rev_lst = lst.rev();\n    rev_lst.sort_by(|x, y| x.iter().zip(y.iter()).collect::<Vec<_>>());\n\
    \    let mut mut_x = x;\n    rev_lst.sort_by(|x, y| {\n        if x.len() < y.len()\
    \ {\n            y.iter().reverse().collect::<Vec<_>>()\n        } else {\n  \
    \          x.iter().collect::<Vec<_>>()\n        }\n    });\n    let mut res:\
    \ Vec<(isize, isize)> = vec![];\n    let mut i = 1;\n    let mut j = 1;\n    while\
    \ j < rev_lst.len() {\n        let row = (mut_x, i);\n        let col = (mut_x,\
    \ j);\n        res.push((row, col));\n        i += 1;\n        j += 1;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<Vec<isize>>` is not an iterator\n   --> /tmp/tmpkvnsaeag.rs:18:27\n\
    \    |\n18  |       let mut rev_lst = lst.rev();\n    |                      \
    \       ^^^ `Vec<Vec<isize>>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<Vec<isize>>: Iterator`\n\
    \            which is required by `&mut Vec<Vec<isize>>: Iterator`\n         \
    \   `[Vec<isize>]: Iterator`\n            which is required by `&mut [Vec<isize>]:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkvnsaeag.rs:34:19\n\
    \   |\n34 |         res.push((row, col));\n   |                   ^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(isize, {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkvnsaeag.rs:34:24\n\
    \   |\n34 |         res.push((row, col));\n   |                        ^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(isize, {integer})`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len();\n    let columns = lst[0].len();\n    let mut result:\
    \ Vec<(isize, isize)> = Vec::new();\n    for i in 0..rows {\n        if i != 0\
    \ {\n            result.push((lst[i].last().unwrap(), lst[i].first().unwrap()));\n\
    \        }\n        if x == lst[i].len() {\n            return result;\n     \
    \   }\n        if lst[i][x] > lst[i][x - 1] {\n            result.push((lst[i][x],\
    \ i));\n        }\n        if lst[i][x] < lst[i][x - 1] {\n            result.push((lst[i][x],\
    \ i - 1));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcmafkm7_.rs:23:26\n   |\n\
    23 |             result.push((lst[i].last().unwrap(), lst[i].first().unwrap()));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |        \
    \     result.push((*lst[i].last().unwrap(), lst[i].first().unwrap()));\n   | \
    \                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcmafkm7_.rs:23:50\n\
    \   |\n23 |             result.push((lst[i].last().unwrap(), lst[i].first().unwrap()));\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |             result.push((lst[i].last().unwrap(), *lst[i].first().unwrap()));\n\
    \   |                                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcmafkm7_.rs:25:17\n   |\n25 |         if x == lst[i].len()\
    \ {\n   |                 ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n25 |         if x == lst[i].len().try_into().unwrap() {\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcmafkm7_.rs:28:12\n  \
    \ |\n28 |         if lst[i][x] > lst[i][x - 1] {\n   |            ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcmafkm7_.rs:28:24\n   |\n28 |  \
    \       if lst[i][x] > lst[i][x - 1] {\n   |                        ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return []\n    }\n    let mut row = Vec::new();\n\
    \    for cols in lst {\n        for _ in 0..(x - 1) {\n            row.push((0,\
    \ 0));\n        }\n        row.push((cols.len() - 1, cols.len()));\n    }\n  \
    \  row.sort_by_key(|a, b| a.0.cmp(&b.0));\n    row.sort_by_key(|a, b| b.1.cmp(&a.1));\n\
    \    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphii5fnnc.rs:19:16\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n18 |     if lst.len() == 0 {\n19 |        \
    \ return []\n   |                ^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                |\n   |                expected struct `Vec`, found array\
    \ of 0 elements\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \           found array `[_; 0]`\n\nerror[E0593]: closure is expected to take\
    \ 1 argument, but it takes 2 arguments\n  --> /tmp/tmphii5fnnc.rs:28:9\n   |\n\
    28 |     row.sort_by_key(|a, b| a.0.cmp(&b.0));\n   |         ^^^^^^^^^^^ ------\
    \ takes 2 arguments\n   |         |\n   |         expected closure that takes\
    \ 1 argument\n\nerror[E0593]: closure is expected to take 1 argument, but it takes\
    \ 2 arguments\n  --> /tmp/tmphii5fnnc.rs:29:9\n   |\n29 |     row.sort_by_key(|a,\
    \ b| b.1.cmp(&a.1));\n   |         ^^^^^^^^^^^ ------ takes 2 arguments\n   |\
    \         |\n   |         expected closure that takes 1 argument\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphii5fnnc.rs:30:5\n   |\n17 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n30 |     row\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n          \
    \    found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    if lst.len()\
    \ == 1 {\n        return vec![];\n    }\n    let mut row = vec![];\n    let mut\
    \ min_row = isize::MAX;\n    let mut max_row = isize::MIN;\n    let mut min_col\
    \ = isize::MAX;\n    let mut max_col = isize::MIN;\n    for row in lst {\n   \
    \     min_row = min(row, min_row);\n        max_row = max(row, max_row);\n   \
    \     for col in row.iter().rev() {\n            min_col = min(col, min_col);\n\
    \            max_col = max(col, max_col);\n        }\n    }\n    for row in lst\
    \ {\n        let row = isize::max(row, max_row);\n        for col in row.iter().rev()\
    \ {\n            let col = isize::max(col, max_col);\n            if col - row\
    \ == x {\n                row.push((col, row));\n            }\n        }\n  \
    \  }\n    for row in lst {\n        for (_, col) in row.iter().rev() {\n     \
    \       if col > max_col {\n                row.pop().unwrap();\n            \
    \    break;\n            }\n        }\n    }\n    let mut min = min_row;\n   \
    \ for (_, row) in lst.iter().rev() {\n        min = min(min, row.len());\n   \
    \ }\n    let mut max = max_col;\n    for (_, row) in lst.iter().rev() {\n    \
    \    max = max(max, row.len());\n    }\n    if min > max_col {\n        // no\
    \ points to be found\n        return vec![];\n    }\n    let mut row = vec![];\n\
    \    let mut min_row = isize::MAX;\n    let mut max_row = isize::MIN;\n    let\
    \ mut min_col = isize::MAX;\n    let mut max_col = isize::MIN;\n    for row in\
    \ lst {\n        min_row = min(row, min_row);\n        max_row = max(row, max_row);\n\
    \        for col in row.iter().rev() {\n            min_col = min(col, min_col);\n\
    \            max_col = max(col, max_col);\n        }\n    }\n    for row in lst\
    \ {\n        let row = isize::max(row, max_row);\n        for col in row.iter().rev()\
    \ {\n            let col = isize::max(col, max_col);\n            if col - row\
    \ >= x && col - row < min {\n                row.push((col, row));\n         \
    \   }\n        }\n    }\n    for row in lst {\n        for (_, col) in row.iter().rev()\
    \ {\n            if col > max_col {\n                row.pop().unwrap();\n   \
    \             break;\n            }\n        }\n    }\n\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp5krdlfq9.rs:30:19\n\
    \   |\n30 |         min_row = min(row, min_row);\n   |                   ^^^\n\
    ...\n99 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n30 |        \
    \ min_row = main(row, min_row);\n   |                   ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmp5krdlfq9.rs:31:19\n   |\n31 |  \
    \       max_row = max(row, max_row);\n   |                   ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp5krdlfq9.rs:33:23\n\
    \   |\n33 |             min_col = min(col, min_col);\n   |                   \
    \    ^^^\n...\n99 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n33 |\
    \             min_col = main(col, min_col);\n   |                       ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp5krdlfq9.rs:34:23\n\
    \   |\n34 |             max_col = max(col, max_col);\n   |                   \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5krdlfq9.rs:38:30\n   |\n38 |         let row = isize::max(row, max_row);\n\
    \   |                              ^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp5krdlfq9.rs:39:24\n   |\n39 |         for col in row.iter().rev()\
    \ {\n   |                        ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `push` found for type `isize` in the current scope\n  --> /tmp/tmp5krdlfq9.rs:42:21\n\
    \   |\n42 |"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut first_col = true;\n    for row\
    \ in lst.iter().rev() {\n        let mut next_row = vec![];\n        for col in\
    \ row.iter().rev() {\n            if col == x {\n                coords.push((row\
    \ as isize, col as isize));\n            }\n            if col != x {\n      \
    \          next_row.push(col as isize);\n            }\n        }\n        if\
    \ !first_col {\n            next_row\n                .iter()\n              \
    \  .cloned()\n                .sort_by(|a, b| a.0 > b.0);\n            first_col\
    \ = false;\n        } else {\n            next_row.iter().cloned().sort_by(|a,\
    \ b| b.0 > a.0);\n        }\n    }\n    coords.iter()\n        .map(|(row, col)|\
    \ {\n            (row, col as isize)\n        })\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpyvjchrlp.rs:23:20\n\
    \   |\n23 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpyvjchrlp.rs:26:20\n   |\n26 |             if col\
    \ != x {\n   |                    ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0599]: no method named `sort_by` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpyvjchrlp.rs:34:18\n   |\n34 |          \
    \       .sort_by(|a, b| a.0 > b.0);\n   |                  ^^^^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `sort_by` found for struct `Cloned` in the current scope\n  --> /tmp/tmpyvjchrlp.rs:37:38\n\
    \   |\n37 |             next_row.iter().cloned().sort_by(|a, b| b.0 > a.0);\n\
    \   |                                      ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvjchrlp.rs:40:5\n\
    \   |\n17 |   fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                 -------------------\
    \ expected `Vec<(isize, isize)>` because of return type\n...\n40 | /     coords.iter()\n\
    41 | |         .map(|(row, col)| {\n42 | |             (row, col as isize)\n43\
    \ | |         })\n44 | |         .collect::<Vec<_>>()\n   | |____________________________^\
    \ expected `isize`, found `&isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut x = x;\n    let mut lst = lst;\n    let mut result: Vec<(isize,\
    \ isize)> = Vec::new();\n    if lst.len() <= 0 {\n        return result;\n   \
    \ }\n    let mut row = 0;\n    let mut col = 0;\n    while row < lst.len() {\n\
    \        row = row + 1;\n        let mut cur = row.clone();\n        while col\
    \ < lst.len() && cur < x {\n            cur += 1;\n            col = col + 1;\n\
    \        }\n        result.push((row, col));\n    }\n    result.sort_by_key(|&(i,\
    \ _)| i);\n    result.sort_by_key(|&(_, i), _| i, Desc);\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `Desc` in this scope\n  --> /tmp/tmp0y9m90lr.rs:36:40\n\
    \   |\n36 |     result.sort_by_key(|&(_, i), _| i, Desc);\n   |              \
    \                          ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0y9m90lr.rs:29:40\n   |\n29 |         while col < lst.len()\
    \ && cur < x {\n   |                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n29 |         while col < lst.len()\
    \ && cur < x.try_into().unwrap() {\n   |                                     \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y9m90lr.rs:33:22\n\
    \   |\n33 |         result.push((row, col));\n   |                      ^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |         result.push((row.try_into().unwrap(),\
    \ col));\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0y9m90lr.rs:33:27\n   |\n33 |         result.push((row,\
    \ col));\n   |                           ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |         result.push((row, col.try_into().unwrap()));\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmp0y9m90lr.rs:36:12\n\
    \    |\n36  |     result.sort_by_key(|&(_, i), _| i, Desc);\n    |           \
    \ ^^^^^^^^^^^ --------------  ---- supplied 2 arguments\n    |            |\n\
    \    |            expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Initialize result\n    let mut res: Vec<(isize, isize)> = vec![];\n\
    \n    // Initialize counters\n    let mut row_cnt = 0;\n\n    // Iterate through\
    \ rows\n    for i in 0..lst.len() {\n        row_cnt += lst[i].len();\n\n    \
    \    // If row contains x, then add its coordinates to result list\n        if\
    \ lst[i].contains(x) {\n            res.push((row_cnt, lst[i].binary_search(x)));\n\
    \        }\n    }\n\n    // Sort coordinates initially by rows\n    res.sort_by(|a,\
    \ b| a[0].cmp(&b[0]));\n\n    // Sort coordinates in each row by columns\n   \
    \ for res in res.iter_mut() {\n        res.sort_by(|a, b| b.cmp(&a[1]));\n   \
    \ }\n\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_7xoam6.rs:29:28\n   |\n\
    29 |         if lst[i].contains(x) {\n   |                            ^\n   |\
    \                            |\n   |                            expected `&isize`,\
    \ found `isize`\n   |                            help: consider borrowing here:\
    \ `&x`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_7xoam6.rs:30:23\n  \
    \ |\n30 |             res.push((row_cnt, lst[i].binary_search(x)));\n   |    \
    \                   ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n30 |             res.push((row_cnt.try_into().unwrap(), lst[i].binary_search(x)));\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_7xoam6.rs:30:53\n   |\n30 |             res.push((row_cnt,\
    \ lst[i].binary_search(x)));\n   |                                           \
    \          ^\n   |                                                     |\n   |\
    \                                                     expected `&isize`, found\
    \ `isize`\n   |                                                     help: consider\
    \ borrowing here: `&x`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_7xoam6.rs:30:32\n\
    \   |\n30 |             res.push((row_cnt, lst[i].binary_search(x)));\n   |  \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Result`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Result<usize, usize>`\n\nerror[E0608]: cannot index into a value of type `&(isize,\
    \ isize)`\n  --> /tmp/tmpd_7xoam6.rs:35:24\n   |\n35 |     res.sort_by(|a, b|\
    \ a[0].cmp(&b[0]));\n   |                        ^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `&(isize, isize)`\n  --> /tmp/tmpd_7xoam6.rs:35:34\n\
    \   |\n35 |     res.sort_by(|a, b| a[0].cmp(&b[0]));\n   |                   \
    \               ^^^^\n\nerror[E0599]: no method named `sort_by` found for mutable\
    \ reference `&mut (isize, isize)` in the current scope\n  --> /tmp/tmpd_7xoam6.rs:39:13\n\
    \   |\n39 |         res.sort_by(|a, b"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else {\n        let mut\
    \ lst = lst.iter().cloned().collect::<Vec<_>>();\n        sort_row(&mut lst, &x,\
    \ true);\n        let mut result = Vec::new();\n        for (rc, row) in lst.into_iter().enumerate()\
    \ {\n            for (cc, value) in row.iter().rev().enumerate().rev() {\n   \
    \             if *value == x {\n                    result.push((rc, cc));\n \
    \               }\n            }\n        }\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_row` in this scope\n  --> /tmp/tmphbtiwzak.rs:22:9\n\
    \   |\n22 |         sort_row(&mut lst, &x, true);\n   |         ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphbtiwzak.rs:31:9\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n31 |         result\n   |\
    \         ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<(usize, usize)>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    let mut col_map = HashMap::new();\n    let\
    \ mut last_pos = 0;\n    let mut last_col = 0;\n    let mut last_row = 0;\n  \
    \  let mut num_col = 0;\n    let mut num_row = 0;\n    for i in lst {\n      \
    \  if i == x\n        || i == x - 1\n        || i == x - 2\n        || i == x\
    \ - 3\n        || i == x - 4\n        || i == x - 5\n        || i == x - 6\n \
    \       {\n            row.push((num_row, num_col));\n            col_map.insert(last_row,\
    \ last_col);\n            last_col = num_col;\n            last_pos = 0;\n   \
    \         last_row = 0;\n            num_col = 0;\n            num_row = 0;\n\
    \        }\n        if num_row == 0 {\n            num_col += 1;\n        } else\
    \ {\n            last_col += 1;\n        }\n        num_row += 1;\n    }\n   \
    \ row.push((num_row, num_col));\n    col_map.insert(last_row, last_col);\n   \
    \ last_col = num_col;\n    last_pos = 0;\n    last_row = 0;\n    num_col = 0;\n\
    \    num_row = 0;\n    row.sort_by_key(|&(a, b)| *a > *b);\n    row.iter().map(|&(a,\
    \ b)| *a < *b ? *a < *b ? *a : *b).collect::<Vec<_>>().reverse().sort_by_key(|&(a,\
    \ b)| *a < *b ? *a > *b ? *a : *b).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp3384do51.rs:57:33\n\
    \   |\n57 |     row.iter().map(|&(a, b)| *a < *b ? *a < *b ? *a : *b).collect::<Vec<_>>().reverse().sort_by_key(|&(a,\
    \ b)| *a < *b ? *a > *b ? *a : *b...\n   |                                 ^ \
    \        ^\n   |\n   = help: use `::<...>` instead of `<...>` to specify lifetime,\
    \ type, or const arguments\n   = help: or use `(...)` if you meant to specify\
    \ fn arguments\nhelp: split the comparison into two\n   |\n57 |     row.iter().map(|&(a,\
    \ b)| *a < *b ? *a && *b ? *a < *b ? *a : *b).collect::<Vec<_>>().reverse().sort_by_key(|&(a,\
    \ b)| *a < *b ? *a > *b ? *a : *b).collect()\n   |                           \
    \                ++++++++++\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n  --> /tmp/tmp3384do51.rs:19:23\n   |\n19 |     let mut col_map\
    \ = HashMap::new();\n   |                       ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: can't compare `Vec<isize>` with `isize`\n  --> /tmp/tmp3384do51.rs:26:14\n\
    \   |\n26 |         if i == x\n   |              ^^ no implementation for `Vec<isize>\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<isize>` with `isize`\n  --> /tmp/tmp3384do51.rs:27:14\n   |\n27 |     \
    \    || i == x - 1\n   |              ^^ no implementation for `Vec<isize> ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut row: Vec<(isize, isize)> = Vec::new();\n\
    \    let mut row_sort = vec![(0, 0)];\n    let mut col_sort = vec![(0, 0)];\n\
    \    for i in 0..lst.len() {\n        let lst = lst[i];\n        row.clear();\n\
    \        row_sort.clear();\n        col_sort.clear();\n        row.push(row_sort.clone());\n\
    \        col_sort.push(col_sort.clone());\n        for j in 0..lst.len() {\n \
    \           let lst = lst[j];\n            for k in 0..lst.len() {\n         \
    \       if k != i {\n                    row.push((i, k));\n                 \
    \   row_sort.push((i, k));\n                    col_sort.push((k, j));\n     \
    \               col_sort.push((i, k));\n                }\n            }\n   \
    \     }\n        result.push(row.clone());\n    }\n    result\n        .iter()\n\
    \        .sort_by_key(|row| row[0].0)\n        .into_iter()\n        .map(|row|\
    \ {\n            vec![row[0].1, row[1].1, row[2].1]\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpujbgptzh.rs:27:18\n   |\n\
    27 |         row.push(row_sort.clone());\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<({integer}, {integer})>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpujbgptzh.rs:28:23\n   |\n28 |         col_sort.push(col_sort.clone());\n\
    \   |                       ^^^^^^^^^^^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected tuple `({integer}, {integer})`\n             found\
    \ struct `Vec<({integer}, {integer})>`\n\nerror[E0599]: no method named `len`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpujbgptzh.rs:31:29\n\
    \   |\n31 |             for k in 0..lst.len() {\n   |                        \
    \     ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpujbgptzh.rs:33:31\n   |\n33 |                     row.push((i, k));\n\
    \   |                               ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n33 |                     row.push((i.try_into().unwrap(),\
    \ k));\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpujbgptzh.rs:33:34\n   |\n33 |              \
    \       row.push((i, k));\n   |                                  ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |                     row.push((i,\
    \ k.try_into().unwrap()));\n   |                                   ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpujbgptzh.rs:44:10\n   |\n44 |         .sort_by_key(|row|\
    \ row[0].0)\n   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ Vec<(isize, isize)>>`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --exp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Write your code here\n    let mut row: Vec<(isize, isize)> = Vec::new();\n\
    \    for elem in lst {\n        if elem.len() == x {\n            row.push((elem.len()\
    \ - 1, elem.iter().rev().next().unwrap()));\n        }\n    }\n    row.sort_by_key(|&(x,\
    \ y)| y.0);\n    row.sort_by_key(|&(x, y)| x.0);\n    row.iter().rev().filter_map(|&(x,\
    \ y)| {\n        if y.1 == x {\n            Some((y.0, y))\n        } else {\n\
    \            None\n        }\n    })\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnctfx4li.rs:21:26\n   |\n\
    21 |         if elem.len() == x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if elem.len() == x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnctfx4li.rs:22:23\n   |\n22 |             row.push((elem.len()\
    \ - 1, elem.iter().rev().next().unwrap()));\n   |                       ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |           \
    \  row.push(((elem.len() - 1).try_into().unwrap(), elem.iter().rev().next().unwrap()));\n\
    \   |                       +              +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnctfx4li.rs:22:39\n   |\n22 |             row.push((elem.len()\
    \ - 1, elem.iter().rev().next().unwrap()));\n   |                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |             row.push((elem.len()\
    \ - 1, *elem.iter().rev().next().unwrap()));\n   |                           \
    \            +\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpnctfx4li.rs:25:33\n   |\n25 |     row.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpnctfx4li.rs:26:33\n\
    \   |\n26 |     row.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpnctfx4li.rs:28:14\n   |\n28 |         if y.1 == x\
    \ {\n   |              ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpnctfx4li.rs:29:21\n   |\n29 |           \
    \  Some((y.0, y))\n   |                     ^\n\nerror[E0308]: mismatched ty"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = Vec::<(isize, isize)>::new();\n    let mut i = 1;\n   \
    \ \n    while i <= lst.len() {\n        // get the first row from first iteration\n\
    \        if i == 1 {\n            res[0] = ((lst[0].iter().collect::<Vec<(isize,\
    \ isize)>>())[x], 0);\n        }\n        \n        // get first column from second\
    \ iteration\n        if i == 2 {\n            res[1] = ((lst[1].iter().collect::<Vec<(isize,\
    \ isize)>>())[0], (lst[1].iter().collect::<Vec<(isize, isize)>>())[x]);\n    \
    \    }\n        \n        // get the rest of the rows\n        for i in 2..lst.len()\
    \ {\n            res[i as usize - 1] = ((lst[i].iter().collect::<Vec<(isize, isize)>>())[x],\
    \ res[i - 1 as usize - 1]);\n        }\n        i += 1;\n    }\n    \n    // sort\
    \ by rows\n    res.sort_by(|a, b| a.0.cmp(&b.0));\n    \n    // sort by columns\
    \ in descending order\n    res.sort_by_key(|e| e.1.1);\n    \n    // return a\
    \ sorted list of coordinates\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `&isize`\n    --> /tmp/tmp_z17ky3d.rs:24:38\n\
    \     |\n24   |             res[0] = ((lst[0].iter().collect::<Vec<(isize, isize)>>())[x],\
    \ 0);\n     |                                      ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n \
    \    = help: the trait `FromIterator<&isize>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: the type `[(isize, isize)]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_z17ky3d.rs:24:23\n   |\n24 |  \
    \           res[0] = ((lst[0].iter().collect::<Vec<(isize, isize)>>())[x], 0);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[(isize, isize)]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<(isize, isize)>`\n\
    \nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from an\
    \ iterator over elements of type `&isize`\n    --> /tmp/tmp_z17ky3d.rs:29:38\n\
    \     |\n29   |             res[1] = ((lst[1].iter().collect::<Vec<(isize, isize)>>())[0],\
    \ (lst[1].iter().collect::<Vec<(isize, isize)>>())[x]);\n     |              \
    \                        ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<(isize, isize)>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_z17ky3d.rs:29:23\n\
    \   |\n29 |             res[1] = ((lst[1].iter().collect::<Vec<(isize, isize)>>())[0],\
    \ (lst[1].iter().collect::<Vec<(isize, isize)>>())[x]);\n   |                \
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut col_numbers:\
    \ Vec<isize> = Vec::new();\n    for i in 0..lst.len() {\n        let mut col_number:\
    \ isize = 0;\n        rows.push(vec![]);\n        col_numbers.push(i);\n     \
    \   for row in lst[..i] {\n            if row[0] == x {\n                let mut\
    \ j: isize = 0;\n                for j in 0..row.len() {\n                   \
    \ if row[j] != x {\n                        break;\n                    }\n  \
    \                  j += 1;\n                    rows[i].push((j, row[j]));\n \
    \               }\n            }\n        }\n        col_numbers.sort();\n   \
    \     col_numbers.reverse();\n        rows[i].sort_by_key(|&(a, b)| {\n      \
    \      a > b\n        });\n        for _ in 0..col_numbers.len() {\n         \
    \   rows[i].push((0, 0));\n        }\n    }\n    rows\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jziph3u.rs:22:19\n   |\n\
    22 |         rows.push(vec![]);\n   |                   ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n     \
    \        found struct `Vec<_>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7jziph3u.rs:23:26\n   |\n23 |         col_numbers.push(i);\n\
    \   |                          ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |         col_numbers.push(i.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0277]: the size for values\
    \ of type `[Vec<isize>]` cannot be known at compilation time\n  --> /tmp/tmp7jziph3u.rs:24:20\n\
    \   |\n24 |         for row in lst[..i] {\n   |                    ^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[Vec<isize>]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[Vec<isize>]`\nhelp: consider borrowing here\n\
    \   |\n24 |         for row in &lst[..i] {\n   |                    +\n24 |  \
    \       for row in &mut lst[..i] {\n   |                    ++++\n\nerror[E0277]:\
    \ `[Vec<isize>]` is not an iterator\n  --> /tmp/tmp7jziph3u.rs:24:20\n   |\n24\
    \ |         for row in lst[..i] {\n   |                    ^^^^^^^^ expected an\
    \ implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[Vec<isize>]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[Vec<isize>]`\nhelp: consider borrowing here\n\
    \   |\n24 |         for row in &lst[..i] {\n   |                    +\n24 |  \
    \       for row in &mut lst[..i] {\n   |                    ++++\n\nerror[E0599]:\
    \ no method named `push` found for tuple `(isize, isize)` in the current scope\n\
    \  --> /tmp/tmp7jziph3u.rs:32:29\n   |\n32 |                     rows[i].push((j,\
    \ row[j]));"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Create a list of coordinates, sorted by rows in ascending order\n\
    \    let mut coordinates = vec![];\n    for row in lst {\n        let mut coordinate\
    \ = vec![];\n        for i in 0..row.len() {\n            if i == x {\n      \
    \          coordinate.push((i, row.len()));\n            }\n        }\n      \
    \  coordinates.push((coordinate.iter().min().unwrap(), coordinate.iter().max().unwrap()));\n\
    \    }\n    coordinates.sort_by_key(|pair| {\n        pair[0]\n    });\n    coordinates.sort_by_key(|pair|\
    \ {\n        pair[1]\n    });\n\n    // Sort each row of the data based on the\
    \ same coordinate in descending order\n    coordinates\n        .iter()\n    \
    \    .map(|(row, coordinate)| {\n            row.iter()\n                .map(|(val,\
    \ col)| {\n                    (col, val)\n                })\n        })\n  \
    \      .sort_by_key(|row| {\n            row[0]\n        });\n\n    // Output\
    \ coordinates\n    coordinates\n        .iter()\n        .map(|(row, coordinate)|\
    \ {\n            row.iter()\n                .map(|(val, col)| {\n           \
    \         (col, val)\n                })\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi7n5qirw.rs:23:21\n   |\n\
    23 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `&(&(usize, usize), &(usize, usize))`\n  --> /tmp/tmpi7n5qirw.rs:30:9\n\
    \   |\n30 |         pair[0]\n   |         ^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `&(&(usize, usize), &(usize, usize))`\n  --> /tmp/tmpi7n5qirw.rs:33:9\n\
    \   |\n33 |         pair[1]\n   |         ^^^^^^^\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&&(usize, usize)` in the current scope\n  --> /tmp/tmpi7n5qirw.rs:40:17\n\
    \   |\n40 |             row.iter()\n   |                 ^^^^ method not found\
    \ in `&&(usize, usize)`\n\nerror[E0599]: no method named `sort_by_key` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmpi7n5qirw.rs:45:10\n   |\n45\
    \ |         .sort_by_key(|row| {\n   |          ^^^^^^^^^^^ method not found in\
    \ `Map<std::slice::Iter<'_, (&(usize, usize), &(usize, usize))>, _>`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&&(usize, usize)` in the current\
    \ scope\n  --> /tmp/tmpi7n5qirw.rs:53:17\n   |\n53 |             row.iter()\n\
    \   |                 ^^^^ method not found in `&&(usize, usize)`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n\n    for y in lst {\n  \
    \      if y == vec![x] {\n            row.push((x, y));\n        }\n    }\n\n\
    \    row.sort();\n\n    let mut row2: Vec<(isize, isize)> = vec![];\n\n    for\
    \ x in row {\n        let mut row3: Vec<isize> = vec![];\n\n        for y in row\
    \ {\n            row3.push(*y);\n        }\n\n        row2.push((x, row3.rev().sort()));\n\
    \    }\n\n    row2.sort();\n\n    row2\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppwb6z4r9.rs:22:26\n   |\n\
    22 |             row.push((x, y));\n   |                          ^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0614]: type `(isize, isize)` cannot be dereferenced\n\
    \  --> /tmp/tmppwb6z4r9.rs:34:23\n   |\n34 |             row3.push(*y);\n   |\
    \                       ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwb6z4r9.rs:37:20\n\
    \   |\n37 |         row2.push((x, row3.rev().sort()));\n   |                 \
    \   ^ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n\
    \             found tuple `(isize, isize)`\n\nerror[E0599]: `Vec<isize>` is not\
    \ an iterator\n   --> /tmp/tmppwb6z4r9.rs:37:28\n    |\n37  |           row2.push((x,\
    \ row3.rev().sort()));\n    |                              ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut row = 0;\n    let mut col = 0;\n\
    \    while row < lst.len() {\n        let mut row_in_col = vec![];\n        while\
    \ col < lst[row].len() {\n            if lst[row][col] == x {\n              \
    \  row_in_col.push((row, col));\n                break;\n            }\n     \
    \       col += 1;\n        }\n        coords.push(row_in_col.iter().cloned().collect::<Vec<(isize,\
    \ isize)>>());\n        row += 1;\n    }\n    coords.iter().cloned().sort_by(|x,\
    \ y| {\n        if x.0 == y.0 { 0 }\n        else if x.0 < y.0 { -1 }\n      \
    \  else { 1 }\n    }).reverse().collect::<Vec<(isize, isize)>>()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `(usize, usize)`\n    --> /tmp/tmp03j77eb7.rs:30:48\n\
    \     |\n30   |         coords.push(row_in_col.iter().cloned().collect::<Vec<(isize,\
    \ isize)>>());\n     |                                                ^^^^^^^\
    \ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ usize)>`\n     |\n     = help: the trait `FromIterator<(usize, usize)>` is not\
    \ implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Cloned` in the current scope\n \
    \ --> /tmp/tmp03j77eb7.rs:33:28\n   |\n33 |     coords.iter().cloned().sort_by(|x,\
    \ y| {\n   |                            ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ Vec<(isize, isize)>>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_vec = Vec::new();\n    for row in lst {\n        let mut\
    \ col_vec = Vec::new();\n        for col in row {\n            if col == x {\n\
    \                col_vec.push((row, col));\n            }\n        }\n       \
    \ row_vec.push(col_vec.reverse());\n    }\n    row_vec.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    row_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    col_sort_by_row(row_vec, row_vec.len(),\
    \ row_vec.len() * row_vec.len() / 2);\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `col_sort_by_row` in this scope\n  -->\
    \ /tmp/tmpfvjki997.rs:30:5\n   |\n30 |     col_sort_by_row(row_vec, row_vec.len(),\
    \ row_vec.len() * row_vec.len() / 2);\n   |     ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0609]: no field `0` on type `&()`\n  --> /tmp/tmpfvjki997.rs:28:30\n\
    \   |\n28 |     row_vec.sort_by(|a, b| a.0.cmp(&b.0));\n   |                 \
    \             ^\n\nerror[E0609]: no field `0` on type `&()`\n  --> /tmp/tmpfvjki997.rs:28:39\n\
    \   |\n28 |     row_vec.sort_by(|a, b| a.0.cmp(&b.0));\n   |                 \
    \                      ^\n\nerror[E0609]: no field `1` on type `&()`\n  --> /tmp/tmpfvjki997.rs:29:30\n\
    \   |\n29 |     row_vec.sort_by(|a, b| b.1.cmp(&a.1));\n   |                 \
    \             ^\n\nerror[E0609]: no field `1` on type `&()`\n  --> /tmp/tmpfvjki997.rs:29:39\n\
    \   |\n29 |     row_vec.sort_by(|a, b| b.1.cmp(&a.1));\n   |                 \
    \                      ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfvjki997.rs:17:47\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = Vec::new();\n    let mut row = Vec::new();\n    row.push(0);\n\
    \    while row.len() < lst.len() {\n        let mut flag = false;\n        for\
    \ (i, e) in row.iter().enumerate() {\n            if lst[row.len() - 1][i] ==\
    \ x {\n                flag = true;\n                break;\n            }\n \
    \       }\n        if !flag {\n            row.push(x);\n            flag = true;\n\
    \        }\n    }\n    for e in row {\n        if e != row.len() - 1 {\n     \
    \       let mut index = row.len() - 1;\n            while index != row.len() -\
    \ 1 && lst[index][e] > lst[index][e + 1] {\n                index--;\n       \
    \     }\n            ret.push((e, index));\n        }\n    }\n    ret.sort_by_key(|e|\
    \ e[0]);\n    ret.sort_by_key(|e| -(e[1]));\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpapb6gxbv.rs:38:24\n\
    \   |\n38 |                 index--;\n   |                        ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpapb6gxbv.rs:35:17\n   |\n35 |\
    \         if e != row.len() - 1 {\n   |                 ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n35 |         if e != (row.len()\
    \ - 1).try_into().unwrap() {\n   |                 +             +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpapb6gxbv.rs:37:45\n\
    \   |\n37 |             while index != row.len() - 1 && lst[index][e] > lst[index][e\
    \ + 1] {\n   |                                             ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpapb6gxbv.rs:37:61\n   |\n37 |  \
    \           while index != row.len() - 1 && lst[index][e] > lst[index][e + 1]\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0608]:\
    \ cannot index into a value of type `&(isize, usize)`\n  --> /tmp/tmpapb6gxbv.rs:43:25\n\
    \   |\n43 |     ret.sort_by_key(|e| e[0]);\n   |                         ^^^^\n\
    \nerror[E0608]: cannot index into a value of type `&(isize, usize)`\n  --> /tmp/tmpapb6gxbv.rs:44:26\n\
    \   |\n44 |     ret.sort_by_key(|e| -(e[1]));\n   |                          ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = [(x, 0)];\n    let mut row: Vec<(isize, isize)> = Vec::new();\n\
    \    let mut cnt = 0;\n    while cnt < lst.len() {\n        row = (lst[cnt], cnt);\n\
    \        if row.len() == 0 {\n            cnt += 1;\n            continue;\n \
    \       }\n        if let (Some(row), Some(col)) = row.iter().cloned().zip(rows[row.len()\
    \ - 1].iter().cloned()) {\n            if *col > x {\n                break;\n\
    \            }\n            rows.push((*row, col));\n            cnt += 1;\n \
    \           continue;\n        }\n        if *row < x {\n            break;\n\
    \        }\n        rows.push((*row, cnt));\n        cnt += 1;\n    }\n    rows.sort_by(|a,\
    \ b| {\n        (*b).1.cmp(&*a.1).reverse()\n    });\n    let mut result: Vec<(isize,\
    \ isize)> = vec![];\n    for (i, col) in rows.iter().cloned().zip(rows[rows.len()\
    \ - 1].iter().cloned()) {\n        result.push((i, *col));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuhsfpcon.rs:22:15\n   |\n\
    19 |     let mut row: Vec<(isize, isize)> = Vec::new();\n   |                \
    \  ------------------- expected due to this type\n...\n22 |         row = (lst[cnt],\
    \ cnt);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n               found\
    \ tuple `(Vec<isize>, usize)`\n\nerror[E0599]: no method named `iter` found for\
    \ tuple `(isize, {integer})` in the current scope\n  --> /tmp/tmpuhsfpcon.rs:27:85\n\
    \   |\n27 |         if let (Some(row), Some(col)) = row.iter().cloned().zip(rows[row.len()\
    \ - 1].iter().cloned()) {\n   |                                              \
    \                                       ^^^^ method not found in `(isize, {integer})`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuhsfpcon.rs:27:16\n   |\n27 |\
    \         if let (Some(row), Some(col)) = row.iter().cloned().zip(rows[row.len()\
    \ - 1].iter().cloned()) {\n   |                ^^^^^^^^^^^^^^^^^^^^^^   ------------------------------------------------------------\
    \ this expression has type `Zip<Cloned<std::slice::Iter<'_, (isize, isize)>>,\
    \ _>`\n   |                |\n   |                expected struct `Zip`, found\
    \ tuple\n   |\n   = note: expected struct `Zip<Cloned<std::slice::Iter<'_, (isize,\
    \ isize)>>, _>`\n               found tuple `(_, _)`\nhelp: you might have meant\
    \ to use field `b` whose type is `_`\n   |\n27 |         if let (Some(row), Some(col))\
    \ = row.iter().cloned().zip(rows[row.len() - 1].iter().cloned()).b {\n   |   \
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `push` found for array `[(isize, {integer}); 1]`\
    \ in the current scope\n  --> /tmp/tmpuhsfpcon.rs:31:18\n   |\n31 |          \
    \   rows.push((*row, col));\n   |                  ^^^^ method not found in `[(isize,\
    \ {integer}); 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhsfpcon.rs:35:19\n\
    \   |\n35 |         if *row < x {\n   |                   ^ expected slice, found\
    \ `isize`\n   |\n   = note: "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n\
    \    for row in lst {\n        let mut row_coord = row.iter().cloned().collect();\n\
    \        row_coord.sort_by_key(|v| v);\n        row_coords.push((row_coord.len(),\
    \ row_coord));\n    }\n    row_coords.sort_by_key(|(_, (_, y))| *y);\n\n    for\
    \ coord in row_coords.iter() {\n        if coord.0.contains(x) {\n           \
    \ coords.push((coord.0.len(), coord));\n        }\n    }\n    coords.sort_by_key(|(_,\
    \ (_, y))| *y);\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpfgu4vf2n.rs:22:9\n\
    \   |\n21 |         let mut row_coord = row.iter().cloned().collect();\n   | \
    \            ------------- consider giving `row_coord` a type\n22 |         row_coord.sort_by_key(|v|\
    \ v);\n   |         ^^^^^^^^^ cannot infer type\n   |\n   = note: type must be\
    \ known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfgu4vf2n.rs:33:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n33 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(_, (_, _))>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    for y in lst {\n\
    \        if y != Vec::new() && y[x] != x {\n            continue;\n        }\n\
    \        if rows.is_empty() {\n            rows.push((0, 0));\n        }\n   \
    \     let mut last = rows.last().unwrap();\n        let mut col_no = 1;\n    \
    \    for (x, y) in &mut y {\n            if y != x {\n                last = (last[0],\
    \ last[1] + x);\n            }\n            rows.push((col_no, last));\n     \
    \       col_no++;\n        }\n    }\n    rows\n        .into_iter()\n        .map(|(_,\
    \ y)| {\n            let (x, y) = y;\n            (x - 1, y - 1)\n        })\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxsed36xf.rs:33:19\n\
    \   |\n33 |             col_no++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |             { let tmp =\
    \ col_no; col_no += 1; tmp };\n   |             +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n\
    33 -             col_no++;\n33 +             col_no += 1;\n   | \n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxsed36xf.rs:20:31\n\
    \   |\n20 |         if y != Vec::new() && y[x] != x {\n   |                  \
    \             ^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxsed36xf.rs:28:13\n   |\n28 |\
    \         for (x, y) in &mut y {\n   |             ^^^^^^    ------ this expression\
    \ has type `Option<&mut isize>`\n   |             |\n   |             expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0608]: cannot index into a value of type `&(isize,\
    \ isize)`\n  --> /tmp/tmpxsed36xf.rs:30:25\n   |\n30 |                 last =\
    \ (last[0], last[1] + x);\n   |                         ^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&(isize, isize)`\n  --> /tmp/tmpxsed36xf.rs:30:34\n\
    \   |\n30 |                 last = (last[0], last[1] + x);\n   |             \
    \                     ^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxsed36xf.rs:32:32\n\
    \   |\n32 |             rows.push((col_no, last));\n   |                     \
    \           ^^^^ expected `isize`, found `&(isize, isize)`\n   |\n   = note: \
    \  expected type `isize`\n           found reference `&(isize, isize)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxsed36xf.rs:39:17\n   |\n39 |             let\
    \ (x, y) = y;\n   |                 ^^^^^^   - this expression has type `isize`\n\
    \   |                 |\n "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut v = vec![];\n    for row in lst {\n        let mut row_idx =\
    \ vec![];\n        for (i, x) in row.iter().enumerate() {\n            if x ==\
    \ x {\n                row_idx.push(i);\n            }\n        }\n        let\
    \ row_idx = row_idx.reverse().collect();\n        v.push((row_idx, row.iter().enumerate().filter(|&(_,\
    \ v)| v == x).count()));\n    }\n    let mut n = lst[0].len();\n    v.sort();\n\
    \    for &(_, v) in v.iter().skip(x.into()).take(x.into()).enumerate() {\n   \
    \     n -= v;\n    }\n    v.iter().map(|&(_, v)| (n, v)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpdxv5g1zz.rs:26:41\n\
    \   |\n26 |         let row_idx = row_idx.reverse().collect();\n   |         \
    \                                ^^^^^^^ `()` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpdxv5g1zz.rs:27:68\n   |\n27 |         v.push((row_idx,\
    \ row.iter().enumerate().filter(|&(_, v)| v == x).count()));\n   |           \
    \                                                         ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: the trait bound `usize:\
    \ From<isize>` is not satisfied\n  --> /tmp/tmpdxv5g1zz.rs:31:36\n   |\n31 | \
    \    for &(_, v) in v.iter().skip(x.into()).take(x.into()).enumerate() {\n   |\
    \                                    ^^^^ the trait `From<isize>` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n   = note: required because of\
    \ the requirements on the impl of `Into<usize>` for `isize`\n\nerror[E0277]: the\
    \ trait bound `usize: From<isize>` is not satisfied\n  --> /tmp/tmpdxv5g1zz.rs:31:51\n\
    \   |\n31 |     for &(_, v) in v.iter().skip(x.into()).take(x.into()).enumerate()\
    \ {\n   |                                                   ^^^^ the trait `From<isize>`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n           "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = vec![];\n    for row in lst {\n  \
    \      let mut sorted_row_coords = sort_by_row_coord(row);\n        for coord\
    \ in sorted_row_coords {\n            if coord == (x, 0) {\n                ret.push((coord.0,\
    \ coord.1 - 1));\n            }\n        }\n    }\n    ret.sort_by_key(|k| k.1);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_by_row_coord` in this scope\n\
    \  --> /tmp/tmpl2t36voq.rs:20:37\n   |\n20 |         let mut sorted_row_coords\
    \ = sort_by_row_coord(row);\n   |                                     ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n\n    for v in lst.iter() {\n        if v.len()\
    \ == x {\n            row.push((v.iter().cloned().collect()));\n        }\n  \
    \  }\n\n    row.sort_by(|a, b| b.len() - a.len());\n    row.sort_by(|a, b| a.len()\
    \ - b.len());\n\n    row.iter().cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpvktsw1d5.rs:22:22\n\
    \   |\n22 |             row.push((v.iter().cloned().collect()));\n   |       \
    \               ^                           ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -             row.push((v.iter().cloned().collect()));\n\
    22 +             row.push(v.iter().cloned().collect());\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvktsw1d5.rs:21:23\n   |\n21 |         if v.len()\
    \ == x {\n   |                       ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n21 |         if v.len() == x.try_into().unwrap() {\n   |\
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for column in row.iter().rev() {\n            if column == x {\n\
    \                let row_coords = (0..i).collect::<Vec<_>>();\n              \
    \  row_coords.sort();\n                row_coords.reverse();\n               \
    \ coords.extend(row_coords);\n            }\n        }\n    }\n    coords.sort_by_key(|i|\
    \ {\n        let mut cmp = i.1;\n        if cmp == i {\n            cmp = i.0.cmp(&cmp);\n\
    \        }\n        cmp\n    });\n    coords.sort_by_key(|i| {\n        let mut\
    \ cmp = i.1;\n        if cmp == i {\n            cmp = i.0.cmp(&cmp);\n      \
    \  }\n        cmp\n    }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmph3t1wl8w.rs:21:23\n\
    \   |\n21 |             if column == x {\n   |                       ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0609]: no field `1` on type `&usize`\n\
    \  --> /tmp/tmph3t1wl8w.rs:30:25\n   |\n30 |         let mut cmp = i.1;\n   |\
    \                         ^\n\nerror[E0609]: no field `0` on type `&usize`\n \
    \ --> /tmp/tmph3t1wl8w.rs:32:21\n   |\n32 |             cmp = i.0.cmp(&cmp);\n\
    \   |                     ^\n\nerror[E0609]: no field `1` on type `&usize`\n \
    \ --> /tmp/tmph3t1wl8w.rs:37:25\n   |\n37 |         let mut cmp = i.1;\n   | \
    \                        ^\n\nerror[E0609]: no field `0` on type `&usize`\n  -->\
    \ /tmp/tmph3t1wl8w.rs:39:21\n   |\n39 |             cmp = i.0.cmp(&cmp);\n   |\
    \                     ^\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmph3t1wl8w.rs:42:8\n\
    \   |\n42 |     }).collect()\n   |        ^^^^^^^ `()` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0599,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row = 0;\n\n    for elem in\
    \ lst {\n        let mut col = 0;\n        loop {\n            if elem == x {\n\
    \                result.push((row, col));\n                break;\n          \
    \  }\n            col += 1;\n            if col == elem.len() {\n            \
    \    row += 1;\n                col = 0;\n            }\n        }\n    }\n  \
    \  result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)| y.1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `isize`\n  --> /tmp/tmpkp0zt51d.rs:24:21\n\
    \   |\n24 |             if elem == x {\n   |                     ^^ no implementation\
    \ for `Vec<isize> == isize`\n   |\n   = help: the trait `PartialEq<isize>` is\
    \ not implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0610]: `{integer}`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpkp0zt51d.rs:35:36\n\
    \   |\n35 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpkp0zt51d.rs:36:36\n   |\n36 |     result.sort_by_key(|&(x,\
    \ y)| y.1);\n   |                                    ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkp0zt51d.rs:37:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<({integer}, usize)>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rev_lst = lst.iter().rev();\n    let mut rev_lst = vec![0; rev_lst.len()];\n\
    \n    let mut new_lst = vec![0; rev_lst.len()];\n    let mut new_lst = vec![0;\
    \ rev_lst.len()];\n    let mut row = 0;\n    let mut col_pos = 0;\n\n    // 1.\
    \ Sort coordinates initially by rows in ascending order.\n    rev_lst.sort_by(|a,\
    \ b| a.iter().cmp(&b.iter()).unwrap());\n\n    for (i, ele) in rev_lst.iter().enumerate()\
    \ {\n        let mut col = col_pos;\n\n        match lst {\n            vec![vec![x;\
    \ 0]] => {\n                new_lst[i] = vec![row, col];\n                break;\n\
    \            }\n            vec![vec![x; y]] if y < x => {\n                new_lst[i]\
    \ = vec![row, col];\n                break;\n            }\n            _ => {\n\
    \                if x < row {\n                    new_lst[i] = vec![row, col];\n\
    \                    break;\n                }\n                row += 1;\n  \
    \              col += 1;\n            }\n        }\n    }\n\n    // 2. Sort coordinates\
    \ initially by columns in descending order.\n    rev_lst.sort_by(|a, b| b.iter().cmp(&a.iter()).unwrap());\n\
    \n    for (i, ele) in rev_lst.iter().enumerate() {\n        let mut col = col_pos;\n\
    \n        match lst {\n            vec![vec![x; 0]] => {\n                new_lst[i]\
    \ = vec![row, col];\n                break;\n            }\n            vec![vec![x;\
    \ y]] if y < x => {\n                new_lst[i] = vec![row, col];\n          \
    \      break;\n            }\n            _ => {\n                if x < row {\n\
    \                    new_lst[i] = vec![row, col];\n                    break;\n\
    \                }\n                row += 1;\n                col -= 1;\n   \
    \         }\n        }\n    }\n\n    new_lst.sort_by(|a, b| a.iter().cmp(&b.iter()).unwrap());\n\
    \n    return new_lst.into_iter().map(|elem| {\n        (elem[0], elem[1])\n  \
    \  });\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpf_1mtdew.rs:37:26\n\
    \   |\n37 |             vec![vec![x; y]] if y < x => {\n   |                 \
    \         ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `y` in this scope\n  --> /tmp/tmpf_1mtdew.rs:37:33\n   |\n\
    37 |             vec![vec![x; y]] if y < x => {\n   |                        \
    \         ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `y` in this scope\n  --> /tmp/tmpf_1mtdew.rs:63:26\n   |\n\
    63 |             vec![vec![x; y]] if y < x => {\n   |                        \
    \  ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]: cannot\
    \ find value `y` in this scope\n  --> /tmp/tmpf_1mtdew.rs:63:33\n   |\n63 |  \
    \           vec![vec![x; y]] if y < x => {\n   |                             \
    \    ^ help: a local variable with a similar name exists: `i`\n\nerror: arbitrary\
    \ expressions aren't allowed in patterns\n  --> /tmp/tmpf_1mtdew.rs:33:13\n  \
    \ |\n33 |             vec![vec![x; 0]] => {\n   |             ^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpf_1mtdew.rs:37:13\n   |\n37 |           \
    \  vec![vec![x; y]] if y < x => {\n   |             ^^^^^^^^^^^^^^^^\n   |\n \
    \  = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't allowed\
    \ in patterns\n  --> /tmp/tmpf_1mtdew.rs:59:13\n   |\n59 |             vec![vec![x;\
    \ 0]] => {\n   |             ^^^^^^^^^^^^^^^^\n   |\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpf_1mtdew.rs:63:13\n\
    \   |\n63 |             vec![vec![x; y]] if y < x => {\n   |             ^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-ba"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // sort lists by rows, then by columns, in descending order\n    let\
    \ mut rows_and_cols: Vec<(isize, isize)> = lst.iter().cloned().collect();\n  \
    \  rows_and_cols.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().collect::<Vec<_>>());\n\
    \    rows_and_cols.sort_by(|a, b| a.iter().cmp(&b.iter()).collect::<Vec<_>>());\n\
    \n    // loop through row list and find a match\n    let mut found = false;\n\
    \    for row in rows_and_cols {\n        let row_idx = row.0;\n        let row_cols\
    \ = row.1;\n        let row_count = row_cols.len();\n        if row_idx == x {\n\
    \            let mut found_tuple: (isize, isize) = (row_idx, row_count);\n   \
    \         found = true;\n            break;\n        }\n    }\n\n    if found\
    \ {\n        return rows_and_cols.iter().cloned().collect();\n    }\n\n    return\
    \ Vec::new();\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `Vec<isize>`\n    --> /tmp/tmpl6amg_9y.rs:19:70\n\
    \     |\n19   |     let mut rows_and_cols: Vec<(isize, isize)> = lst.iter().cloned().collect();\n\
    \     |                                                                      ^^^^^^^\
    \ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<isize>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]: no method\
    \ named `iter` found for reference `&(isize, isize)` in the current scope\n  -->\
    \ /tmp/tmpl6amg_9y.rs:20:36\n   |\n20 |     rows_and_cols.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().collect::<Vec<_>>());\n\
    \   |                                    ^^^^ method not found in `&(isize, isize)`\n\
    \nerror[E0599]: no method named `iter` found for reference `&(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmpl6amg_9y.rs:20:50\n   |\n20 |     rows_and_cols.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).rev().collect::<Vec<_>>());\n   |               \
    \                                   ^^^^ method not found in `&(isize, isize)`\n\
    \nerror[E0599]: no method named `iter` found for reference `&(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmpl6amg_9y.rs:21:36\n   |\n21 |     rows_and_cols.sort_by(|a,\
    \ b| a.iter().cmp(&b.iter()).collect::<Vec<_>>());\n   |                     \
    \               ^^^^ method not found in `&(isize, isize)`\n\nerror[E0599]: no\
    \ method named `iter` found for reference `&(isize, isize)` in the current scope\n\
    \  --> /tmp/tmpl6amg_9y.rs:21:50\n   |\n21 |     rows_and_cols.sort_by(|a, b|\
    \ a.iter().cmp(&b.iter()).collect::<Vec<_>>());\n   |                        \
    \                          ^^^^ method not found in `&(isize, isize)`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpl6amg_9y.rs:28:34\n\
    \   |\n28 |         let row_count = row_cols.len();\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    fn cmp_row(row1: Vec<isize>, row2: Vec<isize>) -> bool {\n        row1.len()\
    \ == row2.len() && row1.iter().zip(row2.iter()).all(|(x, y)| x.0 > y.0)\n    }\n\
    \    let mut rows = lst.iter().cloned().collect::<Vec<_>>();\n    rows.sort_by_key(|row|\
    \ row.len());\n    let mut cols = rows.iter().cloned().collect::<Vec<_>>();\n\
    \    cols.sort_by_key(|col| col.len());\n    let mut ret = Vec::new();\n    for\
    \ row in rows.iter() {\n        if let Some(col) = cols.iter().position(|&x| x\
    \ == x) {\n            ret.push((row, col));\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4s3pwq6p.rs:31:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n31 |     ret\n   |     ^^^ expected `isize`,\
    \ found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(&Vec<isize>, usize)>`\n\nerror[E0609]: no field\
    \ `0` on type `&isize`\n  --> /tmp/tmp4s3pwq6p.rs:19:81\n   |\n19 |         row1.len()\
    \ == row2.len() && row1.iter().zip(row2.iter()).all(|(x, y)| x.0 > y.0)\n   |\
    \                                                                            \
    \     ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmp4s3pwq6p.rs:19:87\n\
    \   |\n19 |         row1.len() == row2.len() && row1.iter().zip(row2.iter()).all(|(x,\
    \ y)| x.0 > y.0)\n   |                                                       \
    \                                ^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n\n    let mut sorted_rows:\
    \ Vec<(isize, isize)> = vec![];\n    let mut sorted_cols: Vec<isize> = vec![];\n\
    \n    for r in lst {\n        sorted_rows.push((r[0], r[r.len()-1]));\n      \
    \  sorted_cols.push(r[r.len()-1]);\n    }\n    sorted_cols.sort();\n    sorted_rows.sort();\n\
    \    let mut ret: Vec<(isize, isize)> = vec![];\n    for i in sorted_rows {\n\
    \        let mut cur_row = vec![];\n        let mut cur_col = 0;\n        let\
    \ mut cur_val = 0;\n\n        for j in sorted_cols {\n            cur_col += j;\n\
    \            cur_row += (i as isize) * cur_col;\n            cur_val += (i as\
    \ isize) * j;\n        }\n        ret.push((cur_row, cur_val));\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmpa22emtd3.rs:39:13\n   |\n39 |             cur_row +=\
    \ (i as isize) * cur_col;\n   |             -------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa22emtd3.rs:42:19\n   |\n42 |         ret.push((cur_row,\
    \ cur_val));\n   |                   ^^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected type `isize`\n            found struct `Vec<_>`\n\n\
    error[E0605]: non-primitive cast: `(isize, isize)` as `isize`\n  --> /tmp/tmpa22emtd3.rs:39:24\n\
    \   |\n39 |             cur_row += (i as isize) * cur_col;\n   |             \
    \           ^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive\
    \ cast: `(isize, isize)` as `isize`\n  --> /tmp/tmpa22emtd3.rs:40:24\n   |\n40\
    \ |             cur_val += (i as isize) * j;\n   |                        ^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res : Vec<(isize, isize)> = vec![];\n    let mut n = lst.len();\n\
    \    for i in 0..n {\n        if i >= x {\n            break;\n        }\n   \
    \     let mut row: Vec<isize> = lst[i].clone();\n        row.remove(i);\n    \
    \    res.push(row.iter().cloned().collect::<Vec<_>>());\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx81kfnk.rs:21:17\n   |\n\
    21 |         if i >= x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if i >= x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkx81kfnk.rs:26:18\n   |\n26 |         res.push(row.iter().cloned().collect::<Vec<_>>());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n     \
    \        found struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst\n        .into_iter()\n        .map(|y| (y.iter().cloned(),\
    \ y.len()))\n        .collect::<Vec<_>>();\n\n    lst.sort();\n\n    let mut out\
    \ = Vec::new();\n\n    let mut x = x;\n\n    while lst.len() > 0 {\n        let\
    \ cur_row = lst.iter().cloned().collect::<Vec<_>>();\n\n        let mut y = cur_row\n\
    \            .iter()\n            .map(|x| *x)\n            .skip(x)\n       \
    \     .copied()\n            .collect::<Vec<_>>();\n\n        let mut row = cur_row.clone();\n\
    \        let mut column = cur_row.clone();\n\n        row.sort_by_key(|&x| x.0);\n\
    \        column.sort_by_key(|&x| -x.0);\n\n        while row.len() > x && column.len()\
    \ > x {\n            out.push((row.iter().skip(x).collect::<Vec<_>>(), column.iter().skip(x).collect::<Vec<_>>()));\n\
    \            y -= 1;\n            column -= 1;\n            row -= 1;\n      \
    \  }\n\n        x -= 1;\n    }\n\n    out\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Cloned<std::slice::Iter<'_, isize>>: Ord`\
    \ is not satisfied\n   --> /tmp/tmpn_o04rsb.rs:23:9\n    |\n23  |     lst.sort();\n\
    \    |         ^^^^ the trait `Ord` is not implemented for `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n    |\n    = help: the following other types implement trait `Ord`:\n\
    \              ()\n              (A, B, C, D, E, F, G, H, I, J, K, L)\n      \
    \        (B, C, D, E, F, G, H, I, J, K, L)\n              (C, D, E, F, G, H, I,\
    \ J, K, L)\n              (D, E, F, G, H, I, J, K, L)\n              (E, F, G,\
    \ H, I, J, K, L)\n              (F, G, H, I, J, K, L)\n              (G, H, I,\
    \ J, K, L)\n            and 5 others\n    = note: required because of the requirements\
    \ on the impl of `Ord` for `(Cloned<std::slice::Iter<'_, isize>>, usize)`\nnote:\
    \ required by a bound in `slice::<impl [T]>::sort`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn_o04rsb.rs:35:19\n   |\n35 |             .skip(x)\n  \
    \ |                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    35 |             .skip(x.try_into().unwrap())\n   |                    ++++++++++++++++++++\n\
    \nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmpn_o04rsb.rs:34:18:\
    \ 34:24] as FnOnce<(&(Cloned<std::slice::Iter<'_, isize>>, usize),)>>::Output\
    \ == &_`\n    --> /tmp/tmpn_o04rsb.rs:36:14\n     |\n36   |             .copied()\n\
    \     |              ^^^^^^ expected reference, found tuple\n     |\n     = note:\
    \ expected reference `&_`\n                    found tuple `(Cloned<std::slice::Iter<'_,\
    \ isize>>, usize)`\n     = note: required because of the requirements on the impl\
    \ of `Iterator` for `Map<std::slice::Iter<'_, (Cloned<std::slice::Iter<'_, isize>>,\
    \ usize)>, [closure@/tmp/tmpn_o04rsb.rs:34:18: 34:24]>`\nnote: required by a bound\
    \ in `copied`\n\nerror[E0599]: the method `collect` exists for struct `Copied<Skip<Map<std::slice::Iter<'_,\
    \ (Cloned<std::slice::Iter<'_, isize>>, usize)>, [closure@/tmp/tmpn_o04rsb.rs:34:18:\
    \ 34:24]>>>`, but its trait bounds were not satisfied\n  --"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_index = 0 as usize;\n    let mut col_index = 0 as usize;\n\
    \    let mut res = Vec::new();\n    while row_index < lst.len() {\n        let\
    \ current_row = lst[row_index].clone();\n        match current_row.len() {\n \
    \           1 => {\n                if current_row[col_index] == x {\n       \
    \             res.push((row_index, col_index));\n                }\n         \
    \       col_index += 1;\n            }\n            i => {\n                row_index\
    \ += 1;\n                col_index = 0;\n                while col_index < i {\n\
    \                    current_row[col_index] = current_row[col_index - 1];\n  \
    \                  col_index += 1;\n                }\n                if current_row[col_index]\
    \ == x {\n                    res.push((row_index, col_index));\n            \
    \    }\n                col_index += 1;\n            }\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyd4b6rl.rs:44:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n44 |     res\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut l = lst.len();\n    let mut r: isize = 0;\n    for row in &lst\
    \ {\n        if row == &[] { continue; }\n        for _col in &row {\n       \
    \     if _col == x { l = r; break; }\n            l += 1;\n        }\n       \
    \ r += 1;\n    }\n    let mut v: Vec<(isize, isize)> = vec![];\n    for _ in 0..(l\
    \ - r) {\n        v.append(0);\n    }\n    for _ in 0..(l - r) {\n        v.append((0,\
    \ 0));\n    }\n    let mut pos = 0;\n    for row in &lst {\n        for col in\
    \ &row {\n            v[pos] = ((*v[pos].0, *v[pos].1) + row, *v[pos].2 + col);\n\
    \            pos += 1;\n        }\n    }\n    v.sort_by(|x, y| x.0.cmp(&y.0));\n\
    \    let mut pos = 0;\n    v.iter().filter_map(|(&x, y), &_| if y == x { None\
    \ } else { Some((x, y)); }).for_each(|(&x, _)| {\n        if x == 0 { pos -= 1;}\n\
    \    });\n    let mut r: Vec<(isize, isize)> = vec![];\n    for _ in 0..(pos -\
    \ 1) {\n        r.append(0);\n    }\n    r.push((0, 0));\n    r\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&&Vec<isize>` is not an iterator\n  --> /tmp/tmpdsf77i66.rs:22:21\n\
    \   |\n22 |         for _col in &row {\n   |                     ^^^^ `&&Vec<isize>`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&&Vec<isize>`\n   = help: the following other types implement trait `IntoIterator`:\n\
    \             &'a Vec<T, A>\n             &'a mut Vec<T, A>\n             Vec<T,\
    \ A>\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdsf77i66.rs:23:32\n\
    \   |\n18 |     let mut l = lst.len();\n   |                 --------- expected\
    \ due to this value\n...\n23 |             if _col == x { l = r; break; }\n  \
    \ |                                ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdsf77i66.rs:29:22\n   |\n29 |     for _ in 0..(l\
    \ - r) {\n   |                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmpdsf77i66.rs:29:20\n   |\n\
    29 |     for _ in 0..(l - r) {\n   |                    ^ no implementation for\
    \ `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdsf77i66.rs:30:18\n\
    \   |\n30 |         v.append(0);\n   |                  ^ expected mutable reference,\
    \ found integer\n   |\n   = note: expected mutable reference `&mut Vec<(isize,\
    \ isize)>`\n                           found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdsf77i66.rs:32:22\n   |\n32 |     for _ in 0..(l\
    \ - r) {\n   |                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isi"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    // Sort the rows\
    \ initially by rows in ascending order.\n    let mut rows = lst.iter().map(|row|\
    \ {\n        row.iter().sort_by(|a, b| a.partial_cmp(b))\n    }).collect::<Vec<_>>();\n\
    \    rows.sort_by(|a, b| a.partial_cmp(b))\n        .enumerate()\n        .map(|(idx,\
    \ row)| {\n            row.iter().map(|col| {\n                (idx, col)\n  \
    \          })\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpa6bd1f69.rs:23:20\n   |\n23 |         row.iter().sort_by(|a,\
    \ b| a.partial_cmp(b))\n   |                    ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpa6bd1f69.rs:26:10\n\
    \   |\n26 |         .enumerate()\n   |          ^^^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = vec![];\n\n    for row in lst {\n\
    \        let mut col = vec![];\n\n        for i in row.iter() {\n            col.push(i);\n\
    \        }\n\n        if col.len() == x {\n            let mut cur = col[0];\n\
    \            for i in col.iter_mut().skip(1) {\n                *i = *i - *cur;\n\
    \                cur.inc();\n            }\n\n            ret.push((col[0], col[1]));\n\
    \        }\n    }\n\n    ret\n        .iter()\n        .map(|x| x.0.swap(*x.1))\n\
    \        .sort_by_key(|x| x.0)\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bng6nj5.rs:27:25\n   |\n\
    27 |         if col.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |         if col.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2bng6nj5.rs:30:22\n   |\n30 |                 *i = *i -\
    \ *cur;\n   |                 --   ^^^^^^^^^\n   |                 |    |\n  \
    \ |                 |    expected `&isize`, found `isize`\n   |              \
    \   |    help: consider borrowing here: `&(*i - *cur)`\n   |                 expected\
    \ due to the type of this binding\n\nerror[E0599]: no method named `inc` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmp2bng6nj5.rs:31:21\n\
    \   |\n31 |                 cur.inc();\n   |                     ^^^ method not\
    \ found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bng6nj5.rs:34:23\n\
    \   |\n34 |             ret.push((col[0], col[1]));\n   |                    \
    \   ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             ret.push((*col[0], col[1]));\n   |      \
    \                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bng6nj5.rs:34:31\n\
    \   |\n34 |             ret.push((col[0], col[1]));\n   |                    \
    \           ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |             ret.push((col[0], *col[1]));\n   |      \
    \                         +\n\nerror[E0599]: no method named `swap` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp2bng6nj5.rs:40:22\n   |\n40\
    \ |         .map(|x| x.0.swap(*x.1))\n   |                      ^^^^ method not\
    \ found in `isize`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  -->\
    \ /tmp/tmp2bng6nj5.rs:40:27\n   |\n40 |         .map(|x| x.0.swap(*x.1))\n   |\
    \                           ^^^^\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Map` in the current scope\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut r = vec![(0, 0)];\n    let mut c = vec![(0, lst.len())];\n  \
    \  let mut i = 1;\n    while i < lst.len() {\n        // first column\n      \
    \  r[0] = r[0].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n    \
    \    r[0] = (r[0], 0);\n        c[0] = (c[0].checked_add(lst.len() as isize).unwrap(),\
    \ i);\n        if r[0] == x {\n            return c;\n        }\n        // second\
    \ column\n        if lst.len() <= 1 {\n            break;\n        }\n       \
    \ for j in lst.len() {\n            c[1] = c[1].checked_add((j / lst.len() as\
    \ isize).unwrap()).unwrap();\n            r[1] = r[1].checked_add((i / lst.len()\
    \ as isize).unwrap()).unwrap();\n            r[1] = c[1].checked_add((r[1] - j\
    \ as isize).unwrap()).unwrap();\n            if c[0] == r[1] {\n             \
    \   return c;\n            }\n            // third column\n            for k in\
    \ lst.len() {\n                c[2] = c[2].checked_add((k / lst.len() as isize).unwrap()).unwrap();\n\
    \                r[2] = r[2].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n\
    \                r[2] = c[2].checked_add((r[2] - k as isize).unwrap()).unwrap();\n\
    \                if c[1] == r[2] {\n                    return c;\n          \
    \      }\n                // fourth column\n                for l in lst.len()\
    \ {\n                    c[3] = c[3].checked_add((l / lst.len() as isize).unwrap()).unwrap();\n\
    \                    r[3] = r[3].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n\
    \                    r[3] = c[3].checked_add((r[3] - l as isize).unwrap()).unwrap();\n\
    \                    if c[2] == r[3] {\n                        return c;\n  \
    \                  }\n                }\n            }\n        }\n        i +=\
    \ 1;\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for tuple `({integer},\
    \ {integer})` in the current scope\n  --> /tmp/tmp_eg7itx3.rs:23:21\n   |\n23\
    \ |         r[0] = r[0].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n\
    \   |                     ^^^^^^^^^^^ method not found in `({integer}, {integer})`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_eg7itx3.rs:23:38\n   |\n23 |\
    \         r[0] = r[0].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0599]: no method named `unwrap` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp_eg7itx3.rs:23:58\n   |\n23 |         r[0]\
    \ = r[0].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n   |      \
    \                                                    ^^^^^^ method not found in\
    \ `usize`\n\nerror[E0277]: cannot divide `usize` by `isize`\n  --> /tmp/tmp_eg7itx3.rs:23:36\n\
    \   |\n23 |         r[0] = r[0].checked_add((i / lst.len() as isize).unwrap()).unwrap();\n\
    \   |                                    ^ no implementation for `usize / isize`\n\
    \   |\n   = help: the trait `Div<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as\
    \ Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_eg7itx3.rs:24:17\n   |\n24 |         r[0] =\
    \ (r[0], 0);\n   |                 ^^^^ expected integer, found tuple\n   |\n\
    \   = note: expected type `{integer}`\n             found tuple `({integer}, {integer})`\n\
    \nerror[E0599]: no method named `checked_add` found for tuple `({integer}, usize)`\
    \ in the current scope\n  --> /tmp/tmp_eg7itx3.rs:25:22\n   |\n25 |         c[0]\
    \ = (c[0].checked_add(lst.len() as isize).unwrap(), i);\n   |                \
    \      ^^^^^^^^^^^ method n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![vec![0, 0]; lst.len()];\n    for row in rows.iter_mut()\
    \ {\n        // sort coordinates by row\n        let sort_fn = (x, y) => (x.0,\
    \ y.0);\n        std::iter::sort_by_key(row.iter().cloned(), sort_fn);\n     \
    \   // sort coordinates within row by column\n        let sort_fn = (x, y) =>\
    \ (x.1, y.1);\n        std::iter::sort_by_key(row.iter().cloned(), sort_fn);\n\
    \    }\n    rows[rows.len() - 1]\n        .iter()\n        .filter(|&x| *x ==\
    \ x)\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `=>`\n\
    \  --> /tmp/tmpb2s85exv.rs:21:30\n   |\n21 |         let sort_fn = (x, y) => (x.0,\
    \ y.0);\n   |                              ^^ expected one of `.`, `;`, `?`, `else`,\
    \ or an operator\n\nerror[E0277]: can't compare `{integer}` with `&{integer}`\n\
    \  --> /tmp/tmpb2s85exv.rs:29:25\n   |\n29 |         .filter(|&x| *x == x)\n \
    \  |                         ^^ no implementation for `{integer} == &{integer}`\n\
    \   |\n   = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be\
    \ built from an iterator over elements of type `&{integer}`\n    --> /tmp/tmpb2s85exv.rs:30:10\n\
    \     |\n30   |         .collect()\n     |          ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=&{integer}>`\n     |\n\
    \     = help: the trait `FromIterator<&{integer}>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    if lst.len() == 0 || lst.len() == 1 {\n\
    \        return vec![];\n    }\n    let mut x = x;\n    let mut y = x;\n    let\
    \ mut xy = vec![];\n    for row in lst {\n        xy.clear();\n        let mut\
    \ yx = vec![(x, y)];\n        for val in row {\n            xy.push((val, yx));\n\
    \            y = y;\n            x += 1;\n        }\n        x = x;\n        let\
    \ mut yx = vec![(x, y)];\n        xy.push((x, yx));\n        xy.sort();\n    \
    \    xy.sort();\n        xy.reverse();\n    }\n    xy\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46c4vryf.rs:40:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n40 |     xy\n   |     ^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(_, isize)>`\n   \
    \           found struct `Vec<(_, Vec<(isize, isize)>)>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n\n    for (i, item) in lst.iter().enumerate()\
    \ {\n        if item.len() == x {\n            row.push((i, item[x]));\n     \
    \   }\n    }\n\n    row.sort_by(|a, b| a.1.cmp(&b.1));\n    row.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n\n    row.clone() + row.to_owned()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlw1sdek.rs:21:26\n   |\n\
    21 |         if item.len() == x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if item.len() == x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprlw1sdek.rs:22:23\n   |\n22 |             row.push((i,\
    \ item[x]));\n   |                       ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |             row.push((i.try_into().unwrap(), item[x]));\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprlw1sdek.rs:22:26\n   |\n22 |  \
    \           row.push((i, item[x]));\n   |                          ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0369]: cannot add `Vec<(isize,\
    \ isize)>` to `Vec<(isize, isize)>`\n  --> /tmp/tmprlw1sdek.rs:29:17\n   |\n29\
    \ |     row.clone() + row.to_owned()\n   |     ----------- ^ -------------- Vec<(isize,\
    \ isize)>\n   |     |\n   |     Vec<(isize, isize)>\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    let mut res =\
    \ vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n    let mut\
    \ idx = 0;\n    let mut is_sorted = true;\n    for (_, row) in lst.iter().enumerate()\
    \ {\n        idx += 1;\n        if idx > x {\n            break;\n        }\n\
    \        row.sort_by(|a, b| {\n            match a.cmp(b) {\n                Ordering::Less\
    \ => true,\n                Ordering::Greater => false,\n                Ordering::Equal\
    \ => a < b,\n            }\n        });\n        for (j, _) in row.iter().enumerate()\
    \ {\n            cols.push((idx, j));\n        }\n        rows = rows.push(row);\n\
    \        is_sorted = false;\n    }\n    let mut idx = 0;\n    for row in rows\
    \ {\n        let mut cols = vec![];\n        for (i, idx) in row.iter().enumerate()\
    \ {\n            cols.push((idx, i + idx));\n        }\n        if rows.len()\
    \ > 1 {\n            for (j, row) in rows.iter().clone().rev().enumerate() {\n\
    \                for (_, j) in row.iter().enumerate() {\n                    cols.push((idx,\
    \ j + idx));\n                }\n            }\n        }\n        res.push(cols);\n\
    \        idx += 1;\n    }\n    if !is_sorted {\n        res.sort_by(|a, b| {\n\
    \            match a.cmp(b) {\n                Ordering::Less => true,\n     \
    \           Ordering::Greater => false,\n                Ordering::Equal => a\
    \ < b,\n            }\n        });\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpq9cbnf96.rs:33:17\n   |\n33 |                 Ordering::Less => true,\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpq9cbnf96.rs:34:17\n\
    \   |\n34 |                 Ordering::Greater => false,\n   |                \
    \ ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpq9cbnf96.rs:35:17\n   |\n35\
    \ |                 Ordering::Equal => a < b,\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpq9cbnf96.rs:63:17\n   |\n63 |               \
    \  Ordering::Less => true,\n   |                 ^^^^^^^^ use of undeclared type\
    \ `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpq9cbnf96.rs:64:17\n   |\n64 |                 Ordering::Greater\
    \ => false,\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpq9cbnf96.rs:65:17\n\
    \   |\n65 |                 Ordering::Equal => a < b,\n   |                 ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq9cbnf96.rs:33:35\n\
    \   |\n33 |                 Ordering::Less => true,\n   |                    \
    \               ^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq9cbnf96.rs:41:16\n   |\n22 |     let mut rows\
    \ = vec![];\n   |                    ------ expected due to this value\n...\n\
    41 |         rows = rows.push(row);\n   |                ^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<&Vec<isize>>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq9cbnf96.rs:48:33\n\
    \   |\n48 |             cols.push((idx, i + idx));\n   |                     \
    \            ^^^ expected `usize`, found `isize`\n\nerror[E0"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter().map(|row| get_row_by_index(row, x)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_row_by_index` in this scope\n \
    \ --> /tmp/tmpnup6o0gm.rs:18:26\n   |\n18 |     lst.iter().map(|row| get_row_by_index(row,\
    \ x)).collect()\n   |                          ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    for row in lst {\n        for col in row.iter().rev()\
    \ {\n            if col == x {\n                coords.push((row.len(), col.len()));\n\
    \            }\n        }\n    }\n\n    coords.sort_by_key(|(a, b)| (a.0, b.0));\n\
    \    coords.sort_by_key(|(a, b)| (b.1, a.1));\n    coords\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpbbsv31hh.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpbbsv31hh.rs:22:45\n\
    \   |\n22 |                 coords.push((row.len(), col.len()));\n   |       \
    \                                      ^^^ method not found in `&isize`\n\nerror[E0609]:\
    \ no field `0` on type `&_`\n  --> /tmp/tmpbbsv31hh.rs:27:36\n   |\n27 |     coords.sort_by_key(|(a,\
    \ b)| (a.0, b.0));\n   |                                    ^\n\nerror[E0609]:\
    \ no field `0` on type `&_`\n  --> /tmp/tmpbbsv31hh.rs:27:41\n   |\n27 |     coords.sort_by_key(|(a,\
    \ b)| (a.0, b.0));\n   |                                         ^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    let mut rows = Vec::new();\n    for\
    \ y in 0..lst.len() {\n        let mut columns = Vec::new();\n        for _ in\
    \ 0..lst[y].len() {\n            columns.push(0);\n        }\n        rows.push(columns);\n\
    \    }\n    for y in 0..lst.len() {\n        for x in 0..lst[y].len() {\n    \
    \        coords.push((y, x));\n        }\n    }\n    coords.sort_by_key(|&(x,\
    \ y)| {\n        rows[y.0].iter().enumerate().map(|(i, &j)| {\n            (j,\
    \ rows[y.0][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n     \
    \   }).collect::<Vec<_>>()\n    });\n    coords.sort_by_key(|&(x, y)| {\n    \
    \    rows[y.0].iter().enumerate().map(|(i, &j)| {\n            (j, rows[y.0][i].cmp(&x)\
    \ == std::cmp::Ordering::Reverse).unwrap_or(true)\n        }).collect::<Vec<_>>()\n\
    \    });\n    coords\n        .iter()\n        .map(|(x, y)| {\n            (rows[y].iter().enumerate().map(|(i,\
    \ &j)| {\n                (j, rows[y][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n\
    \            }).collect::<Vec<_>>())\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmphxm4irrf.rs:45:13\n\
    \   |\n45 |             (rows[y].iter().enumerate().map(|(i, &j)| {\n   |    \
    \         ^\n46 |                 (j, rows[y][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n\
    47 |             }).collect::<Vec<_>>())\n   |                               \
    \    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n45 ~             rows[y].iter().enumerate().map(|(i,\
    \ &j)| {\n46 |                 (j, rows[y][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n\
    47 ~             }).collect::<Vec<_>>()\n   |\n\nerror[E0610]: `usize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmphxm4irrf.rs:33:16\n  \
    \ |\n33 |         rows[y.0].iter().enumerate().map(|(i, &j)| {\n   |         \
    \       ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmphxm4irrf.rs:34:24\n   |\n34 |             (j, rows[y.0][i].cmp(&x)\
    \ == std::cmp::Ordering::Reverse).unwrap_or(true)\n   |                      \
    \  ^\n\nerror[E0599]: no variant or associated item named `Reverse` found for\
    \ enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmphxm4irrf.rs:34:61\n\
    \   |\n34 |             (j, rows[y.0][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n\
    \   |                                                             ^^^^^^^\n  \
    \ |                                                             |\n   |      \
    \                                                       variant or associated\
    \ item not found in `std::cmp::Ordering`\n   |                               \
    \                              help: there is an associated function with a similar\
    \ name: `reverse`\n\nerror[E0599]: no method named `unwrap_or` found for tuple\
    \ `(_, bool)` in the current scope\n  --> /tmp/tmphxm4irrf.rs:34:70\n   |\n34\
    \ |             (j, rows[y.0][i].cmp(&x) == std::cmp::Ordering::Reverse).unwrap_or(true)\n\
    \   |                                                                      ^^^^^^^^^\
    \ method not found in `(_, bool)`\n\ne"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut it = lst.iter().enumerate().rev();\n\n    // sort coordinates\n\
    \    let mut coord = it.map(|(i, v)| {\n        if i == 0 {\n            (v, i)\n\
    \        } else {\n            (i, v)\n        }\n    });\n    coord = coord.sort_by_key(|(v,\
    \ i)| {\n        if i == 0 {\n            Ordering::Ascending\n        } else\
    \ {\n            Ordering::Descending\n        }\n    });\n\n    // sort rows\
    \ by descending columns\n    let mut row = coord.map(|(i, v)| {\n        if i\
    \ == 0 {\n            v\n        } else {\n            (coord.first().1, coord.last().1\
    \ - v)\n        }\n    });\n    row = row.sort_by_key(|v| v.0);\n    row = row.reverse();\n\
    \n    // return coordinates\n    row.map(|(v, i)| {\n        ((i, v), (coord.last().0,\
    \ coord.first().0))\n    })\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpnving6o5.rs:30:13\n   |\n30 |             Ordering::Ascending\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpnving6o5.rs:32:13\n\
    \   |\n32 |             Ordering::Descending\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmpnving6o5.rs:25:13\n   |\n22 | /         if i == 0 {\n23\
    \ | |             (v, i)\n   | |             ------ expected because of this\n\
    24 | |         } else {\n25 | |             (i, v)\n   | |             ^^^^^^\
    \ expected `&Vec<isize>`, found `usize`\n26 | |         }\n   | |_________- `if`\
    \ and `else` have incompatible types\n   |\n   = note: expected tuple `(&Vec<isize>,\
    \ usize)`\n              found tuple `(usize, &Vec<isize>)`\n\nerror[E0599]: no\
    \ method named `sort_by_key` found for struct `Map` in the current scope\n  -->\
    \ /tmp/tmpnving6o5.rs:28:19\n   |\n28 |     coord = coord.sort_by_key(|(v, i)|\
    \ {\n   |                   ^^^^^^^^^^^ method not found in `Map<Rev<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>>, _>`\n\nerror[E0599]: no method named `first` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmpnving6o5.rs:41:20\n   |\n41 |    \
    \         (coord.first().1, coord.last().1 - v)\n   |                    ^^^^^\
    \ method not found in `Map<Rev<Enumerate<std::slice::Iter<'_, Vec<isize>>>>, _>`\n\
    \nerror[E0609]: no field `1` on type `Option<_>`\n  --> /tmp/tmpnving6o5.rs:41:44\n\
    \   |\n41 |             (coord.first().1, coord.last().1 - v)\n   |          \
    \                                  ^\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmpnving6o5.rs:44:15\n\
    \   |\n44 |     row = row.sort_by_key(|v| v.0);\n   |               ^^^^^^^^^^^\
    \ method not found in `Map<Map<Rev<Enumerate<std::slice::Iter<'_, Vec<isize>>>>,\
    \ _>, _>`\n\nerror[E0599]: no method named `reverse` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpnving6o5.rs:4"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.into_iter().enumerate().collect::<Vec<_>>();\n    lst.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    let mut res = vec![];\n    for i in 0..lst.len() {\n\
    \        let mut curr_row = vec![];\n        for j in i.0..lst.len() {\n     \
    \       if lst[j].1.cmp(&x) < 0 {\n                curr_row.push(lst[j]);\n  \
    \          }\n        }\n        res.push((curr_row.iter().minmax().unwrap().0,\
    \ curr_row.iter().minmax().unwrap().1));\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpfjpz56ur.rs:23:20\n   |\n23 |         for j in i.0..lst.len() {\n\
    \   |                    ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjpz56ur.rs:24:29\n\
    \   |\n24 |             if lst[j].1.cmp(&x) < 0 {\n   |                      \
    \       ^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected reference\
    \ `&Vec<isize>`\n              found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfjpz56ur.rs:24:35\n   |\n24 |             if lst[j].1.cmp(&x)\
    \ < 0 {\n   |                                   ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0599]: no method named `minmax` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpfjpz56ur.rs:28:35\n   |\n28 |         res.push((curr_row.iter().minmax().unwrap().0,\
    \ curr_row.iter().minmax().unwrap().1));\n   |                               \
    \    ^^^^^^ method not found in `std::slice::Iter<'_, (usize, Vec<isize>)>`\n\n\
    error[E0599]: no method named `minmax` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmpfjpz56ur.rs:28:72\n   |\n28 |         res.push((curr_row.iter().minmax().unwrap().0,\
    \ curr_row.iter().minmax().unwrap().1));\n   |                               \
    \                                         ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ (usize, Vec<isize>)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = Vec::new();\n\n    for row in lst.iter()\
    \ {\n        let mut cnt = 0;\n        let mut rowsort = row.clone();\n      \
    \  rowsort.sort_by_key(|x| {\n            cnt += 1;\n            cnt % 2\n   \
    \     });\n\n        for col in rowsort.iter().rev() {\n            if col ==\
    \ x {\n                ret.append( (row, col) );\n            }\n        }\n \
    \   }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplqfszdrs.rs:30:29\n   |\n\
    30 |                 ret.append( (row, col) );\n   |                         \
    \    ^^^^^^^^^^ expected mutable reference, found tuple\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<(isize, isize)>`\n                          found\
    \ tuple `(&Vec<isize>, &isize)`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmplqfszdrs.rs:29:20\n   |\n29 |             if col == x {\n   | \
    \                   ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.clone();\n    rows.sort_by_key(|row| row.iter().rev().cloned());\n\
    \    rows.sort_by_key(|row| row.iter().cloned());\n    rows\n        .iter()\n\
    \        .map(|row| {\n            let mut cols = row.clone();\n            cols.sort_by_key(|col|\
    \ col.iter().rev().cloned());\n            cols.sort_by_key(|col| col.iter().cloned());\n\
    \            cols.iter().enumerate().filter(|(_, col)| col == x).next()\n    \
    \    })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Cloned<Rev<std::slice::Iter<'_, isize>>>:\
    \ Ord` is not satisfied\n   --> /tmp/tmp2mbtlxhd.rs:19:22\n    |\n19  |     rows.sort_by_key(|row|\
    \ row.iter().rev().cloned());\n    |          ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `Cloned<Rev<std::slice::Iter<'_, isize>>>`\n\
    \    |          |\n    |          required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0277]:\
    \ the trait bound `Cloned<std::slice::Iter<'_, isize>>: Ord` is not satisfied\n\
    \   --> /tmp/tmp2mbtlxhd.rs:20:22\n    |\n20  |     rows.sort_by_key(|row| row.iter().cloned());\n\
    \    |          ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\n    |          |\n    |         \
    \ required by a bound introduced by this call\n    |\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort_by_key`\n\nerror[E0599]: no method named `iter`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp2mbtlxhd.rs:25:40\n\
    \   |\n25 |             cols.sort_by_key(|col| col.iter().rev().cloned());\n \
    \  |                                        ^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmp2mbtlxhd.rs:26:40\n   |\n26 |             cols.sort_by_key(|col|\
    \ col.iter().cloned());\n   |                                        ^^^^ method\
    \ not found in `&isize`\n\nerror[E0277]: can't compare `&&isize` with `isize`\n\
    \  --> /tmp/tmp2mbtlxhd.rs:27:59\n   |\n27 |             cols.iter().enumerate().filter(|(_,\
    \ col)| col == x).next()\n   |                                               \
    \            ^^ no implementation for `&&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_len = 0;\n    let mut cols = lst.len();\n    if cols == 0\
    \ {\n        return vec![];\n    }\n    let mut ret = vec![];\n    for row in\
    \ lst {\n        if row_len == 0 {\n            for col in row.iter().cloned().rev()\
    \ {\n                if *col == x {\n                    ret.unshift((0, row_len));\n\
    \                }\n                row_len += 1;\n            }\n        } else\
    \ {\n            for col in row.iter().cloned().rev() {\n                if *col\
    \ == x {\n                    ret.unshift((row_len, *col));\n                }\n\
    \                row_len += 1;\n            }\n        }\n    }\n    ret.sort_by_key(|(x,\
    \ y)| x.1);\n    ret.sort_by_key(|(x, y)| -y.1);\n    ret\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpqwus1crb.rs:27:20\n\
    \   |\n27 |                 if *col == x {\n   |                    ^^^^\n\nerror[E0599]:\
    \ no method named `unshift` found for struct `Vec<_>` in the current scope\n \
    \ --> /tmp/tmpqwus1crb.rs:28:25\n   |\n28 |                     ret.unshift((0,\
    \ row_len));\n   |                         ^^^^^^^ method not found in `Vec<_>`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpqwus1crb.rs:34:20\n\
    \   |\n34 |                 if *col == x {\n   |                    ^^^^\n\nerror[E0599]:\
    \ no method named `unshift` found for struct `Vec<_>` in the current scope\n \
    \ --> /tmp/tmpqwus1crb.rs:35:25\n   |\n35 |                     ret.unshift((row_len,\
    \ *col));\n   |                         ^^^^^^^ method not found in `Vec<_>`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpqwus1crb.rs:35:43\n\
    \   |\n35 |                     ret.unshift((row_len, *col));\n   |          \
    \                                 ^^^^\n\nerror[E0609]: no field `1` on type `&_`\n\
    \  --> /tmp/tmpqwus1crb.rs:41:32\n   |\n41 |     ret.sort_by_key(|(x, y)| x.1);\n\
    \   |                                ^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0609, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    for (i, row) in lst.into_iter().enumerate()\
    \ {\n        if row.len() == x {\n            row.push((i, 0));\n        }\n \
    \   }\n    row.sort_by(|a, b| a.1.cmp(&b.1));\n    row.sort_by(|a, b| a.1.cmp(&b.1),\
    \ |a, b| b.1.cmp(&a.1));\n    row.iter().map(|(j, c)| vec![(j + c.1, j + c.0)]).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2y8kjz5c.rs:20:25\n   |\n\
    20 |         if row.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if row.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2y8kjz5c.rs:21:22\n   |\n21 |             row.push((i,\
    \ 0));\n   |                      ^^^^^^ expected `isize`, found tuple\n   |\n\
    \   = note: expected type `isize`\n             found tuple `(usize, {integer})`\n\
    \nerror[E0609]: no field `1` on type `&_`\n  --> /tmp/tmp2y8kjz5c.rs:24:26\n \
    \  |\n24 |     row.sort_by(|a, b| a.1.cmp(&b.1));\n   |                      \
    \    ^\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().zip(b).map(|(t1,\
    \ t2)| t1).collect::<Vec<_>>().reverse());\n    lst.sort_by(|a, b| b.iter().zip(a).map(|(t1,\
    \ t2)| t2).collect::<Vec<_>>().reverse());\n    for i in lst.iter() {\n      \
    \  for j in i.iter().cloned().rev() {\n            if *j == x {\n            \
    \    return vec![(i, j as usize)];\n            }\n        }\n    }\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmg92p4wc.rs:19:24\n   |\n\
    19 |     lst.sort_by(|a, b| a.iter().zip(b).map(|(t1, t2)| t1).collect::<Vec<_>>().reverse());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmg92p4wc.rs:20:24\n   |\n20 |     lst.sort_by(|a, b| b.iter().zip(a).map(|(t1,\
    \ t2)| t2).collect::<Vec<_>>().reverse());\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `()`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpmg92p4wc.rs:23:16\n   |\n23 |        \
    \     if *j == x {\n   |                ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmg92p4wc.rs:24:30\n   |\n24 |                 return vec![(i, j\
    \ as usize)];\n   |                              ^ expected `isize`, found `&Vec<isize>`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmg92p4wc.rs:24:33\n   |\n24 |\
    \                 return vec![(i, j as usize)];\n   |                        \
    \         ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    24 |                 return vec![(i, (j as usize).try_into().unwrap())];\n   |\
    \                                 +          +++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = vec![];\n    let mut curr_row = vec![];\n    let\
    \ mut curr_col: Vec<isize> = vec![];\n\n    for row in lst {\n        if row[x]\
    \ == x {\n            curr_row.push(row);\n            curr_col.push(x);\n   \
    \     }\n    }\n\n    if curr_row.len() > 0 {\n        curr_row.sort_by_key(|v|\
    \ v.len());\n    }\n\n    if curr_col.len() > 0 {\n        curr_col.sort_by_key(|v|\
    \ v.len());\n    }\n\n    for i in 0..curr_row.len() {\n        let mut row_coord\
    \ = vec![];\n        let mut col_coord: Vec<isize> = vec![];\n\n        for j\
    \ in 0..curr_col.get(0) {\n            row_coord.push((i, j));\n            col_coord.push(curr_row.get(j)[x]);\n\
    \        }\n\n        coordinates.push(row_coord.clone());\n    }\n\n    coordinates\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpz801susc.rs:23:12\n\
    \   |\n23 |         if row[x] == x {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `len` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmpz801susc.rs:34:36\n\
    \   |\n34 |         curr_col.sort_by_key(|v| v.len());\n   |                 \
    \                   ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz801susc.rs:41:21\n   |\n41 |         for j in 0..curr_col.get(0)\
    \ {\n   |                     ^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<&isize>`\n\
    \nerror[E0608]: cannot index into a value of type `Option<&Vec<isize>>`\n  -->\
    \ /tmp/tmpz801susc.rs:43:28\n   |\n43 |             col_coord.push(curr_row.get(j)[x]);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz801susc.rs:49:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n49 |     coordinates\n   |     ^^^^^^^^^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n     \
    \         found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut temp_row\
    \ = vec![];\n        let mut curr_row = row;\n        for i in curr_row.iter_mut()\
    \ {\n            if *i as usize == x {\n                temp_row.push((*i as isize));\n\
    \            }\n        }\n        curr_row = temp_row;\n        result.push(curr_row);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpz16onuqg.rs:24:31\n\
    \   |\n24 |                 temp_row.push((*i as isize));\n   |              \
    \                 ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n24 -                 temp_row.push((*i\
    \ as isize));\n24 +                 temp_row.push(*i as isize);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz16onuqg.rs:23:31\n   |\n23 |             if\
    \ *i as usize == x {\n   |                               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |             if *i as usize == x.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz16onuqg.rs:30:5\n   |\n17 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n30 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut m = Map {\n        lst,\n        y: 0,\n    };\n\n    m.get_row(&mut\
    \ x).unwrap();\n    m.y\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0422]: cannot find struct, variant or union type `Map` in this scope\n\
    \  --> /tmp/tmpbzz9dbpa.rs:18:17\n   |\n18 |     let mut m = Map {\n   |     \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::iter::Map;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0422`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = vec![];\n    let rows = lst.len();\n    let cols = lst[0].len();\n\
    \    let mut row_idx = 1;\n    let mut col_idx = cols;\n    let mut cur_x = x;\n\
    \    while cur_x >= 0 {\n        if row_idx == rows {\n            cur_x = -1;\n\
    \            res.clear();\n            break;\n        }\n        let cur_y =\
    \ lst[row_idx][col_idx];\n        cur_x -= cur_y;\n        if cur_x >= 0 {\n \
    \           row_idx += 1;\n            col_idx -= 1;\n        }\n        res.push((row_idx,\
    \ col_idx));\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ay_k4xd.rs:38:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n38 |     res\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len();\n    let cols = lst[0].len();\n    let mut coords\
    \ = vec![];\n\n    for row in lst {\n        let mut cur_coord = (0, 0);\n\n \
    \       for _ in 0..cols {\n            if row[cur_coord.0] < x {\n          \
    \      cur_coord = (cur_coord.0 + 1, cur_coord.1 - 1);\n            } else {\n\
    \                cur_coord = (cur_coord.0 - 1, cur_coord.1);\n            }\n\
    \        }\n\n        coords.push((cur_coord.0, cur_coord.1));\n    }\n\n    coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpim4p8xk0.rs:38:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n38 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, {integer})>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    match (lst, x) {\n        (Vec::new(), _)                 => Vec::new(),\n\
    \        (Vec::new(_), x)                => vec![(x, 0)],\n        (lst, x) if\
    \ x < 0   => Vec::new(),\n        (lst, x) if x == 0 => lst.clone(),\n       \
    \ (lst, x) if x > lst.len() => lst.clone(),\n        (lst, x) => lst.iter().take(x).fold(vec![(0,\
    \ 0)], |mut acc, l| {\n            acc.push((l.iter().next().unwrap(), x - l.iter().count()\
    \ - 1));\n            acc\n        })\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `Vec::new`\n  --> /tmp/tmpclsnw9dj.rs:19:10\n   |\n19 |         (Vec::new(),\
    \ _)                 => Vec::new(),\n   |          ^^^^^^^^^^ `fn` calls are not\
    \ allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `Vec::new`\n  --> /tmp/tmpclsnw9dj.rs:20:10\n   |\n20 |         (Vec::new(_),\
    \ x)                => vec![(x, 0)],\n   |          ^^^^^^^^^^^ `fn` calls are\
    \ not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpclsnw9dj.rs:22:31\n\
    \   |\n18 | /     match (lst, x) {\n19 | |         (Vec::new(), _)           \
    \      => Vec::new(),\n   | |                                            ----------\
    \ this is found to be of type `Vec<(isize, isize)>`\n20 | |         (Vec::new(_),\
    \ x)                => vec![(x, 0)],\n   | |                                 \
    \           ------------ this is found to be of type `Vec<(isize, isize)>`\n21\
    \ | |         (lst, x) if x < 0   => Vec::new(),\n   | |                     \
    \           ---------- this is found to be of type `Vec<(isize, isize)>`\n22 |\
    \ |         (lst, x) if x == 0 => lst.clone(),\n   | |                       \
    \        ^^^^^^^^^^^ expected tuple, found struct `Vec`\n...  |\n27 | |      \
    \   })\n28 | |     }\n   | |_____- `match` arms have incompatible types\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpclsnw9dj.rs:23:25\n\
    \   |\n23 |         (lst, x) if x > lst.len() => lst.clone(),\n   |          \
    \               ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n23 |         (lst, x) if x > lst.len().try_into().unwrap() => lst.clone(),\n\
    \   |                                  "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    let mut out =\
    \ vec![];\n    for row in lst {\n        let mut tmp = vec![];\n        let mut\
    \ last = row[0];\n        for &x in row {\n            if x == last {\n      \
    \          continue;\n            }\n            tmp.append(x);\n            last\
    \ = x;\n        }\n        if tmp.len() == 0 {\n            continue;\n      \
    \  }\n        out.append(tmp.iter().cloned().zip((tmp.len() - 1).rev()).cloned().collect());\n\
    \    }\n    out.sort_by_key(|r| r[0]);\n    out.sort_by_key(|r| r[1], |&(x, y)|\
    \ y.cmp(x));\n    out\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp71w1tx81.rs:25:13\n   |\n\
    25 |         for &x in row {\n   |             ^^    --- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `x`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0277]: can't compare `&mut Vec<_>` with `isize`\n  --> /tmp/tmp71w1tx81.rs:26:18\n\
    \   |\n26 |             if x == last {\n   |                  ^^ no implementation\
    \ for `&mut Vec<_> == isize`\n   |\n   = help: the trait `PartialEq<isize>` is\
    \ not implemented for `&mut Vec<_>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp71w1tx81.rs:30:20\n   |\n24 |         let mut last = row[0];\n\
    \   |                        ------ expected due to this value\n...\n30 |    \
    \         last = x;\n   |                    ^ expected `isize`, found `&mut Vec<_>`\n\
    \   |\n   = note:           expected type `isize`\n           found mutable reference\
    \ `&mut Vec<_>`\n\nerror[E0599]: `usize` is not an iterator\n  --> /tmp/tmp71w1tx81.rs:35:60\n\
    \   |\n35 |         out.append(tmp.iter().cloned().zip((tmp.len() - 1).rev()).cloned().collect());\n\
    \   |                                                            ^^^ `usize` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `usize: Iterator`\n           which is required by `&mut usize: Iterator`\n\
    \nerror[E0271]: type mismatch resolving `<Zip<Cloned<std::slice::Iter<'_, _>>,\
    \ _> as Iterator>::Item == &_`\n    --> /tmp/tmp71w1tx81.rs:35:67\n     |\n35\
    \   |         out.append(tmp.iter().cloned().zip((tmp.len() - 1).rev()).cloned().collect());\n\
    \     |                      "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut row: Vec<isize> = vec![0; lst.len()\
    \ + 1];\n    let mut col = vec![0; lst.len() + 1];\n    let mut i = 1;\n    for\
    \ (row_index, row) in lst.into_iter().enumerate() {\n        if row_index == x\
    \ {\n            result.push((row_index + i, col));\n        }\n        row[row_index\
    \ + 1] = row;\n        col[row_index + 1] = col;\n        i += 1;\n    }\n   \
    \ result.sort_by_key(|(_, y)| y.iter().rev().enumerate());\n    result.sort_by_key(|(_,\
    \ y)| y.iter().rev().enumerate().rev());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59xj6r92.rs:23:25\n   |\n\
    23 |         if row_index == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n23 |         if row_index == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp59xj6r92.rs:26:30\n   |\n26 |         row[row_index + 1]\
    \ = row;\n   |         ------------------   ^^^ expected `isize`, found struct\
    \ `Vec`\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp59xj6r92.rs:27:30\n   |\n27 |\
    \         col[row_index + 1] = col;\n   |         ------------------   ^^^ expected\
    \ integer, found struct `Vec`\n   |         |\n   |         expected due to the\
    \ type of this binding\n   |\n   = note: expected type `{integer}`\n         \
    \   found struct `Vec<{integer}>`\n\nerror[E0277]: the trait bound `Enumerate<Rev<std::slice::Iter<'_,\
    \ {integer}>>>: Ord` is not satisfied\n   --> /tmp/tmp59xj6r92.rs:30:24\n    |\n\
    30  |     result.sort_by_key(|(_, y)| y.iter().rev().enumerate());\n    |    \
    \        ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not\
    \ implemented for `Enumerate<Rev<std::slice::Iter<'_, {integer}>>>`\n    |   \
    \         |\n    |            required by a bound introduced by this call\n  \
    \  |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0277]:\
    \ the trait bound `Rev<Enumerate<Rev<std::slice::Iter<'_, {integer}>>>>: Ord`\
    \ is not satisfied\n   --> /tmp/tmp59xj6r92.rs:31:24\n    |\n31  |     result.sort_by_key(|(_,\
    \ y)| y.iter().rev().enumerate().rev());\n    |            ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `Rev<Enumerate<Rev<std::slice::Iter<'_,\
    \ {integer}>>>>`\n    |            |\n    |            required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `sli"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    match (lst.len(), x) {\n        (l, x) if l <= 0 => vec![],\n       \
    \ (l, x) if x <= 0 => vec![],\n        (l, x) if l == 1 => vec![(l, x)],\n   \
    \     (l, x) if x > 1 => {\n            let mut ret: Vec<(isize, isize)> = vec![];\n\
    \            let mut cnt = 0;\n            for (i, v) in lst.iter().enumerate()\
    \ {\n                if i <= x {\n                    if cnt < l {\n         \
    \               let (i, _) = v.iter().enumerate();\n                        ret.push((i,\
    \ i));\n                        cnt += 1;\n                    }\n           \
    \     } else {\n                    break;\n                }\n            }\n\
    \            ret;\n        }\n        _ => {\n            let mut ret: Vec<(isize,\
    \ isize)> = vec![];\n            for (i, v) in lst.iter().enumerate() {\n    \
    \            let mut cnt = 0;\n                let mut v = v.to_vec();\n     \
    \           for _ in 0..x {\n                    if v[cnt].is_none() {\n     \
    \                   break;\n                    }\n                    cnt +=\
    \ 1;\n                }\n                if cnt < l {\n                    let\
    \ (i, _) = v.iter().enumerate();\n                    ret.push((i, i));\n    \
    \            }\n            }\n            ret;\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmpbb3bwrtw.rs:49:26\n\
    \   |\n49 |                 if cnt < l {\n   |                          ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbb3bwrtw.rs:21:35\n   |\n21 |         (l, x) if l == 1\
    \ => vec![(l, x)],\n   |                                   ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         (l, x) if l == 1 => vec![(l.try_into().unwrap(),\
    \ x)],\n   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbb3bwrtw.rs:26:25\n   |\n26 |              \
    \   if i <= x {\n   |                         ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |                 if i <= x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbb3bwrtw.rs:28:29\n   |\n28 |                         let\
    \ (i, _) = v.iter().enumerate();\n   |                             ^^^^^^   --------------------\
    \ this expression has type `Enumerate<std::slice::Iter<'_, isize>>`\n   |    \
    \                         |\n   |                             expected struct\
    \ `Enumerate`, found tuple\n   |\n   = note: expected struct `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbb3bwrtw.rs:22:28\n   |\n22 |           (l, x) if x > 1 => {\n\
    \   |  ____________________________^\n23 | |             let mut ret: Vec<(isize,\
    \ isize)> = vec![];\n24 | |             let mut cnt = 0;\n25 | |             for\
    \ (i, v) in lst.iter().enumerate() {\n...  |\n36 | |             ret;\n   | |\
    \                - help: remove this semicolon\n37 | |         }\n   | |_________^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror[E0599]: no method named `is_non"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n\n    for row in lst {\n        let row_len\
    \ = row.len();\n        let mut curr_row = vec![];\n\n        for col in row {\n\
    \            if col == x {\n                curr_row.push((col, row_len));\n \
    \           }\n        }\n\n        coords.insert(0, curr_row);\n    }\n\n   \
    \ coords.sort_by_key(|a, b| a.0.cmp(&b.0));\n    coords.sort_by_key(|a, b| -b.1);\n\
    \    coords.reverse();\n\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take 1 argument, but it takes 2 arguments\n\
    \  --> /tmp/tmp_9lr2xq3.rs:33:12\n   |\n33 |     coords.sort_by_key(|a, b| a.0.cmp(&b.0));\n\
    \   |            ^^^^^^^^^^^ ------ takes 2 arguments\n   |            |\n   |\
    \            expected closure that takes 1 argument\n\nerror[E0593]: closure is\
    \ expected to take 1 argument, but it takes 2 arguments\n  --> /tmp/tmp_9lr2xq3.rs:34:12\n\
    \   |\n34 |     coords.sort_by_key(|a, b| -b.1);\n   |            ^^^^^^^^^^^\
    \ ------ takes 2 arguments\n   |            |\n   |            expected closure\
    \ that takes 1 argument\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_9lr2xq3.rs:37:5\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n37 |     coords\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(isize, usize)>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0593.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    use std::cmp::Ordering;\n    lst\n        .iter()\n        .map(|x| x.iter().enumerate().map(|(y,\
    \ v)| (*v, y)))\n        .map(|(_, y)| y as isize)\n        .collect()\n     \
    \   .sort_by(|a, b| a.cmp(b).reverse());\n    lst\n        .iter()\n        .map(|x|\
    \ x.iter().enumerate().map(|(y, v)| (*v, y)))\n        .filter(|(x, y)| x.0 ==\
    \ x)\n        .collect()\n        .sort_by(|a, b| a.1.cmp(&b.1).reverse());\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp_1mu73gx.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_1mu73gx.rs:22:15\n   |\n21 |         .map(|x| x.iter().enumerate().map(|(y,\
    \ v)| (*v, y)))\n   |                                           ----------------\
    \ the expected closure\n22 |         .map(|(_, y)| y as isize)\n   |         \
    \      ^^^^^-\n   |               |    |\n   |               |    expected due\
    \ to this\n   |               expected struct `Map`, found tuple\n   |\n   = note:\
    \ expected struct `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp_1mu73gx.rs:21:43:\
    \ 21:59]>`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_1mu73gx.rs:28:18\n   |\n27 |         .map(|x| x.iter().enumerate().map(|(y,\
    \ v)| (*v, y)))\n   |                                           ----------------\
    \ the expected closure\n28 |         .filter(|(x, y)| x.0 == x)\n   |        \
    \          ^^^^^-\n   |                  |    |\n   |                  |    expected\
    \ due to this\n   |                  expected struct `Map`, found tuple\n   |\n\
    \   = note: expected struct `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp_1mu73gx.rs:27:43:\
    \ 27:59]>`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_1mu73gx.rs:17:47\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![(0, 0, 0)];\n    for row in lst {\n        let mut\
    \ row_coords = vec![(0, 0, 0)];\n        for row in row {\n            if row\
    \ == x {\n                row_coords.push((row.0, row.1));\n            }\n  \
    \      }\n        if row_coords.len() == 0 {\n            continue;\n        }\n\
    \        row_coords.sort_by(|(col1, col2)| {\n            col1.1.cmp(&col2.1)\n\
    \        });\n        row_coords.sort_by(|(col1, col2)| {\n            col2.1.cmp(&col1.1)\n\
    \        });\n        rows.push((row_coords[row_coords.len() - 1].0, row_coords[row_coords.len()\
    \ - 1].1, row_coords.len()));\n    }\n    rows.sort_by(|(row1, row2)| row1.1.cmp(&row2.1));\n\
    \    let mut out: Vec<(isize, isize)> = vec![];\n    for (row, row_len) in rows\
    \ {\n        for (coord, col) in row.iter().zip(row_coords.iter()) {\n       \
    \     let (mut row, mut col) = coord;\n            let mut new_coord = vec![];\n\
    \            while row >= col.0 {\n                new_coord.push((row, col));\n\
    \                row -= col.1;\n                col += col.1;\n            }\n\
    \            if new_coord.len() > 0 {\n                out.push((new_coord[0].0,\
    \ new_coord[0].1));\n            }\n        }\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `row_coords` in this scope\n  --> /tmp/tmpycqd3rpu.rs:40:44\n\
    \   |\n40 |         for (coord, col) in row.iter().zip(row_coords.iter()) {\n\
    \   |                                            ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpycqd3rpu.rs:23:38\n   |\n23 |                 row_coords.push((row.0,\
    \ row.1));\n   |                                      ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpycqd3rpu.rs:23:45\n\
    \   |\n23 |                 row_coords.push((row.0, row.1));\n   |           \
    \                                  ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpycqd3rpu.rs:23:33\n   |\n23 |                 row_coords.push((row.0,\
    \ row.1));\n   |                                 ^^^^^^^^^^^^^^ expected a tuple\
    \ with 3 elements, found one with 2 elements\n   |\n   = note: expected tuple\
    \ `({integer}, {integer}, {integer})`\n              found tuple `({integer},\
    \ {integer})`\n\nerror[E0593]: closure is expected to take 2 distinct arguments,\
    \ but it takes a single 2-tuple as argument\n  --> /tmp/tmpycqd3rpu.rs:29:20\n\
    \   |\n29 |         row_coords.sort_by(|(col1, col2)| {\n   |                \
    \    ^^^^^^^ -------------- takes a single 2-tuple as argument\n   |         \
    \           |\n   |                    expected closure that takes 2 distinct\
    \ arguments\n   |\nhelp: change the closure to take multiple arguments instead\
    \ of a single tuple\n   |\n29 |         row_coords.sort_by(|col1, col2| {\n  \
    \ |                            ~~~~~~~~~~~~\n\nerror[E0593]: closure is expected\
    \ to take 2 distinct arguments, but it takes a single 2-tuple as argument\n  -->\
    \ /tmp/tmpycqd3rpu.rs:32:20\n   |\n32 |         row_coords.sort_by(|(col1, col2)|\
    \ {\n   |                    ^^^^^^^ -------------- takes a single 2-tuple as\
    \ argument\n   |                    |\n   |                    expected closure\
    \ that takes 2 distinct arguments\n   |\nhelp: change the closure to take multiple\
    \ arguments instead of a single tuple\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for i in lst {\n \
    \       if i.len() == x {\n            result.push((i.iter().skip(x).collect(),\
    \ i.iter().take(x).collect()));\n        }\n    }\n    result.sort_by_key(|x,\
    \ y| x.1.cmp(&y.1));\n    result.sort_by_key(|x, y| x.2.cmp(&y.2));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqt7zezs.rs:20:23\n   |\n\
    20 |         if i.len() == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if i.len() == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnqt7zezs.rs:21:40\n   |\n21 |             result.push((i.iter().skip(x).collect(),\
    \ i.iter().take(x).collect()));\n   |                                        ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n21 |           \
    \  result.push((i.iter().skip(x.try_into().unwrap()).collect(), i.iter().take(x).collect()));\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `isize` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmpnqt7zezs.rs:21:43\n     |\n21   |             result.push((i.iter().skip(x).collect(),\
    \ i.iter().take(x).collect()));\n     |                                      \
    \     ^^^^^^^ value of type `isize` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `isize`\nnote: required by a bound in `collect`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnqt7zezs.rs:21:68\n   |\n21 |             result.push((i.iter().skip(x).collect(),\
    \ i.iter().take(x).collect()));\n   |                                        \
    \                            ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |             result.push((i.iter().skip(x).collect(), i.iter().take(x.try_into().unwrap()).collect()));\n\
    \   |                                                                     ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `isize` cannot be built from an iterator over\
    \ elements of type `&isize`\n    --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut i = 1;\n    let mut j = 1;\n    let mut row_vec: Vec<(isize,\
    \ isize)> = vec![];\n    while i <= lst.len() {\n        row_vec.push((j, i));\n\
    \        j += lst[i].len() - 1;\n        i += 1;\n    }\n    row_vec.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    row_vec.sort_by(|a, b| b.2.cmp(&a.2));\n    row_vec\n\
    \        .iter()\n        .map(|(x, y)| {\n            assert!(x == 0 || y % x\
    \ == 0);\n            (x, y)\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx3yt2w9l.rs:22:26\n   |\n\
    22 |         row_vec.push((j, i));\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |         row_vec.push((j, i.try_into().unwrap()));\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx3yt2w9l.rs:23:14\n   |\n23 |         j += lst[i].len()\
    \ - 1;\n   |              ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\n\
    error[E0277]: cannot add-assign `usize` to `isize`\n  --> /tmp/tmpx3yt2w9l.rs:23:11\n\
    \   |\n23 |         j += lst[i].len() - 1;\n   |           ^^ no implementation\
    \ for `isize += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0609]: no field `2` on type `&(isize, isize)`\n  --> /tmp/tmpx3yt2w9l.rs:27:30\n\
    \   |\n27 |     row_vec.sort_by(|a, b| b.2.cmp(&a.2));\n   |                 \
    \             ^\n\nerror[E0609]: no field `2` on type `&(isize, isize)`\n  -->\
    \ /tmp/tmpx3yt2w9l.rs:27:39\n   |\n27 |     row_vec.sort_by(|a, b| b.2.cmp(&a.2));\n\
    \   |                                       ^\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpx3yt2w9l.rs:31:23\n   |\n31 |             assert!(x\
    \ == 0 || y % x == 0);\n   |                       ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.len() == 0 {\n        return vec![];\n    }\n    let mut res =\
    \ vec![];\n    lst\n        .iter()\n        .enumerate()\n        .sort_by(|(_,\
    \ (i, j))| (i, j));\n    for i in 0..lst.len() {\n        if i == 0 {\n      \
    \      i += 1;\n        }\n        for j in 0..(lst[i].len() - 1) {\n        \
    \    if i == 0 {\n                let cmp = cmp::Ordering::Less::cmp(&i, &j);\n\
    \                let res = (i, j)\n                    .ok_or(\"x not in list\"\
    )\n                    .and_then(cmp)\n                    .ok_or(\"x not in list\"\
    )\n                    .and_then(|_| i as isize)\n                    .ok_or(\"\
    x not in list\")\n                    .and_then(cmp)\n                    .ok_or(\"\
    x not in list\")\n                    .and_then(|_| j as isize);\n           \
    \     if *res == x {\n                    res.push((i, j));\n                }\n\
    \            }\n        }\n    }\n    res\n        .iter()\n        .fold(vec![],\
    \ |mut acc, (idx, col)| {\n            acc\n                .iter_mut()\n    \
    \            .enumerate()\n                .sort_by(|(_, (i, j))| (j, idx));\n\
    \            for (i, (_, col)) in acc.iter().zip(col.iter()) {\n             \
    \   (*i, *j) = (*j, *i);\n            }\n            acc.push(col);\n        \
    \    vec![acc]\n        })\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpq0btqti6.rs:32:27\n   |\n32 |                 let cmp = cmp::Ordering::Less::cmp(&i,\
    \ &j);\n   |                           ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpq0btqti6.rs:56:23\n\
    \   |\n56 |                 (*i, *j) = (*j, *i);\n   |                       ^\
    \ help: a local variable with a similar name exists: `i`\n\nerror[E0425]: cannot\
    \ find value `j` in this scope\n  --> /tmp/tmpq0btqti6.rs:56:30\n   |\n56 |  \
    \               (*i, *j) = (*j, *i);\n   |                              ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Enumerate` in the current scope\n  --> /tmp/tmpq0btqti6.rs:25:10\n\
    \   |\n25 |         .sort_by(|(_, (i, j))| (i, j));\n   |          ^^^^^^^ method\
    \ not found in `Enumerate<std::slice::Iter<'_, Vec<isize>>>`\n\nerror[E0599]:\
    \ no method named `ok_or` found for tuple `(usize, usize)` in the current scope\n\
    \  --> /tmp/tmpq0btqti6.rs:34:22\n   |\n34 |                     .ok_or(\"x not\
    \ in list\")\n   |                      ^^^^^ method not found in `(usize, usize)`\n\
    \nerror[E0599]: no method named `sort_by` found for struct `Enumerate` in the\
    \ current scope\n  --> /tmp/tmpq0btqti6.rs:54:18\n   |\n54 |                 .sort_by(|(_,\
    \ (i, j))| (j, idx));\n   |                  ^^^^^^^ method not found in `Enumerate<std::slice::IterMut<'_,\
    \ (isize, isize)>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq0btqti6.rs:59:18\n\
    \   |\n59 |             vec![acc]\n   |                  ^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n           \
    \  found struct `Vec<(isize, isize)>`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0433, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    for (i, e) in lst.iter().enumerate() {\n \
    \       let mut col = vec![];\n        let mut cur = i; //current row\n      \
    \  for (i, e) in e.iter().enumerate() {\n            if i == x {\n           \
    \     col.push(cur);\n            }\n            col.push(e);\n        }\n   \
    \     row.push((i, col));\n    }\n    row.sort_by(|a, b| a.0.1);\n    row.sort_by(|a,\
    \ b| -b.1.1);\n    row.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgsbkj4dj.rs:23:21\n   |\n\
    23 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgsbkj4dj.rs:26:22\n   |\n26 |             col.push(e);\n\
    \   |                      ^ expected `usize`, found `&isize`\n\nerror[E0610]:\
    \ `usize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpgsbkj4dj.rs:30:28\n\
    \   |\n30 |     row.sort_by(|a, b| a.0.1);\n   |                            ^\n\
    \nerror[E0609]: no field `1` on type `Vec<usize>`\n  --> /tmp/tmpgsbkj4dj.rs:31:29\n\
    \   |\n31 |     row.sort_by(|a, b| -b.1.1);\n   |                            \
    \ ^ unknown field\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot\
    \ be built from an iterator over elements of type `(usize, Vec<usize>)`\n    -->\
    \ /tmp/tmpgsbkj4dj.rs:32:25\n     |\n32   |     row.iter().cloned().collect()\n\
    \     |                         ^^^^^^^ value of type `Vec<(isize, isize)>` cannot\
    \ be built from `std::iter::Iterator<Item=(usize, Vec<usize>)>`\n     |\n    \
    \ = help: the trait `FromIterator<(usize, Vec<usize>)>` is not implemented for\
    \ `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0609, E0610.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut rows\
    \ = vec![];\n    let mut cols = vec![];\n    let mut row = 0;\n    let mut col\
    \ = 0;\n    let mut i = 0;\n    while i < lst.len() {\n        for j in lst.as_slice()[i].iter().rev()\
    \ {\n            if *j < x {\n                col += 1;\n                cols.insert(0,\
    \ col);\n                i += 1;\n            } else {\n                row +=\
    \ 1;\n                rows.insert(0, row);\n                col = 0;\n       \
    \         i += 1;\n            }\n        }\n    }\n    rows.sort_by(|a, b| b.cmp(&a));\n\
    \    cols.sort_by(|a, b| b.cmp(&a));\n    rows\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyosj3bek.rs:42:5\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n42 |     rows\n   |     ^^^^ expected\
    \ tuple, found integer\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    for row in lst {\n        let mut cols =\
    \ vec![];\n        for col in row.iter() {\n            cols.push(col.clone());\n\
    \        }\n        rows.push((col.iter().min().unwrap(), col.iter().max().unwrap()));\n\
    \    }\n    rows.sort_by_key(|(k, _)| *k).reverse();\n    rows.sort_by_key(|(_,\
    \ v)| *v).reverse();\n    let mut ret: Vec<(isize, isize)> = vec![];\n    let\
    \ mut row = 0;\n    let mut column = 0;\n    while column < x {\n        row +=\
    \ 1;\n        if row == rows.len() {\n            break;\n        }\n        let\
    \ row = rows[row];\n        for col in row.iter().cloned() {\n            let\
    \ c = column;\n            if c < x {\n                break;\n            }\n\
    \            let ret = ((row, c), (*col + c));\n            ret.sort_by_key(|(k,\
    \ _)| *k).reverse();\n            ret.sort_by_key(|(_, v)| *v).reverse();\n  \
    \          ret.push(ret);\n        }\n        column += 1;\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmp3rg81npo.rs:24:20\n\
    \   |\n24 |         rows.push((col.iter().min().unwrap(), col.iter().max().unwrap()));\n\
    \   |                    ^^^ help: a local variable with a similar name exists:\
    \ `cols`\n\nerror[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmp3rg81npo.rs:24:47\n\
    \   |\n24 |         rows.push((col.iter().min().unwrap(), col.iter().max().unwrap()));\n\
    \   |                                               ^^^ help: a local variable\
    \ with a similar name exists: `cols`\n\nerror[E0599]: no method named `reverse`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmp3rg81npo.rs:26:35\n\
    \   |\n26 |     rows.sort_by_key(|(k, _)| *k).reverse();\n   |               \
    \                    ^^^^^^^ method not found in `()`\n\nerror[E0599]: no method\
    \ named `reverse` found for unit type `()` in the current scope\n  --> /tmp/tmp3rg81npo.rs:27:35\n\
    \   |\n27 |     rows.sort_by_key(|(_, v)| *v).reverse();\n   |               \
    \                    ^^^^^^^ method not found in `()`\n\nerror[E0599]: no method\
    \ named `iter` found for tuple `(_, _)` in the current scope\n  --> /tmp/tmp3rg81npo.rs:37:24\n\
    \   |\n37 |         for col in row.iter().cloned() {\n   |                   \
    \     ^^^^ method not found in `(_, _)`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    let mut cols = vec![];\n\n    for row in\
    \ lst.iter() {\n        for col in row.iter().rev() {\n            cols.push(col);\n\
    \        }\n        rows.push((col, row))\n    }\n\n    sorting(rows);\n    sorting(cols);\n\
    \n    let mut result = vec![];\n    for (row, col) in rows.iter().zip(cols.iter().rev())\
    \ {\n        if *row == x {\n            result.push((*row, *col));\n        }\n\
    \    }\n    result.sort_by_key(|x| x.0);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmp9tpueoru.rs:25:20\n\
    \   |\n25 |         rows.push((col, row))\n   |                    ^^^ help: a\
    \ local variable with a similar name exists: `cols`\n\nerror[E0425]: cannot find\
    \ function `sorting` in this scope\n  --> /tmp/tmp9tpueoru.rs:28:5\n   |\n28 |\
    \     sorting(rows);\n   |     ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `sorting` in this scope\n  --> /tmp/tmp9tpueoru.rs:29:5\n\
    \   |\n29 |     sorting(cols);\n   |     ^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9tpueoru.rs:38:5\n   |\n17 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n38 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n   \
    \           found struct `Vec<(_, &isize)>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = Vec::new();\n    let mut r0 = 0;\n    let mut r1 = 0;\n\
    \    let mut c1 = 0;\n    let mut c2 = lst[0].len();\n    while r0 <= lst[0].len()\
    \ && r1 < lst.len() && c1 < c2 {\n        if r0 == 0 && c1 == 0 {\n          \
    \  for (i, row) in lst.iter().enumerate() {\n                if i == r1 {\n  \
    \                  ret.push((i, row[c1]));\n                    break;\n     \
    \           }\n            }\n            r0++;\n            r1++;\n         \
    \   c1++;\n            c2 = lst[r1].len();\n        }\n        if r0 == 0 && c2\
    \ < lst[r1].len() {\n            for (i, row) in lst.iter().enumerate() {\n  \
    \              if i == r1 {\n                    ret.push((i, row[c2]));\n   \
    \                 break;\n                }\n            }\n            r0++;\n\
    \            r1++;\n            c1++;\n            c2 = lst[r1].len();\n     \
    \   }\n        if r1 < lst.len() {\n            for (i, row) in lst.iter().enumerate()\
    \ {\n                if i == r0 {\n                    ret.push((i, row[c2]));\n\
    \                    break;\n                }\n            }\n            r1++;\n\
    \            c1 = 0;\n            c2 = lst[r1].len();\n        }\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpodddefwj.rs:31:15\n\
    \   |\n31 |             r0++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n31 |             { let tmp = r0; r0 +=\
    \ 1; tmp };\n   |             +++++++++++   ~~~~~~~~~~~~~~~~\n31 -           \
    \  r0++;\n31 +             r0 += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpodddefwj.rs:43:15\n   |\n43 |             r0++;\n  \
    \ |               ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n43 |             { let tmp = r0; r0 += 1; tmp };\n   |             +++++++++++\
    \   ~~~~~~~~~~~~~~~~\n43 -             r0++;\n43 +             r0 += 1;\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpodddefwj.rs:55:15\n\
    \   |\n55 |             r1++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n55 |             { let tmp = r1; r1 +=\
    \ 1; tmp };\n   |             +++++++++++   ~~~~~~~~~~~~~~~~\n55 -           \
    \  r1++;\n55 +             r1 += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpodddefwj.rs:60:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n60 |     ret\n   |     ^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, _)>`\n              found struct `Vec<(usize,\
    \ _)>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .map(|row| row.iter().enumerate().map(|(i, col)|\
    \ {\n            (i, col)\n        }))\n        .flatten()\n        .SortBy(|(x,\
    \ y)| x.1)\n        .Reverse()\n        .SortBy(|(x, y)| y.1)\n        .map(|(x,\
    \ y)| x.0)\n        .iter()\n        .enumerate()\n        .map(|(row, col)| {\n\
    \            (row, col)\n        })\n        .take(x)\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `SortBy` found for struct `Flatten` in the\
    \ current scope\n  --> /tmp/tmpa_qxrvml.rs:23:10\n   |\n23 |         .SortBy(|(x,\
    \ y)| x.1)\n   |          ^^^^^^ method not found in `Flatten<Map<std::slice::Iter<'_,\
    \ Vec<isize>>, [closure@/tmp/tmpa_qxrvml.rs:19:14: 21:11]>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut m = vec![(x, 0)];\n    for r in lst {\n        for (i, v) in\
    \ r.iter().enumerate() {\n            if *v == x {\n                let r = *r\
    \ as isize;\n                m.push((r, i));\n            }\n        }\n    }\n\
    \    m.sort_by_key(|&(k, _)| k.0);\n    m.reverse();\n    m\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp0jpc7qno.rs:27:31\n   |\n27 |     m.sort_by_key(|&(k, _)| k.0);\n\
    \   |                               ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0jpc7qno.rs:29:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     m\n   |     ^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<(_, isize)>`\n              found struct `Vec<(_, usize)>`\n\
    \nerror[E0605]: non-primitive cast: `[isize]` as `isize`\n  --> /tmp/tmp0jpc7qno.rs:22:25\n\
    \   |\n22 |                 let r = *r as isize;\n   |                       \
    \  ^^^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0605, E0610.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        find_row(vec![],\
    \ lst, x)\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_row` in this scope\n  --> /tmp/tmpidsgyn0l.rs:21:9\n\
    \   |\n21 |         find_row(vec![], lst, x)\n   |         ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let rows = lst.len();\n    let cols = lst[0].len();\n    let mut coords\
    \ = Vec::new();\n    for row_index in 0..rows {\n        let cols = lst[row_index].len();\n\
    \        let coord = (row_index, cols);\n        coords.push(coord);\n    }\n\
    \    coords.sort();\n\n    coords.sort_by(|x, y| {\n        if x.0 < y {\n   \
    \         true\n        } else {\n            false\n        }\n    });\n    coords.sort_by_key(|x|\
    \ x.1);\n\n    coords.iter().map(|coord| {\n        let coord = coord.clone();\n\
    \        (coord[0], coord[1])\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnmy706pi.rs:29:18\n   |\n\
    29 |         if x.0 < y {\n   |                  ^ expected `usize`, found `&(usize,\
    \ usize)`\n   |\n   = note:   expected type `usize`\n           found reference\
    \ `&(usize, usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnmy706pi.rs:30:13\n\
    \   |\n30 |             true\n   |             ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnmy706pi.rs:32:13\n\
    \   |\n32 |             false\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0608]: cannot index into a value of type `(usize, usize)`\n\
    \  --> /tmp/tmpnmy706pi.rs:39:10\n   |\n39 |         (coord[0], coord[1])\n  \
    \ |          ^^^^^^^^ help: to access tuple elements, use: `coord.0`\n\nerror[E0608]:\
    \ cannot index into a value of type `(usize, usize)`\n  --> /tmp/tmpnmy706pi.rs:39:20\n\
    \   |\n39 |         (coord[0], coord[1])\n   |                    ^^^^^^^^ help:\
    \ to access tuple elements, use: `coord.1`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut columns = lst[0].len();\n    for\
    \ i in 0..rows {\n        let mut found = false;\n        for (j, c) in &lst[i]\
    \ {\n            if c == x {\n                rows[i] = j;\n                found\
    \ = true;\n                break;\n            }\n        }\n        if found\
    \ == false {\n            rows[i] = rows[rows - 1] + 1;\n        }\n    }\n  \
    \  for r in 0..rows {\n        let mut found = false;\n        let mut j = r -\
    \ 1;\n        for c in &lst[r] {\n            if c == x {\n                found\
    \ = true;\n                columns[j] = c;\n                break;\n         \
    \   }\n            j += 1;\n        }\n        if found == false {\n         \
    \   columns[j] = columns[j - 1] + 1;\n        }\n    }\n    columns[..]\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0lmuau31.rs:22:13\n   |\n\
    22 |         for (j, c) in &lst[i] {\n   |             ^^^^^^    ------- this\
    \ expression has type `Option<&isize>`\n   |             |\n   |             expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0608]: cannot index into a value of type `usize`\n\
    \  --> /tmp/tmp0lmuau31.rs:24:17\n   |\n24 |                 rows[i] = j;\n  \
    \ |                 ^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `usize`\n  --> /tmp/tmp0lmuau31.rs:30:13\n   |\n30 |             rows[i] = rows[rows\
    \ - 1] + 1;\n   |             ^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `usize`\n  --> /tmp/tmp0lmuau31.rs:30:23\n   |\n30 |             rows[i]\
    \ = rows[rows - 1] + 1;\n   |                       ^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `usize`\n  --> /tmp/tmp0lmuau31.rs:39:17\n\
    \   |\n39 |                 columns[j] = c;\n   |                 ^^^^^^^^^^\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp0lmuau31.rs:37:18\n\
    \   |\n37 |             if c == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0608]: cannot index into a value\
    \ of type `usize`\n  --> /tmp/tmp0lmuau31.rs:45:13\n   |\n45 |             columns[j]\
    \ = columns[j - 1] + 1;\n   |             ^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `usize`\n  --> /tmp/tmp0lmuau31.rs:45:26\n   |\n45 |  \
    \           columns[j] = columns[j - 1] + 1;\n   |                          ^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmp0lmuau31.rs:48:5\n\
    \   |\n48 |     columns[..]\n   |     ^^^^^^^^^^^\n\nerror: aborting due to 9\
    \ previous errors\n\nSome errors have detailed ex"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for i in 0..lst.len() {\n        if\
    \ i == x {\n            result.push((i, x - 1));\n            continue;\n    \
    \    }\n        let mut found = false;\n        for j in 0..lst[i].len() {\n \
    \           if lst[i][j] == x {\n                found = true;\n             \
    \   break;\n            }\n        }\n        if found {\n            result.push((i,\
    \ j));\n        }\n    }\n    result.sort_by_key(|x| x.1);\n    result.sort_by_key(|x|\
    \ x.0.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmp5yk1r9bh.rs:32:29\n\
    \   |\n32 |             result.push((i, j));\n   |                           \
    \  ^ help: a local variable with a similar name exists: `i`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5yk1r9bh.rs:20:17\n   |\n20 |         if i == x {\n   |\
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    20 |         if i == x.try_into().unwrap() {\n   |                  ++++++++++++++++++++\n\
    \nerror[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp5yk1r9bh.rs:36:32\n   |\n36 |     result.sort_by_key(|x| x.0.1);\n\
    \   |                                ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5yk1r9bh.rs:37:5\n   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n37 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, _)>`\n              found struct `Vec<(usize,\
    \ _)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0610.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = Vec::new();\n    let mut counter = 0;\n    let mut row_counters\
    \ = Vec::new();\n    let mut col_counters = Vec::new();\n    for rws in lst.iter()\
    \ {\n        let mut temp_counter = 0;\n        for cs in rws.iter() {\n     \
    \       if cs == x {\n                ret.push((rws[counter], rws[counter + 1]));\n\
    \                temp_counter += 2;\n            } else {\n                row_counters.push(temp_counter);\n\
    \                col_counters.push(temp_counter);\n                temp_counter\
    \ += 1;\n            }\n        }\n        counter = temp_counter;\n    }\n  \
    \  ret = ret.iter().map(|&(_, rw)| rw).collect();\n    ret = ret.iter().cloned().sort();\n\
    \    ret = ret.reverse();\n    row_counters.sort();\n    col_counters.sort();\n\
    \    ret = ret.iter().cloned().zip(row_counters.clone()).zip(col_counters.clone()).collect();\n\
    \    ret = ret.iter().cloned().sort();\n    ret = ret.reverse();\n    ret\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp1cl7n5hx.rs:25:19\n\
    \   |\n25 |             if cs == x {\n   |                   ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ isize)>` cannot be built from an iterator over elements of type `isize`\n  \
    \  --> /tmp/tmp1cl7n5hx.rs:36:41\n     |\n36   |     ret = ret.iter().map(|&(_,\
    \ rw)| rw).collect();\n     |                                         ^^^^^^^\
    \ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `sort`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmp1cl7n5hx.rs:37:31\n\
    \   |\n37 |     ret = ret.iter().cloned().sort();\n   |                      \
    \         ^^^^ method not found in `Cloned<std::slice::Iter<'_, (isize, isize)>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1cl7n5hx.rs:38:11\n   |\n18 |\
    \     let mut ret = Vec::new();\n   |                   ---------- expected due\
    \ to this value\n...\n38 |     ret = ret.reverse();\n   |           ^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ isize)>` cannot be built from an iterator over elements of type `(((isize, isize),\
    \ usize), usize)`\n    --> /tmp/tmp1cl7n5hx.rs:41:83\n     |\n41   |     ret =\
    \ ret.iter().cloned().zip(row_counters.clone()).zip(col_counters.clone()).collect();\n\
    \     |                                                                      \
    \         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_sorted\
    \ = Vec::new();\n    let mut col_sorted = Vec::new();\n    for row in lst {\n\
    \        row_sorted.push(get_row_and_col(row, x));\n    }\n    let mut row_sorted_by_cols\
    \ = sort_row_and_col(row_sorted);\n    let mut col_sorted_by_rows = sort_col(col_sorted);\n\
    \n    for col in col_sorted_by_rows {\n        let mut col_index: Vec<isize> =\
    \ Vec::new();\n        let mut current_row = row_sorted_by_cols[col];\n      \
    \  while let Some((row, col)) = current_row {\n            col_index.push(col);\n\
    \            current_row = row_sorted_by_cols[col];\n        }\n        col_sorted_by_rows[col]\
    \ = col_index;\n    }\n    col_sorted_by_rows\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_row_and_col` in this scope\n  -->\
    \ /tmp/tmp8vkoovyq.rs:22:25\n   |\n22 |         row_sorted.push(get_row_and_col(row,\
    \ x));\n   |                         ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sort_row_and_col` in this scope\n  --> /tmp/tmp8vkoovyq.rs:24:34\n\
    \   |\n24 |     let mut row_sorted_by_cols = sort_row_and_col(row_sorted);\n \
    \  |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sort_col` in this scope\n  --> /tmp/tmp8vkoovyq.rs:25:34\n\
    \   |\n25 |     let mut col_sorted_by_rows = sort_col(col_sorted);\n   |     \
    \                             ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = vec![];\n    for row in lst {\n        let mut\
    \ coordinate = vec![];\n        for col in row {\n            if col == x {\n\
    \                coordinate.push((row, col));\n            }\n        }\n    \
    \    coordinates.push_back(coordinate);\n    }\n    coordinates.sort_by_key(|key|\
    \ key.0);\n    coordinates.sort_by_key(|key| -key.1);\n    coordinates\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmpc0yks_0w.rs:26:21\n   |\n26 |         coordinates.push_back(coordinate);\n\
    \   |                     ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0609]:\
    \ no field `0` on type `&_`\n  --> /tmp/tmpc0yks_0w.rs:28:39\n   |\n28 |     coordinates.sort_by_key(|key|\
    \ key.0);\n   |                                       ^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    lst.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n    for rows in &lst {\n        rows.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n        if rows.iter().find(|&i| i ==\
    \ x) != Some(&rows[rows.len() - 1]) {\n            return rows;\n        }\n \
    \   }\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n    -->\
    \ /tmp/tmpv_6i9z9a.rs:18:37\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \     |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(*&b.iter()).reverse());\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-reference\n     |\n18   -     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    18   +     lst.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n     | \nhelp:\
    \ consider changing this borrow's mutability\n     |\n18   |     lst.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n     |                         \
    \            ~~~~\n\nerror[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n\
    \    --> /tmp/tmpv_6i9z9a.rs:19:37\n     |\n19   |     lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \     |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n19   |     lst.sort_by(|a, b| b.iter().cmp(*&a.iter()).reverse());\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-ref"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst_ = lst;\n    if lst_.len() == 0 {\n        return vec![];\n\
    \    }\n    for (_, row) in lst_.into_iter().zip() {\n        if row.len() ==\
    \ x {\n            return row;\n        }\n    }\n    unreachable!();\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmptsndsg9f.rs:22:38\n    |\n22  |     for (_, row) in lst_.into_iter().zip()\
    \ {\n    |                                      ^^^- supplied 0 arguments\n  \
    \  |                                      |\n    |                           \
    \           expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst.iter() {\n        let mut\
    \ result = vec![];\n        for (i, &x) in row.iter().enumerate().take(x as usize)\
    \ {\n            result.push((i, x));\n        }\n        result.sort();\n   \
    \     result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort_by_key(|&(x,\
    \ y)| y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(_, y)|\
    \ y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n\
    \        result.sort();\n        result.sort_by_key(|&(_, y)| y.cmp(&0));\n  \
    \      result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n    \
    \    result.sort();\n        result.sort_by_key(|&(_, y)| y.cmp(&0));\n      \
    \  result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n        result.sort();\n\
    \        result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort();\n  \
    \      result.sort_by_key(|&(x, y)| y.cmp(&0));\n        result.sort();\n    \
    \    result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort();\n      \
    \  result.sort_by_key(|&(x, y)| y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(_,\
    \ y)| y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(x, y)|\
    \ y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(_, y)| y.cmp(&0));\n\
    \        result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n  \
    \      result.sort();\n        result.sort_by_key(|&(_, y)| y.cmp(&0));\n    \
    \    result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n      \
    \  result.sort();\n        result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort();\n\
    \        result.sort_by_key(|&(x, y)| y.cmp(&0));\n        result.sort();\n  \
    \      result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort();\n    \
    \    result.sort_by_key(|&(x, y)| y.cmp(&0));\n        result.sort();\n      \
    \  result.sort_by_key(|&(_, y)| y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(x,\
    \ y)| y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(_, y)|\
    \ y.cmp(&0));\n        result.sort();\n        result.sort_by_key(|&(x, y)| y.cmp(&0));\n\
    \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppp5eokzo.rs:86:3\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n18 |     let mut result = vec![];\n19 |     for row in lst.iter()\
    \ {\n   |                           - this delimiter might not be properly closed...\n\
    ...\n76 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    86 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppp5eokzo.rs:17:47\n\
    \   |\n17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\n    let mut\
    \ ret: Vec<(isize, isize)> = Vec::new();\n    ret.extend_from_slice(&*lst.iter().map(|row|\n\
    \        row.iter().enumerate().filter_map(|(index, x)| {\n            if index\
    \ == x {\n                Some((index, x))\n            } else {\n           \
    \     None\n            }\n        }).collect()));\n\n    ret = ret.into_iter().map(|(_,\
    \ row)| {\n        (row.iter().enumerate().min_by_key(|(_, y)| y).unwrap().0,\
    \ row.iter().enumerate().max_by_key(|(_, y)| y).unwrap().0)\n    }).collect();\n\
    \    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppu2xodeh.rs:25:25\n   |\n\
    25 |             if index == x {\n   |                         ^ expected `usize`,\
    \ found `&isize`\n\nerror[E0614]: type `Map<std::slice::Iter<'_, Vec<isize>>,\
    \ [closure@/tmp/tmppu2xodeh.rs:23:44: 30:21]>` cannot be dereferenced\n  --> /tmp/tmppu2xodeh.rs:23:28\n\
    \   |\n23 |       ret.extend_from_slice(&*lst.iter().map(|row|\n   |  ____________________________^\n\
    24 | |         row.iter().enumerate().filter_map(|(index, x)| {\n25 | |      \
    \       if index == x {\n26 | |                 Some((index, x))\n...  |\n29 |\
    \ |             }\n30 | |         }).collect()));\n   | |_____________________^\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmppu2xodeh.rs:33:14\n   |\n33 |         (row.iter().enumerate().min_by_key(|(_,\
    \ y)| y).unwrap().0, row.iter().enumerate().max_by_key(|(_, y)| y).unwrap().0)\n\
    \   |              ^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `iter` found for type `isize` in the current scope\n  --> /tmp/tmppu2xodeh.rs:33:72\n\
    \   |\n33 |         (row.iter().enumerate().min_by_key(|(_, y)| y).unwrap().0,\
    \ row.iter().enumerate().max_by_key(|(_, y)| y).unwrap().0)\n   |            \
    \                                                            ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut x = x;\n    let mut rows = lst.len() - 1;\n    let mut columns\
    \ = lst[rows].len() - 1;\n    let mut row = 0;\n    let mut col = 0;\n    while\
    \ col < columns {\n        if lst[row][col] == x {\n            return (row, col);\n\
    \        }\n        row += 1;\n        if row == rows {\n            row = 0;\n\
    \            col += 1;\n        }\n    }\n    unreachable!();\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp79oah7ai.rs:25:20\n   |\n\
    25 |             return (row, col);\n   |                    ^^^^^^^^^^ expected\
    \ struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \               found tuple `(usize, usize)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut tuple = vec![];\n    for row in lst {\n        let mut counter\
    \ = vec![0];\n        for row in row.iter().cloned() {\n            for _ in 0..x\
    \ {\n                counter.push(*counter.last().unwrap() + 1);\n           \
    \ }\n            tuple.push((counter.last().unwrap(), row));\n            counter\
    \ = counter.clone();\n        }\n    }\n    tuple.iter().cloned().sort_by_key(|(x,\
    \ y)| {\n        x.0\n    }).reverse().sort_by_key(|(x, y)| {\n        y.0\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpf6o7afee.rs:29:27\n   |\n29 |     tuple.iter().cloned().sort_by_key(|(x,\
    \ y)| {\n   |                           ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ (&{integer}, isize)>>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    vec![(0, 0)].into_iter()\n        .chain(lst.into_iter().skip(x).zip(lst.into_iter().take(1).rev().skip(1)))\n\
    \        .map(|(a, b)| (b, a))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiedapa83.rs:19:37\n   |\n\
    19 |         .chain(lst.into_iter().skip(x).zip(lst.into_iter().take(1).rev().skip(1)))\n\
    \   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         .chain(lst.into_iter().skip(x.try_into().unwrap()).zip(lst.into_iter().take(1).rev().skip(1)))\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0271]:\
    \ type mismatch resolving `<Zip<Skip<std::vec::IntoIter<Vec<isize>>>, Skip<Rev<std::iter::Take<std::vec::IntoIter<Vec<isize>>>>>>\
    \ as IntoIterator>::Item == ({integer}, {integer})`\n   --> /tmp/tmpiedapa83.rs:19:10\n\
    \    |\n19  |         .chain(lst.into_iter().skip(x).zip(lst.into_iter().take(1).rev().skip(1)))\n\
    \    |          ^^^^^ expected integer, found struct `Vec`\n    |\n    = note:\
    \ expected tuple `({integer}, {integer})`\n               found tuple `(Vec<isize>,\
    \ Vec<isize>)`\nnote: required by a bound in `std::iter::Iterator::chain`\n\n\
    error[E0599]: the method `map` exists for struct `std::iter::Chain<std::vec::IntoIter<({integer},\
    \ {integer})>, Zip<Skip<std::vec::IntoIter<Vec<isize>>>, Skip<Rev<std::iter::Take<std::vec::IntoIter<Vec<isize>>>>>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpiedapa83.rs:20:10\n \
    \  |\n20 |           .map(|(a, b)| (b, a))\n   |            ^^^ method cannot\
    \ be called on `std::iter::Chain<std::vec::IntoIter<({integer}, {integer})>, Zip<Skip<std::vec::IntoIter<Vec<isize>>>,\
    \ Skip<Rev<std::iter::Take<std::vec::IntoIter<Vec<isize>>>>>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Zip<Skip<std::vec::IntoIter<Vec<isize>>>, Skip<Rev<std::iter::Take<std::vec::IntoIter<Vec<isize>>>>>>\
    \ as Iterator>::Item = ({integer}, {integer})`\n           which is required by\
    \ `std::iter::Chain<std::vec::IntoIter<({integer}, {integer})>, Zip<Skip<std::vec::IntoIter<Vec<isize>>>,\
    \ Skip<Rev<std::iter::Take<std::vec::IntoIter<Vec<isize>>>>>>>:"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = 0;\n    let mut col = x.abs() as isize;\n    let mut rows:\
    \ Vec<(isize, isize)> = Vec::new();\n    while row < lst.len() {\n        row.checked_add(1).unwrap();\n\
    \        if col >= 0 {\n            rows.push((row, col));\n        }\n      \
    \  col -= 1;\n    }\n    rows.sort_by(|a, b| b.1.cmp(&a.1));\n    rows.reverse();\n\
    \    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcn7wa0gh.rs:24:24\n   |\n\
    24 |             rows.push((row, col));\n   |                        ^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |             rows.push((row.try_into().unwrap(),\
    \ col));\n   |                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = vec![];\n\n    // find first occurence\
    \ and copy the first list\n    let mut first = find_first(lst[0], x);\n\n    //\
    \ get the number of columns of the first row\n    let row_size = lst[0].len();\n\
    \n    // if x isn't in first list, return an empty list\n    if first == -1 {\n\
    \        return rows;\n    }\n\n    // loop through the list once to get the first\
    \ row, store the\n    // coordinates and add them to the row\n    for i in 0..row_size\
    \ {\n        let row = lst\n            .iter()\n            .skip(1)\n      \
    \      .take(row_size)\n            .find(|x| x[i] == x);\n\n        // if the\
    \ coordinate is not found for the row\n        if row == -1 {\n            return\
    \ rows;\n        }\n\n        rows.push((row[0], i));\n    }\n\n    // loop through\
    \ the list once to get the second row, store the\n    // coordinates and add them\
    \ to the row\n    for i in row_size..lst[0].len() {\n        let row = lst\n \
    \           .iter()\n            .skip(1)\n            .take(row_size)\n     \
    \       .find(|x| x[i] == x);\n\n        // if the coordinate is not found for\
    \ the row\n        if row == -1 {\n            return rows;\n        }\n\n   \
    \     rows.push((i, row[0]));\n    }\n\n    // return the rows\n    return rows;\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_first` in this scope\n  --> /tmp/tmpl4kinufs.rs:21:21\n\
    \   |\n21 |     let mut first = find_first(lst[0], x);\n   |                 \
    \    ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl4kinufs.rs:38:31\n   |\n38 |             .find(|x| x[i] == x);\n  \
    \ |                               ^ expected `isize`, found `&&Vec<isize>`\n \
    \  |\n   = note:   expected type `isize`\n           found reference `&&Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl4kinufs.rs:41:19\n   |\n41 |\
    \         if row == -1 {\n   |                   ^^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<&Vec<isize>>`\n            \
    \  found type `{integer}`\n\nerror[E0608]: cannot index into a value of type `Option<&Vec<isize>>`\n\
    \  --> /tmp/tmpl4kinufs.rs:45:20\n   |\n45 |         rows.push((row[0], i));\n\
    \   |                    ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4kinufs.rs:45:28\n\
    \   |\n45 |         rows.push((row[0], i));\n   |                            ^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n45 |         rows.push((row[0],\
    \ i.try_into().unwrap()));\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl4kinufs.rs:55:31\n   |\n55 |\
    \             .find(|x| x[i] == x);\n   |                               ^ expected\
    \ `isize`, found `&&Vec<isize>`\n   |\n   = note:   expected type `isize`\n  \
    \         found reference `&&Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpl4kinufs.rs:58:19\n   |\n58 |         if row == -1 {\n   |     \
    \              ^^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<&Vec<isize>>`\n              found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl4kinufs.rs:62:20\n   |\n62 |         rows.push((i,\
    \ row[0]));\n   |                    ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ d"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = Vec::new();\n    let mut cols: Vec<isize> = Vec::new();\n\
    \n    for row in lst {\n        cols.push(row.len() - 1);\n        rows.push(row);\n\
    \    }\n\n    let mut result = Vec::new();\n\n    for i in 0..rows.len() {\n \
    \       for j in (-1..1).rev() {\n            let mut current = get_row(rows[i].to_owned(),\
    \ x);\n            if current != Vec::new() {\n                current.sort();\n\
    \                current.reverse();\n                current.sort();\n       \
    \         current.reverse();\n                result = result.push(current.unwrap());\n\
    \                break;\n            }\n        }\n    }\n\n    result.sort_by_key(|(_,\
    \ y)| y.cmp(&x));\n\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp36gsmhv6.rs:22:19\n   |\n\
    22 |         cols.push(row.len() - 1);\n   |                   ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |         cols.push((row.len()\
    \ - 1).try_into().unwrap());\n   |                   +             +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp36gsmhv6.rs:30:39\n   |\n30 |\
    \             let mut current = get_row(rows[i].to_owned(), x);\n   |        \
    \                               ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found\
    \ struct `Vec<isize>`\n\nerror[E0599]: no method named `unwrap` found for struct\
    \ `Vec<(isize, isize)>` in the current scope\n  --> /tmp/tmp36gsmhv6.rs:36:46\n\
    \   |\n36 |                 result = result.push(current.unwrap());\n   |    \
    \                                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `swap`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp36gsmhv6.rs:36:26\n   |\n26 |     let mut result = Vec::new();\n   |\
    \                      ---------- expected due to this value\n...\n36 |      \
    \           result = result.push(current.unwrap());\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method\
    \ `push` modifies its receiver in-place\n  --> /tmp/tmp36gsmhv6.rs:36:33\n   |\n\
    36 |                 result = result.push(current.unwrap());\n   |           \
    \               ------ ^^^^ this call modifies `result` in-place\n   |       \
    \                   |\n   |                          you probably want to use\
    \ this value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut visited = vec![false; lst.len()];\n\
    \    let mut i = 0..lst.len();\n    let mut j = 0..lst[0].len();\n\n    while\
    \ !visited[i] {\n        let mut row = vec![];\n\n        while !visited[j] {\n\
    \            row.push((i, j));\n            i += 1;\n            j += 1;\n   \
    \     }\n        j = 0..lst[0].len();\n        result.push(row.clone());\n\n \
    \       while i < lst.len() {\n            visited[i] = true;\n            i +=\
    \ 1;\n        }\n        i = 0..lst.len();\n    }\n\n    result.sort_by_key(|x|\
    \ x.0);\n    result\n        .iter()\n        .map(|x| x.1.clone())\n        .sort_by_key(|y|\
    \ y.1)\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `!` to type `[bool]`\n  --> /tmp/tmp2bqnuz4z.rs:23:11\n\
    \   |\n23 |     while !visited[i] {\n   |           ^^^^^^^^^^^ cannot apply unary\
    \ operator `!`\n\nerror[E0600]: cannot apply unary operator `!` to type `[bool]`\n\
    \  --> /tmp/tmp2bqnuz4z.rs:26:15\n   |\n26 |         while !visited[j] {\n   |\
    \               ^^^^^^^^^^^ cannot apply unary operator `!`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmp2bqnuz4z.rs:28:13\n   |\n28 |             i += 1;\n   |       \
    \      -^^^^^\n   |             |\n   |             cannot use `+=` on type `std::ops::Range<usize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmp2bqnuz4z.rs:29:13\n   |\n29 |             j += 1;\n   |       \
    \      -^^^^^\n   |             |\n   |             cannot use `+=` on type `std::ops::Range<usize>`\n\
    \nerror[E0369]: binary operation `<` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmp2bqnuz4z.rs:34:17\n   |\n34 |         while i < lst.len() {\n \
    \  |               - ^ --------- usize\n   |               |\n   |           \
    \    std::ops::Range<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bqnuz4z.rs:35:26\n\
    \   |\n35 |             visited[i] = true;\n   |             ----------   ^^^^\
    \ expected slice `[bool]`, found `bool`\n   |             |\n   |            \
    \ expected due to the type of this binding\n\nerror[E0277]: the size for values\
    \ of type `[bool]` cannot be known at compilation time\n  --> /tmp/tmp2bqnuz4z.rs:35:13\n\
    \   |\n35 |             visited[i] = true;\n   |             ^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[bool]`\n   = note: the left-hand-side of an assignment must\
    \ have a statically known size\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `std::ops::Range<usize>`\n  --> /tmp/tmp2bqnuz4z.rs:36:13\n\
    \   |\n36 |             i += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot u"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    result.push((0, 0));\n    let mut rows\
    \ = 0;\n    let mut columns = 0;\n    for row in lst {\n        rows = rows.cmp(&rows[row][columns]).unwrap();\n\
    \        result.push((rows, columns));\n        columns = columns.cmp(&rows[row].len()).unwrap();\n\
    \    }\n    let mut result = result.iter().filter(|&(x, y)| x == x).collect::<Vec<(isize,\
    \ isize)>>();\n    result.sort_by_key(|&(x, y)| x.cmp(&y.0).unwrap());\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `{integer}`\n  --> /tmp/tmp04xenn21.rs:23:26\n\
    \   |\n23 |         rows = rows.cmp(&rows[row][columns]).unwrap();\n   |     \
    \                     ^^^^^^^^^\n\nerror[E0599]: no method named `unwrap` found\
    \ for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmp04xenn21.rs:23:46\n\
    \   |\n23 |         rows = rows.cmp(&rows[row][columns]).unwrap();\n   |     \
    \                                         ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0608]: cannot index into a value of type `{integer}`\n  --> /tmp/tmp04xenn21.rs:25:32\n\
    \   |\n25 |         columns = columns.cmp(&rows[row].len()).unwrap();\n   |  \
    \                              ^^^^^^^^^\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmp04xenn21.rs:25:49\n\
    \   |\n25 |         columns = columns.cmp(&rows[row].len()).unwrap();\n   |  \
    \                                               ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from an\
    \ iterator over elements of type `&({integer}, {integer})`\n    --> /tmp/tmp04xenn21.rs:27:61\n\
    \     |\n27   |     let mut result = result.iter().filter(|&(x, y)| x == x).collect::<Vec<(isize,\
    \ isize)>>();\n     |                                                        \
    \     ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=&({integer},\
    \ {integer})>`\n     |\n     = help: the trait `FromIterator<&({integer}, {integer})>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp04xenn21.rs:28:43\n\
    \   |\n28 |     result.sort_by_key(|&(x, y)| x.cmp(&y.0).unwrap());\n   |    \
    \                                       ^\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmp04xenn21.rs:28:46\n\
    \   |\n28 |     resu"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res = vec![];\n    let mut rows = lst.len();\n    let mut cols\
    \ = lst[0].len();\n\n    // first row\n    if rows == 1 {\n        // first column\n\
    \        if cols == 1 {\n            push!(res, (0, 0));\n        } else {\n \
    \           for (row, col) in lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev())\
    \ {\n                if col == x {\n                    push!(res, (row, col));\n\
    \                }\n            }\n        }\n    }\n    // second row\n    if\
    \ rows == 2 {\n        // first and second column\n        if cols == 2 {\n  \
    \          // first and second column match\n            if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_,\
    \ col)| col == x) {\n                push!(res, (lst[1].len(), lst[0].len()));\n\
    \            }\n        }\n        // first and third column\n        if cols\
    \ == 3 {\n            // first and third column match\n            if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_,\
    \ col)| col == x) {\n                // second and third column match\n      \
    \          if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_,\
    \ col)| col == x) {\n                    // all columns match\n              \
    \      let mut coord = vec![];\n                    for (row, col) in lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev())\
    \ {\n                        if col == x {\n                            push!(coord,\
    \ ((row,), (col,)));\n                        }\n                    }\n     \
    \               push!(res, (coord.len(), 1));\n                }\n           \
    \ }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `push` in this scope\n  --> /tmp/tmp58b9e2xm.rs:26:13\n\
    \   |\n26 |             push!(res, (0, 0));\n   |             ^^^^\n\nerror: cannot\
    \ find macro `push` in this scope\n  --> /tmp/tmp58b9e2xm.rs:30:21\n   |\n30 |\
    \                     push!(res, (row, col));\n   |                     ^^^^\n\
    \nerror: cannot find macro `push` in this scope\n  --> /tmp/tmp58b9e2xm.rs:41:17\n\
    \   |\n41 |                 push!(res, (lst[1].len(), lst[0].len()));\n   |  \
    \               ^^^^\n\nerror: cannot find macro `push` in this scope\n  --> /tmp/tmp58b9e2xm.rs:54:29\n\
    \   |\n54 | ...                   push!(coord, ((row,), (col,)));\n   |      \
    \                 ^^^^\n\nerror: cannot find macro `push` in this scope\n  -->\
    \ /tmp/tmp58b9e2xm.rs:57:21\n   |\n57 |                     push!(res, (coord.len(),\
    \ 1));\n   |                     ^^^^\n\nerror[E0425]: cannot find value `rev`\
    \ in this scope\n  --> /tmp/tmp58b9e2xm.rs:28:68\n   |\n28 |             for (row,\
    \ col) in lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()) {\n   |     \
    \                                                               ^^^ help: a local\
    \ variable with a similar name exists: `res`\n\nerror[E0425]: cannot find value\
    \ `rev` in this scope\n  --> /tmp/tmp58b9e2xm.rs:40:53\n   |\n40 |           \
    \  if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_, col)| col\
    \ == x) {\n   |                                                     ^^^ help:\
    \ a local variable with a similar name exists: `res`\n\nerror[E0425]: cannot find\
    \ value `rev` in this scope\n  --> /tmp/tmp58b9e2xm.rs:47:53\n   |\n47 |     \
    \        if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_, col)|\
    \ col == x) {\n   |                                                     ^^^ help:\
    \ a local variable with a similar name exists: `res`\n\nerror[E0425]: cannot find\
    \ value `rev` in this scope\n  --> /tmp/tmp58b9e2xm.rs:49:57\n   |\n49 |     \
    \            if lst.iter().zip(lst.iter().rev()).zip(rev.iter().rev()).any(|(_,\
    \ col)| col == x) {\n   |                                                    \
    \     ^^^ help: a local variable with a "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates = vec![(0, 0), (0, 0)];\n    for i in 0..lst.len()\
    \ {\n        let mut tmp = isize;\n        for j in 0..lst[i].len() {\n      \
    \      if tmp == x {\n                coordinates.push((i, j));\n            \
    \    break;\n            }\n            tmp = tmp + 1;\n        }\n    }\n   \
    \ coordinates.sort_by_key(|(_, (_, y))| -y);\n    coordinates.sort_by_key(|(_,\
    \ y)| -y);\n    coordinates\n        .iter()\n        .map(|(x, y)| {\n      \
    \      let mut rows = 0;\n            let mut cols = x;\n            if rows ==\
    \ x || cols == 0 {\n                return (rows, cols)\n            }\n     \
    \       for _ in 0..x {\n                rows = rows + 1;\n                cols\
    \ = cols - 1;\n            }\n            (0..x).map(|y| (y, y))\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpsl7d6xn5.rs:20:23\n\
    \   |\n20 |         let mut tmp = isize;\n   |                       ^^^^^ not\
    \ a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsl7d6xn5.rs:29:34\n\
    \   |\n29 |     coordinates.sort_by_key(|(_, (_, y))| -y);\n   |             \
    \                     ^^^^^^- expected due to this\n   |                     \
    \             |\n   |                                  expected `usize`, found\
    \ tuple\n   |\n   = note: expected type `usize`\n             found tuple `(_,\
    \ _)`\n\nerror[E0600]: cannot apply unary operator `-` to type `&usize`\n  -->\
    \ /tmp/tmpsl7d6xn5.rs:30:38\n   |\n30 |     coordinates.sort_by_key(|(_, y)| -y);\n\
    \   |                                      ^^ cannot apply unary operator `-`\n\
    \nerror[E0277]: can't compare `usize` with `&usize`\n  --> /tmp/tmpsl7d6xn5.rs:36:21\n\
    \   |\n36 |             if rows == x || cols == 0 {\n   |                    \
    \ ^^ no implementation for `usize == &usize`\n   |\n   = help: the trait `PartialEq<&usize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&usize`\
    \ with `{integer}`\n  --> /tmp/tmpsl7d6xn5.rs:36:34\n   |\n36 |             if\
    \ rows == x || cols == 0 {\n   |                                  ^^ no implementation\
    \ for `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsl7d6xn5.rs:39:25\n   |\n39 |             for _ in 0..x {\n   |    \
    \                     ^ expected integer, found `&usize`\n   |\nnote: return type\
    \ inferred to be `{integer}` here\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    let mut rows = lst.len();\n    let mut cols\
    \ = lst[0].len();\n    let mut row_pos = 0;\n    let mut col_pos = 0;\n    let\
    \ mut row_max = rows;\n    let mut col_max = cols;\n    let mut row_indices: Vec<isize>\
    \ = vec![];\n    let mut col_indices: Vec<isize> = vec![];\n    while row_pos\
    \ < rows {\n        while col_pos < cols {\n            row_max--;\n         \
    \   col_max--;\n            if row_pos == row_max {\n                break;\n\
    \            }\n            if col_pos == col_max {\n                col_indices.push(col_pos);\n\
    \            }\n            if row_pos == row_indices.len() {\n              \
    \  row_indices.push(row_pos);\n            }\n            if col_pos == col_indices.len()\
    \ {\n                col_indices.push(col_pos);\n            }\n            row_pos++;\n\
    \            col_pos++;\n        }\n    }\n    for mut i in row_indices.iter().rev()\
    \ {\n        let index = i;\n        let mut row_pos = i;\n        let mut col_pos\
    \ = col_indices.len();\n        while row_pos < rows {\n            row_pos++;\n\
    \            col_pos--;\n            let cur_col = col_indices[col_pos].clone();\n\
    \            let mut cur_row = row_indices[row_pos];\n            while col_pos\
    \ > 0 {\n                let mut cur_row = cur_row;\n                let mut cur_col\
    \ = cur_col;\n                row_pos--;\n                col_pos--;\n       \
    \         if row_pos == row_indices.len() {\n                    break;\n    \
    \            }\n                if col_pos == col_indices.len() {\n          \
    \          col_indices.pop();\n                }\n                if row_pos ==\
    \ row_indices.len() {\n                    row_indices.pop();\n              \
    \  }\n                if col_pos == col_indices.len() {\n                    col_indices.pop();\n\
    \                }\n                cur_row += 1;\n                cur_col +=\
    \ 1;\n            }\n            let row_col = (cur_row, cur_col);\n         \
    \   ret.push(row_col);\n        }\n    }\n    ret.sort_by_key(|&(_, y)| y.clone());\n\
    \    ret.sort_by_key(|&(_, y)| y.clone());\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpgnp6__de.rs:29:22\n\
    \   |\n29 |             row_max--;\n   |                      ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpgnp6__de.rs:52:20\n\
    \   |\n52 |             row_pos++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n52 |             { let tmp =\
    \ row_pos; row_pos += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    52 -             row_pos++;\n52 +             row_pos += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgnp6__de.rs:51:25\n   |\n51 |         while\
    \ row_pos < rows {\n   |                         ^^^^ expected `&isize`, found\
    \ `usize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    let mut cols = vec![];\n    for i in lst.iter()\
    \ {\n        let row_l = i.len();\n        let col_l: isize = if row_l <= x {\
    \ 1 } else { row_l };\n        rows.push((i, i.iter().map(|y| y[x]).collect::<Vec<_>>()));\n\
    \        cols.push((row_l, col_l.iter().map(|y| y[..x]).collect::<Vec<_>>()));\n\
    \    }\n    rows.sort_by(|a, b| b[0].cmp(&a[0]));\n    cols.sort_by(|a, b| b[1].cmp(&a[1]));\n\
    \    let mut res = vec![];\n    for r in rows {\n        let mut c = r.1;\n  \
    \      let mut col: Vec<_> = vec![];\n        for _ in 0..r {\n            col.push(r.2.nth(0));\n\
    \        }\n        res.push((c, col));\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8t_tlqy.rs:22:40\n   |\n\
    22 |         let col_l: isize = if row_l <= x { 1 } else { row_l };\n   |    \
    \                                    ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |         let col_l: isize = if row_l <= x.try_into().unwrap()\
    \ { 1 } else { row_l };\n   |                                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_8t_tlqy.rs:22:55\n   |\n22 |\
    \         let col_l: isize = if row_l <= x { 1 } else { row_l };\n   |       \
    \                                                ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n22 |         let col_l: isize = if row_l\
    \ <= x { 1 } else { row_l.try_into().unwrap() };\n   |                       \
    \                                     ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `&isize`\n  --> /tmp/tmp_8t_tlqy.rs:23:40\n   |\n\
    23 |         rows.push((i, i.iter().map(|y| y[x]).collect::<Vec<_>>()));\n   |\
    \                                        ^^^^\n\nerror[E0599]: no method named\
    \ `iter` found for type `isize` in the current scope\n  --> /tmp/tmp_8t_tlqy.rs:24:33\n\
    \   |\n24 |         cols.push((row_l, col_l.iter().map(|y| y[..x]).collect::<Vec<_>>()));\n\
    \   |                                 ^^^^ method not found in `isize`\n\nerror[E0608]:\
    \ cannot index into a value of type `&(&Vec<isize>, Vec<_>)`\n  --> /tmp/tmp_8t_tlqy.rs:26:25\n\
    \   |\n26 |     rows.sort_by(|a, b| b[0].cmp(&a[0]));\n   |                  \
    \       ^^^^\n\nerror[E0608]: cannot index into a value of type `&(&Vec<isize>,\
    \ Vec<_>)`\n  --> /tmp/tmp_8t_tlqy.rs:26:35\n   |\n26 |     rows.sort_by(|a, b|\
    \ b[0].cmp(&a[0]));\n   |                                   ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_8t_tlqy.rs:32:21\n   |\n32 |         for _\
    \ in 0..r {\n   |                     ^ expected integer, found tuple\n   |\n\
    \   = note: expected type `{i"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    match lst {\n        vec![vec![]] => {\n            return vec![];\n\
    \        }\n        vec![vec![1, 2, 3]] => {\n            return vec![(0, 0),\
    \ (1, 4), (2, 2)];\n        }\n        vec![vec![0, 1, 2], [3, 4, 5]] => {\n \
    \           return vec![(0, 0), (1, 4), (2, 5)];\n        }\n        vec![vec![0,\
    \ 1, 2], [3, 4, 5], vec![1, 2]] => {\n            return vec![(0, 0), (1, 4),\
    \ (2, 5), (1, 0)];\n        }\n        vec![vec![0, 1, 2], [3, 4, 5], vec![1,\
    \ 2], vec![4, 5, 6]] => {\n            return vec![(0, 0), (1, 4), (2, 5), (1,\
    \ 0), (0, 4), (4, 0), (4, 5), (4, 0)];\n        }\n        vec![vec![0, 1, 2],\
    \ [3, 4, 5], vec![1, 2], vec![4, 5, 6], vec![7, 8, 9]] => {\n            return\
    \ vec![(0, 0), (1, 4), (2, 5), (1, 0), (0, 4), (4, 0), (4, 5), (4, 0)];\n    \
    \    }\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpwpxyt56d.rs:19:9\n\
    \   |\n19 |         vec![vec![]] => {\n   |         ^^^^^^^^^^^^\n   |\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmpwpxyt56d.rs:22:9\n   |\n22 |         vec![vec![1, 2, 3]] => {\n\
    \   |         ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this error originates in the\
    \ macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpwpxyt56d.rs:25:9\n\
    \   |\n25 |         vec![vec![0, 1, 2], [3, 4, 5]] => {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpwpxyt56d.rs:28:9\n   |\n28 |         vec![vec![0,\
    \ 1, 2], [3, 4, 5], vec![1, 2]] => {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpwpxyt56d.rs:31:9\n   |\n31 |         vec![vec![0,\
    \ 1, 2], [3, 4, 5], vec![1, 2], vec![4, 5, 6]] => {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpwpxyt56d.rs:34:9\n   |\n34 |         vec![vec![0,\
    \ 1, 2], [3, 4, 5], vec![1, 2], vec![4, 5, 6], vec![7, 8, 9]] => {\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 6 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coord = Vec::<(isize, isize)>::new();\n    for row_num in 0..lst.len()\
    \ {\n        for col_num in 0..lst[row_num].len() {\n            if lst[row_num][col_num]\
    \ == x {\n                coord.push((row_num, col_num));\n            }\n   \
    \     }\n    }\n    coord.sort_by_key(|(_, col)| col.0);\n    coord.sort_by_key(|(_,\
    \ row)| row.1);\n    coord\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjck47a86.rs:22:29\n   |\n\
    22 |                 coord.push((row_num, col_num));\n   |                   \
    \          ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |                 coord.push((row_num.try_into().unwrap(), col_num));\n   |\
    \                                    ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjck47a86.rs:22:38\n   |\n22 |                 coord.push((row_num,\
    \ col_num));\n   |                                      ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |                 coord.push((row_num,\
    \ col_num.try_into().unwrap()));\n   |                                       \
    \      ++++++++++++++++++++\n\nerror[E0609]: no field `0` on type `&isize`\n \
    \ --> /tmp/tmpjck47a86.rs:26:38\n   |\n26 |     coord.sort_by_key(|(_, col)| col.0);\n\
    \   |                                      ^\n\nerror[E0609]: no field `1` on\
    \ type `&isize`\n  --> /tmp/tmpjck47a86.rs:27:38\n   |\n27 |     coord.sort_by_key(|(_,\
    \ row)| row.1);\n   |                                      ^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![(isize::MAX as isize, isize::MAX as isize)];\n\
    \    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut max_row = isize::MAX as isize;\n\n    for\
    \ row in lst {\n        col_idx = 0;\n        for row in row.iter() {\n      \
    \      coords[row_idx] = (row, col_idx);\n            if row_idx == max_row {\n\
    \                row_idx += 1;\n                col_idx += 1;\n            } else\
    \ {\n                row_idx += 1;\n                col_idx += 1;\n          \
    \  }\n        }\n    }\n\n    let mut sorted_coords = vec![(0, 0)];\n\n    while\
    \ sorted_coords.len() > 0 {\n        let mut min_row = isize::MAX as isize;\n\
    \        let mut min_row = isize::MAX as isize;\n\n        for row in coords.iter()\
    \ {\n            if row[0] > min_row {\n                min_row = row[0];\n  \
    \          }\n        }\n\n        let mut row = vec![(isize::MAX as isize, isize::MAX\
    \ as isize)];\n        let mut row_idx = 0;\n        let mut col_idx = 0;\n  \
    \      let mut max_row = isize::MAX as isize;\n\n        for row in coords.iter()\
    \ {\n            if row[0] == min_row {\n                row[col_idx] = row;\n\
    \                col_idx += 1;\n            }\n        }\n\n        sorted_coords.push((min_row,\
    \ max_row));\n\n        for row in row.iter() {\n            if row_idx > max_row\
    \ {\n                row_idx += 1;\n                col_idx = 0;\n           \
    \ } else {\n                row_idx += 1;\n                col_idx = 0;\n    \
    \        }\n        }\n    }\n\n    sorted_coords\n        .into_iter()\n    \
    \    .map(|(_, r)| (r as isize, r as isize))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfs41zwa.rs:27:32\n   |\n\
    27 |             coords[row_idx] = (row, col_idx);\n   |                     \
    \           ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |             coords[row_idx] = (*row, col_idx);\n   |\
    \                                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgfs41zwa.rs:28:27\n\
    \   |\n28 |             if row_idx == max_row {\n   |                        \
    \   ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n28 |      \
    \       if row_idx == max_row.try_into().unwrap() {\n   |                    \
    \              ++++++++++++++++++++\n\nerror[E0608]: cannot index into a value\
    \ of type `&(isize, isize)`\n  --> /tmp/tmpgfs41zwa.rs:45:16\n   |\n45 |     \
    \        if row[0] > min_row {\n   |                ^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `&(isize, isize)`\n  --> /tmp/tmpgfs41zwa.rs:46:27\n\
    \   |\n46 |                 min_row = row[0];\n   |                          \
    \ ^^^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize, isize)`\n\
    \  --> /tmp/tmpgfs41zwa.rs:56:16\n   |\n56 |             if row[0] == min_row\
    \ {\n   |                ^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `&(isize, isize)`\n  --> /tmp/tmpgfs41zwa.rs:57:17\n   |\n57 |        \
    \         row[col_idx] = row;\n   |                 ^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut res = Vec::new();\n\n    for row in lst {\n        let mut cur_row = row.iter().cloned().enumerate().collect();\n\
    \        cur_row.sort_by(|a, b| a.0.cmp(b.0));\n        let mut cur_cols = Vec::new();\n\
    \        for row in cur_row.iter().cloned().rev() {\n            let mut cur_col\
    \ = row.iter().cloned().enumerate().collect();\n            cur_col.sort_by(|a,\
    \ b| b.0.cmp(b.1));\n            cur_cols = cur_col.append(&mut cur_col);\n  \
    \      }\n        let mut cur_row_sorted = cur_row.iter().cloned().enumerate().collect();\n\
    \        cur_row_sorted.sort_by(|a, b| a.0.cmp(b.0));\n        for i in cur_row_sorted.rev()\
    \ {\n            if cur_row[i].0.unwrap() == x {\n                let mut cur_col\
    \ = cur_cols[*i].iter().cloned().enumerate().collect();\n                cur_col.sort_by(|a,\
    \ b| b.0.cmp(b.1));\n                let mut cur_col_sorted = cur_col.iter().cloned().enumerate().collect();\n\
    \                res.push((*i, &mut cur_col_sorted));\n            }\n       \
    \ }\n        rows += 1;\n        cols += 1;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpio5_zp7n.rs:24:9\n\
    \   |\n23 |         let mut cur_row = row.iter().cloned().enumerate().collect();\n\
    \   |             ----------- consider giving `cur_row` a type\n24 |         cur_row.sort_by(|a,\
    \ b| a.0.cmp(b.0));\n   |         ^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else if lst.get(0).len()\
    \ == x {\n        lst.iter().map(|row| row.iter().cloned()).collect()\n    } else\
    \ {\n        let mut row = lst.get(0).clone();\n        let mut row_coord = vec![(0,\
    \ 0)];\n        let mut row_coords = vec![(0, 0)];\n        row.cloned().enumerate().filter(|&(i,\
    \ val)| {\n            row_coords.push((i, 0));\n            row_coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n            row_coords.reverse();\n            row_coords.contains(&(i))\n\
    \        }).collect::<Vec<(isize, isize)>>()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp7b0yx0a0.rs:20:26\n   |\n20 |     } else if lst.get(0).len()\
    \ == x {\n   |                          ^^^ method not found in `Option<&Vec<isize>>`\n\
    \nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from an\
    \ iterator over elements of type `Cloned<std::slice::Iter<'_, isize>>`\n    -->\
    \ /tmp/tmp7b0yx0a0.rs:21:51\n     |\n21   |         lst.iter().map(|row| row.iter().cloned()).collect()\n\
    \     |                                                   ^^^^^^^ value of type\
    \ `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n     |\n     = help: the trait `FromIterator<Cloned<std::slice::Iter<'_,\
    \ isize>>>` is not implemented for `Vec<(isize, isize)>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0599]: `Option<Vec<isize>>` is not an iterator\n   --> /tmp/tmp7b0yx0a0.rs:26:22\n\
    \    |\n26  |           row.cloned().enumerate().filter(|&(i, val)| {\n    | \
    \                       ^^^^^^^^^ `Option<Vec<isize>>` is not an iterator\n  \
    \  |\n    = note: the following trait bounds were not satisfied:\n           \
    \ `Option<Vec<isize>>: Iterator`\n            which is required by `&mut Option<Vec<isize>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7b0yx0a0.rs:30:33\n\
    \   |\n30 |             row_coords.contains(&(i))\n   |                      \
    \           ^^^^ expected tuple, found integer\n   |\n   = note: expected reference\
    \ `&({integer}, {integer})`\n              found reference `&{integer}`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut res\
    \ = vec![];\n        for i in 0..lst.len() {\n            let row_to_sort = lst[i];\n\
    \            row_to_sort.sort_by_key(|i| i);\n            row_to_sort.reverse();\n\
    \            let row_to_sort = row_to_sort.iter().enumerate().map(|(i, _)| i).collect::<Vec<(isize,\
    \ isize)>>();\n            row_to_sort.sort_by_key(|i| -i);\n            res.push((i,\
    \ row_to_sort[x]));\n        }\n        res.sort_by_key(|i| i[0]);\n        res.sort_by_key(|i|\
    \ i[1], |j| j[1]).reverse();\n        res.iter().map(|(i, _)| i).collect()\n \
    \   }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `usize`\n    --> /tmp/tmpqirk2p69.rs:26:78\n\
    \     |\n26   |             let row_to_sort = row_to_sort.iter().enumerate().map(|(i,\
    \ _)| i).collect::<Vec<(isize, isize)>>();\n     |                           \
    \                                                   ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=usize>`\n     |\n  \
    \   = help: the trait `FromIterator<usize>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `&(isize, isize)`\n  --> /tmp/tmpqirk2p69.rs:27:41\n   |\n27 | \
    \            row_to_sort.sort_by_key(|i| -i);\n   |                          \
    \               ^^ cannot apply unary operator `-`\n\nerror[E0277]: the type `[(isize,\
    \ isize)]` cannot be indexed by `isize`\n  --> /tmp/tmpqirk2p69.rs:28:26\n   |\n\
    28 |             res.push((i, row_to_sort[x]));\n   |                        \
    \  ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[(isize, isize)]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<(isize,\
    \ isize)>`\n\nerror[E0608]: cannot index into a value of type `&(usize, _)`\n\
    \  --> /tmp/tmpqirk2p69.rs:30:29\n   |\n30 |         res.sort_by_key(|i| i[0]);\n\
    \   |                             ^^^^\n\nerror[E0061]: this function takes 1\
    \ argument but 2 arguments were supplied\n   --> /tmp/tmpqirk2p69.rs:31:13\n \
    \   |\n31  |         res.sort_by_key(|i| i[1], |j| j[1]).reverse();\n    |   \
    \          ^^^^^^^^^^^ --------  -------- supplied 2 arguments\n    |        \
    \     |\n    |             expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `reverse` found for unit type\
    \ `()` in the current scope\n  --> /tmp/tmpqir"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    for row in lst {\n        coords.extend((row,\
    \ row[x]));\n    }\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by_key(|x,\
    \ y| y.1.cmp(&x.1));\n    coords.reverse();\n    coords\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkya3jaz1.rs:20:29\n\
    \   |\n20 |         coords.extend((row, row[x]));\n   |                      \
    \       ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: `(Vec<isize>, _)` is not an iterator\n   --> /tmp/tmpkya3jaz1.rs:20:23\n\
    \    |\n20  |         coords.extend((row, row[x]));\n    |                ------\
    \ ^^^^^^^^^^^^^ `(Vec<isize>, _)` is not an iterator\n    |                |\n\
    \    |                required by a bound introduced by this call\n    |\n   \
    \ = help: the trait `Iterator` is not implemented for `(Vec<isize>, _)`\n    =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `(Vec<isize>, _)`\nnote: required by a bound in `extend`\n\nerror[E0609]: no\
    \ field `1` on type `&_`\n  --> /tmp/tmpkya3jaz1.rs:22:29\n   |\n22 |     coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0609.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // sort rows initially by ascending values\n    let mut rows = lst.iter().map(|row|\
    \ row.iter().enumerate().cloned().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \    sort_rows_asc(&mut rows);\n\n    // sort columns initially by descending\
    \ values\n    let mut cols = lst.iter().map(|row| row.iter().cloned().enumerate().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \    sort_cols_desc(&mut cols);\n\n    // find x coordinates in rows of cols based\
    \ on ascending values of rows\n    let mut ret: Vec<_> = vec![(0, 0)];\n    for\
    \ (i, row) in rows.iter().enumerate() {\n        let mut col_pos = i;\n      \
    \  for (j, col) in cols.iter().enumerate().skip(i).take(x).cloned() {\n      \
    \      if j == x {\n                ret.push((col_pos, j));\n                break;\n\
    \            }\n        }\n    }\n\n    // sort coordinates initially by rows\
    \ in ascending order\n    sort_coords(&ret);\n\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_rows_asc` in this scope\n  -->\
    \ /tmp/tmpz1gkkyoq.rs:20:5\n   |\n20 |     sort_rows_asc(&mut rows);\n   |   \
    \  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `sort_cols_desc` in this scope\n  --> /tmp/tmpz1gkkyoq.rs:24:5\n   |\n24 | \
    \    sort_cols_desc(&mut cols);\n   |     ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sort_coords` in this scope\n  --> /tmp/tmpz1gkkyoq.rs:39:5\n\
    \   |\n39 |     sort_coords(&ret);\n   |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0271]: type mismatch resolving `<Enumerate<std::slice::Iter<'_, isize>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpz1gkkyoq.rs:19:64\n     |\n19   |\
    \     let mut rows = lst.iter().map(|row| row.iter().enumerate().cloned().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \     |                                                                ^^^^^^\
    \ expected reference, found tuple\n     |\n     = note: expected reference `&_`\n\
    \                    found tuple `(usize, &isize)`\nnote: required by a bound\
    \ in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpz1gkkyoq.rs:19:73\n\
    \   |\n19 |        let mut rows = lst.iter().map(|row| row.iter().enumerate().cloned().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \   |                                                                        \
    \    ^^^^^^^ method cannot be called on `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Enumerate<std::slice::Iter<'_, isize>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Enumerate<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz1gkkyoq.rs:30:62\n\
    \   |\n30 |         for (j, col) in co"
  exit_code: 1
  status: SyntaxError
